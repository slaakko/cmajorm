// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using Sirius.Math;

namespace Sirius.Graphics
{
    public class Cube : PolygonMeshObject
    {
        public nothrow Cube() : this(1)
        {
        }
        public explicit nothrow Cube(float sideLength) : this(sideLength, 0, 0, 0)
        {
        }
        public nothrow Cube(float sideLength, float roll, float pitch, float yaw) : this(sideLength, roll, pitch, yaw, Vector(0, 0, 0))
        {
        }
        public nothrow Cube(float sideLength, float roll, float pitch, float yaw, const Vector& location) : base()
        {
            AddVertex(Vertex(Vector(0, 0, 0))); // 0
            AddVertex(Vertex(Vector(1, 0, 0))); // 1
            AddVertex(Vertex(Vector(1, 1, 0))); // 2
            AddVertex(Vertex(Vector(0, 1, 0))); // 3
            AddVertex(Vertex(Vector(0, 0, 1))); // 4
            AddVertex(Vertex(Vector(1, 0, 1))); // 5
            AddVertex(Vertex(Vector(1, 1, 1))); // 6
            AddVertex(Vertex(Vector(0, 1, 1))); // 7

            AddEdge(Edge(0, 1)); // 0
            AddEdge(Edge(1, 2)); // 1
            AddEdge(Edge(2, 3)); // 2
            AddEdge(Edge(3, 0)); // 3

            Polygon back(this);
            back.AddVertex(0);
            back.AddVertex(3);
            back.AddVertex(2);
            back.AddVertex(1);
            back.CalculateNormal(); // (0, 0, -1)
            AddPolygon(Rvalue(back));

            AddEdge(Edge(0, 4)); // 4
            AddEdge(Edge(4, 5)); // 5
            AddEdge(Edge(5, 1)); // 6
            //AddEdge(Edge(1, 0));

            Polygon bottom(this);
            bottom.AddVertex(0);
            bottom.AddVertex(1);
            bottom.AddVertex(5);
            bottom.AddVertex(4);
            bottom.CalculateNormal(); // (0, -1, 0)
            AddPolygon(Rvalue(bottom));

            //AddEdge(Edge(4, 5)); // 5
            AddEdge(Edge(5, 6)); // 7
            AddEdge(Edge(6, 7)); // 8
            AddEdge(Edge(7, 4)); // 9

            Polygon front(this);
            front.AddVertex(4);
            front.AddVertex(5);
            front.AddVertex(6);
            front.AddVertex(7);
            front.CalculateNormal(); // (0, 0, 1)
            AddPolygon(Rvalue(front));

            AddEdge(Edge(3, 7)); // 10
            //AddEdge(Edge(7, 6)); // 8
            AddEdge(Edge(6, 2)); // 11
            //AddEdge(Edge(2, 3)); // 2

            Polygon top(this);
            top.AddVertex(3);
            top.AddVertex(7);
            top.AddVertex(6);
            top.AddVertex(2);
            top.CalculateNormal(); // (0, 1, 0)
            AddPolygon(Rvalue(top));

            //AddEdge(Edge(1, 2)); // 1
            //AddEdge(Edge(2, 6)); // 11
            //AddEdge(Edge(6, 5)); // 7
            //AddEdge(Edge(5, 1)); // 6

            Polygon left(this);
            left.AddVertex(1);
            left.AddVertex(5);
            left.AddVertex(6);
            left.AddVertex(2);
            left.CalculateNormal(); // (-1, 0, 0)
            AddPolygon(Rvalue(left));

            //AddEdge(Edge(0, 4)); // 4
            //AddEdge(Edge(4, 7)); // 9
            //AddEdge(Edge(7, 3)); // 10
            //AddEdge(Edge(3, 0)); // 3

            Polygon right(this);
            right.AddVertex(0);
            right.AddVertex(3);
            right.AddVertex(7);
            right.AddVertex(4);
            right.CalculateNormal(); // (1, 0, 0)
            AddPolygon(Rvalue(right));

            Matrix moveToOrigin = Translation(-0.5f, -0.5f, -0.5f);
            Matrix scaling = Scaling(sideLength, sideLength, sideLength);
            Matrix orientation = Rotation(roll, pitch, yaw);
            Matrix moveToLocation = Translation(location.x, location.y, location.z);
            Matrix transformation = moveToLocation * orientation * scaling * moveToOrigin;
            TransformLocal(transformation);
        }
        public nothrow Cube(const Cube& that) : base(that.Vertices(), that.Edges(), that.Polygons())
        {
        }
        public override nothrow Object* Clone() const
        {
            return new Cube(*this);
        }
    }
}


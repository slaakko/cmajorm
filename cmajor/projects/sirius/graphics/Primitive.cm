// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using Sirius.Math;

namespace Sirius.Graphics
{
    public class Vertex
    {
        public nothrow Vertex() : location(), mappedLocation(), mappedPoint(), screenPoint()
        {
        }
        public nothrow explicit Vertex(const Vector& location_) : location(location_), mappedLocation(), mappedPoint(), screenPoint()
        {
        }
        public Vector location;
        public Vector mappedLocation;
        public System.Windows.PointF mappedPoint;
        public System.Windows.Point screenPoint;
    }

    public class Edge
    {
        public nothrow Edge(int startVertex_, int endVertex_) : startVertex(startVertex_), endVertex(endVertex_)
        {
        }
        public int startVertex;
        public int endVertex;
    }

    public class Polygon
    {
        public nothrow inline void AddEdge(const Edge& edge)
        {
            edges.Add(edge);
        }
        private List<Edge> edges;
    }

    public class BoundingSphere
    {
        public nothrow BoundingSphere() : center(), radius(0)
        {
        }
        public nothrow BoundingSphere(const Vector& center_, float radius_) : center(center_), radius(radius_)
        {
        }
        public Vector center;
        public float radius;
    }

    public abstract class Object
    {
        public nothrow Object() {}
        public default virtual ~Object();
        public abstract nothrow Object* Clone() const;
        public abstract nothrow void Transform(const Matrix& transformation);
        public abstract nothrow void Map(const Camera& camera, const Screen& screen);
        public abstract void Draw(const System.Windows.Pen& pen, System.Windows.Graphics& graphics);
    }

    public abstract class CompositeObject : Object
    {
        public nothrow CompositeObject() : base()
        {
        }
        public nothrow CompositeObject(List<UniquePtr<Object>>&& components_) : base(), components(components_)
        {
        }
        public nothrow void AddComponent(Object* component)
        {
            components.Add(UniquePtr<Object>(component));
        }
        public nothrow List<UniquePtr<Object>> CloneComponents() const
        {
            List<UniquePtr<Object>> clonedComponents;
            for (UniquePtr<Object>& component : components)
            {
                clonedComponents.Add(UniquePtr<Object>(component->Clone()));
            }
            return clonedComponents;
        }
        public override nothrow void Transform(const Matrix& transformation)
        {
            for (UniquePtr<Object>& component : components)
            {
                component->Transform(transformation);
            }
        }
        public override nothrow void Map(const Camera& camera, const Screen& screen)
        {
            for (UniquePtr<Object>& component : components)
            {
                component->Map(camera, screen);
            }
        }
        public override void Draw(const System.Windows.Pen& pen, System.Windows.Graphics& graphics)
        {
            for (UniquePtr<Object>& component : components)
            {
                component->Draw(pen, graphics);
            }
        }
        private List<UniquePtr<Object>> components;
    }

    public abstract class PolygonMeshObject : Object
    {
        public nothrow PolygonMeshObject() : base(), vertices(), edges(), polygons()
        {
        }
        public nothrow PolygonMeshObject(const List<Vertex>& vertices_, const List<Edge>& edges_, const List<Polygon>& polygons_) :
            base(), vertices(vertices), edges(edges_), polygons(polygons_)
        {
        }
        public nothrow inline void AddVertex(const Vertex& vertex)
        {
            vertices.Add(vertex);
        }
        public nothrow inline void AddEdge(const Edge& edge)
        {
            edges.Add(edge);
        }
        public nothrow inline void AddPolygon(const Polygon& polygon)
        {
            polygons.Add(polygon);
        }
        public nothrow inline void AddPolygon(Polygon&& polygon)
        {
            polygons.Add(polygon);
        }
        public override nothrow void Transform(const Matrix& transformation)
        {
            for (Vertex& vertex : vertices)
            {
                vertex.location = transformation * vertex.location;
            }
        }
        public override nothrow void Map(const Camera& camera, const Screen& screen)
        {
            float halfWidth = screen.width / 2.0f;
            float halfHeight = screen.height / 2.0f;
            for (Vertex& vertex : vertices)
            {
                vertex.mappedLocation = camera.Mapping() * vertex.location;
                vertex.mappedPoint = System.Windows.PointF(vertex.mappedLocation.x / vertex.mappedLocation.w, vertex.mappedLocation.y / vertex.mappedLocation.w);
                vertex.screenPoint = System.Windows.Point(cast<int>(vertex.mappedPoint.x + halfWidth), cast<int>(vertex.mappedPoint.y + halfHeight));
            }
        }
        public override void Draw(const System.Windows.Pen& pen, System.Windows.Graphics& graphics)
        {
            for (const Edge& edge : edges)
            {
                const Vertex& start = vertices[edge.startVertex];
                const Vertex& end = vertices[edge.endVertex];
                graphics.DrawLineChecked(pen, start.screenPoint, end.screenPoint);
            }
        }
        public nothrow inline const List<Vertex>& Vertices() const
        {
            return vertices;
        }
        public nothrow inline const List<Edge>& Edges() const
        {
            return edges;
        }
        public nothrow inline const List<Polygon>& Polygons() const
        {
            return polygons;
        }
        private List<Vertex> vertices;
        private List<Edge> edges;
        private List<Polygon> polygons;
    }
}


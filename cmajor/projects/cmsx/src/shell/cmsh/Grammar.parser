// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;

namespace cmsh
{
    using stdlib.identifier;
    using stdlib.int;

    BraceExpandedText : ustring
        ::= QuotedBrace{ value.Append('{'); }
        |   ("${" [^}]+ '}'){ value.Append(ustring(matchBegin, matchEnd)); }
        |   (Preamble '{' BraceExpression '}' Postamble){ value.Append(BraceExpand(Preamble, BraceExpression, Postamble)); }
        |   anychar{ value.Append(anychar); }
        ;
        
    NonCommaBraceExpandedText : ustring
        ::= QuotedBrace{ value.Append('{'); }
        |   ("${" [^}]+ '}'){ value.Append(ustring(matchBegin, matchEnd)); }
        |   (PreambleNonComma '{' BraceExpression '}' Postamble){ value.Append(BraceExpand(Preamble, BraceExpression, Postamble)); }
        ;
        
    Preamble : ustring
        ::= ([^{}]*){ value = ustring(matchBegin, matchEnd); }
        ;
        
    PreambleNonComma : ustring
        ::= ([^{},]*){ value = ustring(matchBegin, matchEnd); }
        ;
        
    Postamble : ustring
        ::= ([^{}]*){ value = ustring(matchBegin, matchEnd); }
        ;
        
    BraceExpression : List<ustring>
        ::= (CommaseparatedList{ value = CommaseparatedList; } | SequenceExpression{ value = SequenceExpression; }
        ;
        
    QuotedBrace 
        ::= "\\{"
        ;
        
    CommaseparatedList : List<ustring>
        ::= NonCommaStr:left{ value.Add(left); } (',' NonCommaStr:right{ value.Add(right); })+
        ;
        
    NonCommaStr : ustring
        ::= ([^\\,{}]{ value.Append(*matchBegin); } | "\\,"{ value.Append(','); } | "\\{"{ value.Append('{'); } | "\\}"{ value.Append('}'); } | NonCommaBraceExpandedText{ value.Append(NonCommaBraceExpandedText); })+
        ;
    
    SequenceExpression : List<ustring>
        ::= ('0' int:startsz ".." int:endsz (".." int:incsz)?){ value = GenZSequence(startsz, endsz, incsz); }
        |   (int:startez ".." '0' int:endez (".." int:incez)?){ value = GenZSequence(startez, endez, incez); }
        |   (int:startnz ".." int:endnz (".." int:incnz)?){ value = GenNZSequence(startnz, endnz, incnz); }
        |   (anychar:startc ".." anychar:endc (".." int:incc)?){ value = GetCSequence(startc, endc, incc); }
        ;

    Blank
        ::= [ \t]
        ;
        
    Name
        ::= identifier
        ;

    Meta : uchar
        ::= [ \t\n|&()<>]{ value = *matchBegin; }
        ;
        
    ControlOperator
        ::= "||" 
        |   "&&"
        |   '&'
        |   ";;&"
        |   ";;"
        |   ";&"
        |   ';'
        |   '('
        |   ')'
        |   "|&"
        |   '|'
        |   '\n'
        ;

    Word : ustring
        ::= (WordItem{ value.Append(WordItem); })+
        ;
        
    WordItem : ustring
        ::= BackslashEscape{ value.Append(BackslashEscape); }
        |   SingleQuotedItem{ value = SingleQuotedItem; }
        |   DoubleQuotedItem{ value = DoubleQuotedItem; }
        |   (anychar - Meta){ value.Append(*matchBegin); }
        ;
        
    BackslashEscape : uchar
        ::= ('\\' Meta){ value = Meta; }
        ;
            
    SingleQuotedItem : ustring
        ::= '\'' (NonSingleQuote{ value.Append(NonSingleQuote); })+ '\''
        ;
        
    NonSingleQuote : uchar
        ::= (anychar - '\''){ value = *matchBegin; }
        ;
        
    DoubleQuotedItem : ustring
        ::= '"' (DoubleQuoteExpandedItem{ value.Append(DoubleQuoteExpandedItem); })+ '"'
        ;

    DoubleQuoteExpandedItem : ustring
        ::= DoubleQuoteBackslashEscape{ value.Append(DoubleQuoteBackslashEscape); }
        |   (anychar - '"'){ value.Append(*matchBegin); }
        ;
    
    Dollar
        ::= '$'
        ;
        
    Backtick
        ::= '`'
        ;
        
    DoubleQuoteBackslashEscape : uchar
        ::= '\\' 
        (   '$'{ value = '$'; }
        |   '"'{ value = '"'; }
        |   '\\'{ value = '\\'; }
        |   '\n'{ value = '\n'; }
        )
        ;
            
    SimpleCommand
        ::= VariableAssignments? WordRedirectionList ControlOperator
        ;
        
    VariableAssignments
        ::= VariableAssignment (Blank VariableAssignment)*
        ;
        
    VariableAssignment
        ::= Name '=' Value?
        ;
        
    WordRedirectionList
        ::= WordOrRedirection (Blank WordOrRedirection)* 
        ;
        
    WordOrRedirection
        ::= Redirection
        |   Word 
        ;
        
    Pipeline
        ::= '!'? Command (PipelineOp Command)*
        ;
        
    PipelineOp  
        ::= "|&" 
        |   '|'
        ;
        
    List
        ::= Pipeline (ListOp PipeLine)* ListTerminator?
        ;
        
    ListOp
        ::= ';'
        |   "&&"
        |   '&'
        |   "||"
        ;
        
    ListTerminator
        ::= ';'
        |   '&'
        |   '\n'
        ;
        
    CompoundCommand
        ::= Subshell
        ;
        
    Subshell
        ::= '(' List ')'
        ;
        
}

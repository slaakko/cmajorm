// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Os;
using System.Security;

namespace cmsh
{
    public class SimpleCommand
    {
        public nothrow string ToString() const
        {
            string s;
            bool first = true;
            for (const Pair<ustring, ustring>& var : variableAssignments)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    s.Append(' ');
                }
                s.Append(ToUtf8(var.first)).Append('=').Append(ToUtf8(var.second));
            }
            if (first)
            {
                first = false;
            }
            else
            {
                s.Append(' ');
            }
            s.Append(name);
            for (const string& arg : args)
            {
                s.Append(' ');
                s.Append(arg);
            }
            for (const UniquePtr<Redirection>& redirection : redirections)
            {
                s.Append(' ');
                s.Append(redirection->ToString());
            }
            return s;
        }
        public HashMap<ustring, ustring> variableAssignments;
        public string name;
        public List<string> args;
        public List<UniquePtr<Redirection>> redirections;
    }
    
    public nothrow byte MapExitCode(ushort exitCode)
    {
        if ((exitCode & 0xFF00u) != 0u)
        {
            return cast<byte>(128u + (exitCode >> 8u));
        }
        return cast<byte>(exitCode & 0xFFu);
    }

    public class CommandProcessor
    {
        public nothrow CommandProcessor(const List<Token>& tokens_, ShellEnvironment& shellEnvironment_) : 
            tokens(tokens_), shellEnvironment(shellEnvironment_), tokenIndex(0), end(END, ustring(), 1, 1)
        {
        }
        public void Run()
        {
            NextToken();
            while (token->id == WORD)
            {
                SimpleCommand simpleCommand = ParseSimpleCommand();
                byte result = Execute(simpleCommand);
                if (shellEnvironment.exit)
                {
                    return;
                }
            }
        }
        private byte Execute(const SimpleCommand& simpleCommand)
        {
            if (shellEnvironment.debug)
            {
                Console.Out() << "cmsh: executing '" << simpleCommand.ToString() << "'" << endl();
            }
            bool tcPgrpChanged = false;
            try
            {
                InternalCommand* internalCommand = shellEnvironment.internalCommandMap.GetCommand(simpleCommand.name);
                if (internalCommand != null)
                {
                    return internalCommand->Execute(shellEnvironment, simpleCommand.args);
                }
                else
                {
                    if (!simpleCommand.name.StartsWith("/"))
                    {
                        if (!shellEnvironment.externalCommandMap.Populated())
                        {
                            shellEnvironment.externalCommandMap.Populate(shellEnvironment);
                        }
                        string pathName = shellEnvironment.externalCommandMap.Find(simpleCommand.name);
                        if (!pathName.IsEmpty())
                        {
                            simpleCommand.name = pathName;
                        }
                    }
                    int pid = Fork();
                    if (pid == 0)
                    {
                        try
                        {
                            for (const Pair<ustring, ustring>& var : simpleCommand.variableAssignments)
                            {
                                SetEnv(ToUtf8(var.first), ToUtf8(var.second));
                            }
                            for (const UniquePtr<Redirection>& redirection : simpleCommand.redirections)
                            {
                                redirection->Execute();
                            }
                            int pgrp = SetPGRP();
                            TCSetPGRP(0, pgrp);
                            tcPgrpChanged = true;
                            Exec(simpleCommand.name, simpleCommand.args);
                        }
                        catch (const Exception& ex)
                        {
                            Console.Error() << ex.Message() << endl();
                            return 1u;
                        }
                    }
                    ushort exitCode = 0u;
                    int childPID = Wait(&exitCode);
                    TCSetPGRP(0, shellEnvironment.pgrp);
                    byte retval = MapExitCode(exitCode);
                    if (shellEnvironment.debug)
                    {
                        Console.Out() << "cmsh: result of command is " << retval << endl();
                    }
                    return retval;
                }
            }
            catch (const Exception& ex)
            {
                Console.Error() << ex.Message() << endl();
                if (tcPgrpChanged)
                {
                    try
                    {
                        TCSetPGRP(0, shellEnvironment.pgrp);
                    }
                    catch (const Exception& ex)
                    {
                    }
                }
                return 1u;
            }
            return 0u;
        }
        private SimpleCommand ParseSimpleCommand()
        {
            SimpleCommand simpleCommand;
            if (token->id == WORD)
            {
                HashMap<ustring, ustring> commandVariables;
                ustring variableName;
                ustring variableValue;
                while (TryParseVariableAssignment(variableName, variableValue))
                {
                    commandVariables[variableName] = variableValue;
                    NextToken();
                }
                Token* word = token;
                if (token->id == WORD)
                {
                    simpleCommand.variableAssignments = Rvalue(commandVariables);
                    simpleCommand.name = ToUtf8(token->value);
                    NextToken();
                    while (token->id == WORD || token->id == LANGLE || token->id == RANGLE)
                    {
                        if (token->id == LANGLE)
                        {
                            int fd = 0;
                            if (!token->value.IsEmpty())
                            {
                                fd = ParseInt(ToUtf8(token->value));
                            }
                            UniquePtr<Redirection> redirection(new InputRedirection(fd));
                            NextToken();
                            if (token->id == WORD)
                            {
                                redirection->filename = ToUtf8(token->value);
                                simpleCommand.redirections.Add(Rvalue(redirection));
                                NextToken();
                            }
                            else
                            {
                                throw Exception("filename for redirection expected (line " + 
                                    ToString(token->line) + ", column " + ToString(token->col) + ")");
                            }
                        }
                        else if (token->id == RANGLE)
                        {
                            int fd = 1;
                            if (!token->value.IsEmpty())
                            {
                                fd = ParseInt(ToUtf8(token->value));
                            }
                            NextToken();
                            if (token->id == WORD)
                            {
                                UniquePtr<Redirection> redirection(new OutputRedirection(fd));
                                redirection->filename = ToUtf8(token->value);
                                simpleCommand.redirections.Add(Rvalue(redirection));
                                NextToken();
                            }
                            else if (token->id == RANGLE)
                            {
                                NextToken();
                                if (token->id == WORD)
                                {
                                    UniquePtr<Redirection> redirection(new AppendRedirection(fd));
                                    redirection->filename = ToUtf8(token->value);
                                    simpleCommand.redirections.Add(Rvalue(redirection));
                                    NextToken();
                                }
                                else
                                {
                                    throw Exception("filename for redirection expected (line " + 
                                        ToString(token->line) + ", column " + ToString(token->col) + ")");
                                }
                            }
                            else
                            {
                                throw Exception("filename for redirection expected (line " + 
                                    ToString(token->line) + ", column " + ToString(token->col) + ")");
                            }
                        }
                        else if (token->id == WORD)
                        {
                            simpleCommand.args.Add(ToUtf8(token->value));
                            NextToken();
                        }
                    }
                }
                else
                {
                    if (commandVariables.IsEmpty())
                    {
                        throw Exception("command or variable assignment expected (line " + 
                            ToString(word->line) + ", column " + ToString(word->col) + ")");
                    }
                    for (const Pair<ustring, ustring>& var : commandVariables)
                    {
                        shellEnvironment.variables[var.first] = var.second;
                    }
                }
            }
            return simpleCommand;
        }
        private bool TryParseVariableAssignment(ustring& variableName, ustring& variableValue)
        {
            if (ParseVariableAssignment(token->value, shellEnvironment.home, shellEnvironment.users, variableName, variableValue))
            {
                ustring expandedValue;
                Tokenizer tokenizer(variableValue, 1, 1, true, false);
                List<Token> valueTokens = tokenizer.Tokenize();
                valueTokens = ExpandParameters(valueTokens, shellEnvironment.variables);
                RemoveQuotes(valueTokens);
                bool first = true;
                for (const Token& token : valueTokens)
                {
                    if (first)
                    {
                        first = false;
                    }
                    else
                    {
                        expandedValue.Append(' ');
                    }
                    expandedValue.Append(token.value);
                }
                variableValue = expandedValue;
                return true;
            }
            else
            {
                return false;
            }
        }
        private void NextToken()
        {
            if (tokenIndex < tokens.Count())
            {
                const Token& t = tokens[tokenIndex++];
                token = &t;
            }
            else
            {
                token = &end;
            }
        }
        private const List<Token>& tokens;
        private ShellEnvironment& shellEnvironment;
        private int tokenIndex;
        private Token end;
        private Token* token;
    }
    
    public void ProcessCommandLine(const List<Token>& tokens, ShellEnvironment& shellEnvironment)
    {
        CommandProcessor commandProcessor(tokens, shellEnvironment);
        commandProcessor.Run();
    }
}

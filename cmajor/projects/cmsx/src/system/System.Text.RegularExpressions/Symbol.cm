using System;
using System.Collections;

namespace System.Text.RegularExpressions
{
    public const uchar eps = '\0';

    public abstract class Symbol
    {
        public default virtual ~Symbol();
        public abstract nothrow bool Match(uchar c) const;
        public abstract nothrow string ToString() const;
    }

    public class Char : Symbol
    {
        public nothrow Char(uchar c_) : chr(c_)
        {
        }
        public override nothrow bool Match(uchar c) const
        {
            return chr == c;
        }
        public override nothrow string ToString() const
        {
            if (chr == eps)
            {
                return "<eps>";
            }
            else
            {
                return ToUtf8(ustring(chr));
            }
        }
        private uchar chr;
    }

    public class Any : Symbol
    {
        public override nothrow bool Match(uchar c) const
        {
            return true;
        }
        public override nothrow string ToString() const
        {
            return "<any>";
        }
    }

    public class Range : Symbol
    {
        public nothrow Range(uchar start_, uchar end_) : start(start_), end(end_)
        {
        }
        public override nothrow bool Match(uchar c) const
        {
            return c >= start && c <= end;
        }
        public nothrow inline uchar Start() const
        {
            return start;
        }
        public nothrow inline uchar End() const
        {
            return end;
        }
        public override nothrow string ToString() const
        {
            string s;
            s.Append(ToUtf8(ustring(start))).Append('-').Append(ToUtf8(ustring(end)));
            return s;
        }
        private uchar start;
        private uchar end;
    }

    public nothrow inline bool operator==(const Range& left, const Range& right)
    {
        return left.Start() == right.Start() && left.End() == right.End();
    }

    public nothrow ulong GetHashCode(const Range& range)
    {
        return (cast<ulong>(range.Start()) << 32u) | cast<ulong>(range.End());
    }

    public class Class : Symbol
    {
        public nothrow Class() : inverse(false)
        {
        }
        public nothrow void SetInverse()
        {
            inverse = true;
        }
        public nothrow void AddSymbol(Symbol* symbol)
        {
            symbols.Add(symbol);
        }
        public override nothrow bool Match(uchar c) const
        {
            bool match = false;
            for (Symbol* symbol : symbols)
            {
                if (symbol->Match(c))
                {
                    match = true;
                    break;
                }
            }
            return match != inverse;
        }
        public override nothrow string ToString() const
        {
            string s = "[";
            if (inverse)
            {
                s.Append('^');
            }
            for (Symbol* symbol : symbols)
            {
                s.Append(symbol->ToString());
            }
            s.Append(']');
            return s;
        }
        private bool inverse;
        private List<Symbol*> symbols;
    }
}

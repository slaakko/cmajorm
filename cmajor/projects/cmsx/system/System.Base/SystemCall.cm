// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

public const byte sys_exit = 0u;
public const byte sys_wait = 1u;
public const byte sys_fork = 2u;
public const byte sys_create = 3u;
public const byte sys_open = 4u;
public const byte sys_close = 5u;
public const byte sys_read = 6u;
public const byte sys_write = 7u;
public const byte sys_seek = 8u;
public const byte sys_tell = 9u;
public const byte sys_pool_end = 10u;
public const byte sys_set_pool_end = 11u;
public const byte sys_debug_break = 12u;
public const byte sys_stack_trace = 13u;
public const byte sys_throw = 14u;
public const byte sys_catch = 15u;
public const byte sys_resume = 16u;
public const byte sys_get_system_error = 17u;
public const byte sys_get_current_time_point = 18u;
public const byte sys_sleep = 19u;
public const byte sys_get_current_date = 20u;
public const byte sys_get_current_date_time = 21u;
public const byte sys_pow = 22u;
public const byte sys_is_host_text_file = 23u;
public const byte sys_is_console = 24u;
public const byte sys_get_random_seed = 25u;
public const byte sys_file_exists = 26u;
public const byte sys_get_file_size = 27u;
public const byte sys_unlink = 28u;
public const byte sys_mkdir = 29u;
public const byte sys_opendir = 30u;
public const byte sys_readdir = 31u;
public const byte sys_closedir = 32u;
public const byte sys_getcwd = 33u;
public const byte sys_stat = 34u;

public cdecl nothrow void exit(byte exitCode)
{
    run_at_exits();
    trap(0u, sys_exit, 0u, exitCode);
}

public cdecl nothrow int wait(ushort* exitCodeAddress)
{
    return cast<int>(trap(0u, sys_wait, 0u, exitCodeAddress));
}

public cdecl nothrow int fork()
{
    return cast<int>(trap(0u, sys_fork, 0u));
}

public cdecl nothrow int create(const char* path, int mode)
{
    return cast<int>(trap(0u, sys_create, 0u, path, mode));
}

public cdecl nothrow int open(const char* path, int flags, int mode)
{
    return cast<int>(trap(0u, sys_open, 0u, path, flags, mode));
}

public cdecl nothrow int close(int fd)
{
    return cast<int>(trap(0u, sys_close, 0u, fd));
}

public cdecl nothrow long read(int fd, void* buffer, long count)
{
    return trap(0u, sys_read, 0u, fd, buffer, count);
}

public cdecl nothrow long write(int fd, void* buffer, long count)
{
    return trap(0u, sys_write, 0u, fd, buffer, count);
}

public cdecl nothrow long seek(int fd, long pos, byte origin)
{
    return trap(0u, sys_seek, 0u, fd, pos, origin);
}

public cdecl nothrow long tell(int fd)
{
    return trap(0u, sys_tell, 0u, fd);
}

public cdecl nothrow void* pool_end()
{
    return cast<void*>(cast<ulong>(trap(0u, sys_pool_end, 0u)));
}

public cdecl nothrow int set_pool_end(void* poolEnd)
{
    return cast<int>(trap(0u, sys_set_pool_end, 0u, poolEnd));
}

public cdecl nothrow int stack_trace(void* buffer, long count)
{
    return cast<int>(trap(0u, sys_stack_trace, 0u, buffer, count));
}

public cdecl void do_throw(void* ex, ulong exTypeId)
{
    trap(0u, sys_throw, 0u, ex, exTypeId);
}

public cdecl nothrow void* do_catch()
{
    return cast<void*>(cast<ulong>(trap(0u, sys_catch, 0u)));
}

public cdecl nothrow void do_resume()
{
    trap(0u, sys_resume, 0u);
}

public cdecl nothrow int get_system_error(int* errorCode, void* buffer, long count)
{
    return cast<int>(trap(0u, sys_get_system_error, 0u, errorCode, buffer, count));
}

public cdecl nothrow long get_current_time_point()
{
    return trap(0u, sys_get_current_time_point, 0u);
}

public cdecl nothrow int sleep(long duration)
{
    return cast<int>(trap(0u, sys_sleep, 0u, duration));
}

public cdecl nothrow int get_current_date(short* y, sbyte* m, sbyte* d)
{
    return cast<int>(trap(0u, sys_get_current_date, 0u, y, m, d));
}

public cdecl nothrow int get_current_date_time(short* y, sbyte* m, sbyte* d, int* secs)
{
    return cast<int>(trap(0u, sys_get_current_date_time, 0u, y, m, d, secs));
}

public cdecl nothrow double pow(double x, double y)
{
    long lx = *cast<long*>(cast<void*>(&x));
    long ly = *cast<long*>(cast<void*>(&y));
    long result = trap(0u, sys_pow, 0u, lx, ly);
    return *cast<double*>(cast<void*>(&result));
}

public cdecl nothrow int is_host_text_file(int fd)
{
    return cast<int>(trap(0u, sys_is_host_text_file, 0u, fd));
}

public cdecl nothrow int is_console(int fd)
{
    return cast<int>(trap(0u, sys_is_console, 0u, fd));
}

public cdecl nothrow long get_random_seed()
{
    return trap(0u, sys_get_random_seed, 0u);
}

public cdecl nothrow int file_exists(const char* filePath)
{
    return cast<int>(trap(0u, sys_file_exists, 0u, filePath));
}

public cdecl nothrow long get_file_size(const char* filePath)
{
    return trap(0u, sys_get_file_size, 0u, filePath);
}

public cdecl nothrow int unlink(const char* filePath)
{
    return cast<int>(trap(0u, sys_unlink, 0u, filePath));
}

public cdecl nothrow int mkdir(const char* path)
{
    return cast<int>(trap(0u, sys_mkdir, 0u, path));
}

public cdecl nothrow int opendir(const char* dirPath)
{
    return cast<int>(trap(0u, sys_opendir, 0u, dirPath));
}

public cdecl nothrow int readdir(int dd, int* inodeNumber, char* entryName)
{
    return cast<int>(trap(0u, sys_readdir, 0u, dd, inodeNumber, entryName));
}

public cdecl nothrow int closedir(int dd)
{
    return cast<int>(trap(0u, sys_closedir, 0u, dd));
}

public cdecl nothrow int getcwd(char* buffer, long count)
{
    return cast<int>(trap(0u, sys_getcwd, 0u, buffer, count));
}

public cdecl nothrow int stat(const char* path, System.IO.StatBuf* statBuf)
{
    return cast<int>(trap(0u, sys_stat, 0u, path, statBuf));
}

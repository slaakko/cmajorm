using System;
using System.IO;
using System.Collections;
using cmsx.machine;

namespace cmsx.object
{
    public const char objectFileVersion_1 = '1';
    public const char objectFileVersion_2 = '2';
    public const char objectFileVersion_3 = '3'; 
    public const char libraryFileVersion_1 = '1';
    public const char libraryFileVersion_2 = '2';
    public const char libraryFileVersion_3 = '3';
    public const char executableFileVersion_1 = '1';
    public const char executableFileVersion_2 = '2';
    public const char executableFileVersion_3 = '3';

    public const char currentObjectFileVersion = objectFileVersion_3;
    public const char currentLibraryFileVersion = libraryFileVersion_3;
    public const char currentExecutableFileVersion = executableFileVersion_3;

    public const ulong fileBlockSize = 4096u;

    public string ObjectFileVersionStr()
    {
        return string(currentObjectFileVersion);
    }

    public string LibraryFileVersionStr()
    {
        return string(currentLibraryFileVersion);
    }

    public string ExecutableFileVersionStr()
    {
        return string(currentExecutableFileVersion);
    }

    public string ReadHeaderName(const string& fileName, System.IO.BinaryReader& reader, int length)
    {
        string result;
        for (int i = 0; i < length; ++i)
        {
            int x = reader.ReadByteOrEnd();
            if (x == -1)
            {
                throw Exception("unexpected end of file " + fileName + " while reading header name, length is " + ToString(length));
            }
            result.Append(cast<char>(x));
        }
        return result;
    }

    public void WriteHeaderName(System.IO.BinaryWriter& writer, const string& headerName)
    {
        for (char c : headerName)
        {
            writer.Write(c);
        }
    }

    public ulong ReadULong(const string& fileName, System.IO.BinaryReader& reader)
    {
        List<byte> b;
        for (int i = 0; i < 8; ++i)
        {
            int x = reader.ReadByteOrEnd();
            if (x == -1)
            {
                throw Exception("unexpected end of file " + fileName);
            }
            b.Add(cast<byte>(x));
        }
        ulong x = (cast<ulong>(b[0]) << 56u) | (cast<ulong>(b[1]) << 48u) | (cast<ulong>(b[2]) << 40u) | (cast<ulong>(b[3]) << 32u) | (cast<ulong>(b[4]) << 24u) | (cast<ulong>(b[5]) << 16u) |
            (cast<ulong>(b[6]) << 8u) | cast<ulong>(b[7]);
        return x;
    }

    public void WriteULong(System.IO.BinaryWriter& writer, ulong x)
    {
        byte x0 = cast<byte>(x);
        x = x >> 8u;
        byte x1 = cast<byte>(x);
        x = x >> 8u;
        byte x2 = cast<byte>(x);
        x = x >> 8u;
        byte x3 = cast<byte>(x);
        x = x >> 8u;
        byte x4 = cast<byte>(x);
        x = x >> 8u;
        byte x5 = cast<byte>(x);
        x = x >> 8u;
        byte x6 = cast<byte>(x);
        x = x >> 8u;
        byte x7 = cast<byte>(x);
        x = x >> 8u;
        writer.Write(x7);
        writer.Write(x6);
        writer.Write(x5);
        writer.Write(x4);
        writer.Write(x3);
        writer.Write(x2);
        writer.Write(x1);
        writer.Write(x0);
    }

    public enum ReadOption : int
    {
        readAll = 0, readHeadersOnly = 1
    }

    public UniquePtr<BinaryFile> ReadBinaryFile(System.IO.BinaryReader& reader, const string& fileName, ReadOption readOption)
    {
        UniquePtr<BinaryFile> file;
        ulong fileOffset = cast<ulong>(reader.Tell());
        if (fileOffset > 0u)
        {
            fileOffset = ((fileOffset - 1u) / fileBlockSize + 1u) * fileBlockSize;
        }
        reader.Seek(cast<long>(fileOffset), Origin.seekSet);
        string fileHeaderName = ReadHeaderName(fileName, reader, 8);
        string headerBaseName = fileHeaderName.Substring(0, fileHeaderName.Length() - 1);
        string fileVersion = fileHeaderName.Substring(fileHeaderName.Length() - 1, 1);
        if (headerBaseName == "CMSXOBJ")
        {
            if (fileVersion == ObjectFileVersionStr())
            {
                file.Reset(new ObjectFile(fileName, false, false));
            }
            else
            {
                throw Exception("invalid file " + fileName + " " + headerBaseName + " version " + fileVersion + " read, version " + ObjectFileVersionStr() + " expected");
            }
        }
        else if (headerBaseName == "CMSXLIB")
        {
            if (fileVersion == LibraryFileVersionStr())
            {
                file.Reset(new LibraryFile(fileName, false, false));
            }
            else
            {
                throw Exception("invalid file " + fileName + " " + headerBaseName + " version " + fileVersion + " read, version " + LibraryFileVersionStr() + " expected");
            }
        }
        else if (headerBaseName == "CMSXEXE")
        {
            if (fileVersion == ExecutableFileVersionStr())
            {
                file.Reset(new ExecutableFile(fileName, false, false, 0u, 0u, 0u, 0u));
            }
            else
            {
                throw Exception("invalid file " + fileName + " " + headerBaseName + " version " + fileVersion + " read, version " + ExecutableFileVersionStr() + " expected");
            }
        }
        else
        {
            throw Exception("invalid file " + fileName + " header '" + headerBaseName + "' not CMSXOBJ, CMSXLIB or CMSXEXE");
        }
        file->Read(reader, readOption);
        return file;
    }

    public UniquePtr<BinaryFile> ReadBinaryFile(System.IO.BinaryReader& reader, const string& fileName)
    {
        return ReadBinaryFile(reader, fileName, ReadOption.readAll);
    }

    public UniquePtr<BinaryFile> ReadBinaryFile(const string& fileName)
    {
        System.IO.BinaryReader reader = System.IO.File.OpenBinary(fileName);
        return ReadBinaryFile(reader, fileName);
    }

    public class BinaryFileFormatter : Formatter
    {
        public nothrow BinaryFileFormatter(BinaryFile& file_) : file(file_)
        {
        }
        public override string FormatRegisterNumber(byte x)
        {
            Symbol* registerSymbol = file.GetSymbolTable().GetRegisterSymbol(x);
            if (registerSymbol != null)
            {
                return registerSymbol->name;
            }
            else
            {
                return base->FormatRegisterNumber(x);
            }
        }
        public override string GetLabel(ulong address)
        {
            Symbol* symbol = file.GetSymbolTable().GetSymbolByAddress(address);
            if (symbol != null)
            {
                if (!symbol->localName.IsEmpty())
                {
                    return symbol->localName;
                }
                else
                {
                    return symbol->name;
                }
            }
            else
            {
                return string();
            }
        }
        private BinaryFile& file;
    }

    public class BinaryFile
    {
        public nothrow BinaryFile(const string& fileName_, Section* headerSection_, bool initSymbolTable) : fileName(fileName_), headerSection(headerSection_), symbolTable(this, initSymbolTable)
        {
        }
        public default virtual ~BinaryFile();
        public virtual void Finalize()
        {
            for (const UniquePtr<Section>& section : sections)
            {
                section->Finalize();
            }
        }
        public virtual void AddSection(Section* section)
        {
            section->file = this;
            sections.Add(UniquePtr<Section>(section));
        }
        public nothrow Section* GetHeaderSection() const
        {
            return headerSection.Get();
        }
        public virtual nothrow Section* GetCodeSection()  const
        {
            return null;
        }
        public virtual nothrow Section* GetDataSection() const
        {
            return null;
        }
        public virtual nothrow Section* GetSymbolSection() const
        {
            return null;
        }
        public Section* CreateSection(const string& sectionName)
        {
            if (sectionName == "CODE")
            {
                return new CodeSection(this);
            }
            else if (sectionName == "DATA")
            {
                return new DataSection(this);
            }
            else if (sectionName == "SYMB")
            {
                return new SymbolSection(this);
            }
            else if (sectionName == "LINK")
            {
                return new LinkSection(this);
            }
            else if (sectionName == "DBUG")
            {
                return new DebugSection(this);
            }
            else
            {
                throw Exception("unknown section '" + sectionName + " in file " + fileName);
            }
        }
        public void Write()
        {
            System.IO.BinaryWriter writer = System.IO.File.CreateBinary(fileName);
            Write(writer);
        }
        public void WriteHeader(System.IO.BinaryWriter& writer)
        {
            WriteHeaderName(writer, headerSection->name);
            headerSection->Write(writer);
            ulong numSections = cast<ulong>(sections.Count());
            WriteULong(writer, numSections);
            for (const UniquePtr<Section>& section : sections)
            {
                WriteHeaderName(writer, section->name);
                writer.Write(section->fileOffset);
                writer.Write(section->length);
            }
            WriteExtendedHeader(writer);
        }
        public virtual void WriteExtendedHeader(System.IO.BinaryWriter& writer)
        {
        }
        public void ReadHeader(System.IO.BinaryReader& reader)
        {
            headerSection->Read(reader);
            ulong numSections = ReadULong(fileName, reader);
            for (ulong i = 0u; i < numSections; ++i)
            {
                string sectionName = ReadHeaderName(fileName, reader, 4);
                Section* section = CreateSection(sectionName);
                section->fileOffset = reader.ReadULong();
                section->length = reader.ReadULong();
                AddSection(section);
            }
            ReadExtendedHeader(reader);
        }
        public virtual void ReadExtendedHeader(System.IO.BinaryReader& reader)
        {
        }
        public void Write(System.IO.BinaryWriter& writer)
        {
            ulong prevFileOffset = cast<ulong>(writer.Tell());
            if (prevFileOffset > 0u)
            {
                prevFileOffset = ((prevFileOffset - 1u) / fileBlockSize + 1u) * fileBlockSize;
            }
            writer.Seek(cast<long>(prevFileOffset), Origin.seekSet);
            WriteHeader(writer);
            for (const UniquePtr<Section>& section : sections)
            {
                ulong sectionFileOffset = cast<ulong>(writer.Tell());
                if (sectionFileOffset > 0u)
                {
                    sectionFileOffset = ((sectionFileOffset - 1u) / fileBlockSize + 1u) * fileBlockSize;
                }
                writer.Seek(cast<long>(sectionFileOffset), Origin.seekSet);
                section->fileOffset = sectionFileOffset;
                section->Write(writer);
            }
            ulong currentFileOffset = cast<ulong>(writer.Tell());
            if (currentFileOffset > 0u)
            {
                currentFileOffset = ((currentFileOffset - 1u) / fileBlockSize + 1u) * fileBlockSize;
            }
            writer.Seek(cast<long>(prevFileOffset), Origin.seekSet);
            WriteHeader(writer);
            writer.Seek(cast<long>(currentFileOffset), Origin.seekSet);
            WriteExtended(writer);
        }
        public virtual void WriteExtended(System.IO.BinaryWriter& writer)
        {
        }
        public void Read(System.IO.BinaryReader& reader, ReadOption readOption)
        {
            ReadHeader(reader);
            if (readOption == ReadOption.readAll)
            {
                long n = sections.Count();
                for (long i = 0; i < n; ++i)
                {
                    Section* section = sections[i].Get();
                    reader.Seek(cast<long>(section->fileOffset), Origin.seekSet);
                    section->Read(reader);
                }
                ReadExtended(reader);
            }
        }
        public virtual void ReadExtended(System.IO.BinaryReader& reader)
        {
        }
        public virtual void AddSymbolsToAddressMap()
        {
        }
        public virtual void Dump(StreamWriter& writer)
        {
            headerSection->Dump(writer);
            for (const UniquePtr<Section>& section : sections)
            {
                section->Dump(writer);
                writer.WriteLine();
            }
        }
        public nothrow SymbolTable& GetSymbolTable()
        {
            return symbolTable;
        }
        public nothrow const string& FileName() const
        {
            return fileName;
        }
        public virtual void ReplaceLinkSection(UniquePtr<Section>& newLinkSection)
        {
            for (UniquePtr<Section>& section : sections)
            {
                if (section.Get() is LinkSection*)
                {
                    Swap(section, newLinkSection);
                    return;
                }
            }
        }
        private string fileName;
        private UniquePtr<Section> headerSection;
        private List<UniquePtr<Section>> sections;
        private SymbolTable symbolTable;
    }

    public class ObjectFile : BinaryFile
    {
        public ObjectFile(const string& fileName_, bool createSections_, bool initSymbolTable) : base(fileName_, new ObjectFileHeaderSection(this), initSymbolTable)
        {
            if (createSections_)
            {
                AddSection(new CodeSection(this));
                AddSection(new DataSection(this));
                AddSection(new SymbolSection(this));
                AddSection(new LinkSection(this));
                AddSection(new DebugSection(this));
            }
        }
        public ObjectFile(const string& fileName_, bool initSymbolTable) : this(fileName_, true, initSymbolTable)
        {
        }
        public override void AddSection(Section* section)
        {
            base->AddSection(section);
            if (section is CodeSection*)
            {
                codeSection = section;
            }
            else if (section is DataSection*)
            {
                dataSection = section;
            }
            else if (section is SymbolSection*)
            {
                symbolSection = section;
            }
            else if (section is LinkSection*)
            {
                linkSection = section;
            }
            else if (section is DebugSection*)
            {
                debugSection = section;
            }
        }
        public override nothrow Section* GetCodeSection()  const
        {
            return codeSection;
        }
        public override nothrow Section* GetDataSection() const
        {
            return dataSection;
        }
        public override nothrow Section* GetSymbolSection() const
        {
            return symbolSection;
        }
        public override void AddSymbolsToAddressMap()
        {
            symbolSection->AddSymbolsToAddressMap();
        }
        public override void ReplaceLinkSection(UniquePtr<Section>& newLinkSection)
        {
            linkSection = newLinkSection.Get();
            base->ReplaceLinkSection(newLinkSection);
        }
        public Section* codeSection;
        public Section* dataSection;
        public Section* symbolSection;
        public Section* linkSection;
        public Section* debugSection;
    }

    public class LibraryFile : BinaryFile
    {
        public LibraryFile(const string& fileName_, bool createSections_, bool initSymbolTable) : base(fileName_, new LibraryFileHeaderSection(this), initSymbolTable)
        {
        }
        public LibraryFile(const string& fileName_, bool initSymbolTable) : this(fileName_, true, initSymbolTable)
        {
        }
        public override void WriteExtendedHeader(System.IO.BinaryWriter& writer)
        {
            ulong numObjectFiles = cast<ulong>(objectFiles.Count());
            WriteULong(writer, numObjectFiles);
            for (const UniquePtr<ObjectFile>& objectFile : objectFiles)
            {
                writer.Write(objectFile->FileName());
            }
        }
        public override void WriteExtended(System.IO.BinaryWriter& writer)
        {
            for (const UniquePtr<ObjectFile>& objectFile : objectFiles)
            {
                objectFile->Write(writer);
            }
        }
        public override void ReadExtendedHeader(System.IO.BinaryReader& reader)
        {
            ulong numObjectFiles = ReadULong(FileName(), reader);
            for (ulong i = 0u; i < numObjectFiles; ++i)
            {
                string objectFileName = reader.ReadString();
                objectFileNames.Add(objectFileName);
            }
        }
        public override void ReadExtended(System.IO.BinaryReader& reader)
        {
            long n = objectFileNames.Count();
            for (long i = 0u; i < n; ++i)
            {
                const string& objectFileName = objectFileNames[i];
                UniquePtr<BinaryFile> binaryFile = ReadBinaryFile(reader, objectFileName);
                if (binaryFile.Get() is ObjectFile*)
                {
                    objectFiles.Add(UniquePtr<ObjectFile>(cast<ObjectFile*>(binaryFile.Release())));
                }
                else
                {
                    throw Exception("object file expected");
                }
            }
        }
        public override void Dump(StreamWriter& writer)
        {
            writer.WriteLine(ToString(objectFiles.Count()) + " object files:");
            for (UniquePtr<ObjectFile>& objectFile : objectFiles)
            {
                writer.WriteLine(objectFile->FileName() + ":");
                objectFile->Dump(writer);
                writer.WriteLine();
            }
        }
        public List<UniquePtr<ObjectFile>> objectFiles;
        public List<string> objectFileNames;
    }

    public class ExecutableFile : BinaryFile
    {
        public ExecutableFile(const string& fileName_, bool createSections_, bool initSymbolTable, ulong minStackSize_, ulong maxStackSize_, ulong stackSizeIncrement_, ulong initialPoolSize_) :
            base(fileName_, new ExecutableFileHeaderSection(this, minStackSize_, maxStackSize_, stackSizeIncrement_, initialPoolSize_), initSymbolTable)
        {
            if (createSections_)
            {
                AddSection(new CodeSection(this));
                AddSection(new DataSection(this));
                AddSection(new SymbolSection(this));
            }
        }
        public ExecutableFile(const string& fileName_, bool initSymbolTable, ulong minStackSize_, ulong maxStackSize_, ulong stackSizeIncrement_, ulong initialPoolSize_) :
            this(fileName_, true, initSymbolTable, minStackSize_, maxStackSize_, stackSizeIncrement_, initialPoolSize_)
        {
        }
        public nothrow ulong MinStackSize() const
        {
            Section* headerSection = GetHeaderSection();
            if (headerSection is ExecutableFileHeaderSection*)
            {
                ExecutableFileHeaderSection* executableFileHeaderSection = cast<ExecutableFileHeaderSection*>(headerSection);
                return executableFileHeaderSection->minStackSize;
            }
            else
            {
                return 0u;
            }
        }
        public nothrow ulong MaxStackSize() const
        {
            Section* headerSection = GetHeaderSection();
            if (headerSection is ExecutableFileHeaderSection*)
            {
                ExecutableFileHeaderSection* executableFileHeaderSection = cast<ExecutableFileHeaderSection*>(headerSection);
                return executableFileHeaderSection->maxStackSize;
            }
            else
            {
                return 0u;
            }
        }
        public nothrow ulong StackSizeIncrement() const
        {
            Section* headerSection = GetHeaderSection();
            if (headerSection is ExecutableFileHeaderSection*)
            {
                ExecutableFileHeaderSection* executableFileHeaderSection = cast<ExecutableFileHeaderSection*>(headerSection);
                return executableFileHeaderSection->stackSizeIncrement;
            }
            else
            {
                return 0u;
            }
        }
        public nothrow ulong InitialPoolSize() const
        {
            Section* headerSection = GetHeaderSection();
            if (headerSection is ExecutableFileHeaderSection*)
            {
                ExecutableFileHeaderSection* executableFileHeaderSection = cast<ExecutableFileHeaderSection*>(headerSection);
                return executableFileHeaderSection->initialPoolSize;
            }
            else
            {
                return 0u;
            }
        }
        public override nothrow Section* GetCodeSection()  const
        {
            return codeSection;
        }
        public override nothrow Section* GetDataSection() const
        {
            return dataSection;
        }
        public override nothrow Section* GetSymbolSection() const
        {
            return symbolSection;
        }
        public override void AddSymbolsToAddressMap()
        {
            symbolSection->AddSymbolsToAddressMap();
        }
        public override void AddSection(Section* section)
        {
            base->AddSection(section);
            if (section is CodeSection*)
            {
                codeSection = section;
            }
            else if (section is DataSection*)
            {
                dataSection = section;
            }
            else if (section is SymbolSection*)
            {
                symbolSection = section;
            }
        }
        public Section* codeSection;
        public Section* dataSection;
        public Section* symbolSection;
    }

    public class Section
    {
        public nothrow Section() : file(null), name(), pos(0), baseAddress(0u), length(0u), dataLength(0u), copyStartPos(0u), removeOffset(0u), fileOffset(0u)
        {
        }
        public nothrow Section(BinaryFile* file_, const string& name_) : file(file_), name(name_), pos(0), baseAddress(0u), length(0u), dataLength(0u), copyStartPos(0u), removeOffset(0u), fileOffset(0u)
        {
        }
        public default virtual ~Section();
        public virtual void Finalize()
        {
        }
        public virtual void AddSymbol(Symbol* symbol)
        {
        }
        public virtual void AddSymbolsToAddressMap()
        {
        }
        public nothrow ulong Address() const
        {
            return cast<ulong>(pos);
        }
        public nothrow ulong BaseAddress() const
        {
            return baseAddress;
        }
        public nothrow void SetBaseAddress(ulong baseAddress_)
        {
            baseAddress = baseAddress_;
        }
        public nothrow ulong DataLength() const
        {
            return cast<ulong>(data.Count());
        }
        public void Write(System.IO.BinaryWriter& writer)
        {
            length = cast<ulong>(data.Count()) + 2u * 8u;
            dataLength = cast<ulong>(data.Count());
            WriteULong(writer, dataLength);
            WriteULong(writer, baseAddress);
            for (byte b : data)
            {
                writer.Write(b);
            }
            WriteExtended(writer);
        }
        public virtual void WriteExtended(System.IO.BinaryWriter& writer)
        {
        }
        public void Read(System.IO.BinaryReader& reader)
        {
            dataLength = reader.ReadULong();
            baseAddress = ReadULong(file->FileName(), reader);
            for (ulong i = 0u; i < dataLength; ++i)
            {
                int x = reader.ReadByteOrEnd();
                if (x == -1)
                {
                    throw Exception("unexpected end of " + name + " section  of file '" + file->FileName() + "': dataLength=" + ToString(dataLength) + ", " + ToString(i) + " bytes read.");
                }
                data.Add(cast<byte>(x));
            }
            ReadExtended(reader);
        }
        public virtual void ReadExtended(System.IO.BinaryReader& reader)
        {
        }
        public virtual void Dump(StreamWriter& writer)
        {
            writer.WriteLine(name + " section");
            if ((this is CodeSection*) || (this is DataSection*))
            {
                writer.WriteLine(Format("base address:", 17) + " #" + ToHexString(baseAddress));
            }
            writer.WriteLine(Format("length:", 17) + " #" + ToHexString(dataLength));
        }
        public nothrow int GetByte()
        {
            if (pos < data.Count())
            {
                return data[pos++];
            }
            else
            {
                return -1;
            }
        }
        public void EmitByte(byte b)
        {
            if (pos == data.Count())
            {
                data.Add(b);
                ++pos;
            }
            else if (pos < data.Count())
            {
                data[pos++] = b;
            }
            else
            {
                throw Exception("invalid pos for file " + file->FileName() + " " + name + " section: " + ToString(pos));
            }
        }
        public void EmitByte(ulong address, byte b)
        {
            long prevPos = pos;
            pos = cast<long>(address);
            EmitByte(b);
            pos = prevPos;
        }
        public nothrow void EmitLongOffset(ulong address, uint longOffset)
        {
            long prevPos = pos;
            pos = cast<long>(address + 1u);
            EmitLongOffset(longOffset);
            pos = prevPos;
        }
        public nothrow void EmitShortOffset(ulong address, ushort shortOffset)
        {
            long prevPos = pos;
            pos = cast<long>(address + 2u);
            EmitShortOffset(shortOffset);
            pos = prevPos;
        }
        public nothrow void EmitULong(ulong address, ulong x)
        {
            long prevPos = pos;
            pos = cast<long>(address);
            EmitULong(x);
            pos = prevPos;
        }
        public string GetString()
        {
            string result;
            int x = GetByte();
            while (x != -1 && x != 0)
            {
                result.Append(cast<char>(x));
                x = GetByte();
            }
            if (x == -1)
            {
                throw Exception("unexpected end of " + name + " section of file " + file->FileName());
            }
            return result;
        }
        public void EmitString(const string& s)
        {
            for (char c : s)
            {
                EmitByte(cast<byte>(c));
            }
            EmitByte(0u);
        }
        public void EmitShortOffset(ushort offset)
        {
            byte b0 = cast<byte>(offset);
            offset = offset >> 8u;
            byte b1 = cast<byte>(offset);
            offset = offset >> 8u;
            #assert(offset == 0u);
            EmitByte(b1);
            EmitByte(b0);
        }
        public void EmitLongOffset(uint offset)
        {
            byte b0 = cast<byte>(offset);
            offset = offset >> 8u;
            byte b1 = cast<byte>(offset);
            offset = offset >> 8u;
            byte b2 = cast<byte>(offset);
            offset = offset >> 8u;
            EmitByte(b2);
            EmitByte(b1);
            EmitByte(b0);
        }
        public uint GetUInt()
        {
            List<byte> b;
            for (int i = 0; i < 4; ++i)
            {
                int x = GetByte();
                if (x == -1)
                {
                    throw Exception("unexpected end of " + name + " section of file " + file->FileName());
                }
                b.Add(cast<byte>(x));
            }
            uint u = (cast<uint>(b[0]) << 24u) | (cast<uint>(b[1]) << 16u) | (cast<uint>(b[2]) << 8u) | cast<uint>(b[3]);
            return u;
        }
        public void EmitUInt(uint x)
        {
            byte b0 = cast<byte>(x);
            x = x >> 8u;
            byte b1 = cast<byte>(x);
            x = x >> 8u;
            byte b2 = cast<byte>(x);
            x = x >> 8u;
            byte b3 = cast<byte>(x);
            x = x >> 8u;
            #assert(x == 0u);
            EmitByte(b3);
            EmitByte(b2);
            EmitByte(b1);
            EmitByte(b0);
        }
        public void EmitUInt(ulong address, uint x)
        {
            long prevPos = pos;
            pos = cast<long>(address);
            EmitUInt(x);
            pos = prevPos;
        }
        public ulong GetULong()
        {
            List<byte> b;
            for (int i = 0; i < 8; ++i)
            {
                int x = GetByte();
                if (x == -1)
                {
                    throw Exception("unexpected end of " + name + " section of file " + file->FileName());
                }
                b.Add(cast<byte>(x));
            }
            ulong u = (cast<ulong>(b[0]) << 56u) | (cast<ulong>(b[1]) << 48u) | (cast<ulong>(b[2]) << 40u) | (cast<ulong>(b[3]) << 32u) | (cast<ulong>(b[4]) << 24u) | (cast<ulong>(b[5]) << 16u) |
                (cast<ulong>(b[6]) << 8u) | cast<ulong>(b[7]);
            return u;
        }
        public void EmitULong(ulong x)
        {
            byte b0 = cast<byte>(x);
            x = x >> 8u;
            byte b1 = cast<byte>(x);
            x = x >> 8u;
            byte b2 = cast<byte>(x);
            x = x >> 8u;
            byte b3 = cast<byte>(x);
            x = x >> 8u;
            byte b4 = cast<byte>(x);
            x = x >> 8u;
            byte b5 = cast<byte>(x);
            x = x >> 8u;
            byte b6 = cast<byte>(x);
            x = x >> 8u;
            byte b7 = cast<byte>(x);
            x = x >> 8u;
            #assert(x == 0u);
            EmitByte(b7);
            EmitByte(b6);
            EmitByte(b5);
            EmitByte(b4);
            EmitByte(b3);
            EmitByte(b2);
            EmitByte(b1);
            EmitByte(b0);
        }
        public void Align(ulong alignment)
        {
            ulong at = Address();
            ulong a = at & (alignment - 1u);
            if (a != 0u)
            {
                ulong offset = alignment - a;
                for (ulong i = 0u; i < offset; ++i)
                {
                    EmitByte(0u);
                }
            }
        }
        public BinaryFile* file;
        public string name;
        public List<byte> data;
        public long pos;
        public ulong baseAddress;
        public ulong length;
        public ulong dataLength;
        public ulong copyStartPos;
        public ulong removeOffset;
        public Section* copyTargetSection;
        public ulong fileOffset;
    }

    public class ObjectFileHeaderSection : Section
    {
        public nothrow ObjectFileHeaderSection(BinaryFile* file_) : base(file_, "CMSXOBJ" + ObjectFileVersionStr())
        {
        }
        public override void Dump(StreamWriter& writer)
        {
        }
    }

    public class LibraryFileHeaderSection : Section
    {
        public nothrow LibraryFileHeaderSection(BinaryFile* file_) : base(file_, "CMSXLIB" + LibraryFileVersionStr())
        {
        }
        public override void Dump(StreamWriter& writer)
        {
        }
    }

    public class ExecutableFileHeaderSection : Section
    {
        public nothrow ExecutableFileHeaderSection(BinaryFile* file_, ulong minStackSize_, ulong maxStackSize_, ulong stackSizeIncrement_, ulong initialPoolSize_) :
            base(file_, "CMSXEXE" + ExecutableFileVersionStr()), minStackSize(minStackSize_), maxStackSize(maxStackSize_), stackSizeIncrement(stackSizeIncrement_), initialPoolSize(initialPoolSize_)
        {
        }
        public override void WriteExtended(System.IO.BinaryWriter& writer)
        {
            WriteULong(writer, minStackSize);
            WriteULong(writer, maxStackSize);
            WriteULong(writer, stackSizeIncrement);
            WriteULong(writer, initialPoolSize);
            length = length + 4u * 8u;
        }
        public override void ReadExtended(System.IO.BinaryReader& reader)
        {
            minStackSize = ReadULong(file->FileName(), reader);
            maxStackSize = ReadULong(file->FileName(), reader);
            stackSizeIncrement = ReadULong(file->FileName(), reader);
            initialPoolSize = ReadULong(file->FileName(), reader);
        }
        public override void Dump(StreamWriter& writer)
        {
            writer.WriteLine("HEADER section");
            writer.WriteLine(Format("min stack size:", 17) + " #" + ToHexString(minStackSize));
            writer.WriteLine(Format("max stack size:", 17) + " #" + ToHexString(maxStackSize));
            writer.WriteLine(Format("initial pool size:", 17) + " #" + ToHexString(initialPoolSize));
            writer.WriteLine();
        }
        public ulong minStackSize;
        public ulong maxStackSize;
        public ulong stackSizeIncrement;
        public ulong initialPoolSize;
    }

    public class CodeSection : Section
    {
        public nothrow CodeSection(BinaryFile* file_) : base(file_, "CODE")
        {
        }
        public override void Dump(StreamWriter& writer)
        {
            if (file == null)
            {
                throw Exception("file is null");
            }
            BinaryFileFormatter formatter(*file);
            base->Dump(writer);
            pos = 0;
            ulong address = 0u;
            int opc = GetByte();
            while (opc != -1)
            {
                byte opCode = cast<byte>(opc);
                int x = GetByte();
                int y = GetByte();
                int z = GetByte();
                if (x != -1 && y != -1 && z != -1)
                {
                    byte xx = cast<byte>(x);
                    byte yy = cast<byte>(y);
                    byte zz = cast<byte>(z);
                    string instructionLine = FormatInstruction(BaseAddress() + address, opCode, xx, yy, zz, formatter);
                    writer.WriteLine(instructionLine);
                }
                else
                {
                    throw Exception("unexpected end of data of file " + file->FileName());
                }
                address = address + 4u;
                opc = GetByte();
            }
        }
    }

    public class DataSection : Section
    {
        public nothrow DataSection(BinaryFile* file_) : base(file_, "DATA")
        {
            SetBaseAddress(cmsx.machine.dataSegmentBaseAddress);
        }
        public override void AddSymbol(Symbol* symbol)
        {
            symbols.Add(symbol);
        }
        public override void WriteExtended(System.IO.BinaryWriter& writer)
        {
            long n = symbols.Count();
            writer.Write(cast<ulong>(n));
            for (long i = 0; i < n; ++i)
            {
                Symbol* symbol = symbols[i];
                ulong startOffset = symbol->start;
                writer.Write(startOffset);
            }
            length = length + (cast<ulong>(n) + 1u) * 8u;
        }
        public override void ReadExtended(System.IO.BinaryReader& reader)
        {
            ulong n = reader.ReadULong();
            for (ulong i = 0u; i < n; ++i)
            {
                ulong startOffset = reader.ReadULong();
                startOffsets.Add(startOffset);
            }
        }
        public override void Dump(StreamWriter& writer)
        {
            if (file == null)
            {
                throw Exception("file is null");
            }
            Symbol* debugInfoSymbol = file->GetSymbolTable().GetSymbol("@debug_info");
            long maxPos = MaxValue<long>();
            if (debugInfoSymbol != null)
            {
                maxPos = cast<long>(debugInfoSymbol->value.value);
            }
            BinaryFileFormatter formatter(*file);
            base->Dump(writer);
            ulong startOffset = cast<ulong>(-1);
            long startOffsetIndex = 0;
            if (!startOffsets.IsEmpty())
            {
                startOffset = startOffsets[0];
                ++startOffsetIndex;
                if (startOffsetIndex < startOffsets.Count())
                {
                    startOffset = startOffsets[startOffsetIndex];
                    ++startOffsetIndex;
                }
                else
                {
                    startOffset = cast<ulong>(-1);
                }
            }
            pos = 0;
            ulong address = 0u;
            ulong baseAddr = BaseAddress() + address;
            string currentBytes;
            string currentChars;
            string currentHeader = "#" + ToHexString(baseAddr) + " " + Format(formatter.GetLabel(baseAddr), 80, FormatWidth.min);
            int b = GetByte();
            while (b != -1)
            {
                if (pos >= maxPos)
                {
                    break;
                }
                baseAddr = BaseAddress() + address;
                if (baseAddr == startOffset)
                {
                    writer.WriteLine(currentHeader + " " + currentBytes + " " + currentChars);
                    currentBytes.Clear();
                    currentChars.Clear();
                    currentHeader = "#" + ToHexString(baseAddr) + " " + Format(formatter.GetLabel(baseAddr), 80, FormatWidth.min);
                    if (startOffsetIndex < startOffsets.Count())
                    {
                        startOffset = startOffsets[startOffsetIndex];
                        ++startOffsetIndex;
                    }
                    else
                    {
                        startOffset = cast<ulong>(-1);
                    }
                }
                if (!currentBytes.IsEmpty())
                {
                    currentBytes.Append(" ");
                }
                currentBytes.Append(ToHexString(cast<byte>(b)));
                char c = '.';
                if (b >= 32u && b < 127u)
                {
                    c = cast<char>(b);
                }
                currentChars.Append(c);
                b = GetByte();
                ++address;
            }
            if (!currentBytes.IsEmpty())
            {
                writer.WriteLine(currentHeader + " " + currentBytes + " " + currentChars);
            }
            writer.WriteLine();
            if (debugInfoSymbol != null)
            {
                writer.WriteLine("DEBUG INFO");
                writer.WriteLine("start:  " + ToHexString(debugInfoSymbol->start));
                writer.WriteLine("length: " + ToHexString(debugInfoSymbol->length));
                writer.WriteLine();
                Symbol* functionTableSymbol = file->GetSymbolTable().GetSymbol("@function_table");
                DumpFunctionTable(functionTableSymbol, writer);
            }
        }
        public override void Finalize()
        {
            Align(8u);
        }
        private void DumpFunctionTable(Symbol* functionTableSymbol, StreamWriter& writer)
        {
            writer.WriteLine("FUNCTION TABLE");
            writer.WriteLine("start:  " + ToHexString(functionTableSymbol->start));
            writer.WriteLine("length: " + ToHexString(functionTableSymbol->length));
            writer.WriteLine();
            long prevPos = pos;
            long functionTableStartPos = cast<long>(functionTableSymbol->value.value);
            long functionTableEndPos = functionTableStartPos + cast<long>(functionTableSymbol->length);
            pos = functionTableStartPos;
            while (pos < functionTableEndPos)
            {
                DumpFunctionTableEntry(writer);
            }
        }
        private void DumpFunctionTableEntry(StreamWriter& writer)
        {
            writer.WriteLine("FUNCTION TABLE ENTRY");
            ulong start = GetULong();
            Symbol* functionSymbol = file->GetSymbolTable().GetSymbolByAddress(start);
            ulong length = GetULong();
            ulong mangledNameAddress = GetULong();
            ulong fullNameAddress = GetULong();
            ulong sourceFileNameAddress = GetULong();
            ulong lineNumberTableStartAddress = GetULong();
            ulong lineNumberTableEndAddress = GetULong();
            ulong exceptionTableAddress = GetULong();
            writer.Write("                start: " + ToHexString(start));
            if (functionSymbol != null)
            {
                writer.Write(" " + functionSymbol->name);
            }
            writer.WriteLine();
            writer.WriteLine("               length: " + ToHexString(length));
            writer.WriteLine("          mangledName: " + ToHexString(mangledNameAddress) + " " + GetString(mangledNameAddress));
            writer.WriteLine("             fullName: " + ToHexString(fullNameAddress) + " " + GetString(fullNameAddress));
            writer.WriteLine("       sourceFileName: " + ToHexString(sourceFileNameAddress) + " " + GetString(sourceFileNameAddress));
            writer.WriteLine(" lineNumberTableStart: " + ToHexString(lineNumberTableStartAddress));
            writer.WriteLine("   lineNumberTableEnd: " + ToHexString(lineNumberTableEndAddress));
            writer.Write    ("      lineNumberTable: ");
            DumpLineNumberTable(lineNumberTableStartAddress, lineNumberTableEndAddress, writer);
            writer.WriteLine();
            writer.WriteLine("exceptionTableAddress: " + ToHexString(exceptionTableAddress));
            if (exceptionTableAddress != 0u)
            {
                DumpExceptionTable(exceptionTableAddress, writer);
            }
            writer.WriteLine();
        }
        private string GetString(ulong address)
        {
            long prevPos = pos;
            pos = cast<long>(address);
            string s = GetString();
            pos = prevPos;
            return s;
        }
        private void DumpLineNumberTable(ulong lineNumberTableStartAddress, ulong lineNumberTableEndAddress, StreamWriter& writer)
        {
            if (lineNumberTableStartAddress == lineNumberTableEndAddress) return;
            writer.Write("[");
            long prevPos = pos;
            pos = cast<long>(lineNumberTableStartAddress);
            bool first = true;
            while (pos < cast<long>(lineNumberTableEndAddress))
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    writer.Write(" : ");
                }
                uint offset = GetUInt();
                uint line = GetUInt();
                writer.Write("offset: " + ToString(offset) + ", line: " + ToString(line));
            }
            writer.Write("]");
            pos = prevPos;
        }
        private void DumpExceptionTable(ulong exceptionTableAddress, StreamWriter& writer)
        {
            writer.WriteLine();
            writer.WriteLine("EXCEPTION TABLE " + ToHexString(exceptionTableAddress));
            long prevPos = pos;
            pos = cast<long>(exceptionTableAddress);
            ulong frameSize = GetUInt();
            writer.WriteLine("frame size: " + ToString(frameSize));
            ulong numDispatchTableEntries = GetUInt();
            writer.WriteLine();
            writer.WriteLine("DISPATCH TABLE (" + ToString(numDispatchTableEntries) + " entries)");
            Set<ulong> exceptionBlockTableAddressSet;
            for (ulong i = 0u; i < numDispatchTableEntries; ++i)
            {
                uint offset = GetUInt();
                uint length = GetUInt();
                ulong exceptionBlockTableAddress = GetULong();
                writer.WriteLine(ToString(i) + ": offset: " + ToString(offset) + ", length: " + ToString(length) + ", exception block table address: " + ToHexString(exceptionBlockTableAddress));
                exceptionBlockTableAddressSet.Insert(exceptionBlockTableAddress);
            }
            while (!exceptionBlockTableAddressSet.IsEmpty())
            {
                Set<ulong> newExceptionBlockTableAddressSet;
                for (ulong exceptionBlockTableAddress : exceptionBlockTableAddressSet)
                {
                    writer.WriteLine();
                    writer.WriteLine("EXCEPTION BLOCK TABLE " + ToHexString(exceptionBlockTableAddress));
                    long prevPos = pos;
                    pos = cast<long>(exceptionBlockTableAddress);
                    while (true)
                    {
                        ulong discriminator = GetULong();
                        if (discriminator == handlerBlockDiscriminator)
                        {
                            writer.WriteLine();
                            writer.WriteLine("HANDLER BLOCK");
                            ulong catchedClassId = GetULong();
                            ulong handlerAddress = GetULong();
                            writer.WriteLine("catched class id:   " + ToString(catchedClassId));
                            writer.Write("handlerAddress:     " + ToHexString(handlerAddress) + " ");
                            Symbol* handlerSymbol = file->GetSymbolTable().GetSymbolByAddress(handlerAddress);
                            if (handlerSymbol != null)
                            {
                                writer.Write(handlerSymbol->name);
                            }
                            writer.WriteLine();
                        }
                        else if (discriminator == cleanupBlockDiscriminator)
                        {
                            writer.WriteLine();
                            writer.WriteLine("CLEANUP BLOCK");
                            ulong cleanupAddress = GetULong();
                            ulong  parentTableAddress = GetULong();
                            writer.Write("cleanup address:    " + ToHexString(cleanupAddress) + " ");
                            Symbol* cleanupSymbol = file->GetSymbolTable().GetSymbolByAddress(cleanupAddress);
                            if (cleanupSymbol != null)
                            {
                                writer.Write(cleanupSymbol->name);
                            }
                            writer.WriteLine();
                            writer.WriteLine("parent table addr:  " + ToHexString(parentTableAddress));
                            if (parentTableAddress != 0u)
                            {
                                newExceptionBlockTableAddressSet.Insert(parentTableAddress);
                            }
                        }
                        else if (discriminator == endBlockDiscriminator)
                        {
                            break;
                        }
                        else
                        {
                            throw Exception("unknonwn exception block table discriminator " + ToString(discriminator));
                        }
                    }
                    pos = prevPos;  
                }
                Swap(exceptionBlockTableAddressSet, newExceptionBlockTableAddressSet);
            }
            pos = prevPos;
        }
        private List<Symbol*> symbols;
        private List<ulong> startOffsets;
    }

    public class SymbolSection : Section
    {
        public nothrow SymbolSection(BinaryFile* file_) : base(file_, "SYMB")
        {
        }
        public override void Finalize()
        {
            if (file is ExecutableFile*)
            {
                SymbolTable& symbolTable = file->GetSymbolTable();
                for (const UniquePtr<Symbol>& symbol : symbolTable.Symbols())
                {
                    if (symbol->section != null)
                    {
                        if (symbol->section is CodeSection*)
                        {
                            symbol->value.value = symbol->start - file->GetCodeSection()->BaseAddress();
                        }
                        else if (symbol->section is DataSection*)
                        {
                            symbol->value.value = symbol->start - file->GetDataSection()->BaseAddress();
                        }
                    }
                }
            }
            EmitSymbols();
        }
        public Segment GetSegment()
        {
            int segment = GetByte();
            if (segment == -1)
            {
                throw Exception("unexpected end of " + name + " section of file " + file->FileName());
            }
            return cast<Segment>(cast<byte>(segment));
        }
        public Linkage GetLinkage()
        {
            int linkage = GetByte();
            if (linkage == -1)
            {
                throw Exception("unexpected end of " + name + " section of file " + file->FileName());
            }
            return cast<Linkage>(cast<byte>(linkage));
        }
        public Value.Flag GetValueFlags()
        {
            int flags = GetByte();
            if (flags == -1)
            {
                throw Exception("unexpected end of " + name + " section of file " + file->FileName());
            }
            return cast<Value.Flag>(cast<byte>(flags));
        }
        public Value GetValue()
        {
            Value.Flag flags = GetValueFlags();
            ulong v = GetULong();
            Value value(flags, v, null);
            return value;
        }
        public override void ReadExtended(System.IO.BinaryReader& reader)
        {
            pos = 0;
            ulong numSymbols = GetULong();
            for (ulong i = 0u; i < numSymbols; ++i)
            {
                uint symbolIndex = GetUInt();
                string symbolName = GetString();
                string symbolLocalName = GetString();
                Segment segment = GetSegment();
                Section* section = null;
                if (segment == Segment.text)
                {
                    section = file->GetCodeSection();
                }
                else if (segment == Segment.data)
                {
                    section = file->GetDataSection();
                }
                Linkage linkage = GetLinkage();
                Value value = GetValue();
                ulong start = GetULong();
                ulong length = GetULong();
                Symbol* symbol = new Symbol();
                symbol->index = cast<int>(symbolIndex);
                symbol->name = symbolName;
                symbol->localName = symbolLocalName;
                symbol->segment = segment;
                symbol->linkage = linkage;
                symbol->value = value;
                symbol->start = start;
                symbol->length = length;
                symbol->section = section;
                uint parentIndex = GetUInt();
                symbol->parentIndex = cast<int>(parentIndex);
                uint linkStart = GetUInt();
                uint linkEnd = GetUInt();
                symbol->linkStart = cast<int>(linkStart);
                symbol->linkEnd = cast<int>(linkEnd);
                int alignment = GetByte();
                symbol->alignment = cast<byte>(alignment);
                file->GetSymbolTable().AddSymbol(symbol, false);
            }
            ulong numInternalSymbols = GetULong();
            for (ulong i = 0u; i < numInternalSymbols; ++i)
            {
                uint symbolIndex = GetUInt();
                string symbolName = GetString();
                string symbolLocalName = GetString();
                Segment segment = GetSegment();
                Section* section = null;
                if (segment == Segment.text)
                {
                    section = file->GetCodeSection();
                }
                else if (segment == Segment.data)
                {
                    section = file->GetDataSection();
                }
                Linkage linkage = GetLinkage();
                Value value = GetValue();
                ulong start = GetULong();
                ulong length = GetULong();
                Symbol* symbol = new Symbol();
                symbol->index = cast<int>(symbolIndex);
                symbol->name = symbolName;
                symbol->localName = symbolLocalName;
                symbol->segment = segment;
                symbol->linkage = linkage;
                symbol->value = value;
                symbol->start = start;
                symbol->length = length;
                symbol->section = section;
                uint parentIndex = GetUInt();
                symbol->parentIndex = cast<int>(parentIndex);
                uint linkStart = GetUInt();
                uint linkEnd = GetUInt();
                symbol->linkStart = cast<int>(linkStart);
                symbol->linkEnd = cast<int>(linkEnd);
                int alignment = GetByte();
                symbol->alignment = cast<byte>(alignment);
                file->GetSymbolTable().AddInternalSymbol(symbol, false);
            }
        }
        public void EmitSymbols()
        {
            if (file == null)
            {
                throw Exception("file is null");
            }
            SymbolTable& symbolTable = file->GetSymbolTable();
            EmitULong(cast<ulong>(symbolTable.Symbols().Count()));
            for (const UniquePtr<Symbol>& symbol : symbolTable.Symbols())
            {
                EmitSymbol(symbol.Get());
            }
            EmitULong(cast<ulong>(symbolTable.InternalSymbols().Count()));
            for (const UniquePtr<Symbol>& symbol : symbolTable.InternalSymbols())
            {
                EmitSymbol(symbol.Get());
            }
        }
        public void EmitSymbol(Symbol* symbol)
        {
            EmitUInt(cast<uint>(symbol->index));
            EmitString(symbol->name);
            EmitString(symbol->localName);
            EmitByte(symbol->segment);
            EmitByte(symbol->linkage);
            EmitValue(symbol->value);
            EmitULong(symbol->start);
            EmitULong(symbol->length);
            EmitUInt(cast<uint>(symbol->parentIndex));
            EmitUInt(cast<uint>(symbol->linkStart));
            EmitUInt(cast<uint>(symbol->linkEnd));
            EmitByte(symbol->alignment);
        }
        public void EmitValue(const Value& value)
        {
            EmitByte(value.flags);
            EmitULong(value.value);
        }
        public override void AddSymbolsToAddressMap()
        {
            SymbolTable& symbolTable = file->GetSymbolTable();
            for (const UniquePtr<Symbol>& symbol : symbolTable.Symbols())
            {
                symbolTable.AddSymbolToAddressMap(symbol.Get());
            }
        }
        public override void Dump(StreamWriter& writer)
        {
            base->Dump(writer);
            SymbolTable& symbolTable = file->GetSymbolTable();
            for (const UniquePtr<Symbol>& symbol : symbolTable.Symbols())
            {
                string symbolLine;
                string absoluteAddress;
                if (symbol->value.GetFlag(Value.Flag.pure))
                {
                    absoluteAddress = "#" + ToHexString(symbol->start);
                }
                symbolLine.Append(Format(absoluteAddress, 17));
                symbolLine.Append(" ").Append(Format(ToString(symbol->index), 11));
                symbolLine.Append(" ").Append(Format(symbol->name, 80, FormatWidth.min));
                symbolLine.Append(" ").Append(Format(SegmentStr(symbol->segment), 7));
                symbolLine.Append(" ").Append(Format(LinkageStr(symbol->linkage), 9)); 
                symbolLine.Append(" ").Append(ValueStr(symbol->value));
                if (symbol->value.GetFlag(Value.Flag.function) || symbol->value.GetFlag(Value.Flag.structure))
                {
                    symbolLine.Append(" ").Append("#").Append(ToHexString(symbol->start));
                    symbolLine.Append(" ").Append("#").Append(ToHexString(symbol->length));
                    symbolLine.Append(" ").Append(ToString(symbol->linkStart));
                    symbolLine.Append(" ").Append(ToString(symbol->linkEnd));
                }
                symbolLine.Append(" ").Append(ToString(symbol->alignment));
                writer.WriteLine(symbolLine);
            }
            for (const UniquePtr<Symbol>& symbol : symbolTable.InternalSymbols())
            {
                string symbolLine;
                string absoluteAddress;
                if (symbol->value.GetFlag(Value.Flag.pure))
                {
                    absoluteAddress = "#" + ToHexString(symbol->start);
                }
                symbolLine.Append(Format(absoluteAddress, 17));
                symbolLine.Append(" ").Append(Format(ToString(symbol->index), 11));
                symbolLine.Append(" ").Append(Format(symbol->name, 80, FormatWidth.min));
                symbolLine.Append(" ").Append(Format(SegmentStr(symbol->segment), 7));
                symbolLine.Append(" ").Append(Format(LinkageStr(symbol->linkage), 9)); 
                symbolLine.Append(" ").Append(ValueStr(symbol->value));
                if (symbol->value.GetFlag(Value.Flag.function) || symbol->value.GetFlag(Value.Flag.structure))
                {
                    symbolLine.Append(" ").Append("#").Append(ToHexString(symbol->start));
                    symbolLine.Append(" ").Append("#").Append(ToHexString(symbol->length));
                }
                symbolLine.Append(" ").Append(ToString(symbol->alignment));
                writer.WriteLine(symbolLine);
            }
        }
    }

    public class LinkSection : Section
    {
        public nothrow LinkSection(BinaryFile* file_) : base(file_, "LINK")
        {
        }
        public override void Dump(StreamWriter& writer)
        {
            if (file == null)
            {
                throw Exception("file is null");
            }
            BinaryFileFormatter formatter(*file);
            base->Dump(writer);
            pos = 0;
            long p = pos;
            int x = GetByte();
            while (x != -1)
            {
                LinkCode linkCode = cast<LinkCode>(cast<byte>(x));
                if (linkCode == LinkCode.end)
                {
                    break;
                }
                string linkLine = Format(ToString(p), 5, FormatWidth.min, FormatJustify.right);
                linkLine.Append(" ").Append(Format(LinkCodeStr(linkCode), maxLinkCodeStrLength));
                switch (linkCode)
                {
                    case LinkCode.forwardLongJump:
                    {
                        uint index = GetUInt();
                        linkLine.Append(" ").Append(Format(ToString(index), 5, FormatWidth.min, FormatJustify.right));
                        Symbol* s = file->GetSymbolTable().GetSymbol(cast<int>(index));
                        linkLine.Append(" ").Append(s->name);
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        break;
                    }
                    case LinkCode.forwardShortJump:
                    {
                        uint index = GetUInt();
                        linkLine.Append(" ").Append(Format(ToString(index), 5, FormatWidth.min, FormatJustify.right));
                        Symbol* s = file->GetSymbolTable().GetSymbol(cast<int>(index));
                        linkLine.Append(" ").Append(s->name);
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        break;
                    }
                    case LinkCode.absoluteAddrValue:
                    {
                        uint index = GetUInt();
                        linkLine.Append(" ").Append(Format(ToString(index), 5, FormatWidth.min, FormatJustify.right));
                        Symbol* s = file->GetSymbolTable().GetSymbol(cast<int>(index));
                        linkLine.Append(" ").Append(s->name);
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        break;
                    }
                    case LinkCode.farJump:
                    {
                        uint index = GetUInt();
                        linkLine.Append(" ").Append(Format(ToString(index), 5, FormatWidth.min, FormatJustify.right));
                        Symbol* s = file->GetSymbolTable().GetSymbol(cast<int>(index));
                        linkLine.Append(" ").Append(s->name);
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        break;
                    }
                    case LinkCode.farOcta:
                    {
                        uint index = GetUInt();
                        linkLine.Append(" ").Append(Format(ToString(index), 5, FormatWidth.min, FormatJustify.right));
                        Symbol* s = file->GetSymbolTable().GetSymbol(cast<int>(index));
                        linkLine.Append(" ").Append(s->name);
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        break;
                    }
                    case LinkCode.clsid:
                    {
                        ulong address = GetULong();
                        linkLine.Append(" #").Append(ToHexString(address));
                        ulong typeId1 = GetULong();
                        ulong typeId2 = GetULong();
                        Uuid typeId(typeId1, typeId2);
                        linkLine.Append(" #").Append(ToString(typeId));
                        break;
                    }
                }
                writer.WriteLine(linkLine);
                p = pos;
                x = GetByte();
            }
        }
        public override void Finalize()
        {
            EmitByte(LinkCode.end);
        }
    }

    public class DebugSection : Section
    {
        public nothrow DebugSection(BinaryFile* file_) : base(file_, "DBUG")
        {
        }
        public override void Dump(StreamWriter& writer)
        {
            BinaryFileFormatter formatter(*file);
            base->Dump(writer);
            pos = 0;
            int x = GetByte();
            while (x != -1)
            {
                DebugRecordCode debugRecordCode = cast<DebugRecordCode>(cast<byte>(x));
                if (debugRecordCode == DebugRecordCode.end)
                {
                    break;
                }
                string debugLine = Format(DebugRecordCodeStr(debugRecordCode), maxDebugCodeStrLength);
                if (debugRecordCode == DebugRecordCode.fileInfo)
                {
                    string sourceFileName = GetString();
                    uint sourceFileNameId = GetUInt();
                    debugLine.Append(" ").Append(sourceFileName).Append(" ").Append(ToString(sourceFileNameId));
                }
                else if (debugRecordCode == DebugRecordCode.functionInfo)
                {
                    uint functionSymbolIndex = GetUInt();
                    string functionFullName = GetString();
                    uint sourceFileNameId = GetUInt();
                    uint frameSize = GetUInt();
                    debugLine.Append(" ").Append(ToString(functionSymbolIndex)).Append(' ').Append(functionFullName).Append(' ').Append(ToString(sourceFileNameId)).Append(' ').Append(ToString(frameSize));
                }
                else if (debugRecordCode == DebugRecordCode.startFunc)
                {
                    uint functionSymbolIndex = GetUInt();
                    Symbol* functionSymbol = file->GetSymbolTable().GetSymbol(cast<int>(functionSymbolIndex));
                    debugLine.Append(" ").Append(ToString(functionSymbolIndex)).Append(' ').Append(functionSymbol->name);
                }
                else if (debugRecordCode == DebugRecordCode.endFunc)
                {
                    uint functionSymbolIndex = GetUInt();
                    Symbol* functionSymbol = file->GetSymbolTable().GetSymbol(cast<int>(functionSymbolIndex));
                    debugLine.Append(" ").Append(ToString(functionSymbolIndex)).Append(' ').Append(functionSymbol->name);
                }
                else if (debugRecordCode == DebugRecordCode.lineInfo)
                {
                    uint offset = GetUInt();
                    uint line = GetUInt();
                    debugLine.Append(" ").Append(ToString(offset)).Append(' ').Append(ToString(line));
                }
                else if (debugRecordCode == DebugRecordCode.beginTry)
                {
                    uint tryBlockId = GetUInt();
                    uint parentTryBlockId = GetUInt();
                    uint offset = GetUInt();
                    debugLine.Append(" ").Append(ToString(tryBlockId)).Append(' ').Append(ToString(parentTryBlockId)).Append(' ').Append(ToString(offset));
                }
                else if (debugRecordCode == DebugRecordCode.endTry)
                {
                    uint tryBlockId = GetUInt();
                    uint offset = GetUInt();
                    debugLine.Append(" ").Append(ToString(tryBlockId)).Append(' ').Append(ToString(offset));
                }
                else if (debugRecordCode == DebugRecordCode.catch_)
                {
                    uint catchBlockId = GetUInt();
                    uint tryBlockId = GetUInt();
                    ulong catchTypeId1 = GetULong();
                    ulong catchTypeId2 = GetULong();
                    Uuid catchedTypeId(catchTypeId1, catchTypeId2);
                    debugLine.Append(" ").Append(ToString(catchBlockId)).Append(' ').Append(ToString(tryBlockId)).Append(' ').Append(ToString(catchedTypeId));
                }
                else if (debugRecordCode == DebugRecordCode.beginCleanup)
                {
                    uint cleanupBlockId = GetUInt();
                    uint tryBlockId = GetUInt();
                    uint offset = GetUInt();
                    debugLine.Append(" ").Append(ToString(cleanupBlockId)).Append(' ').Append(ToString(cast<int>(tryBlockId))).Append(' ').Append(ToString(offset));
                }
                else if (debugRecordCode == DebugRecordCode.endCleanup)
                {
                    uint cleanupBlockId = GetUInt();
                    uint offset = GetUInt();
                    debugLine.Append(" ").Append(ToString(cleanupBlockId)).Append(' ').Append(' ').Append(ToString(offset));
                }
                else
                {
                    throw Exception("unknown debug record code " + ToString(debugRecordCode));
                }
                writer.WriteLine(debugLine);
                x = GetByte();
            }
        }
        public void EmitFunctionInfo(const FunctionInfo& functionInfo)
        {
            EmitByte(cast<byte>(DebugRecordCode.functionInfo));
            EmitUInt(functionInfo.functionSymbolIndex);
            EmitString(functionInfo.fullName);
            EmitUInt(functionInfo.sourceFileNameId);
            EmitUInt(functionInfo.frameSize);
        }
        public void EmitLineInfo(const LineInfo& lineInfo)
        {
            EmitByte(cast<byte>(DebugRecordCode.lineInfo));
            EmitUInt(lineInfo.offset);
            EmitUInt(lineInfo.lineNumber);
        }
        public void EmitSourceFileName(const string& sourceFileName, uint sourceFileNameId)
        {
            EmitByte(cast<byte>(DebugRecordCode.fileInfo));
            EmitString(sourceFileName);
            EmitUInt(sourceFileNameId);
        }
        public void EmitStartFunc(uint functionSymbolIndex)
        {
            EmitByte(cast<byte>(DebugRecordCode.startFunc));
            EmitUInt(functionSymbolIndex);
        }
        public void EmitEndFunc(uint functionSymbolIndex)
        {
            EmitByte(cast<byte>(DebugRecordCode.endFunc));
            EmitUInt(functionSymbolIndex);
        }
        public void EmitBeginTry(uint tryBlockId, uint parentTryBlockId, uint offset)
        {
            EmitByte(cast<byte>(DebugRecordCode.beginTry));
            EmitUInt(tryBlockId);
            EmitUInt(parentTryBlockId);
            EmitUInt(offset);
        }
        public void EmitEndTry(uint tryBlockId, uint offset)
        {
            EmitByte(cast<byte>(DebugRecordCode.endTry));
            EmitUInt(tryBlockId);
            EmitUInt(offset);
        }
        public void EmitCatch(uint catchBlockId, uint tryBlockId, ulong catchedTypeId1, ulong catchedTypeId2)
        {
            EmitByte(cast<byte>(DebugRecordCode.catch_));
            EmitUInt(catchBlockId);
            EmitUInt(tryBlockId);
            EmitULong(catchedTypeId1);
            EmitULong(catchedTypeId2);
        }
        public void EmitBeginCleanup(uint cleanupBlockId, uint tryBlockId, uint offset)
        {
            EmitByte(cast<byte>(DebugRecordCode.beginCleanup));
            EmitUInt(cleanupBlockId);
            EmitUInt(tryBlockId);
            EmitUInt(offset);
        }
        public void EmitEndCleanup(uint cleanupBlockId, uint offset)
        {
            EmitByte(cast<byte>(DebugRecordCode.endCleanup));
            EmitUInt(cleanupBlockId);
            EmitUInt(offset);
        }
        public override void Finalize()
        {
            EmitByte(DebugRecordCode.end);
        }
    }
}

using System;
using System.Collections;

namespace cmsx.object
{
    public enum LinkCode : byte
    {
        forwardLongJump = 1u, forwardShortJump = 2u, absoluteAddrValue = 3u, farJump = 4u, farOcta = 5u, clsid = 6u, end = 7u
    }

    public const int maxLinkCodeStrLength = 17;

    public string LinkCodeStr(LinkCode linkCode)
    {
        switch (linkCode)
        {
            case LinkCode.forwardLongJump: return  "LINKFWDLONGJUMP";
            case LinkCode.forwardShortJump: return "LINKFWDSHORTJMP";
            case LinkCode.absoluteAddrValue: return "LINKABSOLUTEADDR";
            case LinkCode.farOcta: return "LINKFAROCTA";
            case LinkCode.clsid: return "LINKCLSID";
        }
        return "";
    }

    public abstract class LinkCommand
    {
        public nothrow LinkCommand(ObjectFile* objectFile_, ulong address_) : objectFile(objectFile_), address(address_)
        {
        }
        public default virtual ~LinkCommand();
        public virtual void Execute(ulong value, bool debug)
        {
        }
        public ObjectFile* objectFile;
        public ulong address;
    }

    public class LinkOnceCommand : LinkCommand
    {
        public nothrow LinkOnceCommand(ObjectFile* objectFile_) : base(objectFile_, 0u)
        {
        }
    }

    public class LinkAbsoluteAddressCommand : LinkCommand
    {
        public nothrow LinkAbsoluteAddressCommand(ObjectFile* objectFile_, ulong address_) : base(objectFile_, address_)
        {
        }
        public override void Execute(ulong value, bool debug)
        {
            if (debug)
            {
                Console.Out() << objectFile->FileName() << ": LINKABSOLUTEADDR(" << ToHexString(address) << " : " << ToHexString(value) << ")" << endl();
            }
            byte b0 = cast<byte>(value);
            value = value >> 8u;
            byte b1 = cast<byte>(value);
            value = value >> 8u;
            byte b2 = cast<byte>(value);
            value = value >> 8u;
            byte b3 = cast<byte>(value);
            value = value >> 8u;
            byte b4 = cast<byte>(value);
            value = value >> 8u;
            byte b5 = cast<byte>(value);
            value = value >> 8u;
            byte b6 = cast<byte>(value);
            value = value >> 8u;
            byte b7 = cast<byte>(value);
            value = value >> 8u;
            ushort offset = (cast<ushort>(b7) << 8u) | cast<ushort>(b6);
            objectFile->codeSection->EmitShortOffset(address, offset);
            offset = (cast<ushort>(b5) << 8u) | cast<ushort>(b4);
            objectFile->codeSection->EmitShortOffset(address + 4u, offset);
            offset = (cast<ushort>(b3) << 8u) | cast<ushort>(b2);
            objectFile->codeSection->EmitShortOffset(address + 8u, offset);
            offset = (cast<ushort>(b1) << 8u) | cast<ushort>(b0);
            objectFile->codeSection->EmitShortOffset(address + 12u, offset);
        }
    }

    public class LinkFarOctaCommand : LinkCommand
    {
        public nothrow LinkFarOctaCommand(ObjectFile* objectFile_, ulong address_) : base(objectFile_, address_)
        {
        }
        public override void Execute(ulong value, bool debug)
        {
            if (debug)
            {
                Console.Out() << objectFile->FileName() << ": LINKFAROCTA(" << ToHexString(address) << " : " << ToHexString(value) << ")" << endl();
            }
            objectFile->dataSection->EmitULong(address, value);
        }
    }

    public class LinkClsIdCommand : LinkCommand
    {
        public nothrow LinkClsIdCommand(ObjectFile* objectFile_, ulong address_, ulong classId_) : base(objectFile_, address_), classId(classId_)
        {
        }
        public override void Execute(ulong value, bool debug)
        {
            if (debug)
            {
                Console.Out() << objectFile->FileName() << ": LINKCLSID(" << ToHexString(address) << " : " << ToHexString(classId) << ")" << endl();
            }
            objectFile->dataSection->EmitULong(address, classId);
        }
        private ulong classId;
    }

    public class CopyRange
    {
        public nothrow CopyRange(Section* fromSection_, Section* toSection_, ulong startPos_, ulong length_, byte alignment_) :
            fromSection(fromSection_), toSection(toSection_), startPos(startPos_), length(length_), alignment(alignment_)
        {
        }
        public string Str() const
        {
            return "copy from " + fromSection->file->FileName() + " " +  fromSection->name + " section to target " + toSection->file->FileName() + " " + toSection->name + " section: [" + ToHexString(startPos) + ":" + ToHexString(length) + "] align " + ToString(alignment);
        }
        public Section* fromSection;
        public Section* toSection;
        public ulong startPos;
        public ulong length;
        public byte alignment;
    }

    public class LinkTable
    {
        public nothrow LinkTable(const ClassIdMap& classIdMap_) : classIdMap(classIdMap_)
        {
        }
        public void AddLinkCommand(const string& symbolName, LinkCommand* command)
        {
            List<LinkCommand*>& commands = linkCommandMap[symbolName];
            commands.Add(command);
        }
        public void ExecuteLinkCommands(const string& symbolName, ulong value, bool debug)
        {
            Map<string, List<LinkCommand*>>.ConstIterator it = linkCommandMap.CFind(symbolName);
            if (it != linkCommandMap.CEnd())
            {
                List<LinkCommand*>& commands = it->second;
                if (debug)
                {
                    Console.Out() << "executing link commands for symbol " << symbolName << " with value " << ToHexString(value) << endl();
                }
                for (LinkCommand* command : commands)
                {
                    command->Execute(value, debug);
                    delete command;
                }
                linkCommandMap.Remove(symbolName);
            }
        }
        public void AddCopyRange(const CopyRange& copyRange, bool debug)
        {
            if (copyRange.length == 0u)
            {
                return;
            }
            if (!copyRanges.IsEmpty())
            {
                CopyRange& prev = copyRanges.Back();
                if (prev.fromSection == copyRange.fromSection && prev.toSection == copyRange.toSection && prev.startPos + prev.length == copyRange.startPos)
                {
                    if (debug)
                    {
                        Console.Out() << "extended " << prev.Str();
                    }
                    prev.length = prev.length + copyRange.length;
                    if (debug)
                    {
                        Console.Out() << " length to " << ToHexString(prev.length) << endl();
                    }
                    return;
                }
            }
            copyRanges.Add(copyRange);
            if (debug)
            {
                Console.Out() << "added " << copyRange.Str() << endl();
            }
        }
        public void ReportUnresolvedSymbols()
        {
            bool hasUnresolvedSymbols = false;
            for (Pair<string, List<LinkCommand*>>& p : linkCommandMap)
            {
                for (LinkCommand* command : p.second)
                {
                    hasUnresolvedSymbols = true;
                    Console.Error() << "unresolved external symbol '" << p.first << "' detected in file " << command->objectFile->FileName() << endl();
                }
            }
            if (hasUnresolvedSymbols)
            {
                throw Exception("linking failed because unresolved external symbols detected");
            }
        }
        public void CopyRanges(bool debug)
        {
            for (const CopyRange& copyRange : copyRanges)
            {
                ulong n = copyRange.length;
                if (n > 0u)
                {
                    if (debug)
                    {
                        Console.Out() << copyRange.Str() << endl();
                    }
                    Section* fromSection = copyRange.fromSection;
                    Section* toSection = copyRange.toSection;
                    ulong startPos = copyRange.startPos;
                    toSection->Align(copyRange.alignment);
                    for (ulong i = 0u; i < n; ++i)
                    {
                        toSection->data.Add(fromSection->data[cast<long>(startPos + i)]);
                    }
                }
            }
        }
        public ulong CodeByteCount() const 
        {
            ulong count = 0u;
            for (const CopyRange& copyRange : copyRanges)
            {
                if (copyRange.fromSection is CodeSection*)
                {
                    count = count + copyRange.length;
                }
            }
            return count;
        }
        public ulong GetClassId(const Uuid& typeId) const
        {
            return classIdMap.GetClassId(typeId);
        }
        public void AddUsedSymbolName(const string& symbolName)
        {
            usedSymbolNames.Insert(symbolName);
        }
        public bool IsUsedSymbolName(const string& symbolName)
        {
            return usedSymbolNames.CFind(symbolName) != usedSymbolNames.CEnd();
        }
        public ~LinkTable()
        {
            for (Pair<string, List<LinkCommand*>>& p : linkCommandMap)
            {
                for (LinkCommand* command : p.second)
                {
                    delete command;
                }
            }
        }
        public void AddUnprocessedSymbol(Symbol* symbol, Section* section, SymbolTable* symbolTable)
        {
            List<Pair<Symbol*, Pair<Section*, SymbolTable*>>>& unprocessedSymbolList = unprocessedSymbolLists[symbol->name];
            unprocessedSymbolList.Add(MakePair(symbol, MakePair(section, symbolTable)));
        }
        public List<Pair<Symbol*, Pair<Section*, SymbolTable*>>>* GetUnprocessedSymbolList(const string& symbolName)
        {
            HashMap<string, List<Pair<Symbol*, Pair<Section*, SymbolTable*>>>>.ConstIterator it = unprocessedSymbolLists.CFind(symbolName);
            if (it != unprocessedSymbolLists.CEnd())
            {
                return &it->second;
            }
            else
            {
                return null;
            }
        }
        private Map<string, List<LinkCommand*>> linkCommandMap;
        private List<CopyRange> copyRanges;
        private const ClassIdMap& classIdMap;
        private HashSet<string> usedSymbolNames;
        private HashMap<string, List<Pair<Symbol*, Pair<Section*, SymbolTable*>>>> unprocessedSymbolLists;
    }

    public void LinkInternal(ObjectFile& objectFile)
    {
        UniquePtr<Section> newLinkSection(new LinkSection(&objectFile));
        SymbolTable& symbolTable = objectFile.GetSymbolTable();
        Section* linkSection = objectFile.linkSection;
        #assert(linkSection != null);
        Section* codeSection = objectFile.codeSection;
        #assert(codeSection != null);
        linkSection->pos = 0u;
        int x = linkSection->GetByte();
        while (x != -1)
        {
            LinkCode linkCode = cast<LinkCode>(cast<byte>(x));
            switch (linkCode)
            {
                case LinkCode.forwardLongJump:
                {
                    uint symbolIndex = linkSection->GetUInt();
                    ulong fromAddress = linkSection->GetULong();
                    Symbol* symbol = symbolTable.GetSymbol(cast<int>(symbolIndex));
                    #assert(symbol != null);
                    #assert(symbol->segment == Segment.text);
                    #assert(symbol->value.GetFlag(Value.Flag.address));
                    ulong toAddress = symbol->value.value;
                    #assert(toAddress >= fromAddress);
                    ulong offset = (toAddress - fromAddress) >> 2u;
                    if (offset >= cast<ulong>(MaxValue<ushort>()) << 8u)
                    {
                        throw Exception("error linking: forward long jump too far");
                    }
                    codeSection->EmitLongOffset(fromAddress, cast<uint>(offset));
                    break;
                }
                case LinkCode.forwardShortJump:
                {
                    uint symbolIndex = linkSection->GetUInt();
                    ulong fromAddress = linkSection->GetULong();
                    Symbol* symbol = symbolTable.GetSymbol(cast<int>(symbolIndex));
                    #assert(symbol != null);
                    #assert(symbol->segment == Segment.text);
                    #assert(symbol->value.GetFlag(Value.Flag.address));
                    ulong toAddress = symbol->value.value;
                    #assert(toAddress >= fromAddress);
                    ulong offset = (toAddress - fromAddress) >> 2u;
                    if (offset >= cast<ulong>(MaxValue<ushort>()))
                    {
                        throw Exception("error linking: forward short jump too far");
                    }
                    codeSection->EmitShortOffset(fromAddress, cast<ushort>(offset));
                    break;
                }
                case LinkCode.absoluteAddrValue:
                {
                    uint index = linkSection->GetUInt();
                    ulong address = linkSection->GetULong();
                    newLinkSection->EmitByte(LinkCode.absoluteAddrValue);
                    newLinkSection->EmitUInt(cast<uint>(index));
                    newLinkSection->EmitULong(address);
                    break;
                }
                case LinkCode.farOcta:
                {
                    uint index = linkSection->GetUInt();
                    ulong address = linkSection->GetULong();
                    newLinkSection->EmitByte(LinkCode.farOcta);
                    newLinkSection->EmitUInt(cast<uint>(index));
                    newLinkSection->EmitULong(address);
                    break;
                }
                case LinkCode.clsid:
                {
                    ulong address = linkSection->GetULong();
                    ulong typeId1 = linkSection->GetULong();
                    ulong typeId2 = linkSection->GetULong();
                    newLinkSection->EmitByte(LinkCode.clsid);
                    newLinkSection->EmitULong(address);
                    newLinkSection->EmitULong(typeId1);
                    newLinkSection->EmitULong(typeId2);
                    break;
                }
            }
            x = linkSection->GetByte();
        }
        objectFile.ReplaceLinkSection(newLinkSection);
    }

    public void ProcessSymbols(LinkTable& linkTable, ExecutableFile& executable, ObjectFile* objectFile, bool removeUnusedCode, bool debug)
    {
        if (debug)
        {
            Console.Out() << "begin processing symbols" << endl();
        }
        SymbolTable& objectFileSymbolTable = objectFile->GetSymbolTable();
        Section* codeSection = objectFile->codeSection;
        codeSection->copyStartPos = 0u;
        codeSection->copyTargetSection = executable.codeSection;
        codeSection->removeOffset = 0u;
        ulong codeSectionLength = codeSection->dataLength;
        Section* dataSection = objectFile->dataSection;
        dataSection->copyTargetSection = executable.dataSection;
        dataSection->copyStartPos = 0u;
        dataSection->removeOffset = 0u;
        ulong dataSectionLength = dataSection->dataLength;
        SymbolTable& executableSymbolTable = executable.GetSymbolTable();
        List<Symbol*> linkSymbols;
        for (const UniquePtr<Symbol>& symbol : objectFileSymbolTable.Symbols())
        {
            if (symbol->linkage == Linkage.internal_)
            {
                if (symbol->value.GetFlag(Value.Flag.address) && (symbol->segment == Segment.text || symbol->segment == Segment.data))
                {
                    bool process = true;
                    if (symbol->parentIndex != -1)
                    {
                        Symbol* parentSymbol = objectFileSymbolTable.GetSymbol(symbol->parentIndex);
                        if (parentSymbol != null && (parentSymbol->linkage == Linkage.remove || removeUnusedCode && !parentSymbol->value.GetFlag(Value.Flag.used)))
                        {
                            process = false;
                        }
                    }
                    if (process)
                    {
                        symbol->start = symbol->section->baseAddress + symbol->value.value - symbol->section->removeOffset;
                        Symbol* executableSymbol = symbol->Clone();
                        #assert(executableSymbol->section != null);
                        if (executableSymbol->section is DataSection*)
                        {
                            executable.dataSection->AddSymbol(executableSymbol);
                        }
                        executableSymbolTable.AddInternalSymbol(executableSymbol, true);
                    }
                }
            }
            else if (symbol->linkage == Linkage.external || symbol->linkage == Linkage.undefined)
            {
                if (debug)
                {
                    Console.Out() << "begin processing " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " : " << ToHexString(symbol->value.value) << ":" << ToHexString(symbol->length) << ":" << ToString(symbol->alignment) << endl();
                }
                if (symbol->value.GetFlag(Value.Flag.address) && (symbol->segment == Segment.text || symbol->segment == Segment.data))
                {
                    if (symbol->value.GetFlag(Value.Flag.definition))
                    {
                        Symbol* prevSymbol = executableSymbolTable.GetSymbol(symbol->name);
                        if (prevSymbol != null)
                        {
                            #assert(prevSymbol->section != null);
                            #assert(symbol->section != null);
                            throw Exception("Duplicate external symbol '" + symbol->name +
                                "'. Original defined in " + prevSymbol->section->name + " section of file " + prevSymbol->section->file->FileName() + 
                                ". Duplicate detected in " + symbol->section->name + " section of file " + symbol->section->file->FileName() + ".");
                        }
                        else
                        {
                            if (symbol->value.GetFlag(Value.Flag.used) || !removeUnusedCode)
                            {
                                symbol->start = symbol->section->baseAddress + symbol->value.value - symbol->section->removeOffset;
                                Symbol* executableSymbol = symbol->Clone();
                                executableSymbol->linkage = Linkage.external;
                                #assert(executableSymbol->section != null);
                                if (executableSymbol->section is DataSection*)
                                {
                                    executable.dataSection->AddSymbol(executableSymbol);
                                }
                                executableSymbolTable.AddSymbol(executableSymbol);
                                linkTable.ExecuteLinkCommands(symbol->name, symbol->start, debug);
                                linkTable.AddCopyRange(CopyRange(symbol->section, symbol->section->copyTargetSection, symbol->value.value, symbol->length, symbol->alignment), debug);
                                symbol->section->copyStartPos = symbol->value.value + symbol->length;
                                linkSymbols.Add(symbol.Get());
                            }
                            else
                            {
                                if (debug)
                                {
                                    Console.Out() << "setting unused " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " linkage to remove" << endl();
                                }
                                symbol->linkage = Linkage.remove;
                                symbol->section->copyStartPos = symbol->value.value + symbol->length;
                                symbol->section->removeOffset = symbol->section->removeOffset + symbol->length;
                                symbol->section->dataLength = symbol->section->dataLength - symbol->length;
                            }
                        }
                    }
                }
                else if (symbol->value.flags == Value.Flag.undefined)
                {
                    Symbol* prevSymbol = executableSymbolTable.GetSymbol(symbol->name);
                    if (prevSymbol != null)
                    {
                        symbol->start = prevSymbol->start;
                        symbol->linkage = Linkage.external;
                        if (debug)
                        {
                            Console.Out() << "define symbol " << symbol->name << " start " << ToHexString(symbol->start) << endl();
                        }
                    }
                }
                if (debug)
                {
                    Console.Out() << "end processing " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " : " << ToHexString(symbol->start) << " : " << ToHexString(symbol->value.value) << ":" << ToHexString(symbol->length) << ":" << ToString(symbol->alignment) << endl();
                }
            }
            else if (symbol->linkage == Linkage.once)
            {
                if (debug)
                {
                    Console.Out() << "begin processing " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " : " << ToHexString(symbol->value.value) << ":" << ToHexString(symbol->length) << ":" << ToString(symbol->alignment) << endl();
                }
                if (symbol->value.GetFlag(Value.Flag.address) && (symbol->segment == Segment.text || symbol->segment == Segment.data))
                {
                    if (symbol->value.GetFlag(Value.Flag.definition))
                    {
                        Symbol* prevSymbol = executableSymbolTable.GetSymbol(symbol->name);
                        if (prevSymbol == null)
                        {
                            if (symbol->value.GetFlag(Value.Flag.used) || !removeUnusedCode)
                            {
                                symbol->start = symbol->section->baseAddress + symbol->value.value - symbol->section->removeOffset;
                                Symbol* executableSymbol = symbol->Clone();
                                #assert(executableSymbol->section != null);
                                if (executableSymbol->section is DataSection*)
                                {
                                    executable.dataSection->AddSymbol(executableSymbol);
                                }
                                executableSymbolTable.AddSymbol(executableSymbol);
                                linkTable.ExecuteLinkCommands(symbol->name, symbol->start, debug);
                                linkTable.AddCopyRange(CopyRange(symbol->section, symbol->section->copyTargetSection, symbol->value.value, symbol->length, symbol->alignment), debug);
                                symbol->section->copyStartPos = symbol->value.value + symbol->length;
                                linkSymbols.Add(symbol.Get());
                            }
                            else
                            {
                                if (debug)
                                {
                                    Console.Out() << "setting unused " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " linkage to remove" << endl();
                                }
                                symbol->linkage = Linkage.remove;
                                symbol->section->copyStartPos = symbol->value.value + symbol->length;
                                symbol->section->removeOffset = symbol->section->removeOffset + symbol->length;
                                symbol->section->dataLength = symbol->section->dataLength - symbol->length;
                            }
                        }
                        else
                        {
                            if (debug)
                            {
                                Console.Out() << "setting " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " linkage to remove" << endl();
                            }
                            symbol->linkage = Linkage.remove;
                            symbol->section->copyStartPos = symbol->value.value + symbol->length;
                            symbol->section->removeOffset = symbol->section->removeOffset + symbol->length;
                            symbol->section->dataLength = symbol->section->dataLength - symbol->length;
                        }
                    }
                }
                if (debug)
                {
                    Console.Out() << "end processing " << LinkageStr(symbol->linkage) << " symbol " << symbol->name << " : " << ToHexString(symbol->start) << " : " << ToHexString(symbol->value.value) << ":" << ToHexString(symbol->length) << ":" << ToString(symbol->alignment) << endl();
                }
            }
        }
        if (debug)
        {
            Console.Out() << "end processing symbols" << endl();
        }
        for (Symbol* linkSymbol : linkSymbols)
        {
            ProcessLinkSection(linkTable, executable, objectFile, linkSymbol, debug);
        }
    }

    public void ProcessLinkSection(LinkTable& linkTable, ExecutableFile& executable, ObjectFile* objectFile, Symbol* forSymbol, bool debug)
    {
        if (debug)
        {
            Console.Out() << "begin processing link section for symbol " << forSymbol->name << " [" << forSymbol->linkStart << ":" << forSymbol->linkEnd << "]" << endl();
        }
        SymbolTable& executableSymbolTable = executable.GetSymbolTable();
        Section* linkSection = objectFile->linkSection;
        long prevPos = linkSection->pos;
        linkSection->pos = cast<long>(forSymbol->linkStart);
        int x = linkSection->GetByte();
        while (x != -1 && linkSection->pos < cast<long>(forSymbol->linkEnd))
        {
            LinkCode linkCode = cast<LinkCode>(cast<byte>(x));
            Symbol* symbol = null;
            UniquePtr<LinkCommand> linkCommand;
            switch (linkCode)
            {
                case LinkCode.absoluteAddrValue:
                {
                    uint index = linkSection->GetUInt();
                    ulong address = linkSection->GetULong();
                    symbol = objectFile->GetSymbolTable().GetSymbol(cast<int>(index));
                    bool linkageIsRemove = false;
                    if (symbol->linkage == Linkage.remove)
                    {
                        linkageIsRemove = true;
                    }
                    if (symbol->value.flags == Value.Flag.undefined || linkageIsRemove)
                    {
                        Symbol* executableSymbol = executableSymbolTable.GetSymbol(symbol->name);
                        if (executableSymbol != null)
                        {
                            symbol = executableSymbol;
                        }
                    }
                    linkCommand.Reset(new LinkAbsoluteAddressCommand(objectFile, address));
                    break;
                }
                case LinkCode.farOcta:
                {
                    uint index = linkSection->GetUInt();
                    ulong address = linkSection->GetULong();
                    symbol = objectFile->GetSymbolTable().GetSymbol(cast<int>(index));
                    bool linkageIsRemove = false;
                    if (symbol->linkage == Linkage.remove)
                    {
                        linkageIsRemove = true;
                    }
                    if (symbol->value.flags == Value.Flag.undefined || linkageIsRemove)
                    {
                        Symbol* executableSymbol = executableSymbolTable.GetSymbol(symbol->name);
                        if (executableSymbol != null)
                        {
                            symbol = executableSymbol;
                        }
                    }
                    linkCommand.Reset(new LinkFarOctaCommand(objectFile, address));
                    break;
                }
                case LinkCode.clsid:
                {
                    ulong address = linkSection->GetULong();
                    ulong typeId1 = linkSection->GetULong();
                    ulong typeId2 = linkSection->GetULong();
                    Uuid typeId(typeId1, typeId2);
                    linkCommand.Reset(new LinkClsIdCommand(objectFile, address, linkTable.GetClassId(typeId)));
                    linkCommand->Execute(0u, debug);
                    linkCommand.Reset();
                    break;
                }
                default:
                {
                    symbol = null;
                    linkCommand.Reset();
                    break;
                }
            }
            if (!linkCommand.IsNull() && symbol != null)
            {
                if (symbol->value.GetFlag(Value.Flag.address))
                {
                    linkCommand->Execute(symbol->start, debug);
                }
                else if (symbol->value.flags == Value.Flag.undefined)
                {
                    linkTable.AddLinkCommand(symbol->name, linkCommand.Release());
                }
            }
            x = linkSection->GetByte();
        }
        if (debug)
        {
            Console.Out() << "end processing link section for symbol " << forSymbol->name << " [" << forSymbol->linkStart << ":" << forSymbol->linkEnd << "]" << endl();
        }
    }

    public void LinkObjectFile(LinkTable& linkTable, ExecutableFile& executable, ObjectFile* objectFile, Section*& prevCodeSection, Section*& prevDataSection, bool removeUnusedCode, bool debug)
    {
        if (debug)
        {
            Console.Out() << "begin linking " << objectFile->FileName() << endl();
        }
        SymbolTable& executableSymbolTable = executable.GetSymbolTable();
        Section* codeSection = objectFile->codeSection;
        if (prevCodeSection == null)
        {
            codeSection->baseAddress = cmsx.machine.textSegmentBaseAddress + 4096u;
            executable.codeSection->baseAddress = codeSection->baseAddress;
            if (debug)
            {
                Console.Out() << "setting code section base address to " << ToHexString(codeSection->baseAddress) << endl();
            }
        }
        else
        {
            codeSection->baseAddress = prevCodeSection->baseAddress + prevCodeSection->dataLength;
            if (debug)
            {
                Console.Out() << "setting code section base address to " << ToHexString(codeSection->baseAddress) << endl();
            }
        }
        prevCodeSection = codeSection;
        Section* dataSection = objectFile->dataSection;
        if (prevDataSection == null)
        {
            dataSection->baseAddress = cmsx.machine.dataSegmentBaseAddress;
            executable.dataSection->baseAddress = dataSection->baseAddress;
            if (debug)
            {
                Console.Out() << "setting data section base address to " << ToHexString(dataSection->baseAddress) << endl();
            }
        }
        else
        {
            dataSection->baseAddress = prevDataSection->baseAddress + prevDataSection->dataLength;
            if (debug)
            {
                Console.Out() << "setting data section base address to " << ToHexString(dataSection->baseAddress) << endl();
            }
        }
        prevDataSection = dataSection;
        ProcessSymbols(linkTable, executable, objectFile, removeUnusedCode, debug);
        if (debug)
        {
            Console.Out() << "end linking " << objectFile->FileName() << endl();
        }
    }

    public void ProcessUsedSymbol(Symbol* symbol, SymbolTable& symbolTable, LinkTable& linkTable, Section* linkSection, bool debug)
    {
        if (symbol->value.GetFlag(Value.Flag.used)) return;
        if (debug)
        {
            Console.Out() << "begin processing used symbol " << symbol->name << endl();
        }
        symbol->value.SetUsed();
        if (symbol->linkStart != -1 && symbol->linkEnd != -1)
        {
            long prevPos = linkSection->pos;
            linkSection->pos = cast<long>(symbol->linkStart);
            int x = linkSection->GetByte();
            while (x != -1 && linkSection->pos < cast<long>(symbol->linkEnd))
            {
                LinkCode linkCode = cast<LinkCode>(cast<byte>(x));
                Symbol* s = null;
                switch (linkCode)
                {
                    case LinkCode.absoluteAddrValue:
                    {
                        uint index = linkSection->GetUInt();
                        ulong address = linkSection->GetULong();
                        s = symbolTable.GetSymbol(cast<int>(index));
                        break;
                    }
                    case LinkCode.farOcta:
                    {
                        uint index = linkSection->GetUInt();
                        ulong address = linkSection->GetULong();
                        s = symbolTable.GetSymbol(cast<int>(index));
                        break;
                    }
                    case LinkCode.clsid:
                    {
                        ulong address = linkSection->GetULong();
                        ulong typeId1 = linkSection->GetULong();
                        ulong typeId2 = linkSection->GetULong();
                        break;
                    }
                }
                if (s != null)
                {
                    if (debug)
                    {
                        Console.Out() << "adding symbol " + s->name + " to used symbol names" << endl();
                    }
                    linkTable.AddUsedSymbolName(s->name);
                    List<Pair<Symbol*, Pair<Section*, SymbolTable*>>>* unprocessedSymbols = linkTable.GetUnprocessedSymbolList(s->name);
                    if (unprocessedSymbols != null)
                    {
                        List<Pair<Symbol*, Pair<Section*, SymbolTable*>>> symbols;
                        Swap(*unprocessedSymbols, symbols);
                        for (const Pair<Symbol*, Pair<Section*, SymbolTable*>>& p : symbols)
                        {
                            Symbol* unprocessedSymbol = p.first;
                            Section* section = p.second.first;
                            SymbolTable* stab = p.second.second; 
                            ProcessUsedSymbol(unprocessedSymbol, *stab, linkTable, section, debug);
                        }
                    }
                }
                x = linkSection->GetByte();
            }
            linkSection->pos = prevPos;
        }
        else
        {
            throw Exception("link start and end not set");
        }
        if (debug)
        {
            Console.Out() << "end processing used symbol " << symbol->name << endl();
        }
    }

    public void MarkUsedSymbols(LinkTable& linkTable, ObjectFile* objectFile, bool debug)
    {
        if (debug)
        {
            Console.Out() << "begin marking used symbols for object file " << objectFile->FileName() << endl();
        }
        SymbolTable& objectFileSymbolTable = objectFile->GetSymbolTable();
        for (const UniquePtr<Symbol>& symbol : objectFileSymbolTable.Symbols())
        {
            if (symbol->value.GetFlag(Value.Flag.definition) && symbol->value.GetFlag(Value.Flag.address) && (symbol->linkage == Linkage.external || symbol->linkage == Linkage.once) &&
                (symbol->segment == Segment.text || symbol->segment == Segment.data))
            {
                if (linkTable.IsUsedSymbolName(symbol->name))
                {
                    ProcessUsedSymbol(symbol.Get(), objectFile->GetSymbolTable(), linkTable, objectFile->linkSection, debug);
                }
                else
                {
                    linkTable.AddUnprocessedSymbol(symbol.Get(), objectFile->linkSection, &objectFile->GetSymbolTable());
                }
            }
        }
        if (debug)
        {
            Console.Out() << "end marking used symbols for object file " << objectFile->FileName() << endl();
        }
    }

    public List<DispatchTableEntry> InsertIntoDispatchTable(const List<DispatchTableEntry>& dispatchTable, const DispatchTableEntry& entry, Section* dataSection)
    {
        if (entry.dispatchBlock is CleanupDispatchBlock*)
        {
            CleanupDispatchBlock* cleanupDispatchBlock = cast<CleanupDispatchBlock*>(entry.dispatchBlock);
            TryBlock* parentTryBlock = cleanupDispatchBlock->tryBlock;
            if (parentTryBlock != null)
            {
                ulong parentTableAddress = parentTryBlock->exceptionBlockTableAddress;
                long prevPos = dataSection->pos;
                dataSection->pos = cast<long>(entry.exceptionBlockTableAddress + 16u);
                dataSection->EmitULong(parentTableAddress);
                dataSection->pos = prevPos;
            }
        }
        bool inserted = false;
        List<DispatchTableEntry> newDispatchTable;
        for (const DispatchTableEntry& prevEntry : dispatchTable)
        {
            if (entry.offset < prevEntry.offset)
            {
                newDispatchTable.Add(entry);
                newDispatchTable.Add(prevEntry);
                inserted = true;
            }
            else if (entry.offset >= prevEntry.offset + prevEntry.length)
            {
                newDispatchTable.Add(prevEntry);
            }
            else if (entry.offset >= prevEntry.offset && entry.offset < prevEntry.offset + prevEntry.length)
            {
                if (entry.offset + entry.length <= prevEntry.offset + prevEntry.length)
                {
                    DispatchTableEntry startEntry(prevEntry.offset, entry.offset - prevEntry.offset, prevEntry.exceptionBlockTableAddress, prevEntry.dispatchBlock);
                    if (startEntry.length > 0)
                    {
                        newDispatchTable.Add(startEntry);
                    }
                    newDispatchTable.Add(entry);
                    inserted = true;
                    DispatchTableEntry endEntry(entry.offset + entry.length, (prevEntry.offset + prevEntry.length) - (entry.offset + entry.length), prevEntry.exceptionBlockTableAddress,
                        prevEntry.dispatchBlock);
                    if (endEntry.length > 0)
                    {
                        newDispatchTable.Add(endEntry);
                    }
                }
                else
                {
                    throw Exception("invalid dispatch table entry (not contained by the parent entry): previous entry offset: " + ToString(prevEntry.offset) +
                    ", previous entry length: " + ToString(prevEntry.length) + ", entry offset: " + ToString(entry.offset) + ", entry length: " + ToString(entry.length));
                }
            }
            else
            {
                newDispatchTable.Add(prevEntry);
            }
        }
        if (!inserted)
        {
            newDispatchTable.Add(entry);
        }
        return newDispatchTable;
    }

    public ulong MakeExceptionTable(ExecutableFile& executable, const FunctionExceptionData& functionExceptionData)
    {
        try
        {
            Section* executableDataSection = executable.dataSection;
            executableDataSection->Align(8u);
            List<DispatchTableEntry> dispatchTable;
            for (TryBlock& tryBlock : functionExceptionData.tryBlocks)
            {
                if (tryBlock.length > 0)
                {
                    ulong exceptionBlockTableAddress = 0u;
                    for (const HandlerBlock& handlerBlock : tryBlock.handlerBlocks)
                    {
                        if (exceptionBlockTableAddress == 0u)
                        {
                            exceptionBlockTableAddress = executableDataSection->Address();
                            tryBlock.exceptionBlockTableAddress = exceptionBlockTableAddress;
                        }
                        executableDataSection->EmitULong(handlerBlock.discriminator);
                        executableDataSection->EmitULong(handlerBlock.catchedClassId);
                        executableDataSection->EmitULong(handlerBlock.handlerAddress);
                    }
                    executableDataSection->EmitULong(endBlockDiscriminator);
                    DispatchTableEntry entry(tryBlock.offset, tryBlock.length, exceptionBlockTableAddress, &tryBlock);
                    dispatchTable = InsertIntoDispatchTable(dispatchTable, entry, executableDataSection);
                }
            }
            for (const CleanupDispatchBlock& cleanupDispatchBlock : functionExceptionData.cleanupDispatchBlocks)
            {
                if (cleanupDispatchBlock.length > 0)
                {
                    ulong exceptionBlockTableAddress = executableDataSection->Address();
                    executableDataSection->EmitULong(cleanupDispatchBlock.cleanupBlock.discriminator);
                    executableDataSection->EmitULong(cleanupDispatchBlock.cleanupBlock.cleanupAddress);
                    executableDataSection->EmitULong(cleanupDispatchBlock.cleanupBlock.parentTableAddress);
                    executableDataSection->EmitULong(endBlockDiscriminator);
                    DispatchTableEntry entry(cleanupDispatchBlock.offset, cleanupDispatchBlock.length, exceptionBlockTableAddress, &cleanupDispatchBlock);
                    dispatchTable = InsertIntoDispatchTable(dispatchTable, entry, executableDataSection);
                }
            }
            executableDataSection->Align(8u);
            ulong exceptionTableAddress = executableDataSection->Address();
            executableDataSection->EmitUInt(functionExceptionData.frameSize);
            executableDataSection->EmitUInt(cast<uint>(dispatchTable.Count()));
            for (long i = 0; i < dispatchTable.Count(); ++i)
            {
                const DispatchTableEntry& entry = dispatchTable[i];
                executableDataSection->EmitUInt(entry.offset);
                executableDataSection->EmitUInt(entry.length);
                executableDataSection->EmitULong(entry.exceptionBlockTableAddress);
            }
            return exceptionTableAddress;
        }
        catch (const Exception& ex)
        {
            throw Exception(ex.Message() + " (function=" + functionExceptionData.functionName + ")");
        }
        return 0u;
    }

    public void ProcessDebugSection(ExecutableFile& executable, ObjectFile* objectFile, HashMap<string, ulong>& stringAddressMap, List<FunctionTableEntry>& functionTable,
        HashSet<ulong>& functionAddressSet, const ClassIdMap& classIdMap, bool debug)
    {
        if (debug)
        {
            Console.Out() << "begin processing debug section of " << objectFile->FileName() << endl();
        }
        Section* debugSection = objectFile->debugSection;
        Section* executableDataSection = executable.dataSection;
        HashMap<uint, ulong> sourceFileIdAddressMap;
        HashMap<string, LineNumberTableLimits> lineNumberTableMap;
        HashMap<string, ulong> exceptionTableAddressMap;
        FunctionExceptionData functionExceptionData;
        bool processFunc = false;
        if (debugSection != null)
        {
            int x = debugSection->GetByte();
            while (x != -1)
            {
                DebugRecordCode debugRecordCode = cast<DebugRecordCode>(cast<byte>(x));
                if (debugRecordCode == DebugRecordCode.end)
                {
                    break;
                }
                if (debugRecordCode == DebugRecordCode.fileInfo)
                {
                    string sourceFileNameName = debugSection->GetString();
                    uint sourceFileNameId = debugSection->GetUInt();
                    HashMap<string, ulong>.ConstIterator it = stringAddressMap.CFind(sourceFileNameName);
                    ulong sourceFileNameAddress = 0u;
                    if (it == stringAddressMap.CEnd())
                    {
                        sourceFileNameAddress = executableDataSection->Address();
                        executableDataSection->EmitString(sourceFileNameName);
                        stringAddressMap[sourceFileNameName] = sourceFileNameAddress;
                    }
                    else
                    {
                        sourceFileNameAddress = it->second;
                    }
                    sourceFileIdAddressMap[sourceFileNameId] = sourceFileNameAddress;
                }
                else if (debugRecordCode == DebugRecordCode.functionInfo)
                {
                    uint functionSymbolIndex = debugSection->GetUInt();
                    string functionFullName = debugSection->GetString();
                    uint sourceFileNameId = debugSection->GetUInt();
                    uint frameSize = debugSection->GetUInt();
                    HashMap<uint, ulong>.ConstIterator sit = sourceFileIdAddressMap.CFind(sourceFileNameId);
                    ulong sourceFileNameAddress = 0u;
                    if (sit != sourceFileIdAddressMap.CEnd())
                    {
                        sourceFileNameAddress = sit->second;
                    }
                    else
                    {
                        throw Exception("source file name address not found");
                    }
                    Symbol* functionSymbol = objectFile->GetSymbolTable().GetSymbol(cast<int>(functionSymbolIndex));
                    if (functionSymbol != null)
                    {
                        Symbol* finalFunctionSymbol = executable.GetSymbolTable().GetSymbol(functionSymbol->name);
                        if (finalFunctionSymbol != null)
                        {
                            if (functionAddressSet.CFind(finalFunctionSymbol->start) == functionAddressSet.CEnd())
                            {
                                functionAddressSet.Insert(finalFunctionSymbol->start);
                                HashMap<string, ulong>.ConstIterator it1 = stringAddressMap.CFind(finalFunctionSymbol->name);
                                ulong mangledNameAddress = 0u;
                                if (it1 == stringAddressMap.CEnd())
                                {
                                    mangledNameAddress = executableDataSection->Address();
                                    executableDataSection->EmitString(finalFunctionSymbol->name);
                                    stringAddressMap[finalFunctionSymbol->name] = mangledNameAddress;
                                }
                                else
                                {
                                    mangledNameAddress = it1->second;
                                }
                                HashMap<string, ulong>.ConstIterator it2 = stringAddressMap.CFind(functionFullName);
                                ulong fullNameAddress = 0u;
                                if (it2 == stringAddressMap.CEnd())
                                {
                                    fullNameAddress = executableDataSection->Address();
                                    executableDataSection->EmitString(functionFullName);
                                    stringAddressMap[functionFullName] = fullNameAddress;
                                }
                                else
                                {
                                    fullNameAddress = it2->second;
                                }
                                ulong exceptionTableAddress = 0u;
                                HashMap<string, ulong>.ConstIterator it3 = exceptionTableAddressMap.CFind(functionSymbol->name);
                                if (it3 != exceptionTableAddressMap.CEnd())
                                {
                                    exceptionTableAddress = it3->second;
                                    executable.dataSection->EmitUInt(exceptionTableAddress, frameSize);
                                }
                                LineNumberTableLimits& lineNumberTable = lineNumberTableMap[functionSymbol->name];
                                FunctionTableEntry entry(finalFunctionSymbol->start, finalFunctionSymbol->length, mangledNameAddress, fullNameAddress, sourceFileNameAddress,
                                    lineNumberTable.startAddress, lineNumberTable.endAddress, exceptionTableAddress);
                                functionTable.Add(entry);
                            }
                        }
                    }
                }
                else if (debugRecordCode == DebugRecordCode.startFunc)
                {
                    uint functionSymbolIndex = debugSection->GetUInt();
                    Symbol* functionSymbol = objectFile->GetSymbolTable().GetSymbol(cast<int>(functionSymbolIndex));
                    if (functionSymbol->linkage == Linkage.remove)
                    {
                        processFunc = false;
                    }
                    else
                    {
                        processFunc = true;
                        executableDataSection->Align(4u);
                        LineNumberTableLimits lineNumberTable;
                        lineNumberTable.startAddress = executableDataSection->Address();
                        lineNumberTableMap[functionSymbol->name] = lineNumberTable;
                        functionExceptionData = FunctionExceptionData();
                        functionExceptionData.functionName = functionSymbol->name;
                        Symbol* finalFunctionSymbol = executable.GetSymbolTable().GetSymbol(functionSymbol->name);
                    }
                }
                else if (debugRecordCode == DebugRecordCode.endFunc)
                {
                    uint functionSymbolIndex = debugSection->GetUInt();
                    if (processFunc)
                    {
                        Symbol* functionSymbol = objectFile->GetSymbolTable().GetSymbol(cast<int>(functionSymbolIndex));
                        LineNumberTableLimits& lineNumberTable = lineNumberTableMap[functionSymbol->name];
                        lineNumberTable.endAddress = executableDataSection->Address();
                        if (!functionExceptionData.IsEmpty())
                        {
                            exceptionTableAddressMap[functionSymbol->name] = MakeExceptionTable(executable, functionExceptionData);
                            functionExceptionData = FunctionExceptionData();
                        }
                    }
                }
                else if (debugRecordCode == DebugRecordCode.lineInfo)
                {
                    uint offset = debugSection->GetUInt();
                    uint lineNumber = debugSection->GetUInt();
                    if (processFunc)
                    {
                        executableDataSection->EmitUInt(offset);
                        executableDataSection->EmitUInt(lineNumber);
                    }
                }
                else if (debugRecordCode == DebugRecordCode.beginTry)
                {
                    uint tryBlockId = debugSection->GetUInt();
                    uint parentTryBlockId = debugSection->GetUInt();
                    uint offset = debugSection->GetUInt();
                    if (processFunc)
                    {
                        TryBlock tryBlock(tryBlockId, parentTryBlockId, offset);
                        functionExceptionData.tryBlocks.Add(tryBlock);
                    }
                }
                else if (debugRecordCode == DebugRecordCode.endTry)
                {
                    uint tryBlockId = debugSection->GetUInt();
                    uint offset = debugSection->GetUInt();
                    if (processFunc)
                    {
                        TryBlock* tryBlock = functionExceptionData.GetTryBlock(tryBlockId);
                        if (tryBlock != null)
                        {
                            tryBlock->length = offset - tryBlock->offset;
                        }
                        else
                        {
                            throw Exception("try block id " + ToString(tryBlockId) + " not found");
                        }
                    }
                }
                else if (debugRecordCode == DebugRecordCode.catch_)
                {
                    uint catchBlockId = debugSection->GetUInt();
                    uint tryBlockId = debugSection->GetUInt();
                    ulong catchedTypeId1 = debugSection->GetULong();
                    ulong catchedTypeId2 = debugSection->GetULong();
                    Uuid catchedTypeId(catchedTypeId1, catchedTypeId2);
                    ulong catchedClassId = classIdMap.GetClassId(catchedTypeId);
                    if (processFunc)
                    {
                        string catchBlockSymbolName = functionExceptionData.functionName;
                        catchBlockSymbolName.Append('@').Append(ToString(catchBlockId));
                        Symbol* handlerAddessSymbol = executable.GetSymbolTable().GetInternalSymbol(catchBlockSymbolName);
                        if (handlerAddessSymbol != null)
                        {
                            ulong handlerAddress = handlerAddessSymbol->start;
                            TryBlock* tryBlock = functionExceptionData.GetTryBlock(tryBlockId);
                            if (tryBlock != null)
                            {
                                HandlerBlock handlerBlock(catchedClassId, handlerAddress);
                                tryBlock->handlerBlocks.Add(handlerBlock);
                            }
                            else
                            {
                                throw Exception("try block id " + ToString(tryBlockId) + " not found (function=" + functionExceptionData.functionName + ")");
                            }
                        }
                        else
                        {
                            throw Exception("handler address for symbol '" + catchBlockSymbolName + "' not found from the symbol table of the executable (function=" +
                            functionExceptionData.functionName + ")");
                        }
                    }
                }
                else if (debugRecordCode == DebugRecordCode.beginCleanup)
                {
                    uint cleanupBlockId = debugSection->GetUInt();
                    uint tryBlockId = debugSection->GetUInt();
                    uint offset = debugSection->GetUInt();
                    if (processFunc)
                    {
                        TryBlock* tryBlock = null;
                        if (cast<int>(tryBlockId) != -1)
                        {
                            tryBlock = functionExceptionData.GetTryBlock(tryBlockId);
                            if (tryBlock == null)
                            {
                                throw Exception("try block id " + ToString(tryBlockId) + " not found from the function exception data (function=" + functionExceptionData.functionName + ")");
                            }
                        }
                        CleanupDispatchBlock cleanupDispatchBlock(cleanupBlockId, tryBlock, offset);
                        string cleanupBlockSymbolName = functionExceptionData.functionName;
                        cleanupBlockSymbolName.Append('@').Append(ToString(cleanupBlockId));
                        Symbol* cleanupAddessSymbol = executable.GetSymbolTable().GetInternalSymbol(cleanupBlockSymbolName);
                        if (cleanupAddessSymbol != null)
                        {
                            ulong cleanupAddess = cleanupAddessSymbol->start;
                            CleanupBlock cleanupBlock(cleanupAddess, 0u);
                            cleanupDispatchBlock.cleanupBlock = cleanupBlock;
                        }
                        else
                        {
                            throw Exception("cleanup address for symbol '" + cleanupBlockSymbolName + "' not found from the symbol table of the executable (function=" + functionExceptionData.functionName + ")");
                        }
                        functionExceptionData.cleanupDispatchBlocks.Add(cleanupDispatchBlock);
                    }
                }
                else if (debugRecordCode == DebugRecordCode.endCleanup)
                {
                    uint cleanupBlockId = debugSection->GetUInt();
                    uint offset = debugSection->GetUInt();
                    if (processFunc)
                    {
                        CleanupDispatchBlock* cleanupDispatchBlock = functionExceptionData.GetOpenCleanupDispatchBlock(cleanupBlockId);
                        if (cleanupDispatchBlock != null)
                        {
                            cleanupDispatchBlock->length = offset - cleanupDispatchBlock->offset;
                        }
                        else
                        {
                            throw Exception("cleanup block id " + ToString(cleanupBlockId) + " not found");
                        }
                    }
                }
                else
                {
                    throw Exception("unknown debug record in object file '" + objectFile->FileName() + "'");
                }
                x = debugSection->GetByte();
            }
        }
        if (debug)
        {
            Console.Out() << "end processing debug section of " << objectFile->FileName() << endl();
        }
    }

    public void MakeFuctionTable(ExecutableFile& executable, List<UniquePtr<BinaryFile>>& binaryFiles, const ClassIdMap& classIdMap, bool debug)
    {
        Section* executableDataSection = executable.dataSection;
        long prevPos = executableDataSection->pos;
        executableDataSection->pos = executableDataSection->data.Count();
        executableDataSection->Align(8u);
        Symbol* debugInfoSymbol = new Symbol();
        debugInfoSymbol->name = "@debug_info";
        debugInfoSymbol->segment = Segment.data;
        debugInfoSymbol->linkage = Linkage.external;
        debugInfoSymbol->value = Value(cast<Value.Flag>(Value.Flag.pure | Value.Flag.address), executableDataSection->Address(), debugInfoSymbol);
        debugInfoSymbol->start = cmsx.machine.dataSegmentBaseAddress + executableDataSection->Address();
        executableDataSection->pos = executableDataSection->data.Count();
        List<FunctionTableEntry> functionTable;
        HashSet<ulong> functionAddressSet;
        HashMap<string, ulong> sourceFileNameAddressMap;
        for (const UniquePtr<BinaryFile>& binaryFile : binaryFiles)
        {
            if (binaryFile.Get() is ObjectFile*)
            {
                ObjectFile* objectFile = cast<ObjectFile*>(binaryFile.Get());
                ProcessDebugSection(executable, objectFile, sourceFileNameAddressMap, functionTable, functionAddressSet, classIdMap, debug);
            }
            else if (binaryFile.Get() is LibraryFile*)
            {
                LibraryFile* libraryFile = cast<LibraryFile*>(binaryFile.Get());
                for (const UniquePtr<ObjectFile>& objectFile : libraryFile->objectFiles)
                {
                    ProcessDebugSection(executable, objectFile.Get(), sourceFileNameAddressMap, functionTable, functionAddressSet, classIdMap, debug);
                }
            }
        }
        Sort(functionTable);
        executableDataSection->Align(8u);
        ulong functionTableAddress = cmsx.machine.dataSegmentBaseAddress + executableDataSection->Address();
        for (const FunctionTableEntry& entry : functionTable)
        {
            executableDataSection->EmitULong(entry.start);
            executableDataSection->EmitULong(entry.length);
            executableDataSection->EmitULong(entry.mangledNameAddress);
            executableDataSection->EmitULong(entry.fullNameAddress);
            executableDataSection->EmitULong(entry.sourceFileNameAddress);
            executableDataSection->EmitULong(entry.lineNumberTableStartAddress);
            executableDataSection->EmitULong(entry.lineNumberTableEndAddress);
            executableDataSection->EmitULong(entry.exceptionTableAddress);
        }
        Symbol* functionTableSymbol = new Symbol();
        functionTableSymbol->name = "@function_table";
        functionTableSymbol->segment = Segment.data;
        functionTableSymbol->linkage = Linkage.external;
        functionTableSymbol->value = Value(cast<Value.Flag>(Value.Flag.pure | Value.Flag.address), functionTableAddress, functionTableSymbol);
        functionTableSymbol->start = functionTableAddress;
        functionTableSymbol->length = cmsx.machine.dataSegmentBaseAddress + executableDataSection->Address() - functionTableSymbol->start;
        functionTableSymbol->section = executableDataSection;
        executable.GetSymbolTable().AddSymbol(functionTableSymbol);
        debugInfoSymbol->length = cmsx.machine.dataSegmentBaseAddress + executableDataSection->Address() - debugInfoSymbol->start;
        debugInfoSymbol->section = executableDataSection;
        executable.GetSymbolTable().AddSymbol(debugInfoSymbol);
        executableDataSection->pos = prevPos;
    }

    public void Link(ExecutableFile& executable, List<UniquePtr<BinaryFile>>& binaryFiles, const ClassIdMap& classIdMap, bool removeUnusedCode, bool debug)
    {
        LinkTable linkTable(classIdMap);
        linkTable.AddUsedSymbolName("Main");
        if (removeUnusedCode)
        {
            for (const UniquePtr<BinaryFile>& binaryFile : binaryFiles)
            {
                if (binaryFile.Get() is ObjectFile*)
                {
                    ObjectFile* objectFile = cast<ObjectFile*>(binaryFile.Get());
                    MarkUsedSymbols(linkTable, objectFile, debug);
                }
                else if (binaryFile.Get() is LibraryFile*)
                {
                    LibraryFile* libraryFile = cast<LibraryFile*>(binaryFile.Get());
                    for (const UniquePtr<ObjectFile>& objectFile : libraryFile->objectFiles)
                    {
                        MarkUsedSymbols(linkTable, objectFile.Get(), debug);
                    }
                }
                else
                {
                    throw Exception("cannot link '" + binaryFile->FileName() + "': not an object or library file");
                }
            }
        }
        CodeSection* prevCodeSection = null;
        DataSection* prevDataSection = null;
        for (const UniquePtr<BinaryFile>& binaryFile : binaryFiles)
        {
            if (binaryFile.Get() is ObjectFile*)
            {
                ObjectFile* objectFile = cast<ObjectFile*>(binaryFile.Get());
                LinkObjectFile(linkTable, executable, objectFile, prevCodeSection, prevDataSection, removeUnusedCode, debug);
            }
            else if (binaryFile.Get() is LibraryFile*)
            {
                LibraryFile* libraryFile = cast<LibraryFile*>(binaryFile.Get());
                for (const UniquePtr<ObjectFile>& objectFile : libraryFile->objectFiles)
                {
                    LinkObjectFile(linkTable, executable, objectFile.Get(), prevCodeSection, prevDataSection, removeUnusedCode, debug);
                }
            }
            else
            {
                throw Exception("cannot link '" + binaryFile->FileName() + "': not an object or library file");
            }
        }
        linkTable.ReportUnresolvedSymbols();
        linkTable.CopyRanges(debug);
        MakeFuctionTable(executable, binaryFiles, classIdMap, debug);
        executable.Finalize();
        executable.Write();
    }
}

using System;
using System.Collections;
using System.IO;
using System.Os;
using System.Text;

void PrintHelp()
{
    Console.Out() << "Usage: ls [options] [<files>]..." << endl() <<
        "List information about files. If no files specified, list contents of current directory." << endl() << endl() <<
        "Options:" << endl() << endl() <<
        "--help | -h" << endl() <<
        "   Print help." << endl() << endl() <<
        "--long | -l" << endl() <<
        "   Use long format." << endl() << endl() <<
        "--all | -a" << endl() <<
        "   List also files names starting with '.'" << endl() << endl() <<
        "--no-columns | -1" << endl() <<
        "   Do not break lines into columns." << endl() << endl() <<
        "--no-colors | -o" << endl() <<
        "   Do not use colors." << endl() << endl() <<
        "--diagnostics | -d" << endl() <<
        "   Show stack trace in case of error." << endl() << endl() <<
        "--recursive | -R" << endl() <<
        "   List subdirectories recursively." << endl() << endl() <<
        "--reverse | -r" << endl() <<
        "   Reverse sort order." << endl() << endl() <<
        "--inode | -i" << endl() <<
        "   Show inode number." << endl() << endl() <<
        "--access | -x" << endl() <<
        "   Show access permissions." << endl() << endl() <<
        "--nlinks | -n" << endl() << 
        "   Show number of hard links." << endl() << endl() <<
        "--size | -s" << endl() <<
        "   Show file size." << endl() << endl() <<
        "--ctime | -c" << endl() <<
        "   Show inode modification time." << endl() << endl() <<
        "--time | -t" << endl() <<
        "   Show file modification time." << endl() << endl() <<
        "--atime | -u" << endl() <<
        "   Show last file access time." << endl() << endl() <<
        "--sort=size | -S" << endl() <<
        "   Sort by file size (largest file first)." << endl() << endl() <<
        "--sort=inode | -I" << endl() <<
        "   Sort by inode number." << endl() << endl() <<
        "--sort=nlinks | -N" << endl() <<
        "   Sort by number of hard links." << endl() << endl() <<
        "--sort=ctime | -C" << endl() <<
        "   Sort by inode modification time." << endl() << endl() <<
        "--sort=time | -T" << endl() <<
        "   Sort by file modification time." << endl() << endl() <<
        "--sort=atime | -U" << endl() << 
        "   Sort by last file access time." << endl() << endl() <<
        endl();
}

private uchar regularColorChar = ' ';
private uchar directoryColorChar = ' ';
private uchar executableColorChar = ' ';
private uchar endColorChar = ' ';

bool HasColors()
{
    return Screen.Instance().HasColors();
}

int GetScreenWidth()
{
    return Screen.Instance().Width();
}

void SetColorChars()
{
    regularColorChar = BeginColors(ConsoleColor.white, ConsoleColor.black);
    directoryColorChar = BeginColors(ConsoleColor.cyan, ConsoleColor.black);
    executableColorChar = BeginColors(ConsoleColor.green, ConsoleColor.black);
    endColorChar = EndColors();
}

enum Column : int
{
    none = 0, inode = 1 << 0, access = 1 << 1, nlinks = 1 << 2, size = 1 << 3, ctime = 1 << 4, mtime = 1 << 5, atime = 1 << 6, name = 1 << 7
}

enum SortBy
{
    name, size, inode, nlinks, ctime, mtime, atime
}

private Column shortColumns = Column.name;
private Column longColumns = cast<Column>(Column.access | Column.nlinks | Column.size | Column.mtime | Column.name);

class InfoEntry
{
    public nothrow InfoEntry(DirectoryEntry* directoryEntry_, StatInfo* statInfo_) : directoryEntry(directoryEntry_), statInfo(statInfo_), name(ToUtf32(&directoryEntry->name[0]))
    {
    }
    public DirectoryEntry* directoryEntry;
    public StatInfo* statInfo;
    public ustring name;
}

class Field
{
    public nothrow Field(const ustring& data_, FormatJustify justification_) : this(data_, cast<int>(data_.Length()), justification_)
    {
    }
    public nothrow Field(const ustring& data_, int width_, FormatJustify justification_) : data(data_), width(width_), justification(justification_)
    {
    }
    public nothrow inline int Width() const
    {
        return width;
    }
    public ustring data;
    public int width;
    public FormatJustify justification;
}

class Item
{
    public Field inode;
    public Field access;
    public Field nlinks;
    public Field size;
    public Field ctime;
    public Field mtime;
    public Field atime;
    public Field name;
}

nothrow ustring GetAccessString(Access access)
{
    ustring accessStr;
    if ((access & Access.read) != Access.none)
    {
        accessStr.Append('r');
    }
    else
    {
        accessStr.Append('-');
    }
    if ((access & Access.write) != Access.none)
    {
        accessStr.Append('w');
    }
    else
    {
        accessStr.Append('-');
    }
    if ((access & Access.execute) != Access.none)
    {
        accessStr.Append('x');
    }
    else
    {
        accessStr.Append('-');
    }
    return accessStr;
}

nothrow ustring MakeAccessString(const InfoEntry& infoEntry)
{
    ustring accessStr;
    if (infoEntry.statInfo->Type() == FileType.directory)
    {
        accessStr.Append('d');
    }
    else
    {
        accessStr.Append('-');
    }
    accessStr.Append(GetAccessString(infoEntry.statInfo->OwnerAccess()));
    accessStr.Append(GetAccessString(infoEntry.statInfo->GroupAccess()));
    accessStr.Append(GetAccessString(infoEntry.statInfo->OtherAccess()));
    return accessStr;
}

nothrow ustring MakeEntryName(const InfoEntry& infoEntry, bool hasColors, int& width)
{
    ustring entryName;
    if (hasColors)
    {
        switch (infoEntry.statInfo->Type())
        {
            case FileType.regular:
            {
                if ((infoEntry.statInfo->OwnerAccess() & Access.execute) != Access.none)
                {
                    entryName.Append(executableColorChar);
                }
                else
                {
                    entryName.Append(regularColorChar);
                }
                break;
            }
            case FileType.directory:
            {
                entryName.Append(directoryColorChar);
                break;
            }
            default:
            {
                if ((infoEntry.statInfo->OwnerAccess() & Access.execute) != Access.none)
                {
                    entryName.Append(executableColorChar);
                }
                else
                {
                    entryName.Append(regularColorChar);
                }
                break;
            }
        }
    }
    entryName.Append(infoEntry.name);
    width = cast<int>(infoEntry.name.Length());
    if (hasColors)
    {
        entryName.Append(endColorChar);
    }
    return entryName;
}

nothrow Item MakeItem(const InfoEntry& infoEntry, Column columns, bool hasColors)
{
    Item item;
    if ((columns & Column.inode) != Column.none)
    {
        item.inode = Field(ToUtf32(ToString(infoEntry.statInfo->INodeNumber())), FormatJustify.right);
    }
    if ((columns & Column.access) != Column.none)
    {
        item.access = Field(MakeAccessString(infoEntry), FormatJustify.left);
    }
    if ((columns & Column.nlinks) != Column.none)
    {
        item.nlinks = Field(ToUtf32(ToString(infoEntry.statInfo->GetNumLinks())), FormatJustify.right);
    }
    if ((columns & Column.size) != Column.none)
    {
        item.size = Field(ToUtf32(ToString(infoEntry.statInfo->GetFileSize())), FormatJustify.right);
    }
    if ((columns & Column.ctime) != Column.none)
    {
        item.ctime = Field(ToUtf32(infoEntry.statInfo->CTime().ToString()), FormatJustify.left);
    }
    if ((columns & Column.mtime) != Column.none)
    {
        item.mtime = Field(ToUtf32(infoEntry.statInfo->MTime().ToString()), FormatJustify.left);
    }
    if ((columns & Column.atime) != Column.none)
    {
        item.atime = Field(ToUtf32(infoEntry.statInfo->ATime().ToString()), FormatJustify.left);
    }
    if ((columns & Column.name) != Column.none)
    {
        int entryWidth = 0;
        ustring entryName = MakeEntryName(infoEntry, hasColors, entryWidth);
        item.name = Field(entryName, entryWidth, FormatJustify.left);
    }
    return item;
} 

class FieldWidths
{
    public int inodeWidth;
    public int accessWidth;
    public int nlinksWidth;
    public int sizeWidth;
    public int ctimeWidth;
    public int mtimeWidth;
    public int atimeWidth;
    public int nameWidth;
}

nothrow FieldWidths CalculateFieldWidths(const List<Item>& items, Column columns)
{
    FieldWidths fieldWidths;
    for (const Item& item : items)
    {
        if ((columns & Column.inode) != Column.none)
        {
            fieldWidths.inodeWidth = Max(item.inode.Width(), fieldWidths.inodeWidth);
        }
        if ((columns & Column.access) != Column.none)
        {
            fieldWidths.accessWidth = Max(item.access.Width(), fieldWidths.accessWidth);
        }
        if ((columns & Column.nlinks) != Column.none)
        {
            fieldWidths.nlinksWidth = Max(item.nlinks.Width(), fieldWidths.nlinksWidth);
        }
        if ((columns & Column.size) != Column.none)
        {
            fieldWidths.sizeWidth = Max(item.size.Width(), fieldWidths.sizeWidth);
        }
        if ((columns & Column.ctime) != Column.none)
        {
            fieldWidths.ctimeWidth = Max(item.ctime.Width(), fieldWidths.ctimeWidth);
        }
        if ((columns & Column.mtime) != Column.none)
        {
            fieldWidths.mtimeWidth = Max(item.mtime.Width(), fieldWidths.mtimeWidth);
        }
        if ((columns & Column.atime) != Column.none)
        {
            fieldWidths.atimeWidth = Max(item.atime.Width(), fieldWidths.atimeWidth);
        }
        if ((columns & Column.name) != Column.none)
        {
            fieldWidths.nameWidth = Max(item.name.Width(), fieldWidths.nameWidth);
        }
    }
    return fieldWidths;
}

nothrow Pair<ustring, int> MakeItemString(const Item& item, Column columns, FieldWidths widths)
{
    int width = 0;
    ustring itemString;
    if ((columns & Column.inode) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.inode.data, widths.inodeWidth, FormatWidth.min, item.inode.justification)) ;
        width = width + item.inode.Width();
    }
    if ((columns & Column.access) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.access.data, widths.accessWidth, FormatWidth.min, item.access.justification));
        width = width + item.access.Width();
    }
    if ((columns & Column.nlinks) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.nlinks.data, widths.nlinksWidth, FormatWidth.min, item.nlinks.justification));
        width = width + item.nlinks.Width();
    }
    if ((columns & Column.size) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.size.data, widths.sizeWidth, FormatWidth.min, item.size.justification));
        width = width + item.size.Width();
    }
    if ((columns & Column.ctime) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.ctime.data, widths.ctimeWidth, FormatWidth.min, item.ctime.justification));
        width = width + item.ctime.Width();
    }
    if ((columns & Column.mtime) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.mtime.data, widths.mtimeWidth, FormatWidth.min, item.mtime.justification));
        width = width + item.mtime.Width();
    }
    if ((columns & Column.atime) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.atime.data, widths.atimeWidth, FormatWidth.min, item.atime.justification));
        width = width + item.atime.Width();
    }
    if ((columns & Column.name) != Column.none)
    {
        if (!itemString.IsEmpty())
        {
            itemString.Append(' ');
            ++width;
        }
        itemString.Append(Format(item.name.data, 0, FormatWidth.min, item.name.justification));
        width = width + item.name.Width();
    }
    return MakePair(itemString, width);
}

class SortRelation : Rel<InfoEntry>
{
    public nothrow SortRelation(SortBy sortBy_, bool reverse_) : sortBy(sortBy_), reverse(reverse_)
    {
    }
    public nothrow bool operator()(const InfoEntry& left, const InfoEntry& right) const
    {
        if (sortBy == SortBy.name)
        {
            ustring leftName = ToUtf32(&left.directoryEntry->name[0]);
            ustring rightName = ToUtf32(&right.directoryEntry->name[0]);
            if (reverse)
            {
                return leftName > rightName;
            }
            else
            {
                return leftName < rightName;
            }
        }
        else if (sortBy == SortBy.size)
        {
            long leftSize = left.statInfo->GetFileSize();
            long rightSize = right.statInfo->GetFileSize();
            if (reverse)
            {
                return leftSize < rightSize;    
            }
            else
            {
                return leftSize > rightSize;
            }
        }
        else if (sortBy == SortBy.inode)
        {
            int leftINodeNumber = left.statInfo->INodeNumber();
            int rightNodeNumber = right.statInfo->INodeNumber();
            if (reverse)
            {
                return leftINodeNumber > rightNodeNumber;
            }
            else
            {
                return leftINodeNumber < rightNodeNumber;
            }
        }
        else if (sortBy == SortBy.nlinks)
        {
            int leftNLinks = left.statInfo->GetNumLinks();
            int rightNLinks = right.statInfo->GetNumLinks();
            if (reverse)
            {
                return leftNLinks > rightNLinks;
            }
            else
            {
                return leftNLinks < rightNLinks;
            }
        }
        else if (sortBy == SortBy.ctime)
        {
            const DateTime& leftCTime = left.statInfo->CTime();
            const DateTime& rightCTime = right.statInfo->CTime();
            if (reverse)
            {
                return leftCTime > rightCTime;
            }
            else
            {
                return leftCTime < rightCTime;
            }
        }
        else if (sortBy == SortBy.mtime)
        {
            const DateTime& leftMTime = left.statInfo->MTime();
            const DateTime& rightMTime = right.statInfo->MTime();
            if (reverse)
            {
                return leftMTime > rightMTime;
            }
            else
            {
                return leftMTime < rightMTime;
            }
        }
        else if (sortBy == SortBy.atime)
        {
            const DateTime& leftATime = left.statInfo->ATime();
            const DateTime& rightATime = right.statInfo->ATime();
            if (reverse)
            {
                return leftATime > rightATime;
            }
            else
            {
                return leftATime < rightATime;
            }
        }
        else
        {
            ustring leftName = ToUtf32(&left.directoryEntry->name[0]);
            ustring rightName = ToUtf32(&right.directoryEntry->name[0]);
            if (reverse)
            {
                return leftName > rightName;
            }
            else
            {
                return leftName < rightName;
            }
        }
    }
    private SortBy sortBy;
    private bool reverse;
}

nothrow List<Pair<ustring, int>> MakeItemStrings(List<InfoEntry>& infoEntries, Column columns, SortBy sortBy, bool reverse, bool hasColors)
{
    List<Item> items;
    List<Pair<ustring, int>> itemStrings;
    Sort(infoEntries, SortRelation(sortBy, reverse));
    for (const InfoEntry& infoEntry : infoEntries)
    {
        items.Add(MakeItem(infoEntry, columns, hasColors));
    }
    FieldWidths widths = CalculateFieldWidths(items, columns);
    for (const Item& item : items)
    {
        itemStrings.Add(MakeItemString(item, columns, widths));
    }
    return itemStrings;
}

nothrow void MakeLines(List<Pair<ustring, int>>& itemStrings, List<Pair<ustring, int>>& lines, bool longFormat, bool multicolumn, int screenWidth)
{
    if (screenWidth == 0 || longFormat || !multicolumn)
    {
        Swap(itemStrings, lines);
    }
    else 
    {
        int maxItemStringLength = 0;
        int totalLength = 0;
        bool first = true;
        for (const Pair<ustring, int>& itemString : itemStrings)
        {
            if (first)
            {
                first = false;
            }
            else
            {
                totalLength = totalLength + 2;
            }
            int itemStringLength = cast<int>(itemString.second);
            if (itemStringLength > maxItemStringLength)
            {
                maxItemStringLength = itemStringLength;
            }
            totalLength = totalLength + itemStringLength;
        }
        if (totalLength <= screenWidth)
        {
            ustring line;
            bool first = true;
            for (const Pair<ustring, int>& itemString : itemStrings)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    line.Append(u"  ");
                }
                line.Append(itemString.first);
            }
            lines.Add(MakePair(line, cast<int>(0)));
        }
        else if (maxItemStringLength * 2 + 2 <= screenWidth)
        {
            ustring line;
            int lineWidth = 0;
            bool first = true;
            for (const Pair<ustring, int>& itemString : itemStrings)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    line.Append(u"  ");
                    lineWidth = lineWidth + 2;
                }
                if (lineWidth + maxItemStringLength > screenWidth)
                {
                    lines.Add(MakePair(line, cast<int>(0)));
                    line.Clear();
                    lineWidth = 0;
                    first = true;
                }
                line.Append(Format(itemString.first, maxItemStringLength, FormatWidth.min));
                lineWidth = lineWidth + itemString.second;
            }
            if (!line.IsEmpty())
            {
                lines.Add(MakePair(line, cast<int>(0)));
            }
        }
        else
        {
            Swap(itemStrings, lines);
        }
    }
}

nothrow void PrintLines(const List<Pair<ustring, int>>& lines)
{
    for (const Pair<ustring, int>& line : lines)
    {
        Console.Out() << line.first << endl();
    }
}

void ListFiles(const List<string>& files, Column columns, SortBy sortBy, bool reverse, bool hasColors, bool all, bool longFormat, bool multicolumn, bool printDirectoryNames, bool recursive, int screenWidth)
{
    List<UniquePtr<StatInfo>> globalStatInfos;
    List<UniquePtr<DirectoryEntry>> globalDirectoryEntries;
    List<InfoEntry> infoEntries;
    for (const string& file : files)
    {
        StatInfo* fileInfo = new StatInfo();
        globalStatInfos.Add(UniquePtr<StatInfo>(fileInfo));
        Stat(file.Chars(), *fileInfo);
        DirectoryEntry* directoryEntry = new DirectoryEntry();
        globalDirectoryEntries.Add(UniquePtr<DirectoryEntry>(directoryEntry));
        directoryEntry->inodeNumber = fileInfo->INodeNumber();
        StrCopy(&directoryEntry->name[0], file.Chars(), nameMax);
        InfoEntry infoEntry(directoryEntry, fileInfo);
        if (fileInfo->Type() == FileType.directory)
        {
            if (printDirectoryNames)
            {
                Console.Out() << "\n" << GetFullPath(file) << ":" << endl();
            }
            List<UniquePtr<StatInfo>> dirStatInfos;
            List<UniquePtr<DirectoryEntry>> dirDirectoryEntries;
            DirectoryReader reader(file);
            DirectoryEntry directoryEntry;
            List<InfoEntry> directoryInfoEntries;
            List<string> subdirectories;
            while (reader.Read(directoryEntry))
            {
                string entryName = &directoryEntry.name[0];
                if (entryName.StartsWith(".") && !all)
                {
                    continue;
                }
                string entryPath = Path.Combine(file, entryName);
                if (recursive && entryName != "." && entryName != "..")
                {
                    subdirectories.Add(entryPath);
                }
                StatInfo* statInfo = new StatInfo();
                dirStatInfos.Add(UniquePtr<StatInfo>(statInfo));
                Stat(entryPath.Chars(), *statInfo);
                DirectoryEntry* dirEntry = new DirectoryEntry(directoryEntry);
                dirDirectoryEntries.Add(UniquePtr<DirectoryEntry>(dirEntry));
                directoryInfoEntries.Add(InfoEntry(dirEntry, statInfo));
            }
            List<Pair<ustring, int>> itemStrings = MakeItemStrings(directoryInfoEntries, columns, sortBy, reverse, hasColors);
            if (!itemStrings.IsEmpty())
            {
                List<Pair<ustring, int>> lines;
                MakeLines(itemStrings, lines, longFormat, multicolumn, screenWidth);
                PrintLines(lines);
            }
            if (recursive)
            {
                ListFiles(subdirectories, columns, sortBy, reverse, hasColors, all, longFormat, multicolumn, true, true, screenWidth);
            }
        }
        else
        {
            infoEntries.Add(infoEntry);
        }
    }
    if (!infoEntries.IsEmpty())
    {
        List<Pair<ustring, int>> itemStrings = MakeItemStrings(infoEntries, columns, sortBy, reverse, hasColors);
        if (!itemStrings.IsEmpty())
        {
            List<Pair<ustring, int>> lines;
            MakeLines(itemStrings, lines, longFormat, multicolumn, screenWidth);
            PrintLines(lines);
        }
    }
}

int main(int argc, const char** argv)
{
    bool diagnostics = false;
    try
    {
        int screenWidth = GetScreenWidth();
        bool multicolumn = screenWidth > 0;
        bool hasColors = HasColors();
        bool all = false;
        bool longFormat = false;
        bool reverse = false;
        bool recursive = false;
        bool inodeColumn = false;
        bool accessColumn = false;
        bool nlinksColumn = false;
        bool sizeColumn = false;
        bool ctimeColumn = false;
        bool mtimeColumn = false;
        bool atimeColumn = false;
        List<string> files;
        SortBy sortBy = SortBy.name;
        for (int i = 1; i < argc; ++i)
        {
            string arg = argv[i];
            if (arg.StartsWith("--"))
            {
                if (arg == "--help")
                {
                    PrintHelp();
                    return 1;
                }
                else if (arg == "--all")
                {
                    all = true;
                }
                else if (arg == "--long")
                {
                    longFormat = true;
                }
                else if (arg == "--no-columns")
                {
                    multicolumn = false;
                }
                else if (arg == "--no-colors")
                {
                    hasColors = false;
                }
                else if (arg == "--diagnostics")
                {
                    diagnostics = true;
                }
                else if (arg == "--reverse")
                {
                    reverse = true;
                }
                else if (arg == "--recursive")
                {
                    recursive = true;
                }
                else if (arg == "--inode")
                {
                    inodeColumn = true;
                }
                else if (arg == "--access")
                {
                    accessColumn = true;
                }
                else if (arg == "--nlinks")
                {
                    nlinksColumn = true;
                }
                else if (arg == "--size")
                {
                    sizeColumn = true;
                }
                else if (arg == "--ctime")
                {
                    ctimeColumn = true;
                }
                else if (arg == "--time")
                {
                    mtimeColumn = true;
                }
                else if (arg == "--atime")
                {
                    atimeColumn = true;
                }
                else if (arg == "--sort=size")
                {
                    sortBy = SortBy.size;
                }
                else if (arg == "--sort=inode")
                {
                    sortBy = SortBy.inode;
                }
                else if (arg == "--sort=nlinks")
                {
                    sortBy = SortBy.nlinks;
                }
                else if (arg == "--sort=ctime")
                {
                    sortBy = SortBy.ctime;
                }
                else if (arg == "--sort=time")
                {
                    sortBy = SortBy.mtime;
                }
                else if (arg == "--sort=atime")
                {
                    sortBy = SortBy.atime;
                }
                else
                {
                    throw Exception("unknown option '" + arg + "'");
                }
            }
            else if (arg.StartsWith("-"))
            {
                string options = arg.Substring(1);
                if (options.IsEmpty())
                {
                    throw Exception("unknown option '" + arg + "'");
                }
                else
                {
                    for (char o : options)
                    {
                        if (o == 'h')
                        {
                            PrintHelp();
                            return 1;
                        }
                        else if (o == 'a')
                        {
                            all = true;
                        }
                        else if (o == 'l')
                        {
                            longFormat = true;
                        }
                        else if (o == 'd')
                        {
                            diagnostics = true;
                        }
                        else if (o == 'r')
                        {
                            reverse = true;
                        }
                        else if (o == 'R')
                        {
                            recursive = true;
                        }
                        else if (o == 'o')
                        {
                            hasColors = false;
                        }
                        else if (o == 'i')
                        {
                            inodeColumn = true;
                        }
                        else if (o == 'x')
                        {
                            accessColumn = true;
                        }
                        else if (o == 'n')
                        {
                            nlinksColumn = true;
                        }
                        else if (o == 's')
                        {
                            sizeColumn = true;
                        }
                        else if (o == 'c')
                        {
                            ctimeColumn = true;
                        }
                        else if (o == 't')
                        {
                            mtimeColumn = true;
                        }
                        else if (o == 'u')
                        {
                            atimeColumn = true;
                        }
                        else if (o == 'S')
                        {
                            sortBy = SortBy.size;
                        }
                        else if (o == 'N')
                        {
                            sortBy = SortBy.nlinks;
                        }
                        else if (o == 'I')
                        {
                            sortBy = SortBy.inode;
                        }
                        else if (o == 'C')
                        {
                            sortBy = SortBy.ctime;
                        }
                        else if (o == 'T')
                        {
                            sortBy = SortBy.mtime;
                        }
                        else if (o == 'U')
                        {
                            sortBy = SortBy.atime;
                        }
                        else if (o == '1')
                        {
                            multicolumn = false;
                        }
                        else
                        {
                            throw Exception("unknown option '-" + string(o) + "'");
                        }
                    }
                }
            }
            else
            {
                files.Add(arg);
            }
        }
        if (hasColors)
        {
            SetColorChars();
        }
        Column columns = cast<Column>(shortColumns);
        if (longFormat)
        {
            columns = cast<Column>(longColumns);
        }
        if (inodeColumn)
        {
            columns = cast<Column>(columns | Column.inode);
        }
        if (accessColumn)
        {
            columns = cast<Column>(columns | Column.access);
        }
        if (nlinksColumn)
        {
            columns = cast<Column>(columns | Column.nlinks);
        }
        if (sizeColumn)
        {
            columns = cast<Column>(columns | Column.size);
        }
        if (ctimeColumn)
        {
            columns = cast<Column>(columns | Column.ctime);
        }
        if (mtimeColumn)
        {
            columns = cast<Column>(columns | Column.mtime);
        }
        if (atimeColumn)
        {
            columns = cast<Column>(columns | Column.atime);
        }
        if (files.IsEmpty())
        {
            files.Add(".");
        }
        bool printDirectoryNames = files.Count() > 1 || recursive;
        ListFiles(files, columns, sortBy, reverse, hasColors, all, longFormat, multicolumn, printDirectoryNames, recursive, screenWidth);
    }
    catch (const Exception& ex)
    {
        if (diagnostics)
        {
            Console.Error() << ex.ToString() << endl();
        }
        else
        {
            Console.Error() << ex.Message() << endl();
        }
        return 1;
    }
    return 0;
}

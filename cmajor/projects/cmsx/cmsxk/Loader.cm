using System;
using System.Collections;
using System.IO;
using cmsx.machine;
using cmsx.object;

namespace cmsx.kernel
{
    public Section MakePoolSection(const List<string>& argv)
    {
        Section poolSection;
        long n = argv.Count() + 1;
        for (long i = 0; i < n; ++i)
        {
            poolSection.EmitULong(0u);
        }
        List<ulong> argAddresses;
        for (const string& arg : argv)
        {
            argAddresses.Add(poolSegmentBaseAddress + poolSection.Address());
            poolSection.EmitString(arg);
        }
        poolSection.pos = 0u;
        for (ulong argAddr : argAddresses)
        {
            poolSection.EmitULong(argAddr);
        }
        return poolSection;
    }

    public int Load(const string& programFileName, const List<string>& programArguments, int sid)
    {
        UniquePtr<BinaryFile> binaryFile = ReadBinaryFile(programFileName);
        if (binaryFile.Get() is ExecutableFile*)
        {
            Machine& machine = GetMachine();
            ProcessTable& processTable = GetProcessTable();
            ExecutableFile* executable = cast<ExecutableFile*>(binaryFile.Get());
            executable->AddSymbolsToAddressMap();
            Section* codeSection = executable->GetCodeSection();
            Section* dataSection = executable->GetDataSection();
            string name = Path.GetFileName(programFileName);
            List<string> argv;
            argv.Add(name);
            for (const string& arg : programArguments)
            {
                argv.Add(arg);
            }
            Section poolSection = MakePoolSection(argv);
            long poolDataLength = poolSection.data.Count();
            long poolSize = Align(poolDataLength, cast<long>(pageSize));
            Process* process = CreateSingleProcess(machine, processTable, name, codeSection->BaseAddress(), codeSection->Length(), dataSection->Length(), cast<ulong>(poolSize), executable->StackSize(), sid);
            if (codeSection->Length() > 0u)
            {
                WriteProcessMemory(machine, process, codeSection->BaseAddress(), codeSection->data.Begin().Ptr(), cast<ulong>(codeSection->data.Count()), Protection.execute);
            }
            if (dataSection->Length() > 0u)
            {
                WriteProcessMemory(machine, process, dataSection->BaseAddress(), dataSection->data.Begin().Ptr(), cast<ulong>(dataSection->data.Count()), Protection.write);
            }
            if (!poolSection.data.IsEmpty())
            {
                WriteProcessMemory(machine, process, poolSegmentBaseAddress, poolSection.data.Begin().Ptr(), cast<ulong>(poolSection.data.Count()), Protection.write);
                int ax = cast<int>(argv.Count());
                ulong bx = poolSegmentBaseAddress;
                WriteProcessMemory(machine, process, process->regAXAddress, cast<ulong>(ax), 8u, Protection.write);
                WriteProcessMemory(machine, process, process->regBXAddress, bx, 8u, Protection.write);
            }
            ulong poolStart = poolSegmentBaseAddress + cast<ulong>(poolSize);
            ulong poolEnd = poolSegmentBaseAddress + cast<ulong>(poolSize);
            process->poolStart = poolStart;
            process->poolEnd = poolEnd;
            Symbol* functionTableSymbol = executable->GetSymbolTable().GetSymbol("@function_table");
            process->functionTableAddress = functionTableSymbol->start;
            process->functionTableLength = functionTableSymbol->length;
            executable = cast<ExecutableFile*>(binaryFile.Release());
            Kernel& kernel = Kernel.Instance();
            kernel.SetExecutable(executable);
            return process->pid;
        }
        else
        {
            Panic("file '" + programFileName + "' is not a cmsx executable");
        }
        return -1;
    }
}

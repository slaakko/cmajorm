using System;
using System.IO;
using System.Collections;
using cmsx.machine;
using cmsx.object;

namespace cmsx.kernel
{
    public SharedPtr<ByteStream> ReadFileIntoMemoryStream(INode* inode)
    {
        SharedPtr<ByteStream> memoryStream(new MemoryByteStream());
        long fileSize = inode->GetFileSize();
        FileSystem* fs = GetMountTable().GetFileSystem(inode->Key().fsNumber);
        long bytesLeft = fileSize;
        long offset = 0;
        while (bytesLeft > 0)
        {
            int blockNumber = 0;
            int blockOffset = 0;
            fs->GetBlockManager()->GetBlockNumber(inode, offset, blockNumber, blockOffset, false);
            long bytesToRead = Min(bytesLeft, blockSize - blockOffset);
            if (bytesToRead == 0)
            {
                break;
            }
            Block* block = null;
            if (!fs->IsRootFileSystem() || blockNumber != 0)
            {
                block = fs->GetBlockManager()->ReadBlock(BlockKey(blockNumber, inode->Key().fsNumber, BlockKind.fileBlock), null);
                #assert(block is FileBlock*);
                BlockPutter blockPutter(block);
                FileBlock* fileBlock = cast<FileBlock*>(block);
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = fileBlock->GetByte(blockOffset + i);
                    memoryStream->Write(x);
                }
            }
            else
            {
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = 0u;
                    memoryStream->Write(x);
                }
            }
            bytesLeft = bytesLeft - bytesToRead;
            offset = offset + bytesToRead;
        }
        return memoryStream;
    }

    public SharedPtr<ByteStream> ReadFirstBlockIntoMemoryStream(INode* inode)
    {
        SharedPtr<ByteStream> memoryStream(new MemoryByteStream());
        long fileSize = inode->GetFileSize();
        FileSystem* fs = GetMountTable().GetFileSystem(inode->Key().fsNumber);
        long bytesLeft = Min(blockSize, fileSize);
        long offset = 0;
        while (bytesLeft > 0)
        {
            int blockNumber = 0;
            int blockOffset = 0;
            fs->GetBlockManager()->GetBlockNumber(inode, offset, blockNumber, blockOffset, false);
            long bytesToRead = Min(bytesLeft, blockSize - blockOffset);
            if (bytesToRead == 0)
            {
                break;
            }
            Block* block = null;
            if (!fs->IsRootFileSystem() || blockNumber != 0)
            {
                block = fs->GetBlockManager()->ReadBlock(BlockKey(blockNumber, inode->Key().fsNumber, BlockKind.fileBlock), null);
                #assert(block is FileBlock*);
                BlockPutter blockPutter(block);
                FileBlock* fileBlock = cast<FileBlock*>(block);
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = fileBlock->GetByte(blockOffset + i);
                    memoryStream->Write(x);
                }
            }
            else
            {
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = 0u;
                    memoryStream->Write(x);
                }
            }
            bytesLeft = bytesLeft - bytesToRead;
            offset = offset + bytesToRead;
        }
        return memoryStream;
    }

    public SharedPtr<ByteStream> ReadFilePortionIntoMemoryStream(INode* inode, long fileOffset, long count)
    {
        SharedPtr<ByteStream> memoryStream(new MemoryByteStream());
        FileSystem* fs = GetMountTable().GetFileSystem(inode->Key().fsNumber);
        long bytesLeft = Min(blockSize, count);
        long offset = fileOffset;
        while (bytesLeft > 0)
        {
            int blockNumber = 0;
            int blockOffset = 0;
            fs->GetBlockManager()->GetBlockNumber(inode, offset, blockNumber, blockOffset, false);
            long bytesToRead = Min(bytesLeft, blockSize - blockOffset);
            if (bytesToRead == 0)
            {
                break;
            }
            Block* block = null;
            if (!fs->IsRootFileSystem() || blockNumber != 0)
            {
                block = fs->GetBlockManager()->ReadBlock(BlockKey(blockNumber, inode->Key().fsNumber, BlockKind.fileBlock), null);
                #assert(block is FileBlock*);
                BlockPutter blockPutter(block);
                FileBlock* fileBlock = cast<FileBlock*>(block);
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = fileBlock->GetByte(blockOffset + i);
                    memoryStream->Write(x);
                }
            }
            else
            {
                for (long i = 0; i < bytesToRead; ++i)
                {
                    byte x = 0u;
                    memoryStream->Write(x);
                }
            }
            bytesLeft = bytesLeft - bytesToRead;
            offset = offset + bytesToRead;
        }
        return memoryStream;
    }

    public void Exec(Machine& machine, ProcessTable& processTable, Process* process, int argc, ulong argvAddress)
    {
        if (argc < 1)
        {
            throw SystemError(EINVAL, "exec: argc must at least 1");
        }
        if (argvAddress == 0u)
        {
            throw SystemError(EINVAL, "exec: argv is null");
        }
        List<string> args;
        for (int i = 0; i < argc; ++i)
        {
            ulong argAddress = 0u;
            ReadProcessMemory(machine, process, argvAddress, argAddress, 8u);
            if (argAddress == 0u)
            {
                if (argAddress == 0u)
                {
                    throw SystemError(EINVAL, "exec: argument " + ToString(i) + " is null");
                }
            }
            string arg;
            ReadStringFromProcessMemory(machine, process, argAddress, arg);
            if (arg.IsEmpty())
            {
                throw SystemError(EINVAL, "exec: argument " + ToString(i) + " is empty");
            }
            args.Add(arg);
        }
        #assert(!args.IsEmpty());
        const string& executablePath = args.Front();
        FileSystem* rootFS = GetMountTable().GetFileSystem(0);
        INode* inode = rootFS->GetINodeManager()->PathToINode(process, executablePath);
        if (inode == null)
        {
            throw SystemError(ENOENT, "executable '" + executablePath + "' not found");
        }
        INodePutter putter(inode);
        if (inode->Type() != FileType.regular)
        {
            throw SystemError(EINVAL, "path '" + executablePath + "' does not denote a regular file");
        }
        try
        {
            inode->CheckPermissions(process->uid, process->gid, Access.execute);
        }
        catch (const Exception& ex)
        {
            throw FileSystemException("cannot execute '" + executablePath + "' using uid " + ToString(process->uid) + ": " + ex.Message());
        }
        Section poolSection = MakePoolSection(args);
        long poolDataLength = poolSection.data.Count();
        long poolSize = Align(poolDataLength, cast<long>(pageSize));
        ulong poolSegmentSize = cast<ulong>(poolSize);
        INodeKey executableINodeKey = inode->Key();
        Process* prevProcess = processTable.GetProcessFromExecutableINodeProcessMap(executableINodeKey);
        ExecutableFile* executable = null;
        if (prevProcess != null)
        {
            SharedPtr<ByteStream> memoryStream = ReadFirstBlockIntoMemoryStream(inode);
            BinaryReader reader(memoryStream);
            UniquePtr<BinaryFile> binaryFile = ReadBinaryFile(reader, executablePath, ReadOption.readHeadersOnly);
            if (binaryFile.Get() is ExecutableFile*)
            {
                executable = cast<ExecutableFile*>(binaryFile.Get());
                Section* dataSection = executable->GetDataSection();
                if (dataSection->Length() > 0u)
                {
                    SharedPtr<ByteStream> dataSectionMemoryStream = ReadFilePortionIntoMemoryStream(inode, cast<long>(dataSection->fileOffset), cast<long>(dataSection->length));
                    BinaryReader dataSectionReader(dataSectionMemoryStream);
                    dataSection->Read(dataSectionReader);
                    WriteProcessMemory(machine, process, dataSection->BaseAddress(), dataSection->data.Begin().Ptr(), cast<ulong>(dataSection->data.Count()), Protection.write);
                }
            }
            else
            {
                throw SystemError(EINVAL, "file '" + executablePath + "' is not a CMSX executable");
            }
            FreeProcessMemory(machine.GetMemory(), process);
            InitializeMemoryTable(machine, process->memoryTable, prevProcess->memoryTable, poolSegmentSize);
        }
        else
        {
            SharedPtr<ByteStream> memoryStream = ReadFileIntoMemoryStream(inode);
            BinaryReader reader(memoryStream);
            UniquePtr<BinaryFile> binaryFile = ReadBinaryFile(reader, executablePath);
            if (binaryFile.Get() is ExecutableFile*)
            {
                executable = cast<ExecutableFile*>(binaryFile.Get());
                Section* codeSection = executable->GetCodeSection();
                Section* dataSection = executable->GetDataSection();
                ulong textSegmentStartAddress = codeSection->BaseAddress();
                if (textSegmentStartAddress == 0u)
                {
                    textSegmentStartAddress = textSegmentStartAddress + 4096u;
                }
                ulong textSegmentSize = codeSection->Length();
                ulong dataSegmentSize = dataSection->Length();
                ulong minStackSegmentSize = cast<ulong>(executable->MinStackSize());
                ulong maxStackSegmentSize = cast<ulong>(executable->MaxStackSize());
                ulong stackSegmentIncrement = cast<ulong>(executable->StackSizeIncrement());
                FreeProcessMemory(machine.GetMemory(), process);
                InitializeProcessMemory(machine, process, textSegmentStartAddress, textSegmentSize, dataSegmentSize, poolSegmentSize, minStackSegmentSize, maxStackSegmentSize, stackSegmentIncrement);
                if (codeSection->Length() > 0u)
                {
                    WriteProcessMemory(machine, process, codeSection->BaseAddress(), codeSection->data.Begin().Ptr(), cast<ulong>(codeSection->data.Count()), Protection.execute);
                }
                if (dataSection->Length() > 0u)
                {
                    WriteProcessMemory(machine, process, dataSection->BaseAddress(), dataSection->data.Begin().Ptr(), cast<ulong>(dataSection->data.Count()), Protection.write);
                }
            }
            else
            {
                throw SystemError(EINVAL, "file '" + executablePath + "' is not a CMSX executable");
            }
        }
        process->fileTable.ReleaseFiles();
        InitializeFileTable(machine, process->fileTable);
        process->executableINodeKey = executableINodeKey;
        processTable.AddProcessToExecutableINodeProcessMap(process);
        if (!poolSection.data.IsEmpty())
        {
            WriteProcessMemory(machine, process, poolSegmentBaseAddress, poolSection.data.Begin().Ptr(), cast<ulong>(poolSection.data.Count()), Protection.write);
            int ax = cast<int>(args.Count());
            ulong bx = poolSegmentBaseAddress;
            WriteProcessMemory(machine, process, process->regAXAddress, cast<ulong>(ax), 8u, Protection.write);
            WriteProcessMemory(machine, process, process->regBXAddress, bx, 8u, Protection.write);
        }
        ulong poolStart = poolSegmentBaseAddress + cast<ulong>(poolSize);
        ulong poolEnd = poolSegmentBaseAddress + cast<ulong>(poolSize);
        process->poolStart = poolStart;
        process->poolEnd = poolEnd;
        Symbol* functionTableSymbol = executable->GetSymbolTable().GetSymbol("@function_table");
        process->functionTableAddress = functionTableSymbol->start;
        process->functionTableLength = functionTableSymbol->length;
    }
}

using System;
using System.IO;
using cmsx.machine;

namespace cmsx.kernel
{
    public long Write(Machine& machine, Process* process, int fd, ulong bufferAddress, long count)
    {
        File* file = process->fileTable.GetFile(fd);
        if (count > 0)
        {
            UniquePtr<byte> buffer(cast<byte*>(RtMemAlloc(count)));
            ReadProcessMemory(machine, process, bufferAddress, buffer.Get(), cast<ulong>(count));
            return file->Write(buffer.Get(), count);
        }
        return 0;
    }

    public abstract class File
    {
        public nothrow File(const string& name_) : name(name_)
        {
        }
        public virtual long Write(byte* buffer, long count)
        {
            throw SystemError(EBADF, name + " not open for writing");
        }
        public virtual long Read(byte* buffer, long count)
        {
            throw SystemError(EBADF, name + " not open for reading");
        }
        public virtual File* Share()
        {
            return this;
        }
        public virtual void Release()
        {
        }
        public string name;
    }

    public class DebuggerOutputFile : File
    {
        public nothrow DebuggerOutputFile() : base("CONSOLE OUTPUT (DEBUGGER)")
        {
        }
        public override long Write(byte* buffer, long count)
        {
            try
            {
                Kernel& kernel = Kernel.Instance();
                Debugger* debugger = kernel.GetDebugger();
                debugger->WriteOutput(buffer, count);
                return count;
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
    }

    public class ConsoleOutputFile : File
    {
        public nothrow ConsoleOutputFile() : base("CONSOLE OUTPUT")
        {
        }
        public override long Write(byte* buffer, long count)
        {
            try
            {
                ByteStream* stream = Console.Out().ContainedStream().Get();
                stream->Write(buffer, count);
                return count;
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
    }

    public const long openFileMax = 1024;

    public class ProcessFileTable
    {
        public void SetFile(int fd, File* file)
        {
            if (fd < 0)
            {
                throw SystemError(EBADF, "value negative");
            }
            else if (fd >= openFileMax)
            {
                throw SystemError(EBADF, "value exceeds max number of open files");
            }
            files[fd] = file;
        }
        public File* GetFile(int fd)
        {
            if (fd < 0)
            {
                throw SystemError(EBADF, "value negative");
            }
            else if (fd >= openFileMax)
            {
                throw SystemError(EBADF, "value exceeds max number of open files");
            }
            File* file = files[fd];
            if (file == null)
            {
                throw SystemError(EBADF, "file not open");
            }
            return file;
        }
        public void ShareFilesTo(ProcessFileTable& that)
        {
            for (long i = 0; i < openFileMax; ++i)
            {
                File* file = files[i];
                if (file != null)
                {
                    that.files[i] = file->Share();
                }
                else
                {
                    that.files[i] = null;
                }
            }
        }
        private File*[openFileMax] files;
    }

    public class GlobalFileTable
    {
        public nothrow inline File* GetDebuggerOutputFile()
        {
            return &debuggerOutputFile;
        }
        public nothrow inline File* GetConsoleOutputFile()
        {
            return &consoleOutputFile;
        }
        private DebuggerOutputFile debuggerOutputFile;
        private ConsoleOutputFile consoleOutputFile;
    }

    public void InitializeFileTable(Machine& machine, ProcessFileTable& fileTable)
    {
        Kernel& kernel = Kernel.Instance();
        GlobalFileTable& globalFileTable = kernel.FileTable();
        if (kernel.HasUserDebugger())
        {
            fileTable.SetFile(1, globalFileTable.GetDebuggerOutputFile());
            fileTable.SetFile(2, globalFileTable.GetDebuggerOutputFile());
        }
        else
        {
            fileTable.SetFile(1, globalFileTable.GetConsoleOutputFile());
            fileTable.SetFile(2, globalFileTable.GetConsoleOutputFile());
        }
    }
}

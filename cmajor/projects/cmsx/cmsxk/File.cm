using System;
using System.IO;
using cmsx.machine;

namespace cmsx.kernel
{
    public enum Origin : byte
    {
        seekSet, seekCur, seekEnd
    }

    public const long RESULT_BLOCKED = -2;

    public long Read(Machine& machine, Process* process, int fd, ulong bufferAddress, long count)
    {
        File* file = process->fileTable.GetFile(fd);
        if (count > 0)
        {
            return file->Read(machine, process, bufferAddress, count);
        }
        return 0;
    }

    public long Write(Machine& machine, Process* process, int fd, ulong bufferAddress, long count)
    {
        File* file = process->fileTable.GetFile(fd);
        if (count > 0)
        {
            return file->Write(machine, process, bufferAddress, count);
        }
        return 0;
    }

    public long Seek(Machine& machine, Process* process, int fd, long pos, Origin origin)
    {
        File* file = process->fileTable.GetFile(fd);
        return file->Seek(pos, origin);
    }

    public long Tell(Machine& machine, Process* process, int fd)
    {
        File* file = process->fileTable.GetFile(fd);
        return file->Tell();
    }

    public bool IsHostTextFile(Process* process, int fd)
    {
        File* file = process->fileTable.GetFile(fd);
        return file->IsHostTextFile();
    }

    public bool IsConsole(Process* process, int fd)
    {
        File* file = process->fileTable.GetFile(fd);
        return file->IsConsole();
    }

    public abstract class File
    {
        public nothrow File(const string& name_) : name(name_)
        {
        }
        public virtual long Write(Machine& machine, Process* writer, ulong bufferAddress, long count)
        {
            throw SystemError(EBADF, name + " not open for writing");
        }
        public virtual long Read(Machine& machine, Process* reader, ulong bufferAddress, long count)
        {
            throw SystemError(EBADF, name + " not open for reading");
        }
        public virtual long Seek(long pos, Origin origin)
        {
            throw SystemError(ENOTSUPPORTED, name + " does not support seek");
        }
        public virtual long Tell()
        {
            throw SystemError(ENOTSUPPORTED, name + " does not support tell");
        }
        public virtual File* Share()
        {
            return this;
        }
        public virtual void Release()
        {
        }
        public virtual bool IsHostTextFile() const
        {
            return false;
        }
        public virtual bool IsConsole() const
        {
            return false;
        }
        public string name;
    }

    public class DebuggerInputFile : File
    {
        public nothrow DebuggerInputFile() : base("CONSOLE INPUT (DEBUGGER)")
        {
        }
        public override long Read(Machine& machine, Process* reader, ulong bufferAddress, long count)
        {
            try
            {
                if (bufferedInput.IsEmpty())
                {
                    Kernel& kernel = Kernel.Instance();
                    Debugger* debugger = kernel.GetDebugger();
                    bufferedInput = debugger->ReadInputLine();
                    if (bufferedInput.IsEmpty())
                    {
                        if (debugger->Eof())
                        {
                            debugger->ResetEof();
                            return 0;
                        }
                    }
                }
                long n = Min(count, bufferedInput.Length());
                WriteProcessMemory(machine, reader, bufferAddress, cast<byte*>(cast<void*>(bufferedInput.Chars())), cast<ulong>(n), Protection.write);
                bufferedInput = bufferedInput.Substring(n);
                return n;
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
        public override bool IsConsole() const
        {
            return true;
        }
        private string bufferedInput;
    }

    public class DebuggerOutputFile : File
    {
        public nothrow DebuggerOutputFile() : base("CONSOLE OUTPUT (DEBUGGER)")
        {
        }
        public override long Write(Machine& machine, Process* writer, ulong bufferAddress, long count)
        {
            try
            {
                Kernel& kernel = Kernel.Instance();
                Debugger* debugger = kernel.GetDebugger();
                UniquePtr<byte> buffer(cast<byte*>(RtMemAlloc(count)));
                ReadProcessMemory(machine, writer, bufferAddress, buffer.Get(), cast<ulong>(count));
                debugger->WriteOutput(buffer.Get(), count);
                return count;
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
        public override bool IsConsole() const
        {
            return true;
        }
    }

    public class ConsoleInputFile : File
    {
        public nothrow ConsoleInputFile() : base("CONSOLE INPUT")
        {
        }
        public override long Read(Machine& machine, Process* reader, ulong bufferAddress, long count)
        {
            try
            {
                Kernel& kernel = Kernel.Instance();
                Session* session = kernel.CurrentSession();
                if (session->fgpid == reader->pid)
                {
                    if (bufferedInput.IsEmpty())
                    {
                        ConsoleDriver* consoleDriver = kernel.GetConsoleDriver();
                        if (consoleDriver->HasLine())
                        {
                            bufferedInput = consoleDriver->GetLine();
                        }
                        else if (consoleDriver->Eof())
                        {
                            consoleDriver->ResetEof();
                            return 0;
                        }
                        else
                        {
                            EnqueueReadRequest(reader, bufferAddress, count);
                            return RESULT_BLOCKED;
                        }
                    }
                    long n = Min(count, bufferedInput.Length());
                    WriteProcessMemory(machine, reader, bufferAddress, cast<byte*>(cast<void*>(bufferedInput.Chars())), cast<ulong>(n), Protection.write);
                    bufferedInput = bufferedInput.Substring(n);
                    return n;
                }
                else
                {
                    EnqueueReadRequest(reader, bufferAddress, count);
                    return RESULT_BLOCKED;
                }
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
        public override bool IsConsole() const
        {
            return true;
        }
        public nothrow inline bool HasBufferedInput() const
        {
            return !bufferedInput.IsEmpty();
        }
        public nothrow void SetBufferedInput(const string& line)
        {
            bufferedInput = line;
        }
        private void EnqueueReadRequest(Process* reader, ulong bufferAddress, long count)
        {
            SleepProcess(reader, consoleInputEvent, bufferAddress, cast<ulong>(count));
        }
        private string bufferedInput;
    }

    public class ConsoleOutputFile : File
    {
        public nothrow ConsoleOutputFile() : base("CONSOLE OUTPUT")
        {
        }
        public override long Write(Machine& machine, Process* writer, ulong bufferAddress, long count)
        {
            try
            {
                UniquePtr<byte> buffer(cast<byte*>(RtMemAlloc(count)));
                ReadProcessMemory(machine, writer, bufferAddress, buffer.Get(), cast<ulong>(count));
                Kernel& kernel = Kernel.Instance();
                ConsoleDriver* consoleDriver = kernel.GetConsoleDriver();
                consoleDriver->WriteToConsole(buffer.Get(), count);
                return count;
            }
            catch (const Exception& ex)
            {
                throw SystemError(EFAIL, ex.Message());
            }
            return -1;
        }
        public override bool IsConsole() const
        {
            return true;
        }
    }

    public const long openFileMax = 32;

    public class ProcessFileTable
    {
        public void SetFile(int fd, File* file)
        {
            if (fd < 0)
            {
                throw SystemError(EBADF, "value negative");
            }
            else if (fd >= openFileMax)
            {
                throw SystemError(EBADF, "value exceeds max number of open files");
            }
            files[fd] = file;
        }
        public File* GetFile(int fd)
        {
            if (fd < 0)
            {
                throw SystemError(EBADF, "value negative");
            }
            else if (fd >= openFileMax)
            {
                throw SystemError(EBADF, "value exceeds max number of open files");
            }
            File* file = files[fd];
            if (file == null)
            {
                throw SystemError(EBADF, "file not open");
            }
            return file;
        }
        public void ShareFilesTo(ProcessFileTable& that)
        {
            for (long i = 0; i < openFileMax; ++i)
            {
                File* file = files[i];
                if (file != null)
                {
                    that.files[i] = file->Share();
                }
                else
                {
                    that.files[i] = null;
                }
            }
        }
        public void ReleaseFiles()
        {
            for (long i = 0; i < openFileMax; ++i)
            {
                File* file = files[i];
                if (file != null)
                {
                    file->Release();
                    files[i] = null;
                }
            }
        }
        private File*[openFileMax] files;
    }

    public class GlobalFileTable
    {
        public nothrow inline DebuggerInputFile* GetDebuggerInputFile()
        {
            return &debuggerInputFile;
        }
        public nothrow inline DebuggerOutputFile* GetDebuggerOutputFile()
        {
            return &debuggerOutputFile;
        }
        public nothrow inline ConsoleInputFile* GetConsoleInputFile()
        {
            return &consoleInputFile;
        }
        public nothrow inline ConsoleOutputFile* GetConsoleOutputFile()
        {
            return &consoleOutputFile;
        }
        private DebuggerInputFile debuggerInputFile;
        private DebuggerOutputFile debuggerOutputFile;
        private ConsoleInputFile consoleInputFile;
        private ConsoleOutputFile consoleOutputFile;
    }

    public void InitializeFileTable(Machine& machine, ProcessFileTable& fileTable)
    {
        Kernel& kernel = Kernel.Instance();
        GlobalFileTable& globalFileTable = kernel.FileTable();
        if (kernel.HasUserDebugger())
        {
            fileTable.SetFile(0, globalFileTable.GetDebuggerInputFile());
            fileTable.SetFile(1, globalFileTable.GetDebuggerOutputFile());
            fileTable.SetFile(2, globalFileTable.GetDebuggerOutputFile());
        }
        else
        {
            fileTable.SetFile(0, globalFileTable.GetConsoleInputFile());
            fileTable.SetFile(1, globalFileTable.GetConsoleOutputFile());
            fileTable.SetFile(2, globalFileTable.GetConsoleOutputFile());
        }
    }
}

using System;
using cmsx.machine;

namespace cmsx.kernel
{
    public const byte sys_exit = 0u;
    public const byte sys_wait = 1u;
    public const byte sys_fork = 2u;
    public const byte sys_create = 3u;
    public const byte sys_open = 4u;
    public const byte sys_close = 5u;
    public const byte sys_read = 6u;
    public const byte sys_write = 7u;
    public const byte sys_seek = 8u;
    public const byte sys_tell = 9u;
    public const byte sys_pool_end = 10u;
    public const byte sys_set_pool_end = 11u;
    public const byte sys_debug_break = 12u;
    public const byte sys_stack_trace = 13u;
    public const byte sys_throw = 14u;
    public const byte sys_catch = 15u;
    public const byte sys_resume = 16u;
    public const byte sys_get_system_error = 17u;
    public const byte sys_get_current_time_point = 18u;
    public const byte sys_sleep = 19u;
    public const byte sys_get_current_date = 20u;
    public const byte sys_get_current_date_time = 21u;
    public const byte sys_pow = 22u;
    public const byte sys_is_host_text_file = 23u;
    public const byte sys_is_console = 24u;
    public const byte sys_get_random_seed = 25u;
    public const byte sys_link = 26u;
    public const byte sys_unlink = 27u;
    public const byte sys_mkdir = 28u;
    public const byte sys_opendir = 29u;
    public const byte sys_readdir = 30u;
    public const byte sys_closedir = 31u;
    public const byte sys_getcwd = 32u;
    public const byte sys_chdir = 33u;
    public const byte sys_stat = 34u;
    public const byte numSystemCalls = sys_stat + 1u;

    public nothrow string SystemCallName(byte systemCall)
    {
        switch (systemCall)
        {
            case sys_exit: return "sys_exit";
            case sys_wait: return "sys_wait";
            case sys_fork: return "sys_fork";
            case sys_create: return "sys_create";
            case sys_open: return "sys_open";
            case sys_close: return "sys_close";
            case sys_read: return "sys_read";
            case sys_write: return "sys_write";
            case sys_seek: return "sys_seek";
            case sys_tell: return "sys_tell";
            case sys_pool_end : return "sys_pool_end";
            case sys_set_pool_end: return "sys_set_pool_end";
            case sys_debug_break : return "sys_debug_break";
            case sys_stack_trace: return "sys_stack_trace";
            case sys_throw: return "sys_throw";
            case sys_catch: return "sys_catch";
            case sys_resume: return "sys_resume";
            case sys_get_system_error: return "sys_get_system_error";
            case sys_get_current_time_point: return "sys_get_current_time_point";
            case sys_sleep: return "sys_sleep";
            case sys_get_current_date: return "sys_get_current_date";
            case sys_get_current_date_time: return "sys_get_current_date_time";
            case sys_pow: return "sys_pow";
            case sys_is_host_text_file: return "sys_is_host_text_file";
            case sys_is_console: return "sys_is_console";
            case sys_get_random_seed: return "sys_get_random_seed";
            case sys_link: return "sys_link";
            case sys_unlink: return "sys_unlink";
            case sys_mkdir: return "sys_mkdir";
            case sys_opendir: return "sys_opendir";
            case sys_readdir: return "sys_readdir";
            case sys_closedir: return "sys_closedir";
            case sys_getcwd: return "sys_getcwd";
            case sys_chdir: return "sys_chdir";
            case sys_stat: return "sys_stat";
        }
        return string();
    }

    public const uint debugBreakInst = (TRAP << 24u) | (0u << 16u) | (sys_debug_break << 8u) | (0u << 0u);

    public inline nothrow ulong MakeSystemCallPtrAddress(int systemCall)
    {
        return trapTableBaseAddress + cast<ulong>(systemCall) * 8u;
    }

    public class SystemCall
    {
        public nothrow SystemCall(Machine* machine_, Kernel* kernel_, ProcessTable* processTable_, Process* process_,
            SystemCallHandler handler_, byte x_, byte y_, byte z_, ulong ax_, ulong bx_, ulong cx_, ulong dx_, ulong ex_) :
            machine(machine_), kernel(kernel_), processTable(processTable_), process(process_),
            handler(handler_), x(x_), y(y_), z(z_), ax(ax_), bx(bx_), cx(cx_), dx(dx_), ex(ex_), result(0)
        {
        }
        public nothrow string ToString() const
        {
            string s;
            s.Append(SystemCallName(y)).Append(".ax=").Append(ToHexString(ax)).Append(".bx=").Append(ToHexString(bx)).Append(".cx=").Append(ToHexString(cx)).Append(".dx=");
            s.Append(ToHexString(dx)).Append(".ex=").Append(ToHexString(ex)).Append(".result=").Append(ToHexString(result));
            return s;
        }
        public nothrow bool IsDebugBreak() const
        {
            return x == 0u && y == sys_debug_break && z == 0u;
        }
        public Machine* machine;
        public Kernel* kernel;
        public ProcessTable* processTable;
        public Process* process;
        public SystemCallHandler handler;
        public byte x;
        public byte y;
        public byte z;
        public ulong ax;
        public ulong bx;
        public ulong cx;
        public ulong dx;
        public ulong ex;
        public long result;
    }

    public delegate void SystemCallHandler(SystemCall& sc);

    public void SystemCallFiber(void* processParam)
    {
        Process* process = cast<Process*>(processParam);
        while (true)
        {
            try
            {
                process->systemCallReady = false;
                const SystemCall& sc = process->systemCall;
                if (Log())
                {
                    LogMessage("sc.begin", sc.ToString());
                }
                SystemCallHandler handler = sc.handler;
                handler(sc);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                process->systemCall.result = -1;
                string s = SystemCallName(process->systemCall.y);
                s.Append(" failed\n");
                Kernel& kernel = GetKernel();
                Debugger* debugger = kernel.GetDebugger();
                debugger->WriteOutput(cast<byte*>(cast<void*>(s.Chars())), s.Length());
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "system call failed: " + ex.ToString());
                process->systemCall.result = -1;
            }
            if (Log())
            {
                string msg = process->systemCall.ToString();
                if (process->systemCall.result == -1)
                {
                    msg.Append(".error=").Append(process->lastError.ToString());
                }
                LogMessage("sc.end", msg);
            }
            process->systemCallReady = true;
            process->mode = Process.Mode.runningUser;
            OsSwitchToFiber(mainFiber);
        }
    }

    public void Exit(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_exit || sc.z != 0u)
        {
            Panic("invalid exit parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ushort exitCode = MakeProcessExitCode(0u, cast<byte>(sc.ax));
        ExitProcess(*sc.machine, *sc.processTable, sc.process, exitCode);
        if (Machine.GetFlag(Machine.Flags.runProgram) && sc.process->pid == sc.kernel->GetProgramPID())
        {
            sc.machine->GetProcessor().Exit();
        }
        Debugger* debugger = sc.kernel->GetDebugger();
        debugger->Exit(sc.process);
    }

    public void Wait(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_wait || sc.z != 0u)
        {
            Panic("invalid wait parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int retval = WaitProcess(*sc.machine, *sc.processTable, sc.process, sc.ax);
        sc.result = retval;
    }

    public void Fork(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_fork || sc.z != 0u)
        {
            Panic("invalid fork parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int retval = ForkProcess(*sc.machine, *sc.processTable, sc.process);
        sc.result = retval;
    }

    public void Create(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_create || sc.z != 0u)
        {
            Panic("invalid create parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = Create(*sc.machine, sc.process, cast<ulong>(sc.ax), cast<int>(sc.bx));
    }

    public void Open(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_open || sc.z != 0u)
        {
            Panic("invalid open parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = Open(*sc.machine, sc.process, cast<ulong>(sc.ax), cast<OpenFlags>(cast<int>(sc.bx)), cast<int>(sc.cx));
    }

    public void Close(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_close || sc.z != 0u)
        {
            Panic("invalid close parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Close(*sc.machine, sc.process, cast<int>(sc.ax));
        sc.result = 0;
    }

    public void Read(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_read || sc.z != 0u)
        {
            Panic("invalid read parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        long retval = Read(*sc.machine, sc.process, cast<int>(sc.ax), sc.bx, cast<long>(sc.cx));
        sc.result = retval;
    }

    public void Write(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_write || sc.z != 0u)
        {
            Panic("invalid write parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        long retval = Write(*sc.machine, sc.process, cast<int>(sc.ax), sc.bx, cast<long>(sc.cx));
        sc.result = retval;
    }

    public void Seek(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_seek || sc.z != 0u)
        {
            Panic("invalid seek parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int fd = cast<int>(sc.ax);
        long pos = cast<long>(sc.bx);
        Origin origin = cast<Origin>(cast<byte>(sc.cx));
        long retval = Seek(*sc.machine, sc.process, fd, pos, origin);
        sc.result = retval;
    }

    public void Tell(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_seek || sc.z != 0u)
        {
            Panic("invalid tell parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int fd = cast<int>(sc.ax);
        long retval = Tell(*sc.machine, sc.process, fd);
        sc.result = retval;
    }

    public void PoolEnd(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_pool_end || sc.z != 0u)
        {
            Panic("invalid pool_end parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        long retval = cast<long>(sc.process->poolEnd);
        sc.result = retval;
    }

    public void SetPoolEnd(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_set_pool_end || sc.z != 0u)
        {
            Panic("invalid set_pool_end parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = SetPoolEndProcess(*sc.machine, sc.process, sc.ax);
    }

    public void DebugBreak(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_debug_break || sc.z != 0u)
        {
            Panic("invalid debug break parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Debugger* debugger = sc.kernel->GetDebugger();
        debugger->Run(sc.process);
    }

    public void StackTrace(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_stack_trace || sc.z != 0u)
        {
            Panic("invalid stack trace parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong fp = sc.machine->GetRegisters().Get(regFP);
        ulong buffer = sc.ax;
        long count = cast<long>(sc.bx);
        GetProcessStackTrace(*sc.machine, sc.process, fp, buffer, count);
        sc.result = 0;
    }

    public void Throw(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_throw || sc.z != 0u)
        {
            Panic("invalid throw parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong exceptionAddress = sc.ax;
        ulong exceptionClassId = sc.bx;
        ulong fp = sc.machine->GetRegisters().Get(regFP);
        sc.process->currentExceptionAddress = exceptionAddress;
        sc.process->currentExceptionClassId = exceptionClassId;
        DispatchException(*sc.machine, sc.process, fp);
        sc.result = 0;
    }

    public void Catch(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_catch || sc.z != 0u)
        {
            Panic("invalid catch parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong exceptionAddress = sc.process->currentExceptionAddress;
        sc.result = cast<long>(exceptionAddress); 
    }

    public void Resume(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_resume || sc.z != 0u)
        {
            Panic("invalid resume parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong fp = sc.machine->GetRegisters().Get(regFP);
        ContinueExceptionDispatch(*sc.machine, sc.process, fp);
        sc.result = 0;
    }

    public void GetSystemError(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_get_system_error || sc.z != 0u)
        {
            Panic("invalid get_system_error parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong errorCodeAddress = sc.ax;
        ulong bufferAddress = sc.bx;
        long count = cast<long>(sc.cx);
        GetProcessSystemError(*sc.machine, sc.process, errorCodeAddress, bufferAddress, count);
        sc.result = 0;
    }

    public void GetCurrentTimePoint(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_get_current_time_point || sc.z != 0u)
        {
            Panic("invalid get_current_time_point parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        long currentTimePoint = System.Now().Rep();
        sc.result = currentTimePoint;
    }

    public void Sleep(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_sleep || sc.z != 0u)
        {
            Panic("invalid sleep parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Duration sleepDuration(cast<long>(sc.ax));
        if (sleepDuration.Rep() < 0)
        {
            throw SystemError(EINVAL, "invalid sleep duration");
        }
        TimePoint dueTime = System.Now() + sleepDuration;
        SleepProcess(sc.process, wakeupEvent, cast<ulong>(dueTime.Rep()), 0u);
        SleepingProcessQueue.Instance().AddProcess(sc.process);
        sc.result = 0;
    }

    public void GetCurrentDate(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_get_current_date || sc.z != 0u)
        {
            Panic("invalid get_current_date parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong yearAddress = sc.ax;
        ulong monthAddress = sc.bx;
        ulong dayAddress = sc.cx;
        if (yearAddress == 0u)
        {
            throw SystemError(EINVAL, "year pointer is null");
        }
        else if (monthAddress == 0u)
        {
            throw SystemError(EINVAL, "month pointer is null");
        }
        else if (dayAddress == 0u)
        {
            throw SystemError(EINVAL, "day pointer is null");
        }
        Date date = System.GetCurrentDate();
        short year = date.Year();
        sbyte month = date.GetMonth();
        sbyte day = date.Day();
        WriteProcessMemory(*sc.machine, sc.process, yearAddress, cast<ulong>(year), 2u, Protection.write);
        WriteProcessMemory(*sc.machine, sc.process, monthAddress, cast<ulong>(month), 1u, Protection.write);
        WriteProcessMemory(*sc.machine, sc.process, dayAddress, cast<ulong>(day), 1u, Protection.write);
    }

    public void GetCurrentDateTime(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_get_current_date_time || sc.z != 0u)
        {
            Panic("invalid get_current_date_time parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ulong yearAddress = sc.ax;
        ulong monthAddress = sc.bx;
        ulong dayAddress = sc.cx;
        ulong secsAddress = sc.dx;
        if (yearAddress == 0u)
        {
            throw SystemError(EINVAL, "year pointer is null");
        }
        else if (monthAddress == 0u)
        {
            throw SystemError(EINVAL, "month pointer is null");
        }
        else if (dayAddress == 0u)
        {
            throw SystemError(EINVAL, "day pointer is null");
        }
        else if (secsAddress == 0u)
        {
            throw SystemError(EINVAL, "secs pointer is null");
        }
        DateTime dateTime = GetCurrentDateTime();
        Date date = dateTime.GetDate();
        short year = date.Year();
        sbyte month = date.GetMonth();
        sbyte day = date.Day();
        int secs = dateTime.Seconds();
        WriteProcessMemory(*sc.machine, sc.process, yearAddress, cast<ulong>(year), 2u, Protection.write);
        WriteProcessMemory(*sc.machine, sc.process, monthAddress, cast<ulong>(month), 1u, Protection.write);
        WriteProcessMemory(*sc.machine, sc.process, dayAddress, cast<ulong>(day), 1u, Protection.write);
        WriteProcessMemory(*sc.machine, sc.process, secsAddress, cast<ulong>(secs), 4u, Protection.write);
    }

    public void Pow(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_pow || sc.z != 0u)
        {
            Panic("invalid pow parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        double x = *cast<double*>(cast<void*>(&sc.ax));
        double y = *cast<double*>(cast<void*>(&sc.bx));
        double r = Pow(x, y);
        sc.result = *cast<long*>(cast<void*>(&r));
    }

    public void IsHostTextFile(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_is_host_text_file || sc.z != 0u)
        {
            Panic("invalid is_host_text_file parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int fd = cast<int>(sc.ax);
        if (IsHostTextFile(sc.process, fd))
        {
            sc.result = 1;
        }
        else
        {
            sc.result = 0;
        }
    }

    public void IsConsole(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_is_console || sc.z != 0u)
        {
            Panic("invalid is_console parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        int fd = cast<int>(sc.ax);
        if (IsConsole(sc.process, fd))
        {
            sc.result = 1;
        }
        else
        {
            sc.result = 0;
        }
    }

    public void GetRandomSeed(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_get_random_seed || sc.z != 0u)
        {
            Panic("invalid get_random_seed parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = RtGetRandomSeed();
    }

    public void Link(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_link || sc.z != 0u)
        {
            Panic("invalid link parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Link(*sc.machine, sc.process, sc.ax, sc.bx);
    }

    public void Unlink(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_unlink || sc.z != 0u)
        {
            Panic("invalid unlink parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Unlink(*sc.machine, sc.process, sc.ax);
        sc.result = 0;
    }

    public void Mkdir(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_mkdir || sc.z != 0u)
        {
            Panic("invalid mkdir parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Mkdir(*sc.machine, sc.process, sc.ax);
    }

    public void OpenDir(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_opendir || sc.z != 0u)
        {
            Panic("invalid opendir parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = OpenDir(*sc.machine, sc.process, sc.ax);
    }

    public void ReadDir(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_readdir || sc.z != 0u)
        {
            Panic("invalid readdir parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        sc.result = ReadDir(*sc.machine, sc.process, cast<int>(sc.ax), sc.bx, sc.cx);
    }

    public void CloseDir(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_closedir || sc.z != 0u)
        {
            Panic("invalid closedir parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        CloseDir(*sc.machine, sc.process, cast<int>(sc.ax));
        sc.result = 0;
    }

    public void GetCWD(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_getcwd || sc.z != 0u)
        {
            Panic("invalid getcwd parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        GetCWD(*sc.machine, sc.process, sc.ax, cast<long>(sc.bx));
        sc.result = 0;
    }

    public void ChDir(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_chdir || sc.z != 0u)
        {
            Panic("invalid chdir parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        ChDir(*sc.machine, sc.process, sc.ax);
        sc.result = 0;
    }

    public void Stat(SystemCall& sc)
    {
        if (sc.x != 0u || sc.y != sys_stat || sc.z != 0u)
        {
            Panic("invalid stat parameters: " + ToString(sc.x) + ", " + ToString(sc.y) + ", " + ToString(sc.z));
        }
        Stat(*sc.machine, sc.process, sc.ax, sc.bx);
        sc.result = 0;
    }
}

using System;
using cmsx.machine;

namespace cmsx.kernel
{
    public const byte exitSystemCall = 0u;
    public const byte waitSystemCall = 1u;
    public const byte forkSystemCall = 2u;
    public const byte writeSystemCall = 3u;
    public const byte poolEndSystemCall = 4u;
    public const byte setPoolEndSystemCall = 5u;
    public const byte debugBreakSystemCall = 6u;
    public const byte stackTraceSystemCall = 7u;
    public const byte throwSystemCall = 8u;
    public const byte catchSystemCall = 9u;
    public const byte resumeSystemCall = 10u;
    public const byte numSystemCalls = 11u;

    public const uint debugBreakInst = (TRAP << 24u) | (0u << 16u) | (debugBreakSystemCall << 8u) | (0u << 0u);

    public delegate long TrapHandler(Machine& machine, byte trapX, byte trapY, byte trapZ, ulong trapAX, ulong trapBX, ulong trapCX, ulong trapDX, ulong trapEX);

    public inline nothrow ulong MakeSystemCallPtrAddress(int systemCall)
    {
        return trapTableBaseAddress + cast<ulong>(systemCall) * 8u;
    }

    public long Exit(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != exitSystemCall || z != 0u)
        {
            Panic("invalid exit parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ushort exitCode = MakeProcessExitCode(0u, cast<byte>(ax));
            try
            {
                ExitProcess(machine, processTable, process, exitCode);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "exit failed: " + ex.ToString());
                return -1;
            }
            if (Machine.GetFlag(Machine.Flags.runProgram) && process->pid == kernel.GetProgramPID())
            {
                machine.GetProcessor().Exit();
            }
            Debugger* debugger = kernel.GetDebugger();
            debugger->Exit(process);
            return 0;
        }
        else
        {
            Panic("exit called for a process that is not running!");
        }
        return 0;
    }

    public long Wait(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != waitSystemCall || z != 0u)
        {
            Panic("invalid wait parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int retval = WaitProcess(machine, processTable, process, ax);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "wait failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("wait called for a process that is not running!");
        }
        return 0;
    }

    public long Fork(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != forkSystemCall || z != 0u)
        {
            Panic("invalid fork parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int retval = ForkProcess(machine, processTable, process);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "fork failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("fork called for a process that is not running!");
        }
        return 0;
    }

    public long Write(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != writeSystemCall || z != 0u)
        {
            Panic("invalid write parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                long retval = Write(machine, process, cast<int>(ax), bx, cast<long>(cx));
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "write failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("write called for a process that is not running!");
        }
        return 0;
    }

    public long PoolEnd(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != poolEndSystemCall || z != 0u)
        {
            Panic("invalid pool_end parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            long retval = cast<long>(process->poolEnd);
            return retval;
        }
        else
        {
            Panic("pool_end called for a process that is not running!");
        }
        return 0;
    }

    public long SetPoolEnd(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != setPoolEndSystemCall || z != 0u)
        {
            Panic("invalid set_pool_end parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                return SetPoolEndProcess(machine, process, ax);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "write failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("set_pool_end called for a process that is not running!");
        }
        return 0;
    }

    public long DebugBreak(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != debugBreakSystemCall || z != 0u)
        {
            Panic("invalid debug break parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            Debugger* debugger = kernel.GetDebugger();
            debugger->Run(process);
            return cast<long>(machine.GetRegisters().Get(regAX));
        }
        else
        {
            Panic("debug break called for a process that is not running!");
        }
        return 0;
    }

    public long StackTrace(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != stackTraceSystemCall || z != 0u)
        {
            Panic("invalid stack trace parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong fp = machine.GetRegisters().Get(regFP);
            ulong buffer = ax;
            long count = cast<long>(bx);
            try
            {
                GetProcessStackTrace(machine, process, fp, buffer, count);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "stacktrace failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("stack trace called for a process that is not running!");
        }
        return 0;
    }

    public long Throw(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != throwSystemCall || z != 0u)
        {
            Panic("invalid throw parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong exceptionAddress = ax;
            ulong exceptionClassId = bx;
            ulong fp = machine.GetRegisters().Get(regFP);
            process->currentExceptionAddress = exceptionAddress;
            process->currentExceptionClassId = exceptionClassId;
            try
            {
                DispatchException(machine, process, fp);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "throw failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("throw called for a process that is not running!");
        }
        return 0;
    }

    public long Catch(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != catchSystemCall || z != 0u)
        {
            Panic("invalid catch parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong exceptionAddress = process->currentExceptionAddress;
            return cast<long>(exceptionAddress); 
        }
        else
        {
            Panic("catch called for a process that is not running!");
        }
        return 0;
    }

    public long Resume(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != resumeSystemCall || z != 0u)
        {
            Panic("invalid resume parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong fp = machine.GetRegisters().Get(regFP);
            try
            {
                ContinueExceptionDispatch(machine, process, fp);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "resume failed: " + ex.ToString());
                return -1;
            }
            return 0;
        }
        else
        {
            Panic("resume called for a process that is not running!");
        }
        return 0;
    }
}

using System;
using cmsx.machine;

namespace cmsx.kernel
{
    public const byte sys_exit = 0u;
    public const byte sys_wait = 1u;
    public const byte sys_fork = 2u;
    public const byte sys_create = 3u;
    public const byte sys_open = 4u;
    public const byte sys_close = 5u;
    public const byte sys_read = 6u;
    public const byte sys_write = 7u;
    public const byte sys_seek = 8u;
    public const byte sys_tell = 9u;
    public const byte sys_pool_end = 10u;
    public const byte sys_set_pool_end = 11u;
    public const byte sys_debug_break = 12u;
    public const byte sys_stack_trace = 13u;
    public const byte sys_throw = 14u;
    public const byte sys_catch = 15u;
    public const byte sys_resume = 16u;
    public const byte sys_get_system_error = 17u;
    public const byte sys_get_current_time_point = 18u;
    public const byte sys_sleep = 19u;
    public const byte sys_get_current_date = 20u;
    public const byte sys_get_current_date_time = 21u;
    public const byte sys_pow = 22u;
    public const byte sys_is_host_text_file = 23u;
    public const byte sys_is_console = 24u;
    public const byte sys_get_random_seed = 25u;
    public const byte numSystemCalls = sys_get_random_seed + 1u;

    public const uint debugBreakInst = (TRAP << 24u) | (0u << 16u) | (sys_debug_break << 8u) | (0u << 0u);

    public delegate long TrapHandler(Machine& machine, byte trapX, byte trapY, byte trapZ, ulong trapAX, ulong trapBX, ulong trapCX, ulong trapDX, ulong trapEX);

    public inline nothrow ulong MakeSystemCallPtrAddress(int systemCall)
    {
        return trapTableBaseAddress + cast<ulong>(systemCall) * 8u;
    }

    public long Exit(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_exit || z != 0u)
        {
            Panic("invalid exit parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ushort exitCode = MakeProcessExitCode(0u, cast<byte>(ax));
            try
            {
                ExitProcess(machine, processTable, process, exitCode);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "exit failed: " + ex.ToString());
                return -1;
            }
            if (Machine.GetFlag(Machine.Flags.runProgram) && process->pid == kernel.GetProgramPID())
            {
                machine.GetProcessor().Exit();
            }
            Debugger* debugger = kernel.GetDebugger();
            debugger->Exit(process);
            return 0;
        }
        else
        {
            Panic("exit called for a process that is not running!");
        }
        return 0;
    }

    public long Wait(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_wait || z != 0u)
        {
            Panic("invalid wait parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int retval = WaitProcess(machine, processTable, process, ax);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "wait failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("wait called for a process that is not running!");
        }
        return 0;
    }

    public long Fork(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_fork || z != 0u)
        {
            Panic("invalid fork parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int retval = ForkProcess(machine, processTable, process);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "fork failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("fork called for a process that is not running!");
        }
        return 0;
    }

    public long Create(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_create || z != 0u)
        {
            Panic("invalid create parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                throw SystemError(ENOTSUPPORTED, "not implemented yet");
                int retval = 0; // todo
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "create failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("create called for a process that is not running!");
        }
        return 0;
    }

    public long Open(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_open || z != 0u)
        {
            Panic("invalid open parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                throw SystemError(ENOTSUPPORTED, "not implemented yet");
                int retval = 0; // todo
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "open failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("open called for a process that is not running!");
        }
        return 0;
    }

    public long Close(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_close || z != 0u)
        {
            Panic("invalid close parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                throw SystemError(ENOTSUPPORTED, "not implemented yet");
                int retval = 0; // todo
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "close failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("close called for a process that is not running!");
        }
        return 0;
    }

    public long Read(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_read || z != 0u)
        {
            Panic("invalid read parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                long retval = Read(machine, process, cast<int>(ax), bx, cast<long>(cx));
                if (retval == RESULT_BLOCKED)
                {
                    Schedule(machine, processTable);
                    return 0;
                }
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "read failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("read called for a process that is not running!");
        }
        return 0;
    }

    public long Write(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_write || z != 0u)
        {
            Panic("invalid write parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                long retval = Write(machine, process, cast<int>(ax), bx, cast<long>(cx));
                if (retval == RESULT_BLOCKED)
                {
                    Schedule(machine, processTable);
                    return 0;
                }
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "write failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("write called for a process that is not running!");
        }
        return 0;
    }

    public long Seek(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_seek || z != 0u)
        {
            Panic("invalid seek parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int fd = cast<int>(ax);
                long pos = cast<long>(bx);
                Origin origin = cast<Origin>(cast<byte>(cx));
                long retval = Seek(machine, process, fd, pos, origin);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "seek failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("seek called for a process that is not running!");
        }
        return 0;
    }

    public long Tell(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_seek || z != 0u)
        {
            Panic("invalid tell parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int fd = cast<int>(ax);
                long retval = Tell(machine, process, fd);
                return retval;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "tell failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("tell called for a process that is not running!");
        }
        return 0;
    }

    public long PoolEnd(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_pool_end || z != 0u)
        {
            Panic("invalid pool_end parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            long retval = cast<long>(process->poolEnd);
            return retval;
        }
        else
        {
            Panic("pool_end called for a process that is not running!");
        }
        return 0;
    }

    public long SetPoolEnd(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_set_pool_end || z != 0u)
        {
            Panic("invalid set_pool_end parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                return SetPoolEndProcess(machine, process, ax);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "set_pool_end failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("set_pool_end called for a process that is not running!");
        }
        return 0;
    }

    public long DebugBreak(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_debug_break || z != 0u)
        {
            Panic("invalid debug break parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            Debugger* debugger = kernel.GetDebugger();
            debugger->Run(process);
            return cast<long>(machine.GetRegisters().Get(regAX));
        }
        else
        {
            Panic("debug break called for a process that is not running!");
        }
        return 0;
    }

    public long StackTrace(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_stack_trace || z != 0u)
        {
            Panic("invalid stack trace parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong fp = machine.GetRegisters().Get(regFP);
            ulong buffer = ax;
            long count = cast<long>(bx);
            try
            {
                GetProcessStackTrace(machine, process, fp, buffer, count);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "stack_trace failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("stack trace called for a process that is not running!");
        }
        return 0;
    }

    public long Throw(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_throw || z != 0u)
        {
            Panic("invalid throw parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong exceptionAddress = ax;
            ulong exceptionClassId = bx;
            ulong fp = machine.GetRegisters().Get(regFP);
            process->currentExceptionAddress = exceptionAddress;
            process->currentExceptionClassId = exceptionClassId;
            try
            {
                DispatchException(machine, process, fp);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "throw failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("throw called for a process that is not running!");
        }
        return 0;
    }

    public long Catch(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_catch || z != 0u)
        {
            Panic("invalid catch parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong exceptionAddress = process->currentExceptionAddress;
            return cast<long>(exceptionAddress); 
        }
        else
        {
            Panic("catch called for a process that is not running!");
        }
        return 0;
    }

    public long Resume(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_resume || z != 0u)
        {
            Panic("invalid resume parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            ulong fp = machine.GetRegisters().Get(regFP);
            try
            {
                ContinueExceptionDispatch(machine, process, fp);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "resume failed: " + ex.ToString());
                return -1;
            }
            return 0;
        }
        else
        {
            Panic("resume called for a process that is not running!");
        }
        return 0;
    }

    public long GetSystemError(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_get_system_error || z != 0u)
        {
            Panic("invalid get_system_error parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                ulong errorCodeAddress = ax;
                ulong bufferAddress = bx;
                long count = cast<long>(cx);
                GetProcessSystemError(machine, process, errorCodeAddress, bufferAddress, count);
                return 0;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "get_system_error failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("get_system_error called for a process that is not running!");
        }
        return 0;
    }

    public long GetCurrentTimePoint(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_get_current_time_point || z != 0u)
        {
            Panic("invalid get_current_time_point parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        long currentTimePoint = System.Now().Rep();
        return currentTimePoint;
    }

    public long Sleep(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_sleep || z != 0u)
        {
            Panic("invalid sleep parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                throw SystemError(ENOTSUPPORTED, "not implemented yet");
                return 0;
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "sleep failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("sleep called for a process that is not running!");
        }
        return 0;
    }

    public long GetCurrentDate(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_get_current_date || z != 0u)
        {
            Panic("invalid get_current_date parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                ulong yearAddress = ax;
                ulong monthAddress = bx;
                ulong dayAddress = cx;
                if (yearAddress == 0u)
                {
                    throw SystemError(EINVAL, "year pointer is null");
                }
                else if (monthAddress == 0u)
                {
                    throw SystemError(EINVAL, "month pointer is null");
                }
                else if (dayAddress == 0u)
                {
                    throw SystemError(EINVAL, "day pointer is null");
                }
                Date date = System.GetCurrentDate();
                short year = date.Year();
                sbyte month = date.GetMonth();
                sbyte day = date.Day();
                WriteProcessMemory(machine, process, yearAddress, cast<ulong>(year), 2u, Protection.write);
                WriteProcessMemory(machine, process, monthAddress, cast<ulong>(month), 1u, Protection.write);
                WriteProcessMemory(machine, process, dayAddress, cast<ulong>(day), 1u, Protection.write);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "get_current_date failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("get_current_date called for a process that is not running!");
        }
        return 0;
    }

    public long GetCurrentDateTime(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_get_current_date_time || z != 0u)
        {
            Panic("invalid get_current_date_time parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                ulong yearAddress = ax;
                ulong monthAddress = bx;
                ulong dayAddress = cx;
                ulong secsAddress = dx;
                if (yearAddress == 0u)
                {
                    throw SystemError(EINVAL, "year pointer is null");
                }
                else if (monthAddress == 0u)
                {
                    throw SystemError(EINVAL, "month pointer is null");
                }
                else if (dayAddress == 0u)
                {
                    throw SystemError(EINVAL, "day pointer is null");
                }
                else if (secsAddress == 0u)
                {
                    throw SystemError(EINVAL, "secs pointer is null");
                }
                DateTime dateTime = GetCurrentDateTime();
                Date date = dateTime.GetDate();
                short year = date.Year();
                sbyte month = date.GetMonth();
                sbyte day = date.Day();
                int secs = dateTime.Seconds();
                WriteProcessMemory(machine, process, yearAddress, cast<ulong>(year), 2u, Protection.write);
                WriteProcessMemory(machine, process, monthAddress, cast<ulong>(month), 1u, Protection.write);
                WriteProcessMemory(machine, process, dayAddress, cast<ulong>(day), 1u, Protection.write);
                WriteProcessMemory(machine, process, secsAddress, cast<ulong>(secs), 4u, Protection.write);
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "get_current_date_time failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("get_current_date_time called for a process that is not running!");
        }
        return 0;
    }

    public long Pow(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_pow || z != 0u)
        {
            Panic("invalid pow parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        double x = *cast<double*>(cast<void*>(&ax));
        double y = *cast<double*>(cast<void*>(&bx));
        double r = Pow(x, y);
        long result = *cast<long*>(cast<void*>(&r));
        return result;
    }

    public long IsHostTextFile(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_is_host_text_file || z != 0u)
        {
            Panic("invalid is_host_text_file parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int fd = cast<int>(ax);
                if (IsHostTextFile(process, fd))
                {
                    return 1;
                }
                else
                {
                    return 0;
                }
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "is_host_text_file failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("is_host_text_file called for a process that is not running!");
        }
        return 0;
    }

    public long IsConsole(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_is_console || z != 0u)
        {
            Panic("invalid is_console parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                int fd = cast<int>(ax);
                if (IsConsole(process, fd))
                {
                    return 1;
                }
                else
                {
                    return 0;
                }
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "is_host_text_file failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("is_host_text_file called for a process that is not running!");
        }
        return 0;
    }

    public long GetRandomSeed(Machine& machine, byte x, byte y, byte z, ulong ax, ulong bx, ulong cx, ulong dx, ulong ex)
    {
        if (x != 0u || y != sys_get_random_seed || z != 0u)
        {
            Panic("invalid get_random_seed parameters: " + ToString(x) + ", " + ToString(y) + ", " + ToString(z));
        }
        Kernel& kernel = Kernel.Instance();
        ProcessTable& processTable = kernel.GetProcessTable();
        Process* process = processTable.GetRunning();
        if (process != null)
        {
            try
            {
                return RtGetRandomSeed();
            }
            catch (const SystemError& systemError)
            {
                process->lastError = systemError;
                return -1;
            }
            catch (const Exception& ex)
            {
                process->lastError = SystemError(EFAIL, "get_random_seed failed: " + ex.ToString());
                return -1;
            }
        }
        else
        {
            Panic("get_random_seed called for a process that is not running!");
        }
        return 0;
    }
}

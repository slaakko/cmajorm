using System;
using System.Collections;
using cmsx.machine;

namespace cmsx.kernel
{
    public class Kernel
    {
        static Kernel() : instance(new Kernel())
        {
        }
        public static nothrow Kernel& Instance()
        {
            return *instance;
        }
        private nothrow Kernel() : machine(GetMachine()), sessionTable(GetSessionTable()), processTable(GetProcessTable()), baseDebugger(), debugger(&baseDebugger)
        {
        }
        public void Init()
        {
            DefaultInitializeMemoryTable(machine, memoryTable);
            memoryTable.addressSpaceNumber = kernelAddressSpaceNumber;
        }
        public inline nothrow Machine& GetMachine()
        {
            return machine;
        }
        public inline nothrow SessionTable& GetSessionTable()
        {
            return sessionTable;
        }
        public inline nothrow ProcessTable& GetProcessTable()
        {
            return processTable;
        }
        public inline nothrow MemoryTable& GetMemoryTable()
        {
            return memoryTable;
        }
        public nothrow void SetProgramFileName(const string& programFileName_)
        {
            programFileName = programFileName_;
        }
        public nothrow void SetProgramArguments(const List<string>& programArguments_)
        {
            programArguments = programArguments_;
        }
        public nothrow const string& GetProgramFileName() const
        {
            return programFileName;
        }
        public nothrow const List<string>& GetProgramArguments() const
        {
            return programArguments;
        }
        public nothrow void SetProgramPID(int pid)
        {
            programPID = pid;
        }
        public nothrow int GetProgramPID()
        {
            return programPID;
        }
        public inline nothrow Debugger* GetDebugger()
        {
            return debugger;
        }
        public inline nothrow void SetDebugger(Debugger* debugger_)
        {
            debugger = debugger_;
        }
        public inline nothrow bool HasUserDebugger() const
        {
            return debugger != &baseDebugger;
        }
        public nothrow void SetExecutable(cmsx.object.ExecutableFile* executable_)
        {
            executable.Reset(executable_);
        }
        public nothrow cmsx.object.ExecutableFile* Executable() const
        {
            return executable.Get();
        }
        public nothrow GlobalFileTable& FileTable()
        {
            return globalFileTable;
        }
        public nothrow void SetCurrentSession(Session* currentSession_)
        {
            currentSession = currentSession_;
        }
        public nothrow Session* CurrentSession() const
        {
            return currentSession;
        }
        private static UniquePtr<Kernel> instance;
        private Machine& machine;
        private SessionTable& sessionTable;
        private ProcessTable& processTable;
        private MemoryTable memoryTable;
        private string programFileName;
        private List<string> programArguments;
        private int programPID;
        private Debugger baseDebugger;
        private Debugger* debugger;
        private UniquePtr<cmsx.object.ExecutableFile> executable;
        private GlobalFileTable globalFileTable;
        private Session* currentSession;
    }
}

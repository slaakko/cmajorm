using System;
using System.Collections;
using cmsx.util;

namespace cmsx.kernel
{
    public const int blockSize = 4096;
    public const int numBitsInBitmapBlock = blockSize * 8;
    public const int numULongsInBitmapBlock = blockSize / 8;
    public const int numBlockNumbersInBlock = blockSize / 4;
    public const int invalidBlockNumber = 0;
    public const int maxCachedSuperBlocks = 16;
    public const int maxCachedBitmapBlocks = 16;
    public const int maxCachedINodeBlocks = 16;
    public const int maxCachedBlockNumberBlocks = 16;
    public const int maxCachedFileBlocks = 128;
    public const int maxCachedDirectoryBlocks = 64;
    public const int nameMax = 252;

    public enum BlockKind : byte
    {
        superBlock, bitmapBlock, inodeBlock, blockNumberBlock, fileBlock, directoryBlock
    }

    public nothrow string BlockKindStr(BlockKind kind)
    {
        switch (kind)
        {
            case BlockKind.superBlock: return "super";
            case BlockKind.bitmapBlock: return "bitmap";
            case BlockKind.inodeBlock: return "inode";
            case BlockKind.blockNumberBlock: return "blocknum";
            case BlockKind.fileBlock: return "file";
            case BlockKind.directoryBlock: return "dir";
        }
        return string();
    }

    public class BlockKey
    {
        public nothrow BlockKey(int blockNumber_, int fsNumber_, BlockKind kind_) : blockNumber(blockNumber_), fsNumber(fsNumber_), kind(kind_)
        {
        }
        public nothrow string ToString() const
        {
            string s;
            s.Append("block.").Append(BlockKindStr(kind)).Append('.').Append(ToString(fsNumber)).Append('.').Append(ToString(blockNumber));
            return s;
        }
        public int blockNumber;
        public int fsNumber;
        public BlockKind kind;
    }

    public nothrow bool operator==(const BlockKey& left, const BlockKey& right)
    {
        return left.blockNumber == right.blockNumber && left.fsNumber == right.fsNumber && left.kind == right.kind;
    }

    public class BlockKeyHash : UnaryFun<BlockKey, ulong>
    {
        public nothrow inline ulong operator()(const BlockKey& key) const
        {
            return cast<ulong>(1099511628211 * key.fsNumber + 16777619 * cast<byte>(key.kind) + key.blockNumber);
        }
    }

    public abstract class Block
    {
        public enum Flags : byte
        {
            none = 0u,
            locked = 1u << 0u,
            valid = 1u << 1u,
            dirty = 1u << 2u,
            old = 1u << 3u
        }
        public nothrow string BlockFlagStr(Flags flags)
        {
            string s = "flags";
            if ((flags & Flags.locked) != Flags.none)
            {
                s.Append(".locked");
            }
            if ((flags & Flags.valid) != Flags.none)
            {
                s.Append(".valid");
            }
            if ((flags & Flags.dirty) != Flags.none)
            {
                s.Append(".dirty");
            }
            if ((flags & Flags.old) != Flags.none)
            {
                s.Append(".old");
            }
            return s;
        }
        public nothrow Block(const BlockKey& key_, BlockManager* manager_, BlockCache* cache_) : key(key_), manager(manager_), cache(cache_), flags(Flags.none), iterator(), owner(null)
        {
        }
        public nothrow inline Process* Owner() const
        {
            return owner;
        }
        public nothrow inline void SetOwner(Process* owner_)
        {
            owner = owner_;
        }
        public nothrow inline void ResetOwner()
        {
            owner = null;
        }
        public default virtual ~Block();
        public nothrow string ToString() const
        {
            string s;
            s.Append(key.ToString());
            s.Append('.').Append(BlockFlagStr(flags));
            return s;
        }
        public virtual void Read(MemoryReader& reader)
        {
        }
        public virtual void Write(MemoryWriter& writer)
        {
            ResetFlag(Flags.dirty);
        }
        public virtual nothrow void Clear()
        {
            SetFlag(Flags.dirty);
        }
        public nothrow inline bool GetFlag(Flags flag) const
        {
            return (flags & flag) != Flags.none;
        }
        public nothrow inline void SetFlag(Flags flag)
        {
            flags = cast<Flags>(flags | flag);
            if (flag == Flags.dirty)
            {
                cache->AddDirtyBlock(this);
            }
        }
        public nothrow inline void ResetFlag(Flags flag)
        {
            flags = cast<Flags>(flags & ~flag);
        }
        public nothrow inline void ResetFlags()
        {
            flags = Flags.none;
        }
        public nothrow inline BlockKey& Key() const
        {
            return key;
        }
        public nothrow void SetKey(const BlockKey& key_)
        {
            key = key_;
        }
        public void AddWaitingProcess(Process* process)
        {
            waitingProcesses.Add(process);
        }
        public nothrow List<Process*> GetWaitingProcesses()
        {
            List<Process*> processes;
            Swap(processes, waitingProcesses);
            return processes;
        }
        public nothrow LinkedList<Block*>.Iterator GetIterator() const
        {
            return iterator;
        }
        public nothrow void SetIterator(LinkedList<Block*>.Iterator iterator_)
        {
            iterator = iterator_;
        }
        public nothrow inline BlockManager* Manager()
        {
            return manager;
        }
        private BlockKey key;
        private BlockManager* manager;
        private BlockCache* cache;
        private Flags flags;
        private List<Process*> waitingProcesses;
        private LinkedList<Block*>.Iterator iterator;
        private Process* owner;
    }

    public class SuperBlock : Block
    {
        public nothrow SuperBlock(BlockManager* manager_, BlockCache* cache_) :
            base(BlockKey(0, 0, BlockKind.superBlock), manager_, cache_), 
            firstINodeBitmapBlockNumber(0), numINodeBitmapBlocks(0), firstBlockBitmapBlockNumber(0), numBlockBitmapBlocks(0), firstINodeBlockNumber(0), numINodeBlocks(0), firstDataBlockNumber(0),
            rootDirINodeNumber(0), lastBlockNumber(-1)
        {
        }
        public override void Read(MemoryReader& reader)
        {
            base->Read(reader);
            firstINodeBitmapBlockNumber = reader.ReadInt();
            numINodeBitmapBlocks = reader.ReadInt();
            firstBlockBitmapBlockNumber = reader.ReadInt();
            numBlockBitmapBlocks = reader.ReadInt();
            firstINodeBlockNumber = reader.ReadInt();
            numINodeBlocks = reader.ReadInt();
            firstDataBlockNumber = reader.ReadInt();
            rootDirINodeNumber = reader.ReadInt();
            lastBlockNumber = reader.ReadInt();
        }
        public override void Write(MemoryWriter& writer)
        {
            base->Write(writer);
            writer.Write(firstINodeBitmapBlockNumber);
            writer.Write(numINodeBitmapBlocks);
            writer.Write(firstBlockBitmapBlockNumber);
            writer.Write(numBlockBitmapBlocks);
            writer.Write(firstINodeBlockNumber);
            writer.Write(numINodeBlocks);
            writer.Write(firstDataBlockNumber);
            writer.Write(rootDirINodeNumber);
            writer.Write(lastBlockNumber);
        }
        public nothrow inline int GetFirstINodeBitmapBlockNumber() const
        {
            return firstINodeBitmapBlockNumber;
        }
        public nothrow void SetFirstINodeBitmapBlockNumber(int firstINodeBitmapBlockNumber_)
        {
            firstINodeBitmapBlockNumber = firstINodeBitmapBlockNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetNumINodeBitmapBlocks() const
        {
            return numINodeBitmapBlocks;
        }
        public nothrow void SetNumINodeBitmapBlocks(int numINodeBitmapBlocks_)
        {
            numINodeBitmapBlocks = numINodeBitmapBlocks_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetFirstBlockBitmapBlockNumber() const
        {
            return firstBlockBitmapBlockNumber;
        }
        public nothrow void SetFirstBlockBitmapBlockNumber(int firstBlockBitmapBlockNumber_)
        {
            firstBlockBitmapBlockNumber = firstBlockBitmapBlockNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetNumBlockBitmapBlocks() const
        {
            return numBlockBitmapBlocks;
        }
        public nothrow void SetNumBlockBitmapBlocks(int numBlockBitmapBlocks_)
        {
            numBlockBitmapBlocks = numBlockBitmapBlocks_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetFirstINodeBlockNumber() const
        {
            return firstINodeBlockNumber;
        }
        public nothrow void SetFirstINodeBlockNumber(int firstINodeBlockNumber_)
        {
            firstINodeBlockNumber = firstINodeBlockNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetNumINodeBlocks() const
        {
            return numINodeBlocks;
        }
        public nothrow void SetNumINodeBlocks(int numINodeBlocks_)
        {
            numINodeBlocks = numINodeBlocks_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetFirstDataBlockNumber() const
        {
            return firstDataBlockNumber;
        }
        public nothrow void SetFirstDataBlockNumber(int firstDataBlockNumber_)
        {
            firstDataBlockNumber = firstDataBlockNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetRootDirINodeNumber() const
        {
            return rootDirINodeNumber;
        }
        public nothrow void SetRootDirINodeNumber(int rootDirINodeNumber_)
        {
            rootDirINodeNumber = rootDirINodeNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow inline int GetLastBlockNumber() const
        {
            return lastBlockNumber;
        }
        public nothrow void SetLastBlockNumber(int lastBlockNumber_)
        {
            lastBlockNumber = lastBlockNumber_;
            SetFlag(Block.Flags.dirty);
        }
        public nothrow override void Clear()
        {
            firstINodeBitmapBlockNumber = 0;
            numINodeBitmapBlocks = 0;
            firstBlockBitmapBlockNumber = 0;
            numBlockBitmapBlocks = 0;
            firstINodeBlockNumber = 0;
            numINodeBlocks = 0;
            firstDataBlockNumber = 0;
            rootDirINodeNumber = 0;
            lastBlockNumber = 0;
            base->Clear();
        }
        private int firstINodeBitmapBlockNumber;
        private int numINodeBitmapBlocks;
        private int firstBlockBitmapBlockNumber;
        private int numBlockBitmapBlocks;
        private int firstINodeBlockNumber;
        private int numINodeBlocks;
        private int firstDataBlockNumber;
        private int rootDirINodeNumber;
        private int lastBlockNumber;
    }

    public class BitmapBlock : Block
    {
        public nothrow BitmapBlock(BlockManager* manager_, BlockCache* cache_) : base(BlockKey(0, 0, BlockKind.bitmapBlock), manager_, cache_)
        {
        }
        public override void Read(MemoryReader& reader)
        {
            base->Read(reader);
            long n = bits.Length();
            for (long i = 0; i < n; ++i)
            {
                ulong b = reader.ReadULong();
                bits[i] = b;
            }
        }
        public override void Write(MemoryWriter& writer)
        {
            base->Write(writer);
            long n = bits.Length();
            for (long i = 0; i < n; ++i)
            {
                writer.Write(bits[i]);
            }
        }
        public nothrow int GetFirstZeroBitIndex() const
        {
            long n = bits.Length();
            for (long i = 0; i < n; ++i)
            {
                if (bits[i] != MaxValue<ulong>())
                {
                    ulong b = bits[i];
                    for (byte j = 0u; j < 64u; ++j)
                    {
                        if ((b & (cast<ulong>(1u) << j)) == 0u)
                        {
                            return cast<int>(i) * 64 + j;
                        }
                    }
                }
            }
            return -1;
        }
        public nothrow bool GetBit(int index) const
        {
            int i = index / 64;
            byte j = cast<byte>(index % 64);
            return (bits[i] & (cast<ulong>(1u) << j)) != 0u;
        }
        public nothrow void SetBit(int index)
        {
            int i = index / 64;
            byte j = cast<byte>(index % 64);
            bits[i] = bits[i] | (cast<ulong>(1u) << j);
            SetFlag(Flags.dirty);
        }
        public nothrow void ResetBit(int index)
        {
            int i = index / 64;
            byte j = cast<byte>(index % 64);
            bits[i] = bits[i] & ~(cast<ulong>(1u) << j);
            SetFlag(Flags.dirty);
        }
        public override nothrow void Clear()
        {
            long n = bits.Length();
            for (long i = 0; i < n; ++i)
            {
                bits[i] = 0u;
            }
            base->Clear();
        }
        private ulong[numULongsInBitmapBlock] bits;
    }

    public class BlockNumberBlock : Block
    {
        public nothrow BlockNumberBlock(BlockManager* manager_, BlockCache* cache_) : base(BlockKey(0, 0, BlockKind.blockNumberBlock), manager_, cache_)
        {
        }
        public override void Read(MemoryReader& reader)
        {
            base->Read(reader);
            for (int i = 0; i < numBlockNumbersInBlock; ++i)
            {
                blockNumbers[i] = reader.ReadInt();
            }
        }
        public override void Write(MemoryWriter& writer)
        {
            base->Write(writer);
            for (int i = 0; i < numBlockNumbersInBlock; ++i)
            {
                writer.Write(blockNumbers[i]);
            }
        }
        public override nothrow void Clear()
        {
            for (int i = 0; i < numBlockNumbersInBlock; ++i)
            {
                blockNumbers[i] = 0;
            }
            base->Clear();
        }
        public nothrow inline int GetBlockNumber(int index) const
        {
            #assert(index >= 0 && index < numBlockNumbersInBlock);
            return blockNumbers[index];
        }
        public nothrow inline void SetBlockNumber(int index, int blockNumber)
        {
            blockNumbers[index] = blockNumber;
            SetFlag(Block.Flags.dirty);
        }
        private int[numBlockNumbersInBlock] blockNumbers;
    }

    public class FileBlock : Block
    {
        public nothrow FileBlock(BlockManager* manager_, BlockCache* cache_) : base(BlockKey(0, 0, BlockKind.fileBlock), manager_, cache_)
        {
        }
        public override void Read(MemoryReader& reader)
        {
            base->Read(reader);
            for (long i = 0; i < blockSize; ++i)
            {
                data[i] = reader.ReadByte();
            }
        }
        public override void Write(MemoryWriter& writer)
        {
            base->Write(writer);
            for (long i = 0; i < blockSize; ++i)
            {
                writer.Write(data[i]);
            }
        }
        public nothrow inline byte GetByte(long index) const
        {
            return data[index];
        }
        public nothrow inline void SetByte(long index, byte x)
        {
            data[index] = x;
        }
        public override nothrow void Clear()
        {
            for (int i = 0; i < blockSize; ++i)
            {
                data[i] = 0u;
            }
            base->Clear();
        }
        private byte[blockSize] data;
    }

    public class DirectoryEntry
    {
        public nothrow DirectoryEntry(int inodeNumber_, const string& name_) : inodeNumber(inodeNumber_)
        {
            #assert(name_.Length() < nameMax);
            for (long i = 0; i < nameMax; ++i)
            {
                if (i < name_.Length())
                {
                    name[i] = name_[i];
                }
                else
                {
                    name[i] = '\0';
                }
            }
        }
        public void Read(MemoryReader& reader)
        {
            inodeNumber = reader.ReadInt();
            for (long i = 0; i < nameMax; ++i)
            {
                name[i] = cast<char>(reader.ReadByte());
            }
        }
        public void Write(MemoryWriter& writer)
        {
            writer.Write(inodeNumber);
            for (long i = 0; i < nameMax; ++i)
            {
                writer.Write(cast<byte>(name[i]));
            }
        }
        public int inodeNumber;
        public char[nameMax] name;
    }

    public const int directoryEntrySize = 4 + nameMax;
    public const int numDirectoryEntriesInBlock = blockSize / directoryEntrySize;

    public class DirectorySlot
    {
        public nothrow DirectorySlot() : blockNumber(invalidBlockNumber), fsNumber(0), offset(-1)
        {
        }
        public nothrow DirectorySlot(int blockNumber_, int fsNumber_, long offset_) : blockNumber(blockNumber_), fsNumber(fsNumber_), offset(offset_)
        {
        }
        public int blockNumber;
        public int fsNumber;
        public long offset;
    }

    public class DirectoryBlock : Block
    {
        public nothrow DirectoryBlock(BlockManager* manager_, BlockCache* cache_) : base(BlockKey(0, 0, BlockKind.directoryBlock), manager_, cache_)
        {
        }
        public override void Read(MemoryReader& reader)
        {
            base->Read(reader);
            long n = entries.Length();
            for (long i = 0; i < n; ++i)
            {
                entries[i].Read(reader);
            }
        }
        public override void Write(MemoryWriter& writer)
        {
            base->Write(writer);
            long n = entries.Length();
            for (long i = 0; i < n; ++i)
            {
                entries[i].Write(writer);
            }
        }
        public nothrow inline const DirectoryEntry& GetDirectoryEntry(int index) const
        {
            #assert(index >= 0 && index < entries.Length());
            return entries[index];
        }
        public nothrow inline DirectoryEntry& GetDirectoryEntry(int index)
        {
            #assert(index >= 0 && index < entries.Length());
            return entries[index];
        }
        public override nothrow void Clear()
        {
            long n = entries.Length();
            for (long i = 0; i < n; ++i)
            {
                entries[i] = DirectoryEntry();
            }
            base->Clear();
        }
        private DirectoryEntry[numDirectoryEntriesInBlock] entries;
    }

    public class BlockPutter
    {
        public nothrow BlockPutter(Block* block_) : block(block_)
        {
        }
        public ~BlockPutter()
        {
            block->Manager()->PutBlock(block);
        }
        private Block* block;
    }
}

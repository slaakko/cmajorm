using System;
using System.Collections;
using CodeFormatter = System.Text.CodeFormatter;

namespace cmsx.intermediate
{
    public const uint prologId = cast<uint>(-1);
    public const uint epilogId = cast<uint>(-2);

    public class Function
    {
        public nothrow Function(Context& context_, FunctionType* type_, const string& name_) :
            context(context_), type(type_), name(name_), addressDescriptors(), locations(context.regs), nextValueNumber(0), nextInstructionIndex(0), frameSizeOperand(null),
            prolog(*this, prologId), epilog(*this, epilogId)
        {
        }
        public BasicBlock* AddBasicBlock(uint id)
        {
            BasicBlock* bb = new BasicBlock(*this, id);
            basicBlocks.Add(UniquePtr<BasicBlock>(bb));
            return bb;
        }
        public Value* MakeIdValue(int lineNumber, uint id, Type* type)
        {
            HashMap<uint, IdValue*>.ConstIterator it = idValueMap.CFind(id);
            if (it != idValueMap.CEnd())
            {
                IdValue* idValue = it->second;
                if (idValue->type != type)
                {
                    throw Exception("type " + type->Name() + " conflicts type " + idValue->type->Name() + " in earlier definition at line " + ToString(idValue->line) +
                        " (" + context.compileUnit.fileName + ":" + ToString(lineNumber) + ")");
                }
                return idValue;
            }
            else
            {
                IdValue* idValue = new IdValue(id);
                idValue->type = type;
                idValue->line = lineNumber;
                values.Add(UniquePtr<Value>(idValue));
                idValueMap[id] = idValue;
                return idValue;
            }
        }
        public void MapInstructions()
        {
            uint nextIdNumber = 0u;
            for (const UniquePtr<BasicBlock>& bb : basicBlocks)
            {
                bb->MapInstructions(nextIdNumber);
            }
        }
        public void MapInstruction(uint id, Instruction* instruction)
        {
            HashMap<uint, Instruction*>.ConstIterator it = instructionMap.CFind(id);
            if (it == instructionMap.CEnd())
            {
                instructionMap[id] = instruction;
            }
            else
            {
                throw Exception("instruction '" + instruction->OperationName() + "' id " + ToString(id) + " at line '" + ToString(instruction->line) + "' already mapped at line " + ToString(it->second->line));
            }
        }
        public void Validate()
        {
            for (const UniquePtr<BasicBlock>& bb : basicBlocks)
            {
                bb->Validate();
            }
        }
        public Value* ResolveOperand(int line, Value* operand)
        {
            if (operand != null)
            {
                IdValue* idValue = operand as IdValue*;
                if (idValue != null)
                {
                    uint id = idValue->id;
                    HashMap<uint, Instruction*>.ConstIterator it = instructionMap.CFind(id);
                    if (it != instructionMap.CEnd())
                    {
                        Instruction* instruction = it->second;
                        if (idValue->type != instruction->type)
                        {
                            throw Exception("error : type conflict for operand '" + operand->Name() + "' at line " + ToString(operand->line) + " with " + instruction->OperationName() +
                                " instruction at line " + ToString(instruction->line));
                        }
                        return instruction;
                    }
                    else
                    {
                        throw Exception("error : id of operand '" + operand->Name() + "' at line " + ToString(operand->line) + "' is not found from instruction map");
                    }
                }
                else
                {
                    return operand;
                }
            }
            else
            {
                throw Exception("internal error : operand is null at line " + ToString(line));
            }
        }
        public BasicBlock* GetBasicBlock(uint target)
        {
            if (target < basicBlocks.Count())
            {
                return basicBlocks[target].Get();
            }
            else
            {
                return null;
            }
        }
        public void Print(CodeFormatter& formatter, int stage)
        {
            nextInstructionIndex = 0;
            nextValueNumber = 0;
            formatter.WriteLine("function @" + name);
            formatter.WriteLine("{");
            formatter.IncIndent();
            bool first = true;
            for (const UniquePtr<BasicBlock>& basicBlock : basicBlocks)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    formatter.WriteLine();
                }
                basicBlock->Print(formatter, stage);
            }
            formatter.DecIndent();
            formatter.WriteLine("}");
        }
        public nothrow inline int GetNextInstructionIndex()
        {
            return nextInstructionIndex++;
        }
        public nothrow inline int GetNextValueNumber()
        {
            return nextValueNumber++;
        }
        public nothrow void ComputeLivenessAndNextUse()
        {
            for (const UniquePtr<BasicBlock>& bb : basicBlocks)
            {
                bb->ComputeLivenessAndNextUse();
            }
        }
        public void GenerateDeclaration(MachineCode& machineCode)
        {
            MachineInstruction* externInst = machineCode.GetInstruction(cmsx.assembly.EXTERN);
            externInst->AddOperand(machineCode.context.GetSymbolOperand(name));
        }
        public void GenerateCode(MachineCode& machineCode, CodeFormatter& formatter)
        {
            nextInstructionIndex = 0;
            nextValueNumber = 0;
            epilog.id = cast<uint>(basicBlocks.Count());
            CreateProlog(machineCode);
            if (Flags.Get(Flag.debug))
            {
                formatter.WriteLine("function @" + name);
                formatter.WriteLine("{");
                formatter.IncIndent();
            }
            for (const UniquePtr<BasicBlock>& basicBlock : basicBlocks)
            {
                basicBlock->GenerateCode(machineCode, formatter);
            }
            if (Flags.Get(Flag.debug))
            {
                formatter.DecIndent();
                formatter.WriteLine("}");
            }
            CreateEpilog(machineCode);
            frameSizeOperand->SetValue(cast<ulong>(locations.offset));
        }
        private void CreateProlog(MachineCode& machineCode)
        {
            MachineInstruction* funcInst = machineCode.GetInstruction(cmsx.assembly.FUNC, name);
            MachineInstruction* stoInst = machineCode.GetInstruction(cmsx.machine.STO);
            stoInst->AddOperand(context.regs.GetFP());
            stoInst->AddOperand(context.regs.GetSP());
            stoInst->AddOperand(context.GetLiteralOperand(0u));
            MachineInstruction* setInst = machineCode.GetInstruction(cmsx.assembly.SET);
            setInst->AddOperand(context.regs.GetFP());
            setInst->AddOperand(context.regs.GetSP());
            MachineInstruction* inclInst = machineCode.GetInstruction(cmsx.machine.INCL);
            inclInst->AddOperand(context.regs.GetSP());
            frameSizeOperand = context.CreateLiteralOperand();
            inclInst->AddOperand(frameSizeOperand);
            prolog.SetEmpty(false);
        }
        private void CreateEpilog(MachineCode& machineCode)
        {
            MachineInstruction* setInst = machineCode.GetInstruction(cmsx.assembly.SET, epilog.Name());
            setInst->AddOperand(context.regs.GetSP());
            setInst->AddOperand(context.regs.GetFP());
            machineCode.GetInstruction(cmsx.machine.RET);
            machineCode.GetInstruction(cmsx.assembly.ENDF, name);
            epilog.SetEmpty(false);
        }
        public Context& context;
        public FunctionType* type;
        public string name;
        public AddressDescriptors addressDescriptors;
        public Locations locations;
        public BasicBlock prolog;
        public BasicBlock epilog;
        private List<UniquePtr<BasicBlock>> basicBlocks;
        private List<UniquePtr<Value>> values;
        private HashMap<uint, IdValue*> idValueMap;
        private HashMap<uint, Instruction*> instructionMap;
        private int nextInstructionIndex;
        private int nextValueNumber;
        private LiteralOperand* frameSizeOperand;
    }
}

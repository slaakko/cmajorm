using System;
using System.Collections;
using System.Text.Parsing;

// this source file has been automatically generated from 'IntermediateCodeFileGrammar.parser' using cmparsergen version 2.0.0.

namespace cmsx.intermediate
{
    public class IntermediateCodeFileGrammar : System.Text.Parsing.Grammar
    {
        public IntermediateCodeFileGrammar() : this(new ParsingDomain())
        {
        }
        public IntermediateCodeFileGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("IntermediateCodeFileGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cmsx.intermediate")), parsingDomain)
        {
            SetOwner(0);
            keywords0.Add(ToUtf32("void"));
            keywords0.Add(ToUtf32("byte"));
            keywords0.Add(ToUtf32("float"));
            keywords0.Add(ToUtf32("uint"));
            keywords0.Add(ToUtf32("bool"));
            keywords0.Add(ToUtf32("long"));
            keywords0.Add(ToUtf32("ushort"));
            keywords0.Add(ToUtf32("ulong"));
            keywords0.Add(ToUtf32("double"));
            keywords0.Add(ToUtf32("int"));
            keywords0.Add(ToUtf32("sbyte"));
            keywords0.Add(ToUtf32("short"));
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, cmsx.intermediate.Context* context)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class IntermediateCodeFileRule : System.Text.Parsing.RuleParser
        {
            public IntermediateCodeFileRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeDeclarationsNonterminalParser = GetNonterminal(ToUtf32("TypeDeclarations"));
                typeDeclarationsNonterminalParser->SetPre(PreTypeDeclarations);
                NonterminalParser* functionsNonterminalParser = GetNonterminal(ToUtf32("Functions"));
                functionsNonterminalParser->SetPre(PreFunctions);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->SetFileName(fileName);
            }
            public void PreTypeDeclarations(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PreFunctions(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context()
                {
                }
                public cmsx.intermediate.Context* context;
            }
        }

        public class TypeDeclarationsRule : System.Text.Parsing.RuleParser
        {
            public TypeDeclarationsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeDeclarationNonterminalParser = GetNonterminal(ToUtf32("TypeDeclaration"));
                typeDeclarationNonterminalParser->SetPre(PreTypeDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->ResolveTypes();
            }
            public void PreTypeDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context()
                {
                }
                public cmsx.intermediate.Context* context;
            }
        }

        public class FunctionsRule : System.Text.Parsing.RuleParser
        {
            public FunctionsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* functionNonterminalParser = GetNonterminal(ToUtf32("Function"));
                functionNonterminalParser->SetPre(PreFunction);
            }
            public void PreFunction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context()
                {
                }
                public cmsx.intermediate.Context* context;
            }
        }

        public class FunctionRule : System.Text.Parsing.RuleParser
        {
            public FunctionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* functionNonterminalParser = GetNonterminal(ToUtf32("function"));
                functionNonterminalParser->SetPre(Prefunction);
                functionNonterminalParser->SetPost(Postfunction);
                NonterminalParser* basicBlockNonterminalParser = GetNonterminal(ToUtf32("BasicBlock"));
                basicBlockNonterminalParser->SetPre(PreBasicBlock);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->SetCurrentFunction(context->fromfunction);
            }
            public void Prefunction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postfunction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfunction_value = stack.Pop();
                    context->fromfunction = *cast<ValueObject<Function*>*>(fromfunction_value.Get());
                }
            }
            public void PreBasicBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Function*>(context->fromfunction)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), fromfunction()
                {
                }
                public cmsx.intermediate.Context* context;
                public Function* fromfunction;
            }
        }

        public class FunctionHeaderRule : System.Text.Parsing.RuleParser
        {
            public FunctionHeaderRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Function*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Function*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* functionTypeNonterminalParser = GetNonterminal(ToUtf32("functionType"));
                functionTypeNonterminalParser->SetPre(PrefunctionType);
                functionTypeNonterminalParser->SetPost(PostfunctionType);
                NonterminalParser* functionIdNonterminalParser = GetNonterminal(ToUtf32("functionId"));
                functionIdNonterminalParser->SetPost(PostfunctionId);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->AddFunction(span.lineNumber, context->fromfunctionType, ToUtf8(context->fromfunctionId));
            }
            public void PrefunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostfunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfunctionType_value = stack.Pop();
                    context->fromfunctionType = *cast<ValueObject<Type*>*>(fromfunctionType_value.Get());
                }
            }
            public void PostfunctionId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfunctionId_value = stack.Pop();
                    context->fromfunctionId = *cast<ValueObject<ustring>*>(fromfunctionId_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromfunctionType(), fromfunctionId()
                {
                }
                public cmsx.intermediate.Context* context;
                public Function* value;
                public Type* fromfunctionType;
                public ustring fromfunctionId;
            }
        }

        public class BasicBlockRule : System.Text.Parsing.RuleParser
        {
            public BasicBlockRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Function*"), ToUtf32("function")));
                AddLocalVariable(AttrOrVar(ToUtf32("BasicBlock*"), ToUtf32("bb")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> function_value = stack.Pop();
                context->function = *cast<ValueObject<Function*>*>(function_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* idNonterminalParser = GetNonterminal(ToUtf32("id"));
                idNonterminalParser->SetPost(Postid);
                NonterminalParser* instructionLineNonterminalParser = GetNonterminal(ToUtf32("InstructionLine"));
                instructionLineNonterminalParser->SetPre(PreInstructionLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->bb = context->function->AddBasicBlock(context->fromid);
            }
            public void Postid(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid_value = stack.Pop();
                    context->fromid = *cast<ValueObject<uint>*>(fromid_value.Get());
                }
            }
            public void PreInstructionLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<BasicBlock*>(context->bb)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), function(), bb(), fromid()
                {
                }
                public cmsx.intermediate.Context* context;
                public Function* function;
                public BasicBlock* bb;
                public uint fromid;
            }
        }

        public class InstructionLineRule : System.Text.Parsing.RuleParser
        {
            public InstructionLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("BasicBlock*"), ToUtf32("bb")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> bb_value = stack.Pop();
                context->bb = *cast<ValueObject<BasicBlock*>*>(bb_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* instructionNonterminalParser = GetNonterminal(ToUtf32("Instruction"));
                instructionNonterminalParser->SetPre(PreInstruction);
                instructionNonterminalParser->SetPost(PostInstruction);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->bb->AddInstruction(context->fromInstruction);
            }
            public void PreInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromInstruction_value = stack.Pop();
                    context->fromInstruction = *cast<ValueObject<Instruction*>*>(fromInstruction_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), bb(), fromInstruction()
                {
                }
                public cmsx.intermediate.Context* context;
                public BasicBlock* bb;
                public Instruction* fromInstruction;
            }
        }

        public class InstructionRule : System.Text.Parsing.RuleParser
        {
            public InstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* storeInstructionNonterminalParser = GetNonterminal(ToUtf32("StoreInstruction"));
                storeInstructionNonterminalParser->SetPre(PreStoreInstruction);
                storeInstructionNonterminalParser->SetPost(PostStoreInstruction);
                NonterminalParser* argInstructionNonterminalParser = GetNonterminal(ToUtf32("ArgInstruction"));
                argInstructionNonterminalParser->SetPre(PreArgInstruction);
                argInstructionNonterminalParser->SetPost(PostArgInstruction);
                NonterminalParser* jumpInstructionNonterminalParser = GetNonterminal(ToUtf32("JumpInstruction"));
                jumpInstructionNonterminalParser->SetPre(PreJumpInstruction);
                jumpInstructionNonterminalParser->SetPost(PostJumpInstruction);
                NonterminalParser* branchInstructionNonterminalParser = GetNonterminal(ToUtf32("BranchInstruction"));
                branchInstructionNonterminalParser->SetPre(PreBranchInstruction);
                branchInstructionNonterminalParser->SetPost(PostBranchInstruction);
                NonterminalParser* procedureCallInstructionNonterminalParser = GetNonterminal(ToUtf32("ProcedureCallInstruction"));
                procedureCallInstructionNonterminalParser->SetPre(PreProcedureCallInstruction);
                procedureCallInstructionNonterminalParser->SetPost(PostProcedureCallInstruction);
                NonterminalParser* retInstructionNonterminalParser = GetNonterminal(ToUtf32("RetInstruction"));
                retInstructionNonterminalParser->SetPre(PreRetInstruction);
                retInstructionNonterminalParser->SetPost(PostRetInstruction);
                NonterminalParser* switchInstructionNonterminalParser = GetNonterminal(ToUtf32("SwitchInstruction"));
                switchInstructionNonterminalParser->SetPre(PreSwitchInstruction);
                switchInstructionNonterminalParser->SetPost(PostSwitchInstruction);
                NonterminalParser* valueInstructionNonterminalParser = GetNonterminal(ToUtf32("ValueInstruction"));
                valueInstructionNonterminalParser->SetPre(PreValueInstruction);
                valueInstructionNonterminalParser->SetPost(PostValueInstruction);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromStoreInstruction;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromArgInstruction;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromJumpInstruction;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBranchInstruction;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromProcedureCallInstruction;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromRetInstruction;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSwitchInstruction;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromValueInstruction;
            }
            public void PreStoreInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostStoreInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStoreInstruction_value = stack.Pop();
                    context->fromStoreInstruction = *cast<ValueObject<Instruction*>*>(fromStoreInstruction_value.Get());
                }
            }
            public void PreArgInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostArgInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromArgInstruction_value = stack.Pop();
                    context->fromArgInstruction = *cast<ValueObject<Instruction*>*>(fromArgInstruction_value.Get());
                }
            }
            public void PreJumpInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostJumpInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromJumpInstruction_value = stack.Pop();
                    context->fromJumpInstruction = *cast<ValueObject<Instruction*>*>(fromJumpInstruction_value.Get());
                }
            }
            public void PreBranchInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostBranchInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBranchInstruction_value = stack.Pop();
                    context->fromBranchInstruction = *cast<ValueObject<Instruction*>*>(fromBranchInstruction_value.Get());
                }
            }
            public void PreProcedureCallInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostProcedureCallInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromProcedureCallInstruction_value = stack.Pop();
                    context->fromProcedureCallInstruction = *cast<ValueObject<Instruction*>*>(fromProcedureCallInstruction_value.Get());
                }
            }
            public void PreRetInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostRetInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromRetInstruction_value = stack.Pop();
                    context->fromRetInstruction = *cast<ValueObject<Instruction*>*>(fromRetInstruction_value.Get());
                }
            }
            public void PreSwitchInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostSwitchInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSwitchInstruction_value = stack.Pop();
                    context->fromSwitchInstruction = *cast<ValueObject<SwitchInstruction*>*>(fromSwitchInstruction_value.Get());
                }
            }
            public void PreValueInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostValueInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromValueInstruction_value = stack.Pop();
                    context->fromValueInstruction = *cast<ValueObject<Instruction*>*>(fromValueInstruction_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromStoreInstruction(), fromArgInstruction(), fromJumpInstruction(), fromBranchInstruction(), fromProcedureCallInstruction(), fromRetInstruction(), fromSwitchInstruction(), fromValueInstruction()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Instruction* fromStoreInstruction;
                public Instruction* fromArgInstruction;
                public Instruction* fromJumpInstruction;
                public Instruction* fromBranchInstruction;
                public Instruction* fromProcedureCallInstruction;
                public Instruction* fromRetInstruction;
                public SwitchInstruction* fromSwitchInstruction;
                public Instruction* fromValueInstruction;
            }
        }

        public class StoreInstructionRule : System.Text.Parsing.RuleParser
        {
            public StoreInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* valNonterminalParser = GetNonterminal(ToUtf32("val"));
                valNonterminalParser->SetPre(Preval);
                valNonterminalParser->SetPost(Postval);
                NonterminalParser* ptrTypeNonterminalParser = GetNonterminal(ToUtf32("ptrType"));
                ptrTypeNonterminalParser->SetPre(PreptrType);
                ptrTypeNonterminalParser->SetPost(PostptrType);
                NonterminalParser* ptrNonterminalParser = GetNonterminal(ToUtf32("ptr"));
                ptrNonterminalParser->SetPre(Preptr);
                ptrNonterminalParser->SetPost(Postptr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new StoreInstruction(context->fromval, context->fromptr, span.lineNumber);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Preval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromval_value = stack.Pop();
                    context->fromval = *cast<ValueObject<Value*>*>(fromval_value.Get());
                }
            }
            public void PreptrType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostptrType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromptrType_value = stack.Pop();
                    context->fromptrType = *cast<ValueObject<Type*>*>(fromptrType_value.Get());
                }
            }
            public void Preptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromptrType)));
            }
            public void Postptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromptr_value = stack.Pop();
                    context->fromptr = *cast<ValueObject<Value*>*>(fromptr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromval(), fromptrType(), fromptr()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromtype;
                public Value* fromval;
                public Type* fromptrType;
                public Value* fromptr;
            }
        }

        public class ArgInstructionRule : System.Text.Parsing.RuleParser
        {
            public ArgInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ArgInstruction(context->fromarg, span.lineNumber);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromtype;
                public Value* fromarg;
            }
        }

        public class JumpInstructionRule : System.Text.Parsing.RuleParser
        {
            public JumpInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* targetNonterminalParser = GetNonterminal(ToUtf32("target"));
                targetNonterminalParser->SetPost(Posttarget);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new JumpInstruction(context->fromtarget, span.lineNumber);
            }
            public void Posttarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtarget_value = stack.Pop();
                    context->fromtarget = *cast<ValueObject<uint>*>(fromtarget_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtarget()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public uint fromtarget;
            }
        }

        public class BranchInstructionRule : System.Text.Parsing.RuleParser
        {
            public BranchInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* condNonterminalParser = GetNonterminal(ToUtf32("cond"));
                condNonterminalParser->SetPre(Precond);
                condNonterminalParser->SetPost(Postcond);
                NonterminalParser* trueTargetNonterminalParser = GetNonterminal(ToUtf32("trueTarget"));
                trueTargetNonterminalParser->SetPost(PosttrueTarget);
                NonterminalParser* falseTargetNonterminalParser = GetNonterminal(ToUtf32("falseTarget"));
                falseTargetNonterminalParser->SetPost(PostfalseTarget);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BranchInstruction(context->fromcond, context->fromtrueTarget, context->fromfalseTarget, span.lineNumber);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Precond(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postcond(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcond_value = stack.Pop();
                    context->fromcond = *cast<ValueObject<Value*>*>(fromcond_value.Get());
                }
            }
            public void PosttrueTarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtrueTarget_value = stack.Pop();
                    context->fromtrueTarget = *cast<ValueObject<uint>*>(fromtrueTarget_value.Get());
                }
            }
            public void PostfalseTarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfalseTarget_value = stack.Pop();
                    context->fromfalseTarget = *cast<ValueObject<uint>*>(fromfalseTarget_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromcond(), fromtrueTarget(), fromfalseTarget()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromtype;
                public Value* fromcond;
                public uint fromtrueTarget;
                public uint fromfalseTarget;
            }
        }

        public class ProcedureCallInstructionRule : System.Text.Parsing.RuleParser
        {
            public ProcedureCallInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* functionTypeNonterminalParser = GetNonterminal(ToUtf32("functionType"));
                functionTypeNonterminalParser->SetPre(PrefunctionType);
                functionTypeNonterminalParser->SetPost(PostfunctionType);
                NonterminalParser* calleeNonterminalParser = GetNonterminal(ToUtf32("callee"));
                calleeNonterminalParser->SetPre(Precallee);
                calleeNonterminalParser->SetPost(Postcallee);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ProcedureCallInstruction(context->fromcallee, span.lineNumber);
            }
            public void PrefunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostfunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfunctionType_value = stack.Pop();
                    context->fromfunctionType = *cast<ValueObject<Type*>*>(fromfunctionType_value.Get());
                }
            }
            public void Precallee(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromfunctionType)));
            }
            public void Postcallee(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcallee_value = stack.Pop();
                    context->fromcallee = *cast<ValueObject<Value*>*>(fromcallee_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromfunctionType(), fromcallee()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromfunctionType;
                public Value* fromcallee;
            }
        }

        public class RetInstructionRule : System.Text.Parsing.RuleParser
        {
            public RetInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* valNonterminalParser = GetNonterminal(ToUtf32("val"));
                valNonterminalParser->SetPre(Preval);
                valNonterminalParser->SetPost(Postval);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new RetInstruction(null, span.lineNumber);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new RetInstruction(context->fromval, span.lineNumber);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Preval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromval_value = stack.Pop();
                    context->fromval = *cast<ValueObject<Value*>*>(fromval_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromval()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromtype;
                public Value* fromval;
            }
        }

        public class SwitchInstructionRule : System.Text.Parsing.RuleParser
        {
            public SwitchInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("SwitchInstruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<SwitchInstruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* condNonterminalParser = GetNonterminal(ToUtf32("cond"));
                condNonterminalParser->SetPre(Precond);
                condNonterminalParser->SetPost(Postcond);
                NonterminalParser* defaultTargetNonterminalParser = GetNonterminal(ToUtf32("defaultTarget"));
                defaultTargetNonterminalParser->SetPost(PostdefaultTarget);
                NonterminalParser* caseTypeNonterminalParser = GetNonterminal(ToUtf32("caseType"));
                caseTypeNonterminalParser->SetPre(PrecaseType);
                caseTypeNonterminalParser->SetPost(PostcaseType);
                NonterminalParser* caseValueNonterminalParser = GetNonterminal(ToUtf32("caseValue"));
                caseValueNonterminalParser->SetPre(PrecaseValue);
                caseValueNonterminalParser->SetPost(PostcaseValue);
                NonterminalParser* caseTargetNonterminalParser = GetNonterminal(ToUtf32("caseTarget"));
                caseTargetNonterminalParser->SetPost(PostcaseTarget);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SwitchInstruction(context->fromcond, context->fromdefaultTarget, span.lineNumber);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddCase(context->fromcaseValue, context->fromcaseTarget);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Precond(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postcond(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcond_value = stack.Pop();
                    context->fromcond = *cast<ValueObject<Value*>*>(fromcond_value.Get());
                }
            }
            public void PostdefaultTarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromdefaultTarget_value = stack.Pop();
                    context->fromdefaultTarget = *cast<ValueObject<uint>*>(fromdefaultTarget_value.Get());
                }
            }
            public void PrecaseType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostcaseType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcaseType_value = stack.Pop();
                    context->fromcaseType = *cast<ValueObject<Type*>*>(fromcaseType_value.Get());
                }
            }
            public void PrecaseValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromcaseType)));
            }
            public void PostcaseValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcaseValue_value = stack.Pop();
                    context->fromcaseValue = *cast<ValueObject<Value*>*>(fromcaseValue_value.Get());
                }
            }
            public void PostcaseTarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcaseTarget_value = stack.Pop();
                    context->fromcaseTarget = *cast<ValueObject<uint>*>(fromcaseTarget_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromcond(), fromdefaultTarget(), fromcaseType(), fromcaseValue(), fromcaseTarget()
                {
                }
                public cmsx.intermediate.Context* context;
                public SwitchInstruction* value;
                public Type* fromtype;
                public Value* fromcond;
                public uint fromdefaultTarget;
                public Type* fromcaseType;
                public Value* fromcaseValue;
                public uint fromcaseTarget;
            }
        }

        public class ValueInstructionRule : System.Text.Parsing.RuleParser
        {
            public ValueInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* resultNonterminalParser = GetNonterminal(ToUtf32("result"));
                resultNonterminalParser->SetPre(Preresult);
                resultNonterminalParser->SetPost(Postresult);
                NonterminalParser* operationNonterminalParser = GetNonterminal(ToUtf32("Operation"));
                operationNonterminalParser->SetPre(PreOperation);
                operationNonterminalParser->SetPost(PostOperation);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromOperation;
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Preresult(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postresult(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromresult_value = stack.Pop();
                    context->fromresult = *cast<ValueObject<Value*>*>(fromresult_value.Get());
                }
            }
            public void PreOperation(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->fromresult)));
            }
            public void PostOperation(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOperation_value = stack.Pop();
                    context->fromOperation = *cast<ValueObject<Instruction*>*>(fromOperation_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromresult(), fromOperation()
                {
                }
                public cmsx.intermediate.Context* context;
                public Instruction* value;
                public Type* fromtype;
                public Value* fromresult;
                public Instruction* fromOperation;
            }
        }

        public class OperationRule : System.Text.Parsing.RuleParser
        {
            public OperationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                NonterminalParser* unaryInstructionNonterminalParser = GetNonterminal(ToUtf32("UnaryInstruction"));
                unaryInstructionNonterminalParser->SetPre(PreUnaryInstruction);
                unaryInstructionNonterminalParser->SetPost(PostUnaryInstruction);
                NonterminalParser* binaryInstructionNonterminalParser = GetNonterminal(ToUtf32("BinaryInstruction"));
                binaryInstructionNonterminalParser->SetPre(PreBinaryInstruction);
                binaryInstructionNonterminalParser->SetPost(PostBinaryInstruction);
                NonterminalParser* paramInstructionNonterminalParser = GetNonterminal(ToUtf32("ParamInstruction"));
                paramInstructionNonterminalParser->SetPre(PreParamInstruction);
                paramInstructionNonterminalParser->SetPost(PostParamInstruction);
                NonterminalParser* localInstructionNonterminalParser = GetNonterminal(ToUtf32("LocalInstruction"));
                localInstructionNonterminalParser->SetPre(PreLocalInstruction);
                localInstructionNonterminalParser->SetPost(PostLocalInstruction);
                NonterminalParser* loadInstructionNonterminalParser = GetNonterminal(ToUtf32("LoadInstruction"));
                loadInstructionNonterminalParser->SetPre(PreLoadInstruction);
                loadInstructionNonterminalParser->SetPost(PostLoadInstruction);
                NonterminalParser* elemAddrInstructionNonterminalParser = GetNonterminal(ToUtf32("ElemAddrInstruction"));
                elemAddrInstructionNonterminalParser->SetPre(PreElemAddrInstruction);
                elemAddrInstructionNonterminalParser->SetPost(PostElemAddrInstruction);
                NonterminalParser* ptrOffsetInstructionNonterminalParser = GetNonterminal(ToUtf32("PtrOffsetInstruction"));
                ptrOffsetInstructionNonterminalParser->SetPre(PrePtrOffsetInstruction);
                ptrOffsetInstructionNonterminalParser->SetPost(PostPtrOffsetInstruction);
                NonterminalParser* ptrDiffInstructionNonterminalParser = GetNonterminal(ToUtf32("PtrDiffInstruction"));
                ptrDiffInstructionNonterminalParser->SetPre(PrePtrDiffInstruction);
                ptrDiffInstructionNonterminalParser->SetPost(PostPtrDiffInstruction);
                NonterminalParser* functionCallInstructionNonterminalParser = GetNonterminal(ToUtf32("FunctionCallInstruction"));
                functionCallInstructionNonterminalParser->SetPre(PreFunctionCallInstruction);
                functionCallInstructionNonterminalParser->SetPost(PostFunctionCallInstruction);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUnaryInstruction;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBinaryInstruction;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromParamInstruction;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLocalInstruction;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLoadInstruction;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromElemAddrInstruction;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPtrOffsetInstruction;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPtrDiffInstruction;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFunctionCallInstruction;
            }
            public void PreUnaryInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostUnaryInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUnaryInstruction_value = stack.Pop();
                    context->fromUnaryInstruction = *cast<ValueObject<Instruction*>*>(fromUnaryInstruction_value.Get());
                }
            }
            public void PreBinaryInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostBinaryInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBinaryInstruction_value = stack.Pop();
                    context->fromBinaryInstruction = *cast<ValueObject<Instruction*>*>(fromBinaryInstruction_value.Get());
                }
            }
            public void PreParamInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostParamInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromParamInstruction_value = stack.Pop();
                    context->fromParamInstruction = *cast<ValueObject<Instruction*>*>(fromParamInstruction_value.Get());
                }
            }
            public void PreLocalInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostLocalInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLocalInstruction_value = stack.Pop();
                    context->fromLocalInstruction = *cast<ValueObject<Instruction*>*>(fromLocalInstruction_value.Get());
                }
            }
            public void PreLoadInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostLoadInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLoadInstruction_value = stack.Pop();
                    context->fromLoadInstruction = *cast<ValueObject<Instruction*>*>(fromLoadInstruction_value.Get());
                }
            }
            public void PreElemAddrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostElemAddrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromElemAddrInstruction_value = stack.Pop();
                    context->fromElemAddrInstruction = *cast<ValueObject<Instruction*>*>(fromElemAddrInstruction_value.Get());
                }
            }
            public void PrePtrOffsetInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostPtrOffsetInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPtrOffsetInstruction_value = stack.Pop();
                    context->fromPtrOffsetInstruction = *cast<ValueObject<Instruction*>*>(fromPtrOffsetInstruction_value.Get());
                }
            }
            public void PrePtrDiffInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostPtrDiffInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPtrDiffInstruction_value = stack.Pop();
                    context->fromPtrDiffInstruction = *cast<ValueObject<Instruction*>*>(fromPtrDiffInstruction_value.Get());
                }
            }
            public void PreFunctionCallInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostFunctionCallInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionCallInstruction_value = stack.Pop();
                    context->fromFunctionCallInstruction = *cast<ValueObject<Instruction*>*>(fromFunctionCallInstruction_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromUnaryInstruction(), fromBinaryInstruction(), fromParamInstruction(), fromLocalInstruction(), fromLoadInstruction(), fromElemAddrInstruction(), fromPtrOffsetInstruction(), fromPtrDiffInstruction(), fromFunctionCallInstruction()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Instruction* fromUnaryInstruction;
                public Instruction* fromBinaryInstruction;
                public Instruction* fromParamInstruction;
                public Instruction* fromLocalInstruction;
                public Instruction* fromLoadInstruction;
                public Instruction* fromElemAddrInstruction;
                public Instruction* fromPtrOffsetInstruction;
                public Instruction* fromPtrDiffInstruction;
                public Instruction* fromFunctionCallInstruction;
            }
        }

        public class UnaryInstructionRule : System.Text.Parsing.RuleParser
        {
            public UnaryInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                NonterminalParser* notInstructionNonterminalParser = GetNonterminal(ToUtf32("NotInstruction"));
                notInstructionNonterminalParser->SetPre(PreNotInstruction);
                notInstructionNonterminalParser->SetPost(PostNotInstruction);
                NonterminalParser* negInstructionNonterminalParser = GetNonterminal(ToUtf32("NegInstruction"));
                negInstructionNonterminalParser->SetPre(PreNegInstruction);
                negInstructionNonterminalParser->SetPost(PostNegInstruction);
                NonterminalParser* signExtendInstructionNonterminalParser = GetNonterminal(ToUtf32("SignExtendInstruction"));
                signExtendInstructionNonterminalParser->SetPre(PreSignExtendInstruction);
                signExtendInstructionNonterminalParser->SetPost(PostSignExtendInstruction);
                NonterminalParser* zeroExtendInstructionNonterminalParser = GetNonterminal(ToUtf32("ZeroExtendInstruction"));
                zeroExtendInstructionNonterminalParser->SetPre(PreZeroExtendInstruction);
                zeroExtendInstructionNonterminalParser->SetPost(PostZeroExtendInstruction);
                NonterminalParser* truncateInstructionNonterminalParser = GetNonterminal(ToUtf32("TruncateInstruction"));
                truncateInstructionNonterminalParser->SetPre(PreTruncateInstruction);
                truncateInstructionNonterminalParser->SetPost(PostTruncateInstruction);
                NonterminalParser* bitCastInstructionNonterminalParser = GetNonterminal(ToUtf32("BitCastInstruction"));
                bitCastInstructionNonterminalParser->SetPre(PreBitCastInstruction);
                bitCastInstructionNonterminalParser->SetPost(PostBitCastInstruction);
                NonterminalParser* intToFloatInstructionNonterminalParser = GetNonterminal(ToUtf32("IntToFloatInstruction"));
                intToFloatInstructionNonterminalParser->SetPre(PreIntToFloatInstruction);
                intToFloatInstructionNonterminalParser->SetPost(PostIntToFloatInstruction);
                NonterminalParser* floatToIntInstructionNonterminalParser = GetNonterminal(ToUtf32("FloatToIntInstruction"));
                floatToIntInstructionNonterminalParser->SetPre(PreFloatToIntInstruction);
                floatToIntInstructionNonterminalParser->SetPost(PostFloatToIntInstruction);
                NonterminalParser* intToPtrInstructionNonterminalParser = GetNonterminal(ToUtf32("IntToPtrInstruction"));
                intToPtrInstructionNonterminalParser->SetPre(PreIntToPtrInstruction);
                intToPtrInstructionNonterminalParser->SetPost(PostIntToPtrInstruction);
                NonterminalParser* ptrToIntInstructionNonterminalParser = GetNonterminal(ToUtf32("PtrToIntInstruction"));
                ptrToIntInstructionNonterminalParser->SetPre(PrePtrToIntInstruction);
                ptrToIntInstructionNonterminalParser->SetPost(PostPtrToIntInstruction);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNotInstruction;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNegInstruction;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSignExtendInstruction;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromZeroExtendInstruction;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTruncateInstruction;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBitCastInstruction;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIntToFloatInstruction;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFloatToIntInstruction;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIntToPtrInstruction;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPtrToIntInstruction;
            }
            public void PreNotInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostNotInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNotInstruction_value = stack.Pop();
                    context->fromNotInstruction = *cast<ValueObject<Instruction*>*>(fromNotInstruction_value.Get());
                }
            }
            public void PreNegInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostNegInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNegInstruction_value = stack.Pop();
                    context->fromNegInstruction = *cast<ValueObject<Instruction*>*>(fromNegInstruction_value.Get());
                }
            }
            public void PreSignExtendInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostSignExtendInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSignExtendInstruction_value = stack.Pop();
                    context->fromSignExtendInstruction = *cast<ValueObject<Instruction*>*>(fromSignExtendInstruction_value.Get());
                }
            }
            public void PreZeroExtendInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostZeroExtendInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromZeroExtendInstruction_value = stack.Pop();
                    context->fromZeroExtendInstruction = *cast<ValueObject<Instruction*>*>(fromZeroExtendInstruction_value.Get());
                }
            }
            public void PreTruncateInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostTruncateInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTruncateInstruction_value = stack.Pop();
                    context->fromTruncateInstruction = *cast<ValueObject<Instruction*>*>(fromTruncateInstruction_value.Get());
                }
            }
            public void PreBitCastInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostBitCastInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBitCastInstruction_value = stack.Pop();
                    context->fromBitCastInstruction = *cast<ValueObject<Instruction*>*>(fromBitCastInstruction_value.Get());
                }
            }
            public void PreIntToFloatInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostIntToFloatInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIntToFloatInstruction_value = stack.Pop();
                    context->fromIntToFloatInstruction = *cast<ValueObject<Instruction*>*>(fromIntToFloatInstruction_value.Get());
                }
            }
            public void PreFloatToIntInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostFloatToIntInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFloatToIntInstruction_value = stack.Pop();
                    context->fromFloatToIntInstruction = *cast<ValueObject<Instruction*>*>(fromFloatToIntInstruction_value.Get());
                }
            }
            public void PreIntToPtrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostIntToPtrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIntToPtrInstruction_value = stack.Pop();
                    context->fromIntToPtrInstruction = *cast<ValueObject<Instruction*>*>(fromIntToPtrInstruction_value.Get());
                }
            }
            public void PrePtrToIntInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostPtrToIntInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPtrToIntInstruction_value = stack.Pop();
                    context->fromPtrToIntInstruction = *cast<ValueObject<Instruction*>*>(fromPtrToIntInstruction_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromNotInstruction(), fromNegInstruction(), fromSignExtendInstruction(), fromZeroExtendInstruction(), fromTruncateInstruction(), fromBitCastInstruction(), fromIntToFloatInstruction(), fromFloatToIntInstruction(), fromIntToPtrInstruction(), fromPtrToIntInstruction()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Instruction* fromNotInstruction;
                public Instruction* fromNegInstruction;
                public Instruction* fromSignExtendInstruction;
                public Instruction* fromZeroExtendInstruction;
                public Instruction* fromTruncateInstruction;
                public Instruction* fromBitCastInstruction;
                public Instruction* fromIntToFloatInstruction;
                public Instruction* fromFloatToIntInstruction;
                public Instruction* fromIntToPtrInstruction;
                public Instruction* fromPtrToIntInstruction;
            }
        }

        public class NotInstructionRule : System.Text.Parsing.RuleParser
        {
            public NotInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new NotInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class NegInstructionRule : System.Text.Parsing.RuleParser
        {
            public NegInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new NegInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class SignExtendInstructionRule : System.Text.Parsing.RuleParser
        {
            public SignExtendInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SignExtendInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class ZeroExtendInstructionRule : System.Text.Parsing.RuleParser
        {
            public ZeroExtendInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ZeroExtendInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class TruncateInstructionRule : System.Text.Parsing.RuleParser
        {
            public TruncateInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TruncateInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class BitCastInstructionRule : System.Text.Parsing.RuleParser
        {
            public BitCastInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BitCastInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class IntToFloatInstructionRule : System.Text.Parsing.RuleParser
        {
            public IntToFloatInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new IntToFloatInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class FloatToIntInstructionRule : System.Text.Parsing.RuleParser
        {
            public FloatToIntInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new FloatToIntInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class IntToPtrInstructionRule : System.Text.Parsing.RuleParser
        {
            public IntToPtrInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new IntToPtrInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class PtrToIntInstructionRule : System.Text.Parsing.RuleParser
        {
            public PtrToIntInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argNonterminalParser = GetNonterminal(ToUtf32("arg"));
                argNonterminalParser->SetPre(Prearg);
                argNonterminalParser->SetPost(Postarg);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new PtrToIntInstruction(context->result, context->fromarg, span.lineNumber);
            }
            public void Prearg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postarg(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarg_value = stack.Pop();
                    context->fromarg = *cast<ValueObject<Value*>*>(fromarg_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromarg()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromarg;
            }
        }

        public class BinaryInstructionRule : System.Text.Parsing.RuleParser
        {
            public BinaryInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                NonterminalParser* addInstructionNonterminalParser = GetNonterminal(ToUtf32("AddInstruction"));
                addInstructionNonterminalParser->SetPre(PreAddInstruction);
                addInstructionNonterminalParser->SetPost(PostAddInstruction);
                NonterminalParser* subInstructionNonterminalParser = GetNonterminal(ToUtf32("SubInstruction"));
                subInstructionNonterminalParser->SetPre(PreSubInstruction);
                subInstructionNonterminalParser->SetPost(PostSubInstruction);
                NonterminalParser* mulInstructionNonterminalParser = GetNonterminal(ToUtf32("MulInstruction"));
                mulInstructionNonterminalParser->SetPre(PreMulInstruction);
                mulInstructionNonterminalParser->SetPost(PostMulInstruction);
                NonterminalParser* divInstructionNonterminalParser = GetNonterminal(ToUtf32("DivInstruction"));
                divInstructionNonterminalParser->SetPre(PreDivInstruction);
                divInstructionNonterminalParser->SetPost(PostDivInstruction);
                NonterminalParser* modInstructionNonterminalParser = GetNonterminal(ToUtf32("ModInstruction"));
                modInstructionNonterminalParser->SetPre(PreModInstruction);
                modInstructionNonterminalParser->SetPost(PostModInstruction);
                NonterminalParser* andInstructionNonterminalParser = GetNonterminal(ToUtf32("AndInstruction"));
                andInstructionNonterminalParser->SetPre(PreAndInstruction);
                andInstructionNonterminalParser->SetPost(PostAndInstruction);
                NonterminalParser* orInstructionNonterminalParser = GetNonterminal(ToUtf32("OrInstruction"));
                orInstructionNonterminalParser->SetPre(PreOrInstruction);
                orInstructionNonterminalParser->SetPost(PostOrInstruction);
                NonterminalParser* xorInstructionNonterminalParser = GetNonterminal(ToUtf32("XorInstruction"));
                xorInstructionNonterminalParser->SetPre(PreXorInstruction);
                xorInstructionNonterminalParser->SetPost(PostXorInstruction);
                NonterminalParser* shlInstructionNonterminalParser = GetNonterminal(ToUtf32("ShlInstruction"));
                shlInstructionNonterminalParser->SetPre(PreShlInstruction);
                shlInstructionNonterminalParser->SetPost(PostShlInstruction);
                NonterminalParser* shrInstructionNonterminalParser = GetNonterminal(ToUtf32("ShrInstruction"));
                shrInstructionNonterminalParser->SetPre(PreShrInstruction);
                shrInstructionNonterminalParser->SetPost(PostShrInstruction);
                NonterminalParser* equalInstructionNonterminalParser = GetNonterminal(ToUtf32("EqualInstruction"));
                equalInstructionNonterminalParser->SetPre(PreEqualInstruction);
                equalInstructionNonterminalParser->SetPost(PostEqualInstruction);
                NonterminalParser* lessInstructionNonterminalParser = GetNonterminal(ToUtf32("LessInstruction"));
                lessInstructionNonterminalParser->SetPre(PreLessInstruction);
                lessInstructionNonterminalParser->SetPost(PostLessInstruction);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAddInstruction;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSubInstruction;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromMulInstruction;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDivInstruction;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromModInstruction;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAndInstruction;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromOrInstruction;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromXorInstruction;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromShlInstruction;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromShrInstruction;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEqualInstruction;
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLessInstruction;
            }
            public void PreAddInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostAddInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAddInstruction_value = stack.Pop();
                    context->fromAddInstruction = *cast<ValueObject<Instruction*>*>(fromAddInstruction_value.Get());
                }
            }
            public void PreSubInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostSubInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSubInstruction_value = stack.Pop();
                    context->fromSubInstruction = *cast<ValueObject<Instruction*>*>(fromSubInstruction_value.Get());
                }
            }
            public void PreMulInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostMulInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromMulInstruction_value = stack.Pop();
                    context->fromMulInstruction = *cast<ValueObject<Instruction*>*>(fromMulInstruction_value.Get());
                }
            }
            public void PreDivInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostDivInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDivInstruction_value = stack.Pop();
                    context->fromDivInstruction = *cast<ValueObject<Instruction*>*>(fromDivInstruction_value.Get());
                }
            }
            public void PreModInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostModInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromModInstruction_value = stack.Pop();
                    context->fromModInstruction = *cast<ValueObject<Instruction*>*>(fromModInstruction_value.Get());
                }
            }
            public void PreAndInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostAndInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAndInstruction_value = stack.Pop();
                    context->fromAndInstruction = *cast<ValueObject<Instruction*>*>(fromAndInstruction_value.Get());
                }
            }
            public void PreOrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostOrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOrInstruction_value = stack.Pop();
                    context->fromOrInstruction = *cast<ValueObject<Instruction*>*>(fromOrInstruction_value.Get());
                }
            }
            public void PreXorInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostXorInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromXorInstruction_value = stack.Pop();
                    context->fromXorInstruction = *cast<ValueObject<Instruction*>*>(fromXorInstruction_value.Get());
                }
            }
            public void PreShlInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostShlInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromShlInstruction_value = stack.Pop();
                    context->fromShlInstruction = *cast<ValueObject<Instruction*>*>(fromShlInstruction_value.Get());
                }
            }
            public void PreShrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostShrInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromShrInstruction_value = stack.Pop();
                    context->fromShrInstruction = *cast<ValueObject<Instruction*>*>(fromShrInstruction_value.Get());
                }
            }
            public void PreEqualInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostEqualInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEqualInstruction_value = stack.Pop();
                    context->fromEqualInstruction = *cast<ValueObject<Instruction*>*>(fromEqualInstruction_value.Get());
                }
            }
            public void PreLessInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->result)));
            }
            public void PostLessInstruction(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLessInstruction_value = stack.Pop();
                    context->fromLessInstruction = *cast<ValueObject<Instruction*>*>(fromLessInstruction_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromAddInstruction(), fromSubInstruction(), fromMulInstruction(), fromDivInstruction(), fromModInstruction(), fromAndInstruction(), fromOrInstruction(), fromXorInstruction(), fromShlInstruction(), fromShrInstruction(), fromEqualInstruction(), fromLessInstruction()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Instruction* fromAddInstruction;
                public Instruction* fromSubInstruction;
                public Instruction* fromMulInstruction;
                public Instruction* fromDivInstruction;
                public Instruction* fromModInstruction;
                public Instruction* fromAndInstruction;
                public Instruction* fromOrInstruction;
                public Instruction* fromXorInstruction;
                public Instruction* fromShlInstruction;
                public Instruction* fromShrInstruction;
                public Instruction* fromEqualInstruction;
                public Instruction* fromLessInstruction;
            }
        }

        public class AddInstructionRule : System.Text.Parsing.RuleParser
        {
            public AddInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AddInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class SubInstructionRule : System.Text.Parsing.RuleParser
        {
            public SubInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SubInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class MulInstructionRule : System.Text.Parsing.RuleParser
        {
            public MulInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new MulInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class DivInstructionRule : System.Text.Parsing.RuleParser
        {
            public DivInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DivInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class ModInstructionRule : System.Text.Parsing.RuleParser
        {
            public ModInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ModInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class AndInstructionRule : System.Text.Parsing.RuleParser
        {
            public AndInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AndInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class OrInstructionRule : System.Text.Parsing.RuleParser
        {
            public OrInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new OrInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class XorInstructionRule : System.Text.Parsing.RuleParser
        {
            public XorInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XorInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class ShlInstructionRule : System.Text.Parsing.RuleParser
        {
            public ShlInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ShlInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class ShrInstructionRule : System.Text.Parsing.RuleParser
        {
            public ShrInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ShrInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class EqualInstructionRule : System.Text.Parsing.RuleParser
        {
            public EqualInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EqualInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class LessInstructionRule : System.Text.Parsing.RuleParser
        {
            public LessInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LessInstruction(context->result, context->fromleft, context->fromright, span.lineNumber);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Value*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Value*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleft(), fromright()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleft;
                public Value* fromright;
            }
        }

        public class ParamInstructionRule : System.Text.Parsing.RuleParser
        {
            public ParamInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ParamInstruction(context->result, span.lineNumber);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
            }
        }

        public class LocalInstructionRule : System.Text.Parsing.RuleParser
        {
            public LocalInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* localTypeNonterminalParser = GetNonterminal(ToUtf32("localType"));
                localTypeNonterminalParser->SetPre(PrelocalType);
                localTypeNonterminalParser->SetPost(PostlocalType);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LocalInstruction(context->result, context->fromlocalType, span.lineNumber);
            }
            public void PrelocalType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostlocalType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlocalType_value = stack.Pop();
                    context->fromlocalType = *cast<ValueObject<Type*>*>(fromlocalType_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromlocalType()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Type* fromlocalType;
            }
        }

        public class LoadInstructionRule : System.Text.Parsing.RuleParser
        {
            public LoadInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* ptrNonterminalParser = GetNonterminal(ToUtf32("ptr"));
                ptrNonterminalParser->SetPre(Preptr);
                ptrNonterminalParser->SetPost(Postptr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LoadInstruction(context->result, context->fromptr, span.lineNumber);
            }
            public void Preptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromptr_value = stack.Pop();
                    context->fromptr = *cast<ValueObject<Value*>*>(fromptr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromptr()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromptr;
            }
        }

        public class ElemAddrInstructionRule : System.Text.Parsing.RuleParser
        {
            public ElemAddrInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* ptrNonterminalParser = GetNonterminal(ToUtf32("ptr"));
                ptrNonterminalParser->SetPre(Preptr);
                ptrNonterminalParser->SetPost(Postptr);
                NonterminalParser* indexNonterminalParser = GetNonterminal(ToUtf32("index"));
                indexNonterminalParser->SetPre(Preindex);
                indexNonterminalParser->SetPost(Postindex);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ElemAddrInstruction(context->result, context->fromptr, context->fromindex, span.lineNumber);
            }
            public void Preptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromptr_value = stack.Pop();
                    context->fromptr = *cast<ValueObject<Value*>*>(fromptr_value.Get());
                }
            }
            public void Preindex(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postindex(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromindex_value = stack.Pop();
                    context->fromindex = *cast<ValueObject<Value*>*>(fromindex_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromptr(), fromindex()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromptr;
                public Value* fromindex;
            }
        }

        public class PtrOffsetInstructionRule : System.Text.Parsing.RuleParser
        {
            public PtrOffsetInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* ptrNonterminalParser = GetNonterminal(ToUtf32("ptr"));
                ptrNonterminalParser->SetPre(Preptr);
                ptrNonterminalParser->SetPost(Postptr);
                NonterminalParser* offsetNonterminalParser = GetNonterminal(ToUtf32("offset"));
                offsetNonterminalParser->SetPre(Preoffset);
                offsetNonterminalParser->SetPost(Postoffset);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new PtrOffsetInstruction(context->result, context->fromptr, context->fromoffset, span.lineNumber);
            }
            public void Preptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postptr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromptr_value = stack.Pop();
                    context->fromptr = *cast<ValueObject<Value*>*>(fromptr_value.Get());
                }
            }
            public void Preoffset(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Postoffset(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromoffset_value = stack.Pop();
                    context->fromoffset = *cast<ValueObject<Value*>*>(fromoffset_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromptr(), fromoffset()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromptr;
                public Value* fromoffset;
            }
        }

        public class PtrDiffInstructionRule : System.Text.Parsing.RuleParser
        {
            public PtrDiffInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* leftPtrNonterminalParser = GetNonterminal(ToUtf32("leftPtr"));
                leftPtrNonterminalParser->SetPre(PreleftPtr);
                leftPtrNonterminalParser->SetPost(PostleftPtr);
                NonterminalParser* rightPtrNonterminalParser = GetNonterminal(ToUtf32("rightPtr"));
                rightPtrNonterminalParser->SetPre(PrerightPtr);
                rightPtrNonterminalParser->SetPost(PostrightPtr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new PtrDiffInstruction(context->result, context->fromleftPtr, context->fromrightPtr, span.lineNumber);
            }
            public void PreleftPtr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostleftPtr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleftPtr_value = stack.Pop();
                    context->fromleftPtr = *cast<ValueObject<Value*>*>(fromleftPtr_value.Get());
                }
            }
            public void PrerightPtr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostrightPtr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromrightPtr_value = stack.Pop();
                    context->fromrightPtr = *cast<ValueObject<Value*>*>(fromrightPtr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromleftPtr(), fromrightPtr()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Value* fromleftPtr;
                public Value* fromrightPtr;
            }
        }

        public class FunctionCallInstructionRule : System.Text.Parsing.RuleParser
        {
            public FunctionCallInstructionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Value*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("Instruction*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<Value*>*>(result_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Instruction*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* functionTypeNonterminalParser = GetNonterminal(ToUtf32("functionType"));
                functionTypeNonterminalParser->SetPre(PrefunctionType);
                functionTypeNonterminalParser->SetPost(PostfunctionType);
                NonterminalParser* calleeNonterminalParser = GetNonterminal(ToUtf32("callee"));
                calleeNonterminalParser->SetPre(Precallee);
                calleeNonterminalParser->SetPost(Postcallee);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new FunctionCallInstruction(context->result, context->fromcallee, span.lineNumber);
            }
            public void PrefunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostfunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfunctionType_value = stack.Pop();
                    context->fromfunctionType = *cast<ValueObject<Type*>*>(fromfunctionType_value.Get());
                }
            }
            public void Precallee(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromfunctionType)));
            }
            public void Postcallee(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcallee_value = stack.Pop();
                    context->fromcallee = *cast<ValueObject<Value*>*>(fromcallee_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), result(), value(), fromfunctionType(), fromcallee()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* result;
                public Instruction* value;
                public Type* fromfunctionType;
                public Value* fromcallee;
            }
        }

        public class OperandRule : System.Text.Parsing.RuleParser
        {
            public OperandRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Value*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* valNonterminalParser = GetNonterminal(ToUtf32("val"));
                valNonterminalParser->SetPre(Preval);
                valNonterminalParser->SetPost(Postval);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromval;
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Type*>*>(fromtype_value.Get());
                }
            }
            public void Preval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->fromtype)));
            }
            public void Postval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromval_value = stack.Pop();
                    context->fromval = *cast<ValueObject<Value*>*>(fromval_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromtype(), fromval()
                {
                }
                public cmsx.intermediate.Context* context;
                public Value* value;
                public Type* fromtype;
                public Value* fromval;
            }
        }

        public class LabelRule : System.Text.Parsing.RuleParser
        {
            public LabelRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("uint"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uint>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* xNonterminalParser = GetNonterminal(ToUtf32("x"));
                xNonterminalParser->SetPost(Postx);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromx;
            }
            public void Postx(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromx_value = stack.Pop();
                    context->fromx = *cast<ValueObject<uint>*>(fromx_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromx()
                {
                }
                public uint value;
                public uint fromx;
            }
        }

        public class ValueRule : System.Text.Parsing.RuleParser
        {
            public ValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Type*"), ToUtf32("type")));
                SetValueTypeName(ToUtf32("Value*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> type_value = stack.Pop();
                context->type = *cast<ValueObject<Type*>*>(type_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* idValueNonterminalParser = GetNonterminal(ToUtf32("IdValue"));
                idValueNonterminalParser->SetPre(PreIdValue);
                idValueNonterminalParser->SetPost(PostIdValue);
                NonterminalParser* symbolValueNonterminalParser = GetNonterminal(ToUtf32("SymbolValue"));
                symbolValueNonterminalParser->SetPre(PreSymbolValue);
                symbolValueNonterminalParser->SetPost(PostSymbolValue);
                NonterminalParser* literalValueNonterminalParser = GetNonterminal(ToUtf32("LiteralValue"));
                literalValueNonterminalParser->SetPre(PreLiteralValue);
                literalValueNonterminalParser->SetPost(PostLiteralValue);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIdValue;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSymbolValue;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLiteralValue;
            }
            public void PreIdValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->type)));
            }
            public void PostIdValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdValue_value = stack.Pop();
                    context->fromIdValue = *cast<ValueObject<Value*>*>(fromIdValue_value.Get());
                }
            }
            public void PreSymbolValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->type)));
            }
            public void PostSymbolValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSymbolValue_value = stack.Pop();
                    context->fromSymbolValue = *cast<ValueObject<Value*>*>(fromSymbolValue_value.Get());
                }
            }
            public void PreLiteralValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
                stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->type)));
            }
            public void PostLiteralValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLiteralValue_value = stack.Pop();
                    context->fromLiteralValue = *cast<ValueObject<Value*>*>(fromLiteralValue_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), type(), value(), fromIdValue(), fromSymbolValue(), fromLiteralValue()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* type;
                public Value* value;
                public Value* fromIdValue;
                public Value* fromSymbolValue;
                public Value* fromLiteralValue;
            }
        }

        public class IdValueRule : System.Text.Parsing.RuleParser
        {
            public IdValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Type*"), ToUtf32("type")));
                SetValueTypeName(ToUtf32("Value*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> type_value = stack.Pop();
                context->type = *cast<ValueObject<Type*>*>(type_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* xNonterminalParser = GetNonterminal(ToUtf32("x"));
                xNonterminalParser->SetPost(Postx);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->currentFunction->MakeIdValue(span.lineNumber, context->fromx, context->type);
            }
            public void Postx(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromx_value = stack.Pop();
                    context->fromx = *cast<ValueObject<uint>*>(fromx_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), type(), value(), fromx()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* type;
                public Value* value;
                public uint fromx;
            }
        }

        public class SymbolValueRule : System.Text.Parsing.RuleParser
        {
            public SymbolValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Type*"), ToUtf32("type")));
                SetValueTypeName(ToUtf32("Value*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> type_value = stack.Pop();
                context->type = *cast<ValueObject<Type*>*>(type_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("identifier"));
                identifierNonterminalParser->SetPost(Postidentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->MakeSymbolValue(span.lineNumber, ToUtf8(context->fromidentifier), context->type);
            }
            public void Postidentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context->fromidentifier = *cast<ValueObject<ustring>*>(fromidentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), type(), value(), fromidentifier()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* type;
                public Value* value;
                public ustring fromidentifier;
            }
        }

        public class LiteralValueRule : System.Text.Parsing.RuleParser
        {
            public LiteralValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("Type*"), ToUtf32("type")));
                SetValueTypeName(ToUtf32("Value*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> type_value = stack.Pop();
                context->type = *cast<ValueObject<Type*>*>(type_value.Get());
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Value*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->MakeLiteralValue(span.lineNumber, ToUtf8(ustring(matchBegin, matchEnd)), context->type);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), type(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* type;
                public Value* value;
            }
        }

        public class TypeDeclarationRule : System.Text.Parsing.RuleParser
        {
            public TypeDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* typeIdNonterminalParser = GetNonterminal(ToUtf32("typeId"));
                typeIdNonterminalParser->SetPre(PretypeId);
                typeIdNonterminalParser->SetPost(PosttypeId);
                NonterminalParser* structureTypeNonterminalParser = GetNonterminal(ToUtf32("StructureType"));
                structureTypeNonterminalParser->SetPre(PreStructureType);
                NonterminalParser* arrayTypeNonterminalParser = GetNonterminal(ToUtf32("ArrayType"));
                arrayTypeNonterminalParser->SetPre(PreArrayType);
                NonterminalParser* functionTypeNonterminalParser = GetNonterminal(ToUtf32("FunctionType"));
                functionTypeNonterminalParser->SetPre(PreFunctionType);
            }
            public void PretypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PosttypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtypeId_value = stack.Pop();
                    context->fromtypeId = *cast<ValueObject<string>*>(fromtypeId_value.Get());
                }
            }
            public void PreStructureType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<string>(context->fromtypeId)));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PreArrayType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<string>(context->fromtypeId)));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PreFunctionType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<string>(context->fromtypeId)));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), fromtypeId()
                {
                }
                public cmsx.intermediate.Context* context;
                public string fromtypeId;
            }
        }

        public class StructureTypeRule : System.Text.Parsing.RuleParser
        {
            public StructureTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("string"), ToUtf32("typeId")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddLocalVariable(AttrOrVar(ToUtf32("List<string>"), ToUtf32("memberTypeIds")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
                UniquePtr<Object> typeId_value = stack.Pop();
                context->typeId = *cast<ValueObject<string>*>(typeId_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* strTypeIdNonterminalParser = GetNonterminal(ToUtf32("StrTypeId"));
                strTypeIdNonterminalParser->SetPre(PreStrTypeId);
                strTypeIdNonterminalParser->SetPost(PostStrTypeId);
                NonterminalParser* longNonterminalParser = GetNonterminal(ToUtf32("long"));
                longNonterminalParser->SetPost(Postlong);
                NonterminalParser* szNonterminalParser = GetNonterminal(ToUtf32("sz"));
                szNonterminalParser->SetPost(Postsz);
                NonterminalParser* alNonterminalParser = GetNonterminal(ToUtf32("al"));
                alNonterminalParser->SetPost(Postal);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->AddStructureType(context->typeId, context->memberTypeIds);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->memberTypeIds.Add(context->fromStrTypeId);
            }
            public void PreStrTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostStrTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStrTypeId_value = stack.Pop();
                    context->fromStrTypeId = *cast<ValueObject<string>*>(fromStrTypeId_value.Get());
                }
            }
            public void Postlong(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlong_value = stack.Pop();
                    context->fromlong = *cast<ValueObject<long>*>(fromlong_value.Get());
                }
            }
            public void Postsz(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsz_value = stack.Pop();
                    context->fromsz = *cast<ValueObject<long>*>(fromsz_value.Get());
                }
            }
            public void Postal(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromal_value = stack.Pop();
                    context->fromal = *cast<ValueObject<long>*>(fromal_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : typeId(), context(), memberTypeIds(), fromStrTypeId(), fromlong(), fromsz(), fromal()
                {
                }
                public string typeId;
                public cmsx.intermediate.Context* context;
                public List<string> memberTypeIds;
                public string fromStrTypeId;
                public long fromlong;
                public long fromsz;
                public long fromal;
            }
        }

        public class ArrayTypeRule : System.Text.Parsing.RuleParser
        {
            public ArrayTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("string"), ToUtf32("typeId")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
                UniquePtr<Object> typeId_value = stack.Pop();
                context->typeId = *cast<ValueObject<string>*>(typeId_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* sizeNonterminalParser = GetNonterminal(ToUtf32("size"));
                sizeNonterminalParser->SetPost(Postsize);
                NonterminalParser* elementTypeIdNonterminalParser = GetNonterminal(ToUtf32("elementTypeId"));
                elementTypeIdNonterminalParser->SetPre(PreelementTypeId);
                elementTypeIdNonterminalParser->SetPost(PostelementTypeId);
                NonterminalParser* szNonterminalParser = GetNonterminal(ToUtf32("sz"));
                szNonterminalParser->SetPost(Postsz);
                NonterminalParser* alNonterminalParser = GetNonterminal(ToUtf32("al"));
                alNonterminalParser->SetPost(Postal);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->AddArrayType(context->typeId, context->fromelementTypeId, context->fromsize);
            }
            public void Postsize(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsize_value = stack.Pop();
                    context->fromsize = *cast<ValueObject<long>*>(fromsize_value.Get());
                }
            }
            public void PreelementTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostelementTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromelementTypeId_value = stack.Pop();
                    context->fromelementTypeId = *cast<ValueObject<string>*>(fromelementTypeId_value.Get());
                }
            }
            public void Postsz(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsz_value = stack.Pop();
                    context->fromsz = *cast<ValueObject<long>*>(fromsz_value.Get());
                }
            }
            public void Postal(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromal_value = stack.Pop();
                    context->fromal = *cast<ValueObject<long>*>(fromal_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : typeId(), context(), fromsize(), fromelementTypeId(), fromsz(), fromal()
                {
                }
                public string typeId;
                public cmsx.intermediate.Context* context;
                public long fromsize;
                public string fromelementTypeId;
                public long fromsz;
                public long fromal;
            }
        }

        public class FunctionTypeRule : System.Text.Parsing.RuleParser
        {
            public FunctionTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("string"), ToUtf32("typeId")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                AddLocalVariable(AttrOrVar(ToUtf32("List<string>"), ToUtf32("paramTypeIds")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
                UniquePtr<Object> typeId_value = stack.Pop();
                context->typeId = *cast<ValueObject<string>*>(typeId_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* returnTypeIdNonterminalParser = GetNonterminal(ToUtf32("returnTypeId"));
                returnTypeIdNonterminalParser->SetPre(PrereturnTypeId);
                returnTypeIdNonterminalParser->SetPost(PostreturnTypeId);
                NonterminalParser* paramTypeNonterminalParser = GetNonterminal(ToUtf32("paramType"));
                paramTypeNonterminalParser->SetPre(PreparamType);
                paramTypeNonterminalParser->SetPost(PostparamType);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->context->AddFunctionType(context->typeId, context->fromreturnTypeId, context->paramTypeIds);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->paramTypeIds.Add(context->fromparamType);
            }
            public void PrereturnTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostreturnTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromreturnTypeId_value = stack.Pop();
                    context->fromreturnTypeId = *cast<ValueObject<string>*>(fromreturnTypeId_value.Get());
                }
            }
            public void PreparamType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostparamType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromparamType_value = stack.Pop();
                    context->fromparamType = *cast<ValueObject<string>*>(fromparamType_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : typeId(), context(), paramTypeIds(), fromreturnTypeId(), fromparamType()
                {
                }
                public string typeId;
                public cmsx.intermediate.Context* context;
                public List<string> paramTypeIds;
                public string fromreturnTypeId;
                public string fromparamType;
            }
        }

        public class StrTypeIdRule : System.Text.Parsing.RuleParser
        {
            public StrTypeIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("string"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<string>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* uintNonterminalParser = GetNonterminal(ToUtf32("uint"));
                uintNonterminalParser->SetPost(Postuint);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ToUtf8(ustring(matchBegin, matchEnd));
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ToUtf8(ustring(matchBegin, matchEnd));
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Append('*');
                context->context->AddPtrType(context->value);
            }
            public void Postuint(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromuint_value = stack.Pop();
                    context->fromuint = *cast<ValueObject<uint>*>(fromuint_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromuint()
                {
                }
                public cmsx.intermediate.Context* context;
                public string value;
                public uint fromuint;
            }
        }

        public class TypeExprRule : System.Text.Parsing.RuleParser
        {
            public TypeExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* postfixTypeExprNonterminalParser = GetNonterminal(ToUtf32("PostfixTypeExpr"));
                postfixTypeExprNonterminalParser->SetPre(PrePostfixTypeExpr);
                postfixTypeExprNonterminalParser->SetPost(PostPostfixTypeExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPostfixTypeExpr;
            }
            public void PrePostfixTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostPostfixTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPostfixTypeExpr_value = stack.Pop();
                    context->fromPostfixTypeExpr = *cast<ValueObject<Type*>*>(fromPostfixTypeExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromPostfixTypeExpr()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
                public Type* fromPostfixTypeExpr;
            }
        }

        public class PostfixTypeExprRule : System.Text.Parsing.RuleParser
        {
            public PostfixTypeExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* primaryTypeExprNonterminalParser = GetNonterminal(ToUtf32("PrimaryTypeExpr"));
                primaryTypeExprNonterminalParser->SetPre(PrePrimaryTypeExpr);
                primaryTypeExprNonterminalParser->SetPost(PostPrimaryTypeExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPrimaryTypeExpr;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetPtrType(context->value);
            }
            public void PrePrimaryTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostPrimaryTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrimaryTypeExpr_value = stack.Pop();
                    context->fromPrimaryTypeExpr = *cast<ValueObject<Type*>*>(fromPrimaryTypeExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromPrimaryTypeExpr()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
                public Type* fromPrimaryTypeExpr;
            }
        }

        public class PrimaryTypeExprRule : System.Text.Parsing.RuleParser
        {
            public PrimaryTypeExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeIdNonterminalParser = GetNonterminal(ToUtf32("TypeId"));
                typeIdNonterminalParser->SetPre(PreTypeId);
                typeIdNonterminalParser->SetPost(PostTypeId);
                NonterminalParser* primitiveTypeNonterminalParser = GetNonterminal(ToUtf32("PrimitiveType"));
                primitiveTypeNonterminalParser->SetPre(PrePrimitiveType);
                primitiveTypeNonterminalParser->SetPost(PostPrimitiveType);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTypeId;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPrimitiveType;
            }
            public void PreTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeId_value = stack.Pop();
                    context->fromTypeId = *cast<ValueObject<Type*>*>(fromTypeId_value.Get());
                }
            }
            public void PrePrimitiveType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostPrimitiveType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrimitiveType_value = stack.Pop();
                    context->fromPrimitiveType = *cast<ValueObject<Type*>*>(fromPrimitiveType_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromTypeId(), fromPrimitiveType()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
                public Type* fromTypeId;
                public Type* fromPrimitiveType;
            }
        }

        public class TypeIdRule : System.Text.Parsing.RuleParser
        {
            public TypeIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* uintNonterminalParser = GetNonterminal(ToUtf32("uint"));
                uintNonterminalParser->SetPost(Postuint);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetTypeById(span.lineNumber, ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public void Postuint(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromuint_value = stack.Pop();
                    context->fromuint = *cast<ValueObject<uint>*>(fromuint_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromuint()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
                public uint fromuint;
            }
        }

        public class PrimitiveTypeRule : System.Text.Parsing.RuleParser
        {
            public PrimitiveTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                NonterminalParser* voidTypeNonterminalParser = GetNonterminal(ToUtf32("VoidType"));
                voidTypeNonterminalParser->SetPre(PreVoidType);
                voidTypeNonterminalParser->SetPost(PostVoidType);
                NonterminalParser* boolTypeNonterminalParser = GetNonterminal(ToUtf32("BoolType"));
                boolTypeNonterminalParser->SetPre(PreBoolType);
                boolTypeNonterminalParser->SetPost(PostBoolType);
                NonterminalParser* sByteTypeNonterminalParser = GetNonterminal(ToUtf32("SByteType"));
                sByteTypeNonterminalParser->SetPre(PreSByteType);
                sByteTypeNonterminalParser->SetPost(PostSByteType);
                NonterminalParser* byteTypeNonterminalParser = GetNonterminal(ToUtf32("ByteType"));
                byteTypeNonterminalParser->SetPre(PreByteType);
                byteTypeNonterminalParser->SetPost(PostByteType);
                NonterminalParser* shortTypeNonterminalParser = GetNonterminal(ToUtf32("ShortType"));
                shortTypeNonterminalParser->SetPre(PreShortType);
                shortTypeNonterminalParser->SetPost(PostShortType);
                NonterminalParser* uShortTypeNonterminalParser = GetNonterminal(ToUtf32("UShortType"));
                uShortTypeNonterminalParser->SetPre(PreUShortType);
                uShortTypeNonterminalParser->SetPost(PostUShortType);
                NonterminalParser* intTypeNonterminalParser = GetNonterminal(ToUtf32("IntType"));
                intTypeNonterminalParser->SetPre(PreIntType);
                intTypeNonterminalParser->SetPost(PostIntType);
                NonterminalParser* uIntTypeNonterminalParser = GetNonterminal(ToUtf32("UIntType"));
                uIntTypeNonterminalParser->SetPre(PreUIntType);
                uIntTypeNonterminalParser->SetPost(PostUIntType);
                NonterminalParser* longTypeNonterminalParser = GetNonterminal(ToUtf32("LongType"));
                longTypeNonterminalParser->SetPre(PreLongType);
                longTypeNonterminalParser->SetPost(PostLongType);
                NonterminalParser* uLongTypeNonterminalParser = GetNonterminal(ToUtf32("ULongType"));
                uLongTypeNonterminalParser->SetPre(PreULongType);
                uLongTypeNonterminalParser->SetPost(PostULongType);
                NonterminalParser* floatTypeNonterminalParser = GetNonterminal(ToUtf32("FloatType"));
                floatTypeNonterminalParser->SetPre(PreFloatType);
                floatTypeNonterminalParser->SetPost(PostFloatType);
                NonterminalParser* doubleTypeNonterminalParser = GetNonterminal(ToUtf32("DoubleType"));
                doubleTypeNonterminalParser->SetPre(PreDoubleType);
                doubleTypeNonterminalParser->SetPost(PostDoubleType);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromVoidType;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBoolType;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSByteType;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromByteType;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromShortType;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUShortType;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIntType;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUIntType;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLongType;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromULongType;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFloatType;
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDoubleType;
            }
            public void PreVoidType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostVoidType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromVoidType_value = stack.Pop();
                    context->fromVoidType = *cast<ValueObject<Type*>*>(fromVoidType_value.Get());
                }
            }
            public void PreBoolType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostBoolType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBoolType_value = stack.Pop();
                    context->fromBoolType = *cast<ValueObject<Type*>*>(fromBoolType_value.Get());
                }
            }
            public void PreSByteType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostSByteType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSByteType_value = stack.Pop();
                    context->fromSByteType = *cast<ValueObject<Type*>*>(fromSByteType_value.Get());
                }
            }
            public void PreByteType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostByteType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromByteType_value = stack.Pop();
                    context->fromByteType = *cast<ValueObject<Type*>*>(fromByteType_value.Get());
                }
            }
            public void PreShortType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostShortType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromShortType_value = stack.Pop();
                    context->fromShortType = *cast<ValueObject<Type*>*>(fromShortType_value.Get());
                }
            }
            public void PreUShortType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostUShortType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUShortType_value = stack.Pop();
                    context->fromUShortType = *cast<ValueObject<Type*>*>(fromUShortType_value.Get());
                }
            }
            public void PreIntType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostIntType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIntType_value = stack.Pop();
                    context->fromIntType = *cast<ValueObject<Type*>*>(fromIntType_value.Get());
                }
            }
            public void PreUIntType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostUIntType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUIntType_value = stack.Pop();
                    context->fromUIntType = *cast<ValueObject<Type*>*>(fromUIntType_value.Get());
                }
            }
            public void PreLongType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostLongType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLongType_value = stack.Pop();
                    context->fromLongType = *cast<ValueObject<Type*>*>(fromLongType_value.Get());
                }
            }
            public void PreULongType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostULongType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromULongType_value = stack.Pop();
                    context->fromULongType = *cast<ValueObject<Type*>*>(fromULongType_value.Get());
                }
            }
            public void PreFloatType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostFloatType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFloatType_value = stack.Pop();
                    context->fromFloatType = *cast<ValueObject<Type*>*>(fromFloatType_value.Get());
                }
            }
            public void PreDoubleType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<cmsx.intermediate.Context*>(context->context)));
            }
            public void PostDoubleType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDoubleType_value = stack.Pop();
                    context->fromDoubleType = *cast<ValueObject<Type*>*>(fromDoubleType_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value(), fromVoidType(), fromBoolType(), fromSByteType(), fromByteType(), fromShortType(), fromUShortType(), fromIntType(), fromUIntType(), fromLongType(), fromULongType(), fromFloatType(), fromDoubleType()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
                public Type* fromVoidType;
                public Type* fromBoolType;
                public Type* fromSByteType;
                public Type* fromByteType;
                public Type* fromShortType;
                public Type* fromUShortType;
                public Type* fromIntType;
                public Type* fromUIntType;
                public Type* fromLongType;
                public Type* fromULongType;
                public Type* fromFloatType;
                public Type* fromDoubleType;
            }
        }

        public class VoidTypeRule : System.Text.Parsing.RuleParser
        {
            public VoidTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetVoidType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class BoolTypeRule : System.Text.Parsing.RuleParser
        {
            public BoolTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetBoolType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class SByteTypeRule : System.Text.Parsing.RuleParser
        {
            public SByteTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetSByteType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class ByteTypeRule : System.Text.Parsing.RuleParser
        {
            public ByteTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetByteType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class ShortTypeRule : System.Text.Parsing.RuleParser
        {
            public ShortTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetShortType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class UShortTypeRule : System.Text.Parsing.RuleParser
        {
            public UShortTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetUShortType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class IntTypeRule : System.Text.Parsing.RuleParser
        {
            public IntTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetIntType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class UIntTypeRule : System.Text.Parsing.RuleParser
        {
            public UIntTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetUIntType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class LongTypeRule : System.Text.Parsing.RuleParser
        {
            public LongTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetLongType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class ULongTypeRule : System.Text.Parsing.RuleParser
        {
            public ULongTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetULongType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class FloatTypeRule : System.Text.Parsing.RuleParser
        {
            public FloatTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetFloatType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public class DoubleTypeRule : System.Text.Parsing.RuleParser
        {
            public DoubleTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("cmsx.intermediate.Context*"), ToUtf32("context")));
                SetValueTypeName(ToUtf32("Type*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> context_value = stack.Pop();
                context->context = *cast<ValueObject<cmsx.intermediate.Context*>*>(context_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Type*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->context->GetDoubleType();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : context(), value()
                {
                }
                public cmsx.intermediate.Context* context;
                public Type* value;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar0 == null)
            {
                grammar0 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("identifier"), this, ToUtf32("System.Text.Parsing.stdlib.identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("newline"), this, ToUtf32("System.Text.Parsing.stdlib.newline")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("uint"), this, ToUtf32("System.Text.Parsing.stdlib.uint")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("long"), this, ToUtf32("System.Text.Parsing.stdlib.long")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("spaces"), this, ToUtf32("System.Text.Parsing.stdlib.spaces")));
            AddRule(new IntermediateCodeFileRule(ToUtf32("IntermediateCodeFile"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.EmptyParser()),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeDeclarations"), ToUtf32("TypeDeclarations"), 1))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Functions"), ToUtf32("Functions"), 1)))));
            AddRule(new TypeDeclarationsRule(ToUtf32("TypeDeclarations"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("types")),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser('{'))),
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("TypeDeclaration"), ToUtf32("TypeDeclaration"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser('}')))))));
            AddRule(new FunctionsRule(ToUtf32("Functions"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.KleeneStarParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Function"), ToUtf32("Function"), 1))));
            AddRule(new FunctionRule(ToUtf32("Function"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("function"), ToUtf32("FunctionHeader"), 1)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser('{'))),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("BasicBlock"), ToUtf32("BasicBlock"), 2))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new FunctionHeaderRule(ToUtf32("FunctionHeader"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("function")),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("functionType"), ToUtf32("TypeExpr"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("functionId"), ToUtf32("identifier"), 0))))));
            AddRule(new BasicBlockRule(ToUtf32("BasicBlock"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.TokenParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("id"), ToUtf32("Label"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.PositiveParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("InstructionLine"), ToUtf32("InstructionLine"), 2))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("EmptyLine"), ToUtf32("EmptyLine"), 0))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("EmptyLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.TokenParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))));
            AddRule(new InstructionLineRule(ToUtf32("InstructionLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Instruction"), ToUtf32("Instruction"), 1)),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new InstructionRule(ToUtf32("Instruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("StoreInstruction"), ToUtf32("StoreInstruction"), 1)),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ArgInstruction"), ToUtf32("ArgInstruction"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("JumpInstruction"), ToUtf32("JumpInstruction"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("BranchInstruction"), ToUtf32("BranchInstruction"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ProcedureCallInstruction"), ToUtf32("ProcedureCallInstruction"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("RetInstruction"), ToUtf32("RetInstruction"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("SwitchInstruction"), ToUtf32("SwitchInstruction"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("ValueInstruction"), ToUtf32("ValueInstruction"), 1)))));
            AddRule(new StoreInstructionRule(ToUtf32("StoreInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("store")),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                    new System.Text.Parsing.ExpectationParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1))),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("val"), ToUtf32("Value"), 2))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ptrType"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ptr"), ToUtf32("Value"), 2)))))));
            AddRule(new ArgInstructionRule(ToUtf32("ArgInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("arg")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Value"), 2)))))));
            AddRule(new JumpInstructionRule(ToUtf32("JumpInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("jmp")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("target"), ToUtf32("Label"), 0)))))));
            AddRule(new BranchInstructionRule(ToUtf32("BranchInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("branch")),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                    new System.Text.Parsing.ExpectationParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1))),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("cond"), ToUtf32("Value"), 2))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("trueTarget"), ToUtf32("Label"), 0))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("falseTarget"), ToUtf32("Label"), 0)))))));
            AddRule(new ProcedureCallInstructionRule(ToUtf32("ProcedureCallInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("call")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("functionType"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("callee"), ToUtf32("Value"), 2)))))));
            AddRule(new RetInstructionRule(ToUtf32("RetInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("ret")),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.KeywordParser(ToUtf32("void"))),
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("val"), ToUtf32("Value"), 2))))))));
            AddRule(new SwitchInstructionRule(ToUtf32("SwitchInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.SequenceParser(
                                                                    new System.Text.Parsing.KeywordParser(ToUtf32("switch")),
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                                new System.Text.Parsing.ExpectationParser(
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1))),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                        new System.Text.Parsing.ExpectationParser(
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("cond"), ToUtf32("Value"), 2))),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                new System.Text.Parsing.ExpectationParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("defaultTarget"), ToUtf32("Label"), 0))))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser('['))),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                        new System.Text.Parsing.ListParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("caseType"), ToUtf32("TypeExpr"), 1),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("caseValue"), ToUtf32("Value"), 2)),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0)),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("caseTarget"), ToUtf32("Label"), 0)))),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                        new System.Text.Parsing.CharParser(':')),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)))))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser(']')))));
            AddRule(new ValueInstructionRule(ToUtf32("ValueInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("result"), ToUtf32("Value"), 2))),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                    new System.Text.Parsing.CharParser('=')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Operation"), ToUtf32("Operation"), 2)))))));
            AddRule(new OperationRule(ToUtf32("Operation"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("UnaryInstruction"), ToUtf32("UnaryInstruction"), 2)),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("BinaryInstruction"), ToUtf32("BinaryInstruction"), 2))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ParamInstruction"), ToUtf32("ParamInstruction"), 2))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("LocalInstruction"), ToUtf32("LocalInstruction"), 2))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("LoadInstruction"), ToUtf32("LoadInstruction"), 2))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ElemAddrInstruction"), ToUtf32("ElemAddrInstruction"), 2))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("PtrOffsetInstruction"), ToUtf32("PtrOffsetInstruction"), 2))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("PtrDiffInstruction"), ToUtf32("PtrDiffInstruction"), 2))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionCallInstruction"), ToUtf32("FunctionCallInstruction"), 2)))));
            AddRule(new UnaryInstructionRule(ToUtf32("UnaryInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NotInstruction"), ToUtf32("NotInstruction"), 2)),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NegInstruction"), ToUtf32("NegInstruction"), 2))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("SignExtendInstruction"), ToUtf32("SignExtendInstruction"), 2))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ZeroExtendInstruction"), ToUtf32("ZeroExtendInstruction"), 2))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("TruncateInstruction"), ToUtf32("TruncateInstruction"), 2))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("BitCastInstruction"), ToUtf32("BitCastInstruction"), 2))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("IntToFloatInstruction"), ToUtf32("IntToFloatInstruction"), 2))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("FloatToIntInstruction"), ToUtf32("FloatToIntInstruction"), 2))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("IntToPtrInstruction"), ToUtf32("IntToPtrInstruction"), 2))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("PtrToIntInstruction"), ToUtf32("PtrToIntInstruction"), 2)))));
            AddRule(new NotInstructionRule(ToUtf32("NotInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("not")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new NegInstructionRule(ToUtf32("NegInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("neg")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new SignExtendInstructionRule(ToUtf32("SignExtendInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("signextend")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new ZeroExtendInstructionRule(ToUtf32("ZeroExtendInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("zeroextend")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new TruncateInstructionRule(ToUtf32("TruncateInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("truncate")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new BitCastInstructionRule(ToUtf32("BitCastInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("bitcast")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new IntToFloatInstructionRule(ToUtf32("IntToFloatInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("inttofloat")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new FloatToIntInstructionRule(ToUtf32("FloatToIntInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("floattoint")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new IntToPtrInstructionRule(ToUtf32("IntToPtrInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("inttoptr")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new PtrToIntInstructionRule(ToUtf32("PtrToIntInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("ptrtoint")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("arg"), ToUtf32("Operand"), 1)))))));
            AddRule(new BinaryInstructionRule(ToUtf32("BinaryInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("AddInstruction"), ToUtf32("AddInstruction"), 2)),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SubInstruction"), ToUtf32("SubInstruction"), 2))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("MulInstruction"), ToUtf32("MulInstruction"), 2))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("DivInstruction"), ToUtf32("DivInstruction"), 2))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ModInstruction"), ToUtf32("ModInstruction"), 2))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("AndInstruction"), ToUtf32("AndInstruction"), 2))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("OrInstruction"), ToUtf32("OrInstruction"), 2))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("XorInstruction"), ToUtf32("XorInstruction"), 2))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ShlInstruction"), ToUtf32("ShlInstruction"), 2))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ShrInstruction"), ToUtf32("ShrInstruction"), 2))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("EqualInstruction"), ToUtf32("EqualInstruction"), 2))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("LessInstruction"), ToUtf32("LessInstruction"), 2)))));
            AddRule(new AddInstructionRule(ToUtf32("AddInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("add")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new SubInstructionRule(ToUtf32("SubInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("sub")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new MulInstructionRule(ToUtf32("MulInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("mul")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new DivInstructionRule(ToUtf32("DivInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("div")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new ModInstructionRule(ToUtf32("ModInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("mod")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new AndInstructionRule(ToUtf32("AndInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("and")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new OrInstructionRule(ToUtf32("OrInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("or")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new XorInstructionRule(ToUtf32("XorInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("xor")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new ShlInstructionRule(ToUtf32("ShlInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("shl")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new ShrInstructionRule(ToUtf32("ShrInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("shr")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new EqualInstructionRule(ToUtf32("EqualInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("equal")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new LessInstructionRule(ToUtf32("LessInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("less")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Operand"), 1)))))));
            AddRule(new ParamInstructionRule(ToUtf32("ParamInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("param")))));
            AddRule(new LocalInstructionRule(ToUtf32("LocalInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("local")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("localType"), ToUtf32("TypeExpr"), 1)))))));
            AddRule(new LoadInstructionRule(ToUtf32("LoadInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("load")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ptr"), ToUtf32("Operand"), 1)))))));
            AddRule(new ElemAddrInstructionRule(ToUtf32("ElemAddrInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("elemaddr")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ptr"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("index"), ToUtf32("Operand"), 1)))))));
            AddRule(new PtrOffsetInstructionRule(ToUtf32("PtrOffsetInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("ptroffset")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ptr"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("offset"), ToUtf32("Operand"), 1)))))));
            AddRule(new PtrDiffInstructionRule(ToUtf32("PtrDiffInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("ptrdiff")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("leftPtr"), ToUtf32("Operand"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Comma"), ToUtf32("Comma"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("rightPtr"), ToUtf32("Operand"), 1)))))));
            AddRule(new FunctionCallInstructionRule(ToUtf32("FunctionCallInstruction"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("call")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("functionType"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("callee"), ToUtf32("Value"), 2)))))));
            AddRule(new OperandRule(ToUtf32("Operand"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("val"), ToUtf32("Value"), 2)))))));
            AddRule(new LabelRule(ToUtf32("Label"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser('@'),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("x"), ToUtf32("uint"), 0))))));
            AddRule(new ValueRule(ToUtf32("Value"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("IdValue"), ToUtf32("IdValue"), 2)),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("SymbolValue"), ToUtf32("SymbolValue"), 2))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("LiteralValue"), ToUtf32("LiteralValue"), 2)))));
            AddRule(new IdValueRule(ToUtf32("IdValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser('$'),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("x"), ToUtf32("uint"), 0))))));
            AddRule(new SymbolValueRule(ToUtf32("SymbolValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser('@'),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("identifier"), ToUtf32("identifier"), 0))))));
            AddRule(new LiteralValueRule(ToUtf32("LiteralValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.PositiveParser(
                            new System.Text.Parsing.TokenParser(
                                new System.Text.Parsing.DifferenceParser(
                                    new System.Text.Parsing.AnyCharParser(),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.CharParser(','),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))))))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("S"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.PositiveParser(
                    new System.Text.Parsing.CharSetParser(ToUtf32(" \t")))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("Comma"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                        new System.Text.Parsing.CharParser(',')),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)))));
            AddRule(new TypeDeclarationRule(ToUtf32("TypeDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("typeId"), ToUtf32("StrTypeId"), 1),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser('='))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("type")))),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("StructureType"), ToUtf32("StructureType"), 2),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ArrayType"), ToUtf32("ArrayType"), 2)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionType"), ToUtf32("FunctionType"), 2))))));
            AddRule(new StructureTypeRule(ToUtf32("StructureType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('{'),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.ListParser(
                                                new System.Text.Parsing.GroupingParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                            new System.Text.Parsing.ExpectationParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("StrTypeId"), ToUtf32("StrTypeId"), 1))),
                                                        new System.Text.Parsing.OptionalParser(
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.SequenceParser(
                                                                    new System.Text.Parsing.SequenceParser(
                                                                        new System.Text.Parsing.SequenceParser(
                                                                            new System.Text.Parsing.CharParser(':'),
                                                                            new System.Text.Parsing.StringParser(ToUtf32("offset"))),
                                                                        new System.Text.Parsing.CharParser('=')),
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("long"), ToUtf32("long"), 0)))))),
                                                new System.Text.Parsing.CharParser(','))))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser('}'))))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("size")),
                                                    new System.Text.Parsing.CharParser('=')),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("sz"), ToUtf32("long"), 0)),
                                            new System.Text.Parsing.CharParser(',')),
                                        new System.Text.Parsing.KeywordParser(ToUtf32("alignment"))),
                                    new System.Text.Parsing.CharParser('=')),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("al"), ToUtf32("long"), 0)))))));
            AddRule(new ArrayTypeRule(ToUtf32("ArrayType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('['),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("size"), ToUtf32("long"), 0))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser('x'))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("elementTypeId"), ToUtf32("StrTypeId"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser(']'))))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("size")),
                                                    new System.Text.Parsing.CharParser('=')),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("sz"), ToUtf32("long"), 0)),
                                            new System.Text.Parsing.CharParser(',')),
                                        new System.Text.Parsing.KeywordParser(ToUtf32("alignment"))),
                                    new System.Text.Parsing.CharParser('=')),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("al"), ToUtf32("long"), 0)))))));
            AddRule(new FunctionTypeRule(ToUtf32("FunctionType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("function")),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("returnTypeId"), ToUtf32("StrTypeId"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser('('))),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.ListParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("paramType"), ToUtf32("StrTypeId"), 1)),
                                            new System.Text.Parsing.CharParser(','))))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')')))))));
            AddRule(new StrTypeIdRule(ToUtf32("StrTypeId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.TokenParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.StringParser(ToUtf32("$T")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("uint"), ToUtf32("uint"), 0)))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.KeywordListParser(ToUtf32("identifier"), keywords0))))),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.CharParser('*'))))))));
            AddRule(new TypeExprRule(ToUtf32("TypeExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("PostfixTypeExpr"), ToUtf32("PostfixTypeExpr"), 1))));
            AddRule(new PostfixTypeExprRule(ToUtf32("PostfixTypeExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("PrimaryTypeExpr"), ToUtf32("PrimaryTypeExpr"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.CharParser('*')))))));
            AddRule(new PrimaryTypeExprRule(ToUtf32("PrimaryTypeExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("TypeId"), ToUtf32("TypeId"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("PrimitiveType"), ToUtf32("PrimitiveType"), 1)))));
            AddRule(new TypeIdRule(ToUtf32("TypeId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.StringParser(ToUtf32("$T")),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("uint"), ToUtf32("uint"), 0))))));
            AddRule(new PrimitiveTypeRule(ToUtf32("PrimitiveType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("VoidType"), ToUtf32("VoidType"), 1)),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("BoolType"), ToUtf32("BoolType"), 1))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("SByteType"), ToUtf32("SByteType"), 1))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ByteType"), ToUtf32("ByteType"), 1))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ShortType"), ToUtf32("ShortType"), 1))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("UShortType"), ToUtf32("UShortType"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("IntType"), ToUtf32("IntType"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("UIntType"), ToUtf32("UIntType"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("LongType"), ToUtf32("LongType"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ULongType"), ToUtf32("ULongType"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("FloatType"), ToUtf32("FloatType"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("DoubleType"), ToUtf32("DoubleType"), 1)))));
            AddRule(new VoidTypeRule(ToUtf32("VoidType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("void")))));
            AddRule(new BoolTypeRule(ToUtf32("BoolType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("bool")))));
            AddRule(new SByteTypeRule(ToUtf32("SByteType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("sbyte")))));
            AddRule(new ByteTypeRule(ToUtf32("ByteType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("byte")))));
            AddRule(new ShortTypeRule(ToUtf32("ShortType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("short")))));
            AddRule(new UShortTypeRule(ToUtf32("UShortType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("ushort")))));
            AddRule(new IntTypeRule(ToUtf32("IntType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("int")))));
            AddRule(new UIntTypeRule(ToUtf32("UIntType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("uint")))));
            AddRule(new LongTypeRule(ToUtf32("LongType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("long")))));
            AddRule(new ULongTypeRule(ToUtf32("ULongType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("ulong")))));
            AddRule(new FloatTypeRule(ToUtf32("FloatType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("float")))));
            AddRule(new DoubleTypeRule(ToUtf32("DoubleType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordParser(ToUtf32("double")))));
            SetSkipRuleName(ToUtf32("spaces"));
        }
        private List<ustring> keywords0;
    }
} // cmsx.intermediate

using System;
using System.Collections;
using System.IO;
using CodeFormatter = System.Text.CodeFormatter;

namespace cmsx.intermediate
{
    public const int printMachineCodeStage = 9999;

    public class CompileUnit
    {
        public nothrow CompileUnit(Context& context_) : context(context_)
        {
        }
        public nothrow void SetFileName(const string& fileName_)
        {
            fileName = fileName_;
        }
        public Function* AddFunction(int lineNumber, Type* type, const string& name)
        {
            if (type is FunctionType*)
            {
                Function* function = new Function(context, cast<FunctionType*>(type), name);
                functions.Add(UniquePtr<Function>(function));
                return function;
            }
            else
            {
                throw Exception("function type expected (" + fileName + ":" + ToString(lineNumber) + ")");
            }
        }
        public void MapInstructions()
        {
            for (const UniquePtr<Function>& function : functions)
            {
                function->MapInstructions();
            }
        }
        public void Validate()
        {
            for (const UniquePtr<Function>& function : functions)
            {
                try
                {
                    function->Validate();
                }
                catch (const Exception& ex)
                {
                    throw Exception("validation of function " + function->name + " in file '" + fileName + "' failed: " + ex.Message());
                }
            }
        }
        public void Print(int stage)
        {
            string filePath;
            if (stage == printMachineCodeStage)
            {
                filePath = Path.ChangeExtension(fileName, ".is");
            }
            else
            {
                filePath = Path.ChangeExtension(fileName, ".i" + ToString(stage));
            }
            StreamWriter writer = File.CreateText(filePath);
            CodeFormatter formatter(writer);
            formatter.SetIndentSize(5);
            context.PrintTypes(formatter);
            formatter.WriteLine();
            bool first = true;
            for (const UniquePtr<Function>& function : functions)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    formatter.WriteLine();
                }
                function->Print(formatter, stage);
            }
            if (Flags.Get(Flag.verbose))
            {
                Console.Out() << "==> " << filePath << endl();
            }
        }
        public nothrow void ComputeLivenessAndNextUse()
        {
            for (const UniquePtr<Function>& function : functions)
            {
                function->ComputeLivenessAndNextUse();
            }
        }
        public GlobalVariable* GetGlobalVariable(const string& globalVariableName) const
        {
            HashMap<string, GlobalVariable*>.ConstIterator it = globalVariableMap.CFind(globalVariableName);
            if (it != globalVariableMap.CEnd())
            {
                return it->second;
            }
            else
            {
                throw Exception("global variable '" + globalVariableName + "' not found");
            }
        }
        public void AddGlobalVariable(Type* type, const string& name, ConstantValue* initializer, int line)
        {
            Location* dataLocation = dataLocations.GetDataLocation(context.GetSymbolOperand(name));
            GlobalVariable* globalVariable = new GlobalVariable(type, name, initializer, line, dataLocation);
            globalVariables.Add(UniquePtr<GlobalVariable>(globalVariable));
            globalVariableMap[name] = globalVariable;
        }
        public void ValidateGlobalVariables()
        {
            for (const UniquePtr<GlobalVariable>& globalVariable : globalVariables)
            {
                globalVariable->Validate();
            }
        }
        public void GenerateCode(MachineCode& machineCode)
        {
            StreamWriter* writer = &Console.Out();
            UniquePtr<StreamWriter> debugWriter;
            if (Flags.Get(Flag.debug))
            {
                string filePath = Path.ChangeExtension(fileName, ".id");
                debugWriter.Reset(new StreamWriter(File.CreateText(filePath)));
                writer = debugWriter.Get();
            }
            CodeFormatter formatter(*writer);
            for (const UniquePtr<GlobalVariable>& globalVariable : globalVariables)
            {
                globalVariable->GenerateDeclaration(machineCode);
            }
            for (const UniquePtr<Function>& function : functions)
            {
                function->GenerateDeclaration(machineCode);
            }
            if (!globalVariables.IsEmpty())
            {
                machineCode.GetInstruction(separatorInstructionOpCode, null);
                machineCode.GetInstruction(cmsx.assembly.DATA, null);
                machineCode.GetInstruction(separatorInstructionOpCode, null);
                for (const UniquePtr<GlobalVariable>& globalVariable : globalVariables)
                {
                    globalVariable->GenerateDefinition(machineCode, context);
                }
                machineCode.GetInstruction(separatorInstructionOpCode, null);
                machineCode.GetInstruction(cmsx.assembly.CODE, null);
            }
            for (const UniquePtr<Function>& function : functions)
            {
                machineCode.GetInstruction(separatorInstructionOpCode, null);
                function->GenerateCode(machineCode, formatter);
            }
        }
        public Context& context;
        public string fileName;
        private List<UniquePtr<GlobalVariable>> globalVariables;
        private HashMap<string, GlobalVariable*> globalVariableMap;
        private List<UniquePtr<Function>> functions;
        private DataLocations dataLocations;
    }
}

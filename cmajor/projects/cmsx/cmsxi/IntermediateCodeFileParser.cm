using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using IntermediateCodeTokens;

// this file has been automatically generated from 'D:/work/cmajorm/cmajor/projects/cmsx/cmsxi/IntermediateCodeFileParser.parser' using soulcm parser generator scmpg version 3.0.0

public static class IntermediateCodeFileParser
{
    public static void Parse(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->WriteBeginRule(u"parse");
                lexer.Log()->IncIndent();
            }
        #endif
        ++lexer;
        System.Lex.Span span = lexer.GetSpan();
        Match match = IntermediateCodeFile(lexer, context);
        if (match.hit)
        {
            if (*lexer == System.Lex.END_TOKEN)
            {
                return;
            }
            else
            {
                lexer.ThrowExpectationFailure(lexer.GetSpan(), GetEndTokenInfo());
            }
        }
        else
        {
            lexer.ThrowExpectationFailure(span, u"IntermediateCodeFile");
        }
        return;
    }
    public static Match IntermediateCodeFile(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IntermediateCodeFile");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                if (match.hit)
                                {
                                    context->SetFileName(lexer.FileName());
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match = IntermediateCodeFileParser.CompileUnitHeader(lexer, context);
                                *parentMatch6 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch8 = &match;
                            {
                                Match match = IntermediateCodeFileParser.TypeDeclarations(lexer, context);
                                if (match.hit)
                                {
                                    *parentMatch8 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch10 = &match;
                        {
                            Match match = IntermediateCodeFileParser.DataDefinitions(lexer, context);
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch12 = &match;
                    {
                        Match match = IntermediateCodeFileParser.Functions(lexer, context);
                        if (match.hit)
                        {
                            *parentMatch12 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch14 = &match;
                {
                    Match match = IntermediateCodeFileParser.Metadata(lexer, context);
                    if (match.hit)
                    {
                        *parentMatch14 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IntermediateCodeFile");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IntermediateCodeFile");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CompileUnitHeader(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CompileUnitHeader");
            }
        #endif
        UniquePtr<Value<string>> cuid;
        UniquePtr<cmsx.intermediate.MDStructRef> mdRef;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == CU)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            Match* parentMatch8 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = IntermediateCodeFileParser.CompileUnitId(lexer);
                                cuid.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch8 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"CompileUnitId");
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == COMMA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    Match match(true);
                    Match* parentMatch12 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.MDStructRef(lexer, context);
                        mdRef.Reset(cast<cmsx.intermediate.MDStructRef*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch12 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"MDStructRef");
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch15 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                        }
                    }
                    if (match.hit)
                    {
                        context->SetCompileUnitInfo(cuid->value, mdRef.Release());
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompileUnitHeader");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CompileUnitHeader");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CompileUnitId(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CompileUnitId");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case HEXNUM: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompileUnitId");
                    #endif
                    return Match(true, new Value<string>(ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
                break;
            }
            case NUMBER: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompileUnitId");
                    #endif
                    return Match(true, new Value<string>(ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
                break;
            }
            case ID: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompileUnitId");
                    #endif
                    return Match(true, new Value<string>(ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompileUnitId");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CompileUnitId");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TypeDeclarations(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TypeDeclarations");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == TYPES)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match = IntermediateCodeFileParser.TypeDeclaration(lexer, context);
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch9 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch9 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        context->ResolveTypes();
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeDeclarations");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TypeDeclarations");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TypeDeclaration(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TypeDeclaration");
            }
        #endif
        string typeId;
        UniquePtr<Value<string>> tid;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                        tid.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            typeId = tid->value;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == ASSIGN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(ASSIGN));
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == TYPE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(TYPE));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch8 = &match;
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.StructureType(lexer, typeId, context);
                            *parentMatch11 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match = IntermediateCodeFileParser.ArrayType(lexer, typeId, context);
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                        }
                        *parentMatch10 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch13 = &match;
                            lexer.SetPos(save);
                            {
                                Match match = IntermediateCodeFileParser.FunctionType(lexer, typeId, context);
                                *parentMatch13 = match;
                            }
                            *parentMatch10 = match;
                        }
                    }
                    *parentMatch9 = match;
                }
                *parentMatch8 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeDeclaration");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TypeDeclaration");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StrTypeId(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StrTypeId");
            }
        #endif
        string str;
        UniquePtr<Value<string>> primitiveTypeName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == TYPEID)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    str = ToUtf8(lexer.GetToken(pos).match.ToString());
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.PrimitiveTypeName(lexer);
                                        primitiveTypeName.Reset(cast<Value<string>*>(match.value));
                                        if (match.hit)
                                        {
                                            str = primitiveTypeName->value;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        Match* parentMatch9 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == AST)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                str.Append('*');
                                                context->AddPtrType(str, span.line);
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StrTypeId");
                    #endif
                    return Match(true, new Value<string>(str));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StrTypeId");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StrTypeId");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StructureType(IntermediateCodeLexer& lexer, string typeId, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StructureType");
            }
        #endif
        List<string> memberTypeIds;
        UniquePtr<Value<string>> tid;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(true);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                                        tid.Reset(cast<Value<string>*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            *parentMatch11 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(span, u"StrTypeId");
                                                        }
                                                    }
                                                    if (match.hit)
                                                    {
                                                        memberTypeIds.Add(tid->value);
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch12 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch13 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch14 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch15 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch16 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch17 = &match;
                                                                    {
                                                                        Match match(false);
                                                                        if (*lexer == COLON)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        *parentMatch17 = match;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch18 = &match;
                                                                        {
                                                                            Match match(false);
                                                                            if (*lexer == OFFSET)
                                                                            {
                                                                                ++lexer;
                                                                                match.hit = true;
                                                                            }
                                                                            *parentMatch18 = match;
                                                                        }
                                                                        *parentMatch17 = match;
                                                                    }
                                                                    *parentMatch16 = match;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch19 = &match;
                                                                    {
                                                                        Match match(false);
                                                                        if (*lexer == ASSIGN)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        *parentMatch19 = match;
                                                                    }
                                                                    *parentMatch16 = match;
                                                                }
                                                                *parentMatch15 = match;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch20 = &match;
                                                                {
                                                                    Match match(false);
                                                                    if (*lexer == NUMBER)
                                                                    {
                                                                        ++lexer;
                                                                        match.hit = true;
                                                                    }
                                                                    *parentMatch20 = match;
                                                                }
                                                                *parentMatch15 = match;
                                                            }
                                                            *parentMatch14 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch13 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch12 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch22 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch23 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == COMMA)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch23 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch24 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch25 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch26 = &match;
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch27 = &match;
                                                                        {
                                                                            long pos = lexer.GetPos();
                                                                            Match match(true);
                                                                            Match* parentMatch28 = &match;
                                                                            {
                                                                                System.Lex.Span span = lexer.GetSpan();
                                                                                Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                                                                tid.Reset(cast<Value<string>*>(match.value));
                                                                                if (match.hit)
                                                                                {
                                                                                    *parentMatch28 = match;
                                                                                }
                                                                                else
                                                                                {
                                                                                    lexer.ThrowExpectationFailure(span, u"StrTypeId");
                                                                                }
                                                                            }
                                                                            if (match.hit)
                                                                            {
                                                                                memberTypeIds.Add(tid->value);
                                                                            }
                                                                            *parentMatch27 = match;
                                                                        }
                                                                        *parentMatch26 = match;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch29 = &match;
                                                                        {
                                                                            Match match(true);
                                                                            long save = lexer.GetPos();
                                                                            Match* parentMatch30 = &match;
                                                                            {
                                                                                Match match(false);
                                                                                Match* parentMatch31 = &match;
                                                                                {
                                                                                    Match match(false);
                                                                                    Match* parentMatch32 = &match;
                                                                                    {
                                                                                        Match match(false);
                                                                                        Match* parentMatch33 = &match;
                                                                                        {
                                                                                            Match match(false);
                                                                                            Match* parentMatch34 = &match;
                                                                                            {
                                                                                                Match match(false);
                                                                                                if (*lexer == COLON)
                                                                                                {
                                                                                                    ++lexer;
                                                                                                    match.hit = true;
                                                                                                }
                                                                                                *parentMatch34 = match;
                                                                                            }
                                                                                            if (match.hit)
                                                                                            {
                                                                                                Match match(false);
                                                                                                Match* parentMatch35 = &match;
                                                                                                {
                                                                                                    Match match(false);
                                                                                                    if (*lexer == OFFSET)
                                                                                                    {
                                                                                                        ++lexer;
                                                                                                        match.hit = true;
                                                                                                    }
                                                                                                    *parentMatch35 = match;
                                                                                                }
                                                                                                *parentMatch34 = match;
                                                                                            }
                                                                                            *parentMatch33 = match;
                                                                                        }
                                                                                        if (match.hit)
                                                                                        {
                                                                                            Match match(false);
                                                                                            Match* parentMatch36 = &match;
                                                                                            {
                                                                                                Match match(false);
                                                                                                if (*lexer == ASSIGN)
                                                                                                {
                                                                                                    ++lexer;
                                                                                                    match.hit = true;
                                                                                                }
                                                                                                *parentMatch36 = match;
                                                                                            }
                                                                                            *parentMatch33 = match;
                                                                                        }
                                                                                        *parentMatch32 = match;
                                                                                    }
                                                                                    if (match.hit)
                                                                                    {
                                                                                        Match match(false);
                                                                                        Match* parentMatch37 = &match;
                                                                                        {
                                                                                            Match match(false);
                                                                                            if (*lexer == NUMBER)
                                                                                            {
                                                                                                ++lexer;
                                                                                                match.hit = true;
                                                                                            }
                                                                                            *parentMatch37 = match;
                                                                                        }
                                                                                        *parentMatch32 = match;
                                                                                    }
                                                                                    *parentMatch31 = match;
                                                                                }
                                                                                if (match.hit)
                                                                                {
                                                                                    *parentMatch30 = match;
                                                                                }
                                                                                else
                                                                                {
                                                                                    lexer.SetPos(save);
                                                                                }
                                                                            }
                                                                            *parentMatch29 = match;
                                                                        }
                                                                        *parentMatch26 = match;
                                                                    }
                                                                    *parentMatch25 = match;
                                                                }
                                                                *parentMatch24 = match;
                                                            }
                                                            *parentMatch23 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch22 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch38 = &match;
                        {
                            Match match(true);
                            Match* parentMatch39 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == RBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch39 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                                }
                            }
                            *parentMatch38 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    context->AddStructureType(typeId, memberTypeIds);
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch40 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch41 = &match;
                {
                    Match match(false);
                    Match* parentMatch42 = &match;
                    {
                        Match match(false);
                        Match* parentMatch43 = &match;
                        {
                            Match match(false);
                            Match* parentMatch44 = &match;
                            {
                                Match match(false);
                                Match* parentMatch45 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch46 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch47 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch48 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == SIZE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch48 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch49 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == ASSIGN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch49 = match;
                                                }
                                                *parentMatch48 = match;
                                            }
                                            *parentMatch47 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch50 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == NUMBER)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch50 = match;
                                            }
                                            *parentMatch47 = match;
                                        }
                                        *parentMatch46 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch51 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == COMMA)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch51 = match;
                                        }
                                        *parentMatch46 = match;
                                    }
                                    *parentMatch45 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch52 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == ALIGNMENT)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch52 = match;
                                    }
                                    *parentMatch45 = match;
                                }
                                *parentMatch44 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch53 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == ASSIGN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch53 = match;
                                }
                                *parentMatch44 = match;
                            }
                            *parentMatch43 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch54 = &match;
                            {
                                Match match(false);
                                if (*lexer == NUMBER)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch54 = match;
                            }
                            *parentMatch43 = match;
                        }
                        *parentMatch42 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch41 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch40 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StructureType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StructureType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ArrayType(IntermediateCodeLexer& lexer, string typeId, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ArrayType");
            }
        #endif
        long size;
        UniquePtr<Value<string>> elementTypeId;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == LBRACKET)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            Match* parentMatch9 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == NUMBER)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch9 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, GetTokenName(NUMBER));
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                size = ParseLong(ToUtf8(lexer.GetToken(pos).match.ToString()));
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        bool pass = true;
                                        Match match(false);
                                        if (*lexer == ID)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            pass = lexer.GetToken(pos).match.ToString() == u"x";
                                        }
                                        if (match.hit && !pass)
                                        {
                                            match = Match(false);
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                Match match(true);
                                Match* parentMatch13 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                    elementTypeId.Reset(cast<Value<string>*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch13 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"StrTypeId");
                                    }
                                }
                                *parentMatch12 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch14 = &match;
                        {
                            Match match(true);
                            Match* parentMatch15 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == RBRACKET)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch15 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(RBRACKET));
                                }
                            }
                            *parentMatch14 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    context->AddArrayType(typeId, elementTypeId->value, size);
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch16 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch17 = &match;
                {
                    Match match(false);
                    Match* parentMatch18 = &match;
                    {
                        Match match(false);
                        Match* parentMatch19 = &match;
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            {
                                Match match(false);
                                Match* parentMatch21 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch22 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch23 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch24 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == SIZE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch24 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch25 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == ASSIGN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch25 = match;
                                                }
                                                *parentMatch24 = match;
                                            }
                                            *parentMatch23 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch26 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == NUMBER)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch26 = match;
                                            }
                                            *parentMatch23 = match;
                                        }
                                        *parentMatch22 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch27 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == COMMA)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch27 = match;
                                        }
                                        *parentMatch22 = match;
                                    }
                                    *parentMatch21 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch28 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == ALIGNMENT)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch28 = match;
                                    }
                                    *parentMatch21 = match;
                                }
                                *parentMatch20 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch29 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == ASSIGN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch29 = match;
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch19 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch30 = &match;
                            {
                                Match match(false);
                                if (*lexer == NUMBER)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch30 = match;
                            }
                            *parentMatch19 = match;
                        }
                        *parentMatch18 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch17 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch16 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ArrayType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ArrayType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match FunctionType(IntermediateCodeLexer& lexer, string typeId, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"FunctionType");
            }
        #endif
        List<string> paramTypeIds;
        UniquePtr<Value<string>> returnTypeId;
        UniquePtr<Value<string>> paramType;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == FUNCTION)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch7 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                        returnTypeId.Reset(cast<Value<string>*>(match.value));
                                        if (match.hit)
                                        {
                                            *parentMatch7 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, u"StrTypeId");
                                        }
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch11 = &match;
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch14 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                            paramType.Reset(cast<Value<string>*>(match.value));
                                            if (match.hit)
                                            {
                                                paramTypeIds.Add(paramType->value);
                                            }
                                            *parentMatch14 = match;
                                        }
                                        *parentMatch13 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch16 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch17 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == COMMA)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch17 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch18 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch19 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = IntermediateCodeFileParser.StrTypeId(lexer, context);
                                                                    paramType.Reset(cast<Value<string>*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        paramTypeIds.Add(paramType->value);
                                                                    }
                                                                    *parentMatch19 = match;
                                                                }
                                                                *parentMatch18 = match;
                                                            }
                                                            *parentMatch17 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch16 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch11 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch20 = &match;
                    {
                        Match match(true);
                        Match* parentMatch21 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch21 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                            }
                        }
                        *parentMatch20 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                context->AddFunctionType(typeId, returnTypeId->value, paramTypeIds);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FunctionType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"FunctionType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DataDefinitions(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DataDefinitions");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == DATA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LBRACE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            Match* parentMatch8 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match = IntermediateCodeFileParser.DataDefinition(lexer, context);
                                        if (match.hit)
                                        {
                                            *parentMatch8 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                context->ValidateGlobalVariables();
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DataDefinitions");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DataDefinitions");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DataDefinition(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DataDefinition");
            }
        #endif
        bool once;
        string variableName;
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.ConstantValue> constant;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                        if (match.hit)
                        {
                            type = t.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ONCE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        once = true;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(ID));
                            }
                        }
                        if (match.hit)
                        {
                            variableName = ToUtf8(lexer.GetToken(pos).match.ToString());
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch8 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch11 = &match;
            {
                Match match(false);
                Match* parentMatch12 = &match;
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch14 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == SEMICOLON)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                context->AddGlobalVariable(type, variableName, cast<cmsx.intermediate.ConstantValue*>(null), span.line, once);
                            }
                            *parentMatch14 = match;
                        }
                        *parentMatch13 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch15 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch16 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch17 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == ASSIGN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch17 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, GetTokenName(ASSIGN));
                                        }
                                    }
                                    *parentMatch16 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch18 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch19 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                            constant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                            if (match.hit)
                                            {
                                                context->AddGlobalVariable(type, variableName, constant.Release(), span.line, once);
                                            }
                                            *parentMatch19 = match;
                                        }
                                        *parentMatch18 = match;
                                    }
                                    *parentMatch16 = match;
                                }
                                *parentMatch15 = match;
                            }
                            *parentMatch13 = match;
                        }
                    }
                    *parentMatch12 = match;
                }
                *parentMatch11 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DataDefinition");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DataDefinition");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Functions(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Functions");
            }
        #endif
        Match match(true);
        Match* parentMatch0 = &match;
        {
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match = IntermediateCodeFileParser.Function(lexer, context);
                    if (match.hit)
                    {
                        *parentMatch0 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Functions");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Functions");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Function(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Function");
            }
        #endif
        cmsx.intermediate.Function* function;
        UniquePtr<cmsx.intermediate.Function> fun;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.FunctionHeader(lexer, context);
                        fun.Reset(cast<cmsx.intermediate.Function*>(match.value));
                        if (match.hit)
                        {
                            function = fun.Release();
                            context->SetCurrentFunction(function);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match = IntermediateCodeFileParser.BasicBlock(lexer, context, function);
                                if (match.hit)
                                {
                                    *parentMatch7 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch8 = &match;
            {
                Match match(true);
                Match* parentMatch9 = &match;
                {
                    System.Lex.Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch9 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                    }
                }
                *parentMatch8 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Function");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Function");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match FunctionHeader(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"FunctionHeader");
            }
        #endif
        bool once;
        string functionId;
        cmsx.intermediate.Type* functionType;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.MDStructRef> md;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == FUNCTION)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                    t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                    }
                                }
                                if (match.hit)
                                {
                                    functionType = t.Release();
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ONCE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        once = true;
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch8 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch13 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch13 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(ID));
                            }
                        }
                        if (match.hit)
                        {
                            functionId = ToUtf8(lexer.GetToken(pos).match.ToString());
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch11 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch14 = &match;
            {
                Match match(false);
                Match* parentMatch15 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    Match* parentMatch16 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch17 = &match;
                        {
                            Match match = IntermediateCodeFileParser.MDStructRef(lexer, context);
                            md.Reset(cast<cmsx.intermediate.MDStructRef*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch17 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch16 = match;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FunctionHeader");
                            #endif
                            return Match(true, context->AddFunction(span.line, functionType, functionId, once, md.Release()));
                        }
                    }
                    *parentMatch15 = match;
                }
                *parentMatch14 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FunctionHeader");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"FunctionHeader");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BasicBlock(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Function* function)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BasicBlock");
            }
        #endif
        cmsx.intermediate.BasicBlock* bb;
        UniquePtr<Value<uint>> id;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = IntermediateCodeFileParser.Label(lexer);
                id.Reset(cast<Value<uint>*>(match.value));
                if (match.hit)
                {
                    bb = function->AddBasicBlock(id->value);
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match = IntermediateCodeFileParser.Instructions(lexer, context, bb);
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BasicBlock");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BasicBlock");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Label(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Label");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == AT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                            #endif
                            return Match(true, new Value<uint>(ParseUInt(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Label");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Instructions(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.BasicBlock* bb)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Instructions");
            }
        #endif
        UniquePtr<cmsx.intermediate.Instruction> instruction;
        UniquePtr<cmsx.intermediate.MDStructRef> lineInfo;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = IntermediateCodeFileParser.Instruction(lexer, context);
                            instruction.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match = IntermediateCodeFileParser.MDStructRef(lexer, context);
                                        lineInfo.Reset(cast<cmsx.intermediate.MDStructRef*>(match.value));
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        bb->AddInstruction(instruction.Release(), lineInfo.Release());
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(true);
            Match* parentMatch8 = &match;
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match = IntermediateCodeFileParser.Instruction(lexer, context);
                                    instruction.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                    *parentMatch12 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match(true);
                                        long save = lexer.GetPos();
                                        Match* parentMatch14 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                Match match = IntermediateCodeFileParser.MDStructRef(lexer, context);
                                                lineInfo.Reset(cast<cmsx.intermediate.MDStructRef*>(match.value));
                                                *parentMatch15 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch14 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                            }
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                            if (match.hit)
                            {
                                bb->AddInstruction(instruction.Release(), lineInfo.Release());
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch9 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch8 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instructions");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Instructions");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Instruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Instruction");
            }
        #endif
        UniquePtr<cmsx.intermediate.Instruction> store;
        UniquePtr<cmsx.intermediate.Instruction> arg;
        UniquePtr<cmsx.intermediate.Instruction> jmp;
        UniquePtr<cmsx.intermediate.Instruction> branch;
        UniquePtr<cmsx.intermediate.Instruction> call;
        UniquePtr<cmsx.intermediate.Instruction> ret;
        UniquePtr<cmsx.intermediate.SwitchInstruction> swtch;
        UniquePtr<cmsx.intermediate.Instruction> valueInst;
        UniquePtr<cmsx.intermediate.Instruction> nopInst;
        UniquePtr<cmsx.intermediate.Instruction> saveInst;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = IntermediateCodeFileParser.StoreInstruction(lexer, context);
                                                store.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                        #endif
                                                        return Match(true, store.Release());
                                                    }
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = IntermediateCodeFileParser.ArgInstruction(lexer, context);
                                                        arg.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                                #endif
                                                                return Match(true, arg.Release());
                                                            }
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch12 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = IntermediateCodeFileParser.JumpInstruction(lexer, context);
                                                    jmp.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                            #endif
                                                            return Match(true, jmp.Release());
                                                        }
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch14 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = IntermediateCodeFileParser.BranchInstruction(lexer, context);
                                                branch.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                        #endif
                                                        return Match(true, branch.Release());
                                                    }
                                                }
                                                *parentMatch15 = match;
                                            }
                                            *parentMatch14 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch16 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch17 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = IntermediateCodeFileParser.ProcedureCallInstruction(lexer, context);
                                            call.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                    #endif
                                                    return Match(true, call.Release());
                                                }
                                            }
                                            *parentMatch17 = match;
                                        }
                                        *parentMatch16 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.RetInstruction(lexer, context);
                                        ret.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                                #endif
                                                return Match(true, ret.Release());
                                            }
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch21 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.SwitchInstruction(lexer, context);
                                    swtch.Reset(cast<cmsx.intermediate.SwitchInstruction*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                            #endif
                                            return Match(true, swtch.Release());
                                        }
                                    }
                                    *parentMatch21 = match;
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch22 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch23 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = IntermediateCodeFileParser.ValueInstruction(lexer, context);
                                valueInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                        #endif
                                        return Match(true, valueInst.Release());
                                    }
                                }
                                *parentMatch23 = match;
                            }
                            *parentMatch22 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch24 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch25 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.NoOperationInstruction(lexer, context);
                            nopInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                    #endif
                                    return Match(true, nopInst.Release());
                                }
                            }
                            *parentMatch25 = match;
                        }
                        *parentMatch24 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch26 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch27 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.SaveInstruction(lexer, context);
                        saveInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                                #endif
                                return Match(true, saveInst.Release());
                            }
                        }
                        *parentMatch27 = match;
                    }
                    *parentMatch26 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Instruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Instruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StoreInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StoreInstruction");
            }
        #endif
        cmsx.intermediate.Type* type;
        cmsx.intermediate.Type* ptrType;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> val;
        UniquePtr<cmsx.intermediate.Type> pt;
        UniquePtr<cmsx.intermediate.Value> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == STORE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(true);
                                    Match* parentMatch7 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                        if (match.hit)
                                        {
                                            *parentMatch7 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        type = t.Release();
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(true);
                            Match* parentMatch9 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                                val.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"TypedValue");
                                }
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        Match match(true);
                        Match* parentMatch11 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == COMMA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                            }
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch12 = &match;
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch14 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                            pt.Reset(cast<cmsx.intermediate.Type*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch14 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypeExpr");
                            }
                        }
                        if (match.hit)
                        {
                            ptrType = pt.Release();
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch12 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch15 = &match;
            {
                Match match(false);
                Match* parentMatch16 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch17 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.TypedValue(lexer, context, ptrType);
                        ptr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch17 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"TypedValue");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StoreInstruction");
                            #endif
                            return Match(true, new cmsx.intermediate.StoreInstruction(val.Release(), ptr.Release(), span.line));
                        }
                    }
                    *parentMatch16 = match;
                }
                *parentMatch15 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StoreInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StoreInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ArgInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ArgInstruction");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> arg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == ARG)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                            t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypeExpr");
                            }
                        }
                        if (match.hit)
                        {
                            type = t.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                        arg.Reset(cast<cmsx.intermediate.Value*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"TypedValue");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ArgInstruction");
                            #endif
                            return Match(true, new cmsx.intermediate.ArgInstruction(arg.Release(), span.line));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ArgInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ArgInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match JumpInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"JumpInstruction");
            }
        #endif
        UniquePtr<Value<uint>> target;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == JMP)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch3 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.Label(lexer);
                        target.Reset(cast<Value<uint>*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch3 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"Label");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"JumpInstruction");
                            #endif
                            return Match(true, new cmsx.intermediate.JumpInstruction(target->value, span.line));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"JumpInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"JumpInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BranchInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BranchInstruction");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> cond;
        UniquePtr<Value<uint>> trueTarget;
        UniquePtr<Value<uint>> falseTarget;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == BRANCH)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(true);
                                        Match* parentMatch8 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                            t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                            if (match.hit)
                                            {
                                                *parentMatch8 = match;
                                            }
                                            else
                                            {
                                                lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            type = t.Release();
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(true);
                                Match* parentMatch10 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                                    cond.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch10 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"TypedValue");
                                    }
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match(true);
                            Match* parentMatch12 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == COMMA)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch12 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                }
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        Match match(true);
                        Match* parentMatch14 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Label(lexer);
                            trueTarget.Reset(cast<Value<uint>*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch14 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Label");
                            }
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch15 = &match;
                {
                    Match match(true);
                    Match* parentMatch16 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == COMMA)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch16 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                        }
                    }
                    *parentMatch15 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch17 = &match;
            {
                Match match(false);
                Match* parentMatch18 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch19 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.Label(lexer);
                        falseTarget.Reset(cast<Value<uint>*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch19 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"Label");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BranchInstruction");
                            #endif
                            return Match(true, new cmsx.intermediate.BranchInstruction(cond.Release(), trueTarget->value, falseTarget->value, span.line));
                        }
                    }
                    *parentMatch18 = match;
                }
                *parentMatch17 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BranchInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BranchInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ProcedureCallInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ProcedureCallInstruction");
            }
        #endif
        cmsx.intermediate.Type* functionType;
        UniquePtr<cmsx.intermediate.Type> ft;
        UniquePtr<cmsx.intermediate.Value> callee;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == CALL)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                            ft.Reset(cast<cmsx.intermediate.Type*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypeExpr");
                            }
                        }
                        if (match.hit)
                        {
                            functionType = ft.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.TypedValue(lexer, context, functionType);
                        callee.Reset(cast<cmsx.intermediate.Value*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"TypedValue");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ProcedureCallInstruction");
                            #endif
                            return Match(true, new cmsx.intermediate.ProcedureCallInstruction(callee.Release(), span.line));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ProcedureCallInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ProcedureCallInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RetInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RetInstruction");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> val;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == RET)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    if (*lexer == VOID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long tmp = lexer.GetPos();
                                        lexer.SetPos(save);
                                        save = tmp;
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == VOID)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == AST)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (!match.hit)
                                    {
                                        lexer.SetPos(save);
                                    }
                                    *parentMatch6 = Match(!match.hit, match.value);
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RetInstruction");
                                    #endif
                                    return Match(true, new cmsx.intermediate.RetInstruction(null, span.line));
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                        if (match.hit)
                                        {
                                            type = t.Release();
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                                            val.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RetInstruction");
                                                    #endif
                                                    return Match(true, new cmsx.intermediate.RetInstruction(val.Release(), span.line));
                                                }
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RetInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RetInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SwitchInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SwitchInstruction");
            }
        #endif
        cmsx.intermediate.SwitchInstruction* inst;
        cmsx.intermediate.Type* type;
        cmsx.intermediate.Type* caseType;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> cond;
        UniquePtr<Value<uint>> defaultTarget;
        UniquePtr<cmsx.intermediate.Type> ct;
        UniquePtr<cmsx.intermediate.Value> caseValue;
        UniquePtr<Value<uint>> caseTarget;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == SWITCH)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(true);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            *parentMatch11 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                                        }
                                                    }
                                                    if (match.hit)
                                                    {
                                                        type = t.Release();
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch13 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                                                cond.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch13 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"TypedValue");
                                                }
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(true);
                                            Match* parentMatch16 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = IntermediateCodeFileParser.Label(lexer);
                                                defaultTarget.Reset(cast<Value<uint>*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch16 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"Label");
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                inst = new cmsx.intermediate.SwitchInstruction(cond.Release(), defaultTarget->value, span.line);
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch17 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch18 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == COMMA)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch18 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                        }
                                    }
                                    *parentMatch17 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch19 = &match;
                            {
                                Match match(true);
                                Match* parentMatch20 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LBRACKET)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch20 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LBRACKET));
                                    }
                                }
                                *parentMatch19 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch21 = &match;
                        {
                            Match match(false);
                            Match* parentMatch22 = &match;
                            {
                                Match match(false);
                                Match* parentMatch23 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch24 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch25 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch26 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch27 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch28 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch29 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                                            ct.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                caseType = ct.Release();
                                                            }
                                                            *parentMatch29 = match;
                                                        }
                                                        *parentMatch28 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch30 = &match;
                                                        {
                                                            Match match = IntermediateCodeFileParser.TypedValue(lexer, context, caseType);
                                                            caseValue.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                                            *parentMatch30 = match;
                                                        }
                                                        *parentMatch28 = match;
                                                    }
                                                    *parentMatch27 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch31 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == COMMA)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch31 = match;
                                                    }
                                                    *parentMatch27 = match;
                                                }
                                                *parentMatch26 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch32 = &match;
                                                {
                                                    Match match = IntermediateCodeFileParser.Label(lexer);
                                                    caseTarget.Reset(cast<Value<uint>*>(match.value));
                                                    *parentMatch32 = match;
                                                }
                                                *parentMatch26 = match;
                                            }
                                            *parentMatch25 = match;
                                        }
                                        if (match.hit)
                                        {
                                            inst->AddCase(caseValue.Release(), caseTarget->value);
                                        }
                                        *parentMatch24 = match;
                                    }
                                    *parentMatch23 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch33 = &match;
                                    {
                                        Match match(true);
                                        Match* parentMatch34 = &match;
                                        {
                                            while (true)
                                            {
                                                long save = lexer.GetPos();
                                                {
                                                    Match match(false);
                                                    Match* parentMatch35 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == COLON)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch35 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch36 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch37 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match(false);
                                                                Match* parentMatch38 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch39 = &match;
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch40 = &match;
                                                                        {
                                                                            Match match(false);
                                                                            Match* parentMatch41 = &match;
                                                                            {
                                                                                Match match(false);
                                                                                Match* parentMatch42 = &match;
                                                                                {
                                                                                    long pos = lexer.GetPos();
                                                                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                                                                    ct.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                                                                    if (match.hit)
                                                                                    {
                                                                                        caseType = ct.Release();
                                                                                    }
                                                                                    *parentMatch42 = match;
                                                                                }
                                                                                *parentMatch41 = match;
                                                                            }
                                                                            if (match.hit)
                                                                            {
                                                                                Match match(false);
                                                                                Match* parentMatch43 = &match;
                                                                                {
                                                                                    Match match = IntermediateCodeFileParser.TypedValue(lexer, context, caseType);
                                                                                    caseValue.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                                                                    *parentMatch43 = match;
                                                                                }
                                                                                *parentMatch41 = match;
                                                                            }
                                                                            *parentMatch40 = match;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            Match match(false);
                                                                            Match* parentMatch44 = &match;
                                                                            {
                                                                                Match match(false);
                                                                                if (*lexer == COMMA)
                                                                                {
                                                                                    ++lexer;
                                                                                    match.hit = true;
                                                                                }
                                                                                *parentMatch44 = match;
                                                                            }
                                                                            *parentMatch40 = match;
                                                                        }
                                                                        *parentMatch39 = match;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch45 = &match;
                                                                        {
                                                                            Match match = IntermediateCodeFileParser.Label(lexer);
                                                                            caseTarget.Reset(cast<Value<uint>*>(match.value));
                                                                            *parentMatch45 = match;
                                                                        }
                                                                        *parentMatch39 = match;
                                                                    }
                                                                    *parentMatch38 = match;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    inst->AddCase(caseValue.Release(), caseTarget->value);
                                                                }
                                                                *parentMatch37 = match;
                                                            }
                                                            *parentMatch36 = match;
                                                        }
                                                        *parentMatch35 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch34 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.SetPos(save);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        *parentMatch33 = match;
                                    }
                                    *parentMatch23 = match;
                                }
                                *parentMatch22 = match;
                            }
                            *parentMatch21 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch46 = &match;
                    {
                        Match match(true);
                        Match* parentMatch47 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RBRACKET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch47 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RBRACKET));
                            }
                        }
                        *parentMatch46 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchInstruction");
                    #endif
                    return Match(true, inst);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SwitchInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ValueInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ValueInstruction");
            }
        #endif
        cmsx.intermediate.Type* type;
        cmsx.intermediate.Value* result;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> r;
        UniquePtr<cmsx.intermediate.Instruction> op;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                        if (match.hit)
                        {
                            type = t.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(true);
                            Match* parentMatch6 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                                r.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"TypedValue");
                                }
                            }
                            if (match.hit)
                            {
                                result = r.Release();
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    Match match(false);
                    if (*lexer == ASSIGN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch7 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch8 = &match;
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch10 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.Operation(lexer, context, result);
                        op.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch10 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"Operation");
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ValueInstruction");
                            #endif
                            return Match(true, op.Release());
                        }
                    }
                    *parentMatch9 = match;
                }
                *parentMatch8 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ValueInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ValueInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Operation(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Operation");
            }
        #endif
        UniquePtr<cmsx.intermediate.Instruction> unaryInst;
        UniquePtr<cmsx.intermediate.Instruction> binaryInst;
        UniquePtr<cmsx.intermediate.Instruction> paramInst;
        UniquePtr<cmsx.intermediate.Instruction> localInst;
        UniquePtr<cmsx.intermediate.Instruction> loadInst;
        UniquePtr<cmsx.intermediate.Instruction> elemAddrInst;
        UniquePtr<cmsx.intermediate.Instruction> ptrOffsetInst;
        UniquePtr<cmsx.intermediate.Instruction> ptrDiffInst;
        UniquePtr<cmsx.intermediate.Instruction> functionCallInst;
        UniquePtr<cmsx.intermediate.Instruction> trapInst;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = IntermediateCodeFileParser.UnaryInstruction(lexer, context, result);
                                                unaryInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                        #endif
                                                        return Match(true, unaryInst.Release());
                                                    }
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = IntermediateCodeFileParser.BinaryInstruction(lexer, context, result);
                                                        binaryInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                                #endif
                                                                return Match(true, binaryInst.Release());
                                                            }
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch12 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = IntermediateCodeFileParser.ParamInstruction(lexer, context, result);
                                                    paramInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                            #endif
                                                            return Match(true, paramInst.Release());
                                                        }
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch14 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = IntermediateCodeFileParser.LocalInstruction(lexer, context, result);
                                                localInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                        #endif
                                                        return Match(true, localInst.Release());
                                                    }
                                                }
                                                *parentMatch15 = match;
                                            }
                                            *parentMatch14 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch16 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch17 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = IntermediateCodeFileParser.LoadInstruction(lexer, context, result);
                                            loadInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                    #endif
                                                    return Match(true, loadInst.Release());
                                                }
                                            }
                                            *parentMatch17 = match;
                                        }
                                        *parentMatch16 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.ElemAddrInstruction(lexer, context, result);
                                        elemAddrInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                                #endif
                                                return Match(true, elemAddrInst.Release());
                                            }
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch21 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.PtrOffsetInstruction(lexer, context, result);
                                    ptrOffsetInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                            #endif
                                            return Match(true, ptrOffsetInst.Release());
                                        }
                                    }
                                    *parentMatch21 = match;
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch22 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch23 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = IntermediateCodeFileParser.PtrDiffInstruction(lexer, context, result);
                                ptrDiffInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                        #endif
                                        return Match(true, ptrDiffInst.Release());
                                    }
                                }
                                *parentMatch23 = match;
                            }
                            *parentMatch22 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch24 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch25 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.FunctionCallInstruction(lexer, context, result);
                            functionCallInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                    #endif
                                    return Match(true, functionCallInst.Release());
                                }
                            }
                            *parentMatch25 = match;
                        }
                        *parentMatch24 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch26 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch27 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.TrapInstruction(lexer, context, result);
                        trapInst.Reset(cast<cmsx.intermediate.Instruction*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                                #endif
                                return Match(true, trapInst.Release());
                            }
                        }
                        *parentMatch27 = match;
                    }
                    *parentMatch26 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operation");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Operation");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UnaryInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UnaryInstruction");
            }
        #endif
        cmsx.intermediate.UnaryInstruction* inst;
        UniquePtr<cmsx.intermediate.UnaryInstruction> unaryInst;
        UniquePtr<cmsx.intermediate.Value> arg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = IntermediateCodeFileParser.UnaryInst(lexer);
                unaryInst.Reset(cast<cmsx.intermediate.UnaryInstruction*>(match.value));
                if (match.hit)
                {
                    inst = unaryInst.Release();
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.Operand(lexer, context);
                        arg.Reset(cast<cmsx.intermediate.Value*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"Operand");
                        }
                    }
                    if (match.hit)
                    {
                        inst->SetOperand(arg.Release());
                        inst->SetResult(result);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInstruction");
                            #endif
                            return Match(true, inst);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UnaryInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UnaryInst(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UnaryInst");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case NOT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.NotInstruction(span.line));
                }
                break;
            }
            case NEG: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.NegInstruction(span.line));
                }
                break;
            }
            case SIGNEXTEND: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.SignExtendInstruction(span.line));
                }
                break;
            }
            case ZEROEXTEND: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.ZeroExtendInstruction(span.line));
                }
                break;
            }
            case TRUNCATE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.TruncateInstruction(span.line));
                }
                break;
            }
            case BITCAST: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.BitCastInstruction(span.line));
                }
                break;
            }
            case INTTOFLOAT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.IntToFloatInstruction(span.line));
                }
                break;
            }
            case FLOATTOINT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.FloatToIntInstruction(span.line));
                }
                break;
            }
            case INTTOPTR: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.IntToPtrInstruction(span.line));
                }
                break;
            }
            case PTRTOINT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.PtrToIntInstruction(span.line));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UnaryInst");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UnaryInst");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BinaryInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BinaryInstruction");
            }
        #endif
        cmsx.intermediate.BinaryInstruction* inst;
        UniquePtr<cmsx.intermediate.BinaryInstruction> binaryInst;
        UniquePtr<cmsx.intermediate.Value> left;
        UniquePtr<cmsx.intermediate.Value> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.BinaryInst(lexer);
                        binaryInst.Reset(cast<cmsx.intermediate.BinaryInstruction*>(match.value));
                        if (match.hit)
                        {
                            inst = binaryInst.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Operand(lexer, context);
                            left.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Operand");
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == COMMA)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch8 = &match;
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch10 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = IntermediateCodeFileParser.Operand(lexer, context);
                        right.Reset(cast<cmsx.intermediate.Value*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch10 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"Operand");
                        }
                    }
                    if (match.hit)
                    {
                        inst->SetOperands(left.Release(), right.Release());
                        inst->SetResult(result);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInstruction");
                            #endif
                            return Match(true, inst);
                        }
                    }
                    *parentMatch9 = match;
                }
                *parentMatch8 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BinaryInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BinaryInst(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BinaryInst");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case ADD: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.AddInstruction(span.line));
                }
                break;
            }
            case SUB: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.SubInstruction(span.line));
                }
                break;
            }
            case MUL: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.MulInstruction(span.line));
                }
                break;
            }
            case DIV: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.DivInstruction(span.line));
                }
                break;
            }
            case MOD: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.ModInstruction(span.line));
                }
                break;
            }
            case AND: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.AndInstruction(span.line));
                }
                break;
            }
            case OR: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.OrInstruction(span.line));
                }
                break;
            }
            case XOR: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.XorInstruction(span.line));
                }
                break;
            }
            case SHL: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.ShlInstruction(span.line));
                }
                break;
            }
            case SHR: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.ShrInstruction(span.line));
                }
                break;
            }
            case EQUAL: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.EqualInstruction(span.line));
                }
                break;
            }
            case LESS: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                    #endif
                    return Match(true, new cmsx.intermediate.LessInstruction(span.line));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BinaryInst");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BinaryInst");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ParamInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ParamInstruction");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == PARAM)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParamInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.ParamInstruction(result, span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParamInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ParamInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LocalInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LocalInstruction");
            }
        #endif
        cmsx.intermediate.Type* localType;
        UniquePtr<cmsx.intermediate.Type> t;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == LOCAL)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(true);
                            Match* parentMatch5 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch5 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                }
                            }
                            if (match.hit)
                            {
                                localType = t.Release();
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LocalInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.LocalInstruction(result, localType, span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LocalInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LocalInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LoadInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LoadInstruction");
            }
        #endif
        UniquePtr<cmsx.intermediate.Value> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == LOAD)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Operand(lexer, context);
                            ptr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Operand");
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LoadInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.LoadInstruction(result, ptr.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LoadInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LoadInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ElemAddrInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ElemAddrInstruction");
            }
        #endif
        UniquePtr<cmsx.intermediate.Value> ptr;
        UniquePtr<cmsx.intermediate.Value> index;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == ELEMADDR)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.Operand(lexer, context);
                                    ptr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"Operand");
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            Match* parentMatch8 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == COMMA)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch8 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Operand(lexer, context);
                            index.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Operand");
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ElemAddrInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.ElemAddrInstruction(result, ptr.Release(), index.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ElemAddrInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ElemAddrInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PtrOffsetInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PtrOffsetInstruction");
            }
        #endif
        UniquePtr<cmsx.intermediate.Value> ptr;
        UniquePtr<cmsx.intermediate.Value> offset;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == PTROFFSET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.Operand(lexer, context);
                                    ptr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"Operand");
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            Match* parentMatch8 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == COMMA)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch8 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Operand(lexer, context);
                            offset.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Operand");
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrOffsetInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.PtrOffsetInstruction(result, ptr.Release(), offset.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrOffsetInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PtrOffsetInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PtrDiffInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PtrDiffInstruction");
            }
        #endif
        UniquePtr<cmsx.intermediate.Value> leftPtr;
        UniquePtr<cmsx.intermediate.Value> rightPtr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == PTRDIFF)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.Operand(lexer, context);
                                    leftPtr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"Operand");
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(true);
                            Match* parentMatch8 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == COMMA)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch8 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(true);
                        Match* parentMatch10 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.Operand(lexer, context);
                            rightPtr.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch10 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"Operand");
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrDiffInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.PtrDiffInstruction(result, leftPtr.Release(), rightPtr.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrDiffInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PtrDiffInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match FunctionCallInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"FunctionCallInstruction");
            }
        #endif
        cmsx.intermediate.Type* functionType;
        UniquePtr<cmsx.intermediate.Type> ft;
        UniquePtr<cmsx.intermediate.Value> callee;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == CALL)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                    ft.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                    }
                                }
                                if (match.hit)
                                {
                                    functionType = ft.Release();
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        Match* parentMatch8 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypedValue(lexer, context, functionType);
                            callee.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch8 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypedValue");
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FunctionCallInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.FunctionCallInstruction(result, callee.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FunctionCallInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"FunctionCallInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TrapInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Value* result)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TrapInstruction");
            }
        #endif
        cmsx.intermediate.Type* type1;
        cmsx.intermediate.Type* type2;
        cmsx.intermediate.Type* type3;
        UniquePtr<cmsx.intermediate.Type> t1;
        UniquePtr<cmsx.intermediate.Value> val1;
        UniquePtr<cmsx.intermediate.Type> t2;
        UniquePtr<cmsx.intermediate.Value> val2;
        UniquePtr<cmsx.intermediate.Type> t3;
        UniquePtr<cmsx.intermediate.Value> val3;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == TRAP)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match(true);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            System.Lex.Span span = lexer.GetSpan();
                                                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                                            t1.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                *parentMatch12 = match;
                                                            }
                                                            else
                                                            {
                                                                lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                                            }
                                                        }
                                                        if (match.hit)
                                                        {
                                                            type1 = t1.Release();
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch13 = &match;
                                            {
                                                Match match(true);
                                                Match* parentMatch14 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type1);
                                                    val1.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        *parentMatch14 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.ThrowExpectationFailure(span, u"TypedValue");
                                                    }
                                                }
                                                *parentMatch13 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch16 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == COMMA)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch16 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                                }
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch17 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch18 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            Match* parentMatch19 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                                t2.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch19 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                type2 = t2.Release();
                                            }
                                            *parentMatch18 = match;
                                        }
                                        *parentMatch17 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch20 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch21 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type2);
                                        val2.Reset(cast<cmsx.intermediate.Value*>(match.value));
                                        if (match.hit)
                                        {
                                            *parentMatch21 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, u"TypedValue");
                                        }
                                    }
                                    *parentMatch20 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch22 = &match;
                            {
                                Match match(true);
                                Match* parentMatch23 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == COMMA)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch23 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                                    }
                                }
                                *parentMatch22 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch24 = &match;
                        {
                            Match match(false);
                            Match* parentMatch25 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                Match* parentMatch26 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                    t3.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch26 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"TypeExpr");
                                    }
                                }
                                if (match.hit)
                                {
                                    type3 = t3.Release();
                                }
                                *parentMatch25 = match;
                            }
                            *parentMatch24 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch27 = &match;
                    {
                        Match match(true);
                        Match* parentMatch28 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type3);
                            val3.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch28 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypedValue");
                            }
                        }
                        *parentMatch27 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TrapInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.TrapInstruction(result, val1.Release(), val2.Release(), val3.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TrapInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TrapInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NoOperationInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NoOperationInstruction");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == NOP)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NoOperationInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.NoOperationInstruction(span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NoOperationInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NoOperationInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SaveInstruction(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SaveInstruction");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == SAVE)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SaveInstruction");
                    #endif
                    return Match(true, new cmsx.intermediate.SaveInstruction(span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SaveInstruction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SaveInstruction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Operand(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Operand");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.Value> val;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                        t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                        if (match.hit)
                        {
                            type = t.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match = IntermediateCodeFileParser.TypedValue(lexer, context, type);
                            val.Reset(cast<cmsx.intermediate.Value*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, u"TypedValue");
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operand");
                    #endif
                    return Match(true, val.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Operand");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Operand");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TypeExpr(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TypeExpr");
            }
        #endif
        UniquePtr<cmsx.intermediate.Type> postfix;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match = IntermediateCodeFileParser.PostfixTypeExpr(lexer, context);
            postfix.Reset(cast<cmsx.intermediate.Type*>(match.value));
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeExpr");
                    #endif
                    return Match(true, postfix.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TypeExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PostfixTypeExpr(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PostfixTypeExpr");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> primary;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.PrimaryTypeExpr(lexer, context);
                        primary.Reset(cast<cmsx.intermediate.Type*>(match.value));
                        if (match.hit)
                        {
                            type = primary.Release();
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == AST)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                type = context->GetPtrType(type);
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PostfixTypeExpr");
                    #endif
                    return Match(true, type);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PostfixTypeExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PostfixTypeExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PrimaryTypeExpr(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PrimaryTypeExpr");
            }
        #endif
        UniquePtr<cmsx.intermediate.Type> typeId;
        UniquePtr<cmsx.intermediate.Type> primitive;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = IntermediateCodeFileParser.TypeId(lexer, context);
                typeId.Reset(cast<cmsx.intermediate.Type*>(match.value));
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimaryTypeExpr");
                        #endif
                        return Match(true, typeId.Release());
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.PrimitiveType(lexer, context);
                        primitive.Reset(cast<cmsx.intermediate.Type*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimaryTypeExpr");
                                #endif
                                return Match(true, primitive.Release());
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimaryTypeExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PrimaryTypeExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TypeId(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TypeId");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == TYPEID)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeId");
                    #endif
                    return Match(true, context->GetTypeById(span.line, ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypeId");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TypeId");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PrimitiveType(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PrimitiveType");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case VOID: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetVoidType());
                }
                break;
            }
            case BOOL: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetBoolType());
                }
                break;
            }
            case SBYTE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetSByteType());
                }
                break;
            }
            case BYTE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetByteType());
                }
                break;
            }
            case SHORT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetShortType());
                }
                break;
            }
            case USHORT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetUShortType());
                }
                break;
            }
            case INT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetIntType());
                }
                break;
            }
            case UINT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetUIntType());
                }
                break;
            }
            case LONG: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetLongType());
                }
                break;
            }
            case ULONG: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetULongType());
                }
                break;
            }
            case FLOAT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetFloatType());
                }
                break;
            }
            case DOUBLE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                    #endif
                    return Match(true, context->GetDoubleType());
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PrimitiveType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PrimitiveTypeName(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PrimitiveTypeName");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case VOID: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("void"));
                }
                break;
            }
            case BOOL: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("bool"));
                }
                break;
            }
            case SBYTE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("sbyte"));
                }
                break;
            }
            case BYTE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("byte"));
                }
                break;
            }
            case SHORT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("short"));
                }
                break;
            }
            case USHORT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("ushort"));
                }
                break;
            }
            case INT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("int"));
                }
                break;
            }
            case UINT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("uint"));
                }
                break;
            }
            case LONG: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("long"));
                }
                break;
            }
            case ULONG: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("ulong"));
                }
                break;
            }
            case FLOAT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("float"));
                }
                break;
            }
            case DOUBLE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                    #endif
                    return Match(true, new Value<string>("double"));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PrimitiveTypeName");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PrimitiveTypeName");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TypedValue(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Type* type)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TypedValue");
            }
        #endif
        UniquePtr<cmsx.intermediate.Value> idValue;
        UniquePtr<cmsx.intermediate.ConstantValue> symbolValue;
        UniquePtr<cmsx.intermediate.ConstantValue> literalValue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = IntermediateCodeFileParser.IdValue(lexer, context, type);
                    idValue.Reset(cast<cmsx.intermediate.Value*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypedValue");
                            #endif
                            return Match(true, idValue.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.SymbolValue(lexer, context, type);
                            symbolValue.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypedValue");
                                    #endif
                                    return Match(true, symbolValue.Release());
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.LiteralValue(lexer, context, type);
                        literalValue.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypedValue");
                                #endif
                                return Match(true, literalValue.Release());
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TypedValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TypedValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match IdValue(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Type* type)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IdValue");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == DOLLAR)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        uint x = ParseUInt(ToUtf8(lexer.GetToken(pos).match.ToString()));
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IdValue");
                            #endif
                            return Match(true, context->currentFunction->MakeIdValue(span.line, x, type));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IdValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IdValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SymbolValue(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Type* type)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SymbolValue");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == AT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == ID)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SymbolValue");
                            #endif
                            return Match(true, context->MakeSymbolValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SymbolValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SymbolValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LiteralValue(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.Type* type)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LiteralValue");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case TRUE: 
            {
                ++lexer;
                if (type is cmsx.intermediate.BoolType*)
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                    #endif
                    return Match(true, context->GetBoolType()->MakeBoolValue(true));
                }
                else context->MakeLiteralValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type);
                break;
            }
            case FALSE: 
            {
                ++lexer;
                if (type is cmsx.intermediate.BoolType*)
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                    #endif
                    return Match(true, context->GetBoolType()->MakeBoolValue(false));
                }
                else context->MakeLiteralValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type);
                break;
            }
            case NULL: 
            {
                ++lexer;
                if (type is cmsx.intermediate.PtrType*)
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                    #endif
                    return Match(true, type->DefaultValue());
                }
                else context->MakeLiteralValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type);
                break;
            }
            case NUMBER: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                    #endif
                    return Match(true, context->MakeLiteralValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type));
                }
                break;
            }
            case ID: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                    #endif
                    return Match(true, context->MakeLiteralValue(span.line, ToUtf8(lexer.GetToken(pos).match.ToString()), type));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LiteralValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LiteralValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Constant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Constant");
            }
        #endif
        UniquePtr<cmsx.intermediate.ConstantValue> conversionConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> clsIdConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> ptrConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> symbolConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> boolConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> sbyteConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> byteConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> shortConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> ushortConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> intConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> uintConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> longConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> ulongConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> floatConstant;
        UniquePtr<cmsx.intermediate.ConstantValue> doubleConstant;
        UniquePtr<cmsx.intermediate.ArrayValue> arrayConstant;
        UniquePtr<cmsx.intermediate.StructureValue> structureConstant;
        UniquePtr<cmsx.intermediate.StringValue> stringConstant;
        UniquePtr<cmsx.intermediate.StringArrayValue> stringArrayConstant;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long save = lexer.GetPos();
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            {
                                                                long save = lexer.GetPos();
                                                                Match match(false);
                                                                Match* parentMatch14 = &match;
                                                                {
                                                                    long save = lexer.GetPos();
                                                                    Match match(false);
                                                                    Match* parentMatch15 = &match;
                                                                    {
                                                                        long save = lexer.GetPos();
                                                                        Match match(false);
                                                                        Match* parentMatch16 = &match;
                                                                        {
                                                                            long save = lexer.GetPos();
                                                                            Match match(false);
                                                                            Match* parentMatch17 = &match;
                                                                            {
                                                                                long save = lexer.GetPos();
                                                                                Match match(false);
                                                                                Match* parentMatch18 = &match;
                                                                                {
                                                                                    long pos = lexer.GetPos();
                                                                                    Match match = IntermediateCodeFileParser.ConversionConstant(lexer, context);
                                                                                    conversionConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                                    if (match.hit)
                                                                                    {
                                                                                        {
                                                                                            #if (DEBUG)
                                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                            #endif
                                                                                            return Match(true, conversionConstant.Release());
                                                                                        }
                                                                                    }
                                                                                    *parentMatch18 = match;
                                                                                }
                                                                                *parentMatch17 = match;
                                                                                if (!match.hit)
                                                                                {
                                                                                    Match match(false);
                                                                                    Match* parentMatch19 = &match;
                                                                                    lexer.SetPos(save);
                                                                                    {
                                                                                        Match match(false);
                                                                                        Match* parentMatch20 = &match;
                                                                                        {
                                                                                            long pos = lexer.GetPos();
                                                                                            Match match = IntermediateCodeFileParser.ClsIdConstant(lexer, context);
                                                                                            clsIdConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                                            if (match.hit)
                                                                                            {
                                                                                                {
                                                                                                    #if (DEBUG)
                                                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                                    #endif
                                                                                                    return Match(true, clsIdConstant.Release());
                                                                                                }
                                                                                            }
                                                                                            *parentMatch20 = match;
                                                                                        }
                                                                                        *parentMatch19 = match;
                                                                                    }
                                                                                    *parentMatch17 = match;
                                                                                }
                                                                            }
                                                                            *parentMatch16 = match;
                                                                            if (!match.hit)
                                                                            {
                                                                                Match match(false);
                                                                                Match* parentMatch21 = &match;
                                                                                lexer.SetPos(save);
                                                                                {
                                                                                    Match match(false);
                                                                                    Match* parentMatch22 = &match;
                                                                                    {
                                                                                        long pos = lexer.GetPos();
                                                                                        Match match = IntermediateCodeFileParser.PtrConstant(lexer, context);
                                                                                        ptrConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                                        if (match.hit)
                                                                                        {
                                                                                            {
                                                                                                #if (DEBUG)
                                                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                                #endif
                                                                                                return Match(true, ptrConstant.Release());
                                                                                            }
                                                                                        }
                                                                                        *parentMatch22 = match;
                                                                                    }
                                                                                    *parentMatch21 = match;
                                                                                }
                                                                                *parentMatch16 = match;
                                                                            }
                                                                        }
                                                                        *parentMatch15 = match;
                                                                        if (!match.hit)
                                                                        {
                                                                            Match match(false);
                                                                            Match* parentMatch23 = &match;
                                                                            lexer.SetPos(save);
                                                                            {
                                                                                Match match(false);
                                                                                Match* parentMatch24 = &match;
                                                                                {
                                                                                    long pos = lexer.GetPos();
                                                                                    Match match = IntermediateCodeFileParser.SymbolConstant(lexer, context);
                                                                                    symbolConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                                    if (match.hit)
                                                                                    {
                                                                                        {
                                                                                            #if (DEBUG)
                                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                            #endif
                                                                                            return Match(true, symbolConstant.Release());
                                                                                        }
                                                                                    }
                                                                                    *parentMatch24 = match;
                                                                                }
                                                                                *parentMatch23 = match;
                                                                            }
                                                                            *parentMatch15 = match;
                                                                        }
                                                                    }
                                                                    *parentMatch14 = match;
                                                                    if (!match.hit)
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch25 = &match;
                                                                        lexer.SetPos(save);
                                                                        {
                                                                            Match match(false);
                                                                            Match* parentMatch26 = &match;
                                                                            {
                                                                                long pos = lexer.GetPos();
                                                                                Match match = IntermediateCodeFileParser.BoolConstant(lexer, context);
                                                                                boolConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                                if (match.hit)
                                                                                {
                                                                                    {
                                                                                        #if (DEBUG)
                                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                        #endif
                                                                                        return Match(true, boolConstant.Release());
                                                                                    }
                                                                                }
                                                                                *parentMatch26 = match;
                                                                            }
                                                                            *parentMatch25 = match;
                                                                        }
                                                                        *parentMatch14 = match;
                                                                    }
                                                                }
                                                                *parentMatch13 = match;
                                                                if (!match.hit)
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch27 = &match;
                                                                    lexer.SetPos(save);
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch28 = &match;
                                                                        {
                                                                            long pos = lexer.GetPos();
                                                                            Match match = IntermediateCodeFileParser.SByteConstant(lexer, context);
                                                                            sbyteConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                            if (match.hit)
                                                                            {
                                                                                {
                                                                                    #if (DEBUG)
                                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                    #endif
                                                                                    return Match(true, sbyteConstant.Release());
                                                                                }
                                                                            }
                                                                            *parentMatch28 = match;
                                                                        }
                                                                        *parentMatch27 = match;
                                                                    }
                                                                    *parentMatch13 = match;
                                                                }
                                                            }
                                                            *parentMatch12 = match;
                                                            if (!match.hit)
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch29 = &match;
                                                                lexer.SetPos(save);
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch30 = &match;
                                                                    {
                                                                        long pos = lexer.GetPos();
                                                                        Match match = IntermediateCodeFileParser.ByteConstant(lexer, context);
                                                                        byteConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                        if (match.hit)
                                                                        {
                                                                            {
                                                                                #if (DEBUG)
                                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                                #endif
                                                                                return Match(true, byteConstant.Release());
                                                                            }
                                                                        }
                                                                        *parentMatch30 = match;
                                                                    }
                                                                    *parentMatch29 = match;
                                                                }
                                                                *parentMatch12 = match;
                                                            }
                                                        }
                                                        *parentMatch11 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch31 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch32 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = IntermediateCodeFileParser.ShortConstant(lexer, context);
                                                                    shortConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        {
                                                                            #if (DEBUG)
                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                            #endif
                                                                            return Match(true, shortConstant.Release());
                                                                        }
                                                                    }
                                                                    *parentMatch32 = match;
                                                                }
                                                                *parentMatch31 = match;
                                                            }
                                                            *parentMatch11 = match;
                                                        }
                                                    }
                                                    *parentMatch10 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch33 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch34 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match = IntermediateCodeFileParser.UShortConstant(lexer, context);
                                                                ushortConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    {
                                                                        #if (DEBUG)
                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                        #endif
                                                                        return Match(true, ushortConstant.Release());
                                                                    }
                                                                }
                                                                *parentMatch34 = match;
                                                            }
                                                            *parentMatch33 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                }
                                                *parentMatch9 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch35 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch36 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = IntermediateCodeFileParser.IntConstant(lexer, context);
                                                            intConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                    #endif
                                                                    return Match(true, intConstant.Release());
                                                                }
                                                            }
                                                            *parentMatch36 = match;
                                                        }
                                                        *parentMatch35 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch37 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch38 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = IntermediateCodeFileParser.UIntConstant(lexer, context);
                                                        uintConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                                #endif
                                                                return Match(true, uintConstant.Release());
                                                            }
                                                        }
                                                        *parentMatch38 = match;
                                                    }
                                                    *parentMatch37 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch39 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch40 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = IntermediateCodeFileParser.LongConstant(lexer, context);
                                                    longConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                            #endif
                                                            return Match(true, longConstant.Release());
                                                        }
                                                    }
                                                    *parentMatch40 = match;
                                                }
                                                *parentMatch39 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch41 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch42 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = IntermediateCodeFileParser.ULongConstant(lexer, context);
                                                ulongConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                        #endif
                                                        return Match(true, ulongConstant.Release());
                                                    }
                                                }
                                                *parentMatch42 = match;
                                            }
                                            *parentMatch41 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch43 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch44 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = IntermediateCodeFileParser.FloatConstant(lexer, context);
                                            floatConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                    #endif
                                                    return Match(true, floatConstant.Release());
                                                }
                                            }
                                            *parentMatch44 = match;
                                        }
                                        *parentMatch43 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch45 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch46 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.DoubleConstant(lexer, context);
                                        doubleConstant.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                                #endif
                                                return Match(true, doubleConstant.Release());
                                            }
                                        }
                                        *parentMatch46 = match;
                                    }
                                    *parentMatch45 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch47 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch48 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.ArrayConstant(lexer, context);
                                    arrayConstant.Reset(cast<cmsx.intermediate.ArrayValue*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                            #endif
                                            return Match(true, arrayConstant.Release());
                                        }
                                    }
                                    *parentMatch48 = match;
                                }
                                *parentMatch47 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch49 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch50 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = IntermediateCodeFileParser.StructureConstant(lexer, context);
                                structureConstant.Reset(cast<cmsx.intermediate.StructureValue*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                        #endif
                                        return Match(true, structureConstant.Release());
                                    }
                                }
                                *parentMatch50 = match;
                            }
                            *parentMatch49 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch51 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch52 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.StringConstant(lexer, context);
                            stringConstant.Reset(cast<cmsx.intermediate.StringValue*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                    #endif
                                    return Match(true, stringConstant.Release());
                                }
                            }
                            *parentMatch52 = match;
                        }
                        *parentMatch51 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch53 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch54 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.StringArrayConstant(lexer, context);
                        stringArrayConstant.Reset(cast<cmsx.intermediate.StringArrayValue*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                                #endif
                                return Match(true, stringArrayConstant.Release());
                            }
                        }
                        *parentMatch54 = match;
                    }
                    *parentMatch53 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Constant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Constant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConversionConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConversionConstant");
            }
        #endif
        cmsx.intermediate.Type* targetType;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.ConstantValue> from;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                    t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                    if (match.hit)
                                    {
                                        targetType = t.Release();
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == CONV)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            Match match(true);
                            Match* parentMatch11 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                from.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch11 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"Constant");
                                }
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        Match match(true);
                        Match* parentMatch13 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch13 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                            }
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConversionConstant");
                    #endif
                    return Match(true, context->MakeConversionValue(targetType, from.Release(), span.line));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConversionConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConversionConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ClsIdConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ClsIdConstant");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                if (match.hit)
                {
                    type = t.Release();
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == CLSID)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ClsIdConstant");
                            #endif
                            return Match(true, context->MakeClsIdValue(type, ToUtf8(lexer.GetToken(pos).match.ToString()), span.line));
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ClsIdConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ClsIdConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PtrConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PtrConstant");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> type1;
        UniquePtr<cmsx.intermediate.Type> type2;
        UniquePtr<cmsx.intermediate.ConstantValue> literalValue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            bool pass = true;
                            Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                            type1.Reset(cast<cmsx.intermediate.Type*>(match.value));
                            if (match.hit)
                            {
                                type = type1.Release();
                                pass = cmsx.intermediate.IsPtrType(type);
                            }
                            if (match.hit && !pass)
                            {
                                match = Match(false);
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            if (*lexer == NULL)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrConstant");
                        #endif
                        return Match(true, cast<cmsx.intermediate.PtrType*>(type)->DefaultValue());
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    bool pass = true;
                                    Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                                    type2.Reset(cast<cmsx.intermediate.Type*>(match.value));
                                    if (match.hit)
                                    {
                                        type = type2.Release();
                                        pass = cmsx.intermediate.IsPtrType(type);
                                    }
                                    if (match.hit && !pass)
                                    {
                                        match = Match(false);
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match = IntermediateCodeFileParser.LiteralValue(lexer, context, type);
                                    literalValue.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                    *parentMatch11 = match;
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrConstant");
                                #endif
                                return Match(true, literalValue.Release());
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PtrConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PtrConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SymbolConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SymbolConstant");
            }
        #endif
        cmsx.intermediate.Type* type;
        UniquePtr<cmsx.intermediate.Type> t;
        UniquePtr<cmsx.intermediate.ConstantValue> symbolValue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = IntermediateCodeFileParser.TypeExpr(lexer, context);
                t.Reset(cast<cmsx.intermediate.Type*>(match.value));
                if (match.hit)
                {
                    type = t.Release();
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = IntermediateCodeFileParser.SymbolValue(lexer, context, type);
                    symbolValue.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SymbolConstant");
                            #endif
                            return Match(true, symbolValue.Release());
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SymbolConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SymbolConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BoolConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BoolConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == BOOL)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    switch (*lexer)
                    {
                        case TRUE: 
                        {
                            ++lexer;
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BoolConstant");
                                #endif
                                return Match(true, context->GetBoolType()->MakeBoolValue(true));
                            }
                            break;
                        }
                        case FALSE: 
                        {
                            ++lexer;
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BoolConstant");
                                #endif
                                return Match(true, context->GetBoolType()->MakeBoolValue(false));
                            }
                            break;
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BoolConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BoolConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SByteConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SByteConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == SBYTE)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SByteConstant");
                            #endif
                            return Match(true, context->MakeSByteValue(context->GetSByteType(), ParseSByte(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SByteConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SByteConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ByteConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ByteConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == BYTE)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ByteConstant");
                            #endif
                            return Match(true, context->MakeByteValue(context->GetByteType(), ParseByte(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ByteConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ByteConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ShortConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ShortConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == SHORT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ShortConstant");
                            #endif
                            return Match(true, context->MakeShortValue(context->GetShortType(), ParseShort(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ShortConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ShortConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UShortConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UShortConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == USHORT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UShortConstant");
                            #endif
                            return Match(true, context->MakeUShortValue(context->GetUShortType(), ParseUShort(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UShortConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UShortConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match IntConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IntConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == INT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IntConstant");
                            #endif
                            return Match(true, context->MakeIntValue(context->GetIntType(), ParseInt(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IntConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IntConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UIntConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UIntConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == UINT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UIntConstant");
                            #endif
                            return Match(true, context->MakeUIntValue(context->GetUIntType(), ParseUInt(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UIntConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UIntConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LongConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LongConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == LONG)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LongConstant");
                            #endif
                            return Match(true, context->MakeLongValue(context->GetLongType(), ParseLong(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LongConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LongConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ULongConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ULongConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == ULONG)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ULongConstant");
                            #endif
                            return Match(true, context->MakeULongValue(context->GetULongType(), ParseULong(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ULongConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ULongConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match FloatConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"FloatConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == FLOAT)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FloatConstant");
                            #endif
                            return Match(true, context->MakeFloatValue(context->GetFloatType(), ParseFloat(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"FloatConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"FloatConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DoubleConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DoubleConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == DOUBLE)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoubleConstant");
                            #endif
                            return Match(true, context->MakeDoubleValue(context->GetDoubleType(), ParseDouble(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoubleConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DoubleConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ArrayConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ArrayConstant");
            }
        #endif
        cmsx.intermediate.ArrayValue* value;
        UniquePtr<cmsx.intermediate.ConstantValue> element;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACKET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                value = context->MakeArrayValue();
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                            element.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                            if (match.hit)
                                            {
                                                value->AddElement(element.Release());
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch10 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch11 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == COMMA)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch14 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                                                    element.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        value->AddElement(element.Release());
                                                                    }
                                                                    *parentMatch14 = match;
                                                                }
                                                                *parentMatch13 = match;
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch11 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch10 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(false);
                        if (*lexer == RBRACKET)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ArrayConstant");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ArrayConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ArrayConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StructureConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StructureConstant");
            }
        #endif
        cmsx.intermediate.StructureValue* value;
        UniquePtr<cmsx.intermediate.ConstantValue> member;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == LBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        value = context->MakeStructureValue();
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                    member.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                    if (match.hit)
                                    {
                                        value->AddMember(member.Release());
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch9 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                                            member.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                value->AddMember(member.Release());
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch9 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch15 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StructureConstant");
                            #endif
                            return Match(true, value);
                        }
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StructureConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StructureConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StringConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StringConstant");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            if (*lexer == STRING)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringConstant");
                    #endif
                    return Match(true, context->MakeStringValue(ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StringConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StringArrayConstant(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StringArrayConstant");
            }
        #endif
        cmsx.intermediate.StringArrayValue* value;
        UniquePtr<Value<char>> prefix;
        UniquePtr<cmsx.intermediate.ConstantValue> element;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = IntermediateCodeFileParser.StringArrayPrefix(lexer);
                    prefix.Reset(cast<Value<char>*>(match.value));
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACKET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                value = context->MakeStringArrayValue(prefix->value);
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                    element.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                    if (match.hit)
                                    {
                                        value->AddElement(element.Release());
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch11 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch12 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch12 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch14 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = IntermediateCodeFileParser.Constant(lexer, context);
                                                            element.Reset(cast<cmsx.intermediate.ConstantValue*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                value->AddElement(element.Release());
                                                            }
                                                            *parentMatch14 = match;
                                                        }
                                                        *parentMatch13 = match;
                                                    }
                                                    *parentMatch12 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch11 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch15 = &match;
            {
                Match match(false);
                Match* parentMatch16 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == RBRACKET)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringArrayConstant");
                            #endif
                            return Match(true, value);
                        }
                    }
                    *parentMatch16 = match;
                }
                *parentMatch15 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringArrayConstant");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StringArrayConstant");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StringArrayPrefix(IntermediateCodeLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StringArrayPrefix");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            bool pass = true;
            Match match(false);
            if (*lexer == ID)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                string p = ToUtf8(lexer.GetToken(pos).match.ToString());
                pass = p == "w" || p == "u" || p == "b";
                if (pass)
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringArrayPrefix");
                    #endif
                    return Match(true, new Value<char>(p[0]));
                }
            }
            if (match.hit && !pass)
            {
                match = Match(false);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringArrayPrefix");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StringArrayPrefix");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Metadata(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Metadata");
            }
        #endif
        cmsx.intermediate.MDStruct* mdStruct;
        UniquePtr<cmsx.intermediate.MDStruct> mds;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == METADATA)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = IntermediateCodeFileParser.MDStruct(lexer, context);
                                        mds.Reset(cast<cmsx.intermediate.MDStruct*>(match.value));
                                        if (match.hit)
                                        {
                                            mdStruct = mds.Release();
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(true);
                Match* parentMatch10 = &match;
                {
                    System.Lex.Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch10 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                    }
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Metadata");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Metadata");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDItem(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDItem");
            }
        #endif
        UniquePtr<cmsx.intermediate.MDBool> mdBool;
        UniquePtr<cmsx.intermediate.MDLong> mdLong;
        UniquePtr<cmsx.intermediate.MDString> mdString;
        UniquePtr<cmsx.intermediate.MDStructRef> mdStructRef;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.MDBool(lexer, context);
                        mdBool.Reset(cast<cmsx.intermediate.MDBool*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDItem");
                                #endif
                                return Match(true, mdBool.Release());
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = IntermediateCodeFileParser.MDLong(lexer, context);
                                mdLong.Reset(cast<cmsx.intermediate.MDLong*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDItem");
                                        #endif
                                        return Match(true, mdLong.Release());
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = IntermediateCodeFileParser.MDString(lexer, context);
                            mdString.Reset(cast<cmsx.intermediate.MDString*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDItem");
                                    #endif
                                    return Match(true, mdString.Release());
                                }
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch8 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IntermediateCodeFileParser.MDStructRef(lexer, context);
                        mdStructRef.Reset(cast<cmsx.intermediate.MDStructRef*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDItem");
                                #endif
                                return Match(true, mdStructRef.Release());
                            }
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch8 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDItem");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDItem");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDBool(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDBool");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case TRUE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDBool");
                    #endif
                    return Match(true, context->CreateMDBool(true));
                }
                break;
            }
            case FALSE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDBool");
                    #endif
                    return Match(true, context->CreateMDBool(false));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDBool");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDBool");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDLong(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDLong");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            if (*lexer == NUMBER)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDLong");
                    #endif
                    return Match(true, context->CreateMDLong(ParseLong(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDLong");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDLong");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDString(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDString");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            if (*lexer == STRING)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDString");
                    #endif
                    return Match(true, context->CreateMDString(ToUtf8(lexer.GetToken(pos).match.ToString())));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDString");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDString");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDStructRef(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDStructRef");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == EXCLAMATION)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == NUMBER)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDStructRef");
                            #endif
                            return Match(true, context->CreateMDStructRef(ParseInt(ToUtf8(lexer.GetToken(pos).match.ToString()))));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDStructRef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDStructRef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDStruct(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDStruct");
            }
        #endif
        cmsx.intermediate.MDStruct* value;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == EXCLAMATION)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == NUMBER)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                value = context->CreateMDStruct(ParseInt(ToUtf8(lexer.GetToken(pos).match.ToString())));
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == ASSIGN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch12 = &match;
                            {
                                Match match(false);
                                Match* parentMatch13 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match = IntermediateCodeFileParser.MDField(lexer, context, value);
                                        *parentMatch14 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch16 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch17 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == COMMA)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch17 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch18 = &match;
                                                            {
                                                                Match match = IntermediateCodeFileParser.MDField(lexer, context, value);
                                                                *parentMatch18 = match;
                                                            }
                                                            *parentMatch17 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch16 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch13 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch12 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch19 = &match;
                    {
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch19 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDStruct");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDStruct");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDStruct");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MDField(IntermediateCodeLexer& lexer, cmsx.intermediate.Context* context, cmsx.intermediate.MDStruct* parent)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MDField");
            }
        #endif
        string fieldName;
        UniquePtr<cmsx.intermediate.MDItem> item;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                fieldName = ToUtf8(lexer.GetToken(pos).match.ToString());
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            if (*lexer == COLON)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match = IntermediateCodeFileParser.MDItem(lexer, context);
                        item.Reset(cast<cmsx.intermediate.MDItem*>(match.value));
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                parent->AddItem(fieldName, item.Release());
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MDField");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MDField");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

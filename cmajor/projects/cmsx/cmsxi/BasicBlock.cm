using System;
using System.Collections;
using CodeFormatter = System.Text.CodeFormatter;

namespace cmsx.intermediate
{
    public class BasicBlock
    {
        public nothrow BasicBlock(Function& function_, uint id_) : function(function_), id(id_)
        {
        }
        public nothrow void AddInstruction(Instruction* instruction)
        {
            instruction->parent = this;
            instructions.Add(UniquePtr<Instruction>(instruction));
        }
        public void MapInstructions(uint& nextIdNumber)
        {
            for (const UniquePtr<Instruction>& instruction : instructions)
            {
                ValueInstruction* valueInst = instruction.Get() as ValueInstruction*;
                if (valueInst != null)
                {
                    IdValue* idValue = valueInst->result as IdValue*;
                    if (idValue != null)
                    {
                        if (idValue->id != nextIdNumber)
                        {
                            throw Exception("error: value number " + ToString(nextIdNumber) + " expected for " + instruction->Name() + " instruction at line " + ToString(instruction->line));
                        }
                        function.MapInstruction(idValue->id, instruction.Get());
                        nextIdNumber = nextIdNumber + 1u;
                    }
                    else
                    {
                        throw Exception("internal error: value instruction '" + instruction->Name() + "' at line " + ToString(instruction->line) + " has no id value");
                    }
                }
            }
        }
        public void Validate()
        {
            if (Flags.Get(Flag.debug))
            {
                Console.Out() << id << endl();
            }
            long n = instructions.Count();
            int numParams = 0;
            int numArgs = 0;
            for (long i = 0; i < n; ++i)
            {
                Instruction* instruction = instructions[i].Get();
                if (Flags.Get(Flag.debug))
                {
                    Console.Out() << instruction->Name() << endl();
                }
                if (i < n - 1 && (instruction is TerminatorInstruction*))
                {
                    throw Exception("error: terminator instruction " + instruction->Name() + " at line " + ToString(instruction->line) + " found in the middle of a basic block");
                }
                else if (i == n - 1 && !(instruction is TerminatorInstruction*))
                {
                    throw Exception("error: the last instruction of a basic block, the " + instruction->Name() + " instruction at line " + ToString(instruction->line) + " must be a terminator instruction");
                }
                bool resetArgs = true;
                if (instruction is ArgInstruction*)
                {
                    ++numArgs;
                    resetArgs = false;
                }
                else if (instruction is ParamInstruction*)
                {
                    if (id == 0u)
                    {
                        ++numParams;
                    }
                    else
                    {
                        throw Exception("error: a non-entry block contains a param instruction (line " + ToString(instruction->line) + ")");
                    }
                }
                instruction->Validate(function, numArgs);
                if (resetArgs)
                {
                    numArgs = 0;
                }
            }
            if (id == 0u && numParams != function.type->ParamTypes().Count())
            {
                throw Exception("error: wrong number of param instructions for function " + function.name);
            }
        }
        public void Print(CodeFormatter& formatter)
        {
            int indentSize = formatter.IndentSize();
            formatter.DecIndent();
            formatter.Write(Format(Name(), indentSize, FormatWidth.min));
            bool first = true;
            for (const UniquePtr<Instruction>& instruction : instructions)
            {
                instruction->Print(formatter);
                formatter.WriteLine();
                if (first)
                {
                    first = false;
                    formatter.IncIndent();
                }
            }
        }
        public nothrow string Name() const
        {
            return "@" + ToString(id);
        }
        public Function& function;
        public uint id;
        private List<UniquePtr<Instruction>> instructions;
    }
}

using System;
using System.IO;
using System.Json;
using System.Concepts;
using System.Collections;
using System.Threading;

namespace Trade
{
    public class Engine 
    {
        
        public ~Engine()
        {
            try
            {
                input.Clear();
            }
            catch(Exception& ex)
            {
            }        
            try
            {
                output.Clear();
            }
            catch(Exception& ex)
            {
            }        
            try
            {
                trash.Clear();
            }
            catch(Exception& ex)
            {
            }        
        }        
        public Queue<UniquePtr<Object>> input;
        public string inputPath;
        public Queue<UniquePtr<Object>> output;
        public string outputPath;
        public Queue<UniquePtr<Object>> trash;
        public string trashPath;

        public Engine()
        {
            inputPath = "c:\\cmajor\\projects\\TradeEngine\\Input";
            if (!LoadAll(inputPath, input))
            {
                // log error
            }
            outputPath = "c:\\cmajor\\projects\\TradeEngine\\Output";
            if (!LoadAll(outputPath, output))
            {
                // log error
            }
            trashPath = "c:\\cmajor\\projects\\TradeEngine\\Trash";
            if (!LoadAll(trashPath, trash))
            {
                // log error
            }
        }
        private bool LoadAll(const string& path, const Queue<UniquePtr<Object>>& target)
        {
            if (Directory.Exists(path))
            {
                List<string> files = Directory.GetFiles(path);
                for (const string& file : files)
                {
                    if (File.Exists(file))
                    {
                        // add exception handling
                        string json = File.ReadAllText(file);
                        UniquePtr<JsonValue> parsedJsonValue = ParseJson(json);
                        UniquePtr<Object> object;
                        FromJson(parsedJsonValue.Get(), object);
                        target.Put(Rvalue(object)); 
                    }
                }
                return true;
            }
            else
            {
                return false;
            }
        }
        private bool LoadFile(const string& file, UniquePtr<Object>& target)
        {
            if (File.Exists(file))
            {
                // add exception handling
                string json = File.ReadAllText(file);
                UniquePtr<JsonValue> parsedJsonValue = ParseJson(json);
                UniquePtr<Object> object;
                FromJson(parsedJsonValue.Get(), object);
                target = Rvalue(object); 
                return true;
            }
            else
            {
                return false;
            }
        }
        public void Run()
        {
            // read or wait input
            // try to handle transaction
            // retry once
            // if fails -> put to trash           
            //return 0;
        }
        private bool SaveAll()
        {
            // input
            bool ret;
            for (const UniquePtr<Object>& object : input.Rep())
            {
                if (SaveFile(inputPath, object)){ret = true;}
                else{return false;}
            }
            // output
            for (const UniquePtr<Object>& object : output.Rep())
            {
                if (SaveFile(outputPath, object)){ret = true;}
                else{return false;}
            }
            // trash
            for (const UniquePtr<Object>& object : trash.Rep())
            {
                if (SaveFile(trashPath, object)){ret = true;}
                else{return false;}
            }
            return ret;
        }
        private bool SaveFile(const string& path, const UniquePtr<Object>& source)
        {
            if (Directory.Exists(path))
            {
                string filename = path + ToString(source.Get()->id) + ".json"; 
                if (!File.Exists(filename))
                {
                    UniquePtr<JsonValue> objectsJsonValue = ToJson(source);
                    string objectsJsonStr = objectsJsonValue->ToString();
                    OutputFileStream ofs;
                    ofs.Open(filename,OpenMode.write);
                    ofs.Write(objectsJsonStr);
                    ofs.Close();
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                return false;
            }
        }
        public void ListenInput()
        {

        }
    } 
    void RunInput(void* param)
    {
        try
        { Engine* e = cast<Engine*>(param);}
        catch (const Exception& ex)
        {}
    }
    void RunOutput(void* param)
    {
        try
        { Engine* e = cast<Engine*>(param);}
        catch (const Exception& ex)
        {}
    }
    void RunTrash(void* param)
    {
        try
        { Engine* e = cast<Engine*>(param);}
        catch (const Exception& ex)
        {}
    }
}

int main(int argc, const char** argv)
{
    
    Trade.Engine e;

    try
    {
        Thread inputThread = Thread.StartFunction(Trade.RunInput,&e);
        inputThread.Join();
    }
    catch (const Exception& ex)
    {
        Console.WriteLine(ex.Message());
    }    

    try
    {
        Thread outputThread = Thread.StartFunction(Trade.RunOutput,&e);
        outputThread.Join();
    }
    catch (const Exception& ex)
    {
        Console.WriteLine(ex.Message());
    }    

    try
    {
        Thread trashThread = Thread.StartFunction(Trade.RunTrash,&e);
        trashThread.Join();
    }
    catch (const Exception& ex)
    {
        Console.WriteLine(ex.Message());
    }    


    return 0;
}      


// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Threading;
using System.Net.Sockets;
using System.Json;
using System.IO;
using System.Text;
using Cm.Ast;

namespace Cm.Build
{
    public int defaultPort = 54325;

    public class delegate void LogMessageNotificationFunction();

    public string CmCodeLogDir()
    {
        string cmajorRootDir = CmajorRootDir();
        string logDir = Path.Combine(Path.Combine(Path.Combine(Path.Combine(cmajorRootDir, "projects"), "cm"), "cmcode"), "log");
        Directory.CreateDirectories(logDir);
        return logDir;
    }

    public class Service
    {
        public nothrow Service(int port_, bool serverVerbose_) : port(port_), serverVerbose(serverVerbose_), notifyLogMessageAvailable()
        {
            serverStartCommand = "cmbs --machine --port=" + ToString(port);
            if (serverVerbose)
            {
                serverStartCommand.Append(" --verbose");
            }
        }
        public nothrow void SetLogMessageNotificationFunction(const LogMessageNotificationFunction& notifyLogMessageAvailable_)
        {
            notifyLogMessageAvailable = notifyLogMessageAvailable_;
        }
        public nothrow bool ServerRunning() const
        {
            if (buildServer.IsNull()) return false;
            return buildServer->Running();
        }
        public bool StartServer()
        {
            try
            {
                if (ServerRunning())
                {
                    StopServer();
                }
                LogMessage("Cm.Build.Service: Starting Build Server...");
                buildServer.Reset(
                    new Process(serverStartCommand,
                    cast<Process.Redirections>(Process.Redirections.processStdIn | Process.Redirections.processStdOut | Process.Redirections.processStdErr)));
                logServerMessageThread = Thread.StartMethod(LogServerMessages);
                LogMessage("Cm.Build.Service: Build Server started.");
            }
            catch (const Exception& ex)
            {
                LogException(ex);
                LogMessage("Cm.Build.Service.StartServer: " + ex.Message());
                return false;
            }
            return true;
        }
        public void StopServer()
        {
            try
            {
                if (!ServerRunning()) return;
                LogMessage("Cm.Build.Service: Stopping Build Server...");
                buildServer->WriteLine("quit");
                bool serverStopped = false;
                for (int i = 0; i < 10; ++i)
                {
                    if (buildServer->Running())
                    {
                        Sleep(Duration.FromSeconds(1));
                    }
                    else
                    {
                        serverStopped = true;
                        break;
                    }
                }
                if (!serverStopped)
                {
                    LogMessage("Cm.Build.Service: Build Server not stopped after 10 seconds, terminating server process...");
                    buildServer->Terminate();
                }
                int exitCode = buildServer->ExitCode();
                string exitCodeStr;
                if (exitCode != 0)
                {
                    exitCodeStr.Append(" Exit code=" + ToString(exitCode));
                }
                LogMessage("Cm.Build.Service: Build Server stopped." + exitCodeStr);
            }
            catch (const Exception& ex)
            {
                LogException(ex);
                LogMessage("Cm.Build.Service.StopServer: " + ex.Message());
            }
        }
        public void ProcessBuildRequest(const BuildRequest& request)
        {
            try
            {
/*
                if (!ServerRunning())
                {
                    if (!StartServer())
                    {
                        return;
                    }
                }
*/
                UniquePtr<JsonValue> requestJsonValue = request.ToJson();
                StreamWriter writer(File.CreateText(Path.Combine(CmCodeLogDir(), "build-request.json")));
                CodeFormatter formatter(writer);
                requestJsonValue->Write(formatter);
/*
                TcpSocket socket("localhost", ToString(port));
                string requestStr = requestJsonValue->ToString();
                Write(socket, requestStr);
                string replyStr = ReadStr(socket);
                UniquePtr<JsonValue> replyJsonValue = ParseJson(replyStr);
*/
            }
            catch (const Exception& ex)
            {
                LogException(ex);
                LogMessage("Cm.Build.Service.ProcessBuildRequest: " + ex.Message());
            }
        }
        private void LogServerMessages()
        {
            try
            {
                while (buildServer->Running())
                {
                    while (!buildServer->Eof(Process.StdHandle.stdOut))
                    {
                        string serverMessage = buildServer->ReadLine(Process.StdHandle.stdOut);
                        LogMessage(serverMessage);
                    }
                    while (!buildServer->Eof(Process.StdHandle.stdErr))
                    {
                        string serverMessage = buildServer->ReadLine(Process.StdHandle.stdErr);
                        LogMessage(serverMessage);
                    }
                }
            }
            catch (const Exception& ex)
            {
                LogException(ex);
            }
        }
        private void LogMessage(const string& message)
        {
            LockGuard<Mutex> lock(messageLogMutex);
            messageLog.Add(message);
            notifyLogMessageAvailable();
        }
        public nothrow bool MessageLogEmpty() const
        {
            LockGuard<Mutex> lock(messageLogMutex);
            return messageLog.IsEmpty();
        }
        public string FetchLogMessage()
        {
            LockGuard<Mutex> lock(messageLogMutex);
            if (!messageLog.IsEmpty())
            {
                string message = messageLog.Front();
                messageLog.RemoveFirst();
                return message;
            }
            return string();
        }
        private int port;
        private bool serverVerbose;
        private LogMessageNotificationFunction notifyLogMessageAvailable;
        private string serverStartCommand;
        private UniquePtr<Process> buildServer;
        private Thread logServerMessageThread;
        private LinkedList<string> messageLog;
        private Mutex messageLogMutex;
    }

    public void LogException(const Exception& ex)
    {
        try
        {
            StreamWriter errorWriter = File.CreateText(Path.Combine(CmCodeLogDir(), "error.txt"));
            errorWriter << ex.ToString() << endl();
        }
        catch (const Exception&)
        {
        }
    }
}

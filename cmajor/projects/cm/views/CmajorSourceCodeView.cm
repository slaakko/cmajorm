// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows;
using System.Lex;
using Cm.Lexer;
using CmajorTokens;
using Cm.Debug;

namespace Cm.Views
{
    public class IdentifierHoverEventArgs
    {
        public nothrow IdentifierHoverEventArgs(const ustring& identifier_, int lineNumber_, short columnNumber_) :
            identifier(identifier_), lineNumber(lineNumber_), columnNumber(columnNumber_)
        {
        }
        public ustring identifier;
        public int lineNumber;
        public short columnNumber;
    }

    public class delegate void IdentifierHoverEventHandler(IdentifierHoverEventArgs& args);

    public nothrow inline System.Windows.Color DefaultDebugLocationBackgroundColor()
    {
        return System.Windows.Color(255u, 241u, 129u);
    }

    public nothrow inline System.Windows.Color DefaultDebugLocationTextColor()
    {
        return System.Windows.Color.Black();
    }

    public nothrow inline Padding DebugLocationPadding()
    {
        return Padding(0, 2, 4, 0);
    }

    public class CmajorSourceCodeView : SourceCodeView
    {
        private enum Flags : sbyte
        {
            none = 0, generateIdentifierHoverEvents = 1 << 0
        }

        public CmajorSourceCodeView(const Point& location, const Size& size, Dock dock, Anchors anchors) :
            base(location, size, dock, anchors), lexer(null, null, string(), 0), flags(Flags.none), prevTokenPointed(null),
            debugLocationBackgroundColor(DefaultDebugLocationBackgroundColor()), debugLocationTextColor(DefaultDebugLocationTextColor())
        {
            lexer.SetCommentTokenId(COMMENT);
            Set<int> blockCommentStates;
            blockCommentStates.Insert(124);
            blockCommentStates.Insert(125);
            blockCommentStates.Insert(126);
            blockCommentStates.Insert(127);
            lexer.SetBlockCommentStates(blockCommentStates);
        }
        public nothrow void SetDebugLocationBackgroundColor(const System.Windows.Color& debugLocationBackgroundColor_)
        {
            debugLocationBackgroundColor = debugLocationBackgroundColor_;
        }
        public nothrow void SetDebugLocationTextColor(const System.Windows.Color& debugLocationTextColor_)
        {
            debugLocationTextColor = debugLocationTextColor_;
        }
        public nothrow inline DebugStrip* GetDebugStrip() const
        {
            return debugStrip;
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            try
            {
                base->OnKeyDown(args);
                if (!args.handled)
                {
                    switch (args.keyData)
                    {
                        case Keys.f9:
                        {
                            int line = CaretLine();
                            Breakpoint* bp = debugStrip->GetBreakpoint(line);
                            if (bp != null)
                            {
                                debugStrip->RemoveBreakpoint(bp);
                                debugStrip->Invalidate();
                            }
                            else
                            {
                                Breakpoint* bp = new Breakpoint(line);
                                debugStrip->AddBreakpoint(bp);
                                debugStrip->Invalidate();
                            }
                            args.handled = true;
                            break;
                        }
                        case Keys.f11:
                        {
                            int line = CaretLine();
                            SourceSpan debugLocation(line, 0, 0);
                            if (debugStrip->DebugLocation() == debugLocation)
                            {
                                debugStrip->ResetDebugLocation();
                            }
                            else
                            {
                                debugStrip->SetDebugLocation(debugLocation);
                            }
                            debugStrip->Invalidate();
                            args.handled = true;
                            break;
                        }
                        case Keys.f2:
                        {
                            int line = CaretLine();
                            Breakpoint* bp = debugStrip->GetBreakpoint(line);
                            if (bp != null)
                            {
                                bp->disabled = !bp->disabled;
                                debugStrip->Invalidate();
                            }
                            args.handled = true;
                            break;
                        }
                    }
                }
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message(), "Error", null, cast<MessageBoxType>(MessageBoxType.MB_OK | MessageBoxType.MB_ICONSTOP));
            }
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            try
            {
                base->OnMouseMove(args);
                if (GenerateIdentifierHoverEvents())
                {
                    int lineNumber = 0;
                    short columnNumber = 0;
                    GetLineColumn(args.location, lineNumber, columnNumber);
                    if (lineNumber >= 1 && lineNumber <= Lines().Count() && columnNumber >= 1 && columnNumber <= GetLineLength(lineNumber))
                    {
                        Pair<Token*, short> tokenColumn = GetToken(lineNumber, columnNumber);
                        Token* token = tokenColumn.first;
                        if (token != null)
                        {
                            if (token != prevTokenPointed)
                            {
                                prevTokenPointed = token;
                                SourceCodeTokenKind tokenKind = GetTokenKind(*token);
                                if (tokenKind == SourceCodeTokenKind.identifier)
                                {
                                    OnIdentifierHovered(token->match.ToString(), lineNumber, tokenColumn.second);
                                }
                            }
                        }
                        else
                        {
                            prevTokenPointed = null;
                        }
                    }
                    else
                    {
                        prevTokenPointed = null;
                    }
                }
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message(), "Error", null, cast<MessageBoxType>(MessageBoxType.MB_OK | MessageBoxType.MB_ICONSTOP));
            }
        }
        protected virtual void OnIdentifierHovered(const ustring& identifier, int lineNumber, short columnNumber)
        {
            IdentifierHoverEventArgs args(identifier, lineNumber, columnNumber);
            identifierHoverEvent.Fire(args);
        }
        protected override void DrawHilites(Graphics& graphics, int lineIndex, const PointF& origin)
        {
            SourceSpan debugLocation = debugStrip->DebugLocation();
            if (!debugLocation.IsEmpty() && debugLocation.line == lineIndex + 1)
            {
                DrawDebugLocationHilite(graphics, debugLocation, origin);
            }
        }
        private void DrawDebugLocationHilite(Graphics& graphics, const SourceSpan& debugLocation, const PointF& origin)
        {
            string hiliteText = ToUtf8(GetText(debugLocation));
            int n = Max(cast<int>(0), cast<int>(debugLocation.ecol - debugLocation.scol));
            RectF r(PointF(origin.x + CharWidth() * (debugLocation.scol - 1), origin.y), SizeF(CharWidth() * n, CharHeight()));
            Brush* backgroundBrush = GetOrInsertBrush(debugLocationBackgroundColor);
            Padding padding = DebugLocationPadding();
            RectF f(PointF(r.location.x - padding.left, r.location.y - padding.top), SizeF(r.size.w + padding.Horizontal(), r.size.h + padding.Vertical()));
            graphics.FillRectangleChecked(*backgroundBrush, f);
            if (!hiliteText.IsEmpty())
            {
                Brush* textBrush = GetOrInsertBrush(debugLocationTextColor);
                Font* font = GetOrInsertFont(FontStyle.regular);
                graphics.DrawStringChecked(hiliteText, *font, r.location, *textBrush);
            }
        }
        protected override TokenLine TokenizeLine(const ustring& line, int lineNumber, int startState)
        {
            TokenLine tokenLine = lexer.TokenizeLine(line, lineNumber, startState);
            int tokenIndex = 0;
            for (Token& token : tokenLine.tokens)
            {
                ustring s = token.match.ToString();
                string sl = MakeStringLiteral(ToUtf8(s));
                switch (startState)
                {
                    case 0:
                    {
                        if (token.id == CONTINUE_TOKEN)
                        {
                            if (s.Length() >= 2)
                            {
                                if (s[0] == '/' && s[1] == '/')
                                {
                                    token.id = COMMENT;
                                    tokenLine.endState = 0;
                                }
                                else if (s[0] == '/' && s[1] == '*')
                                {
                                    token.id = COMMENT;
                                }
                            }
                            else if (!s.IsEmpty())
                            {
                                if (IsWhiteSpace(s[0]))
                                {
                                    token.id = WS;
                                    if (tokenIndex == tokenLine.tokens.Count() -1)
                                    {
                                        tokenLine.endState = 0;
                                    }
                                }
                            }
                        }
                        break;
                    }
                    default:
                    {
                        if (lexer.BlockCommentStates().CFind(startState) != lexer.BlockCommentStates().CEnd())
                        {
                            token.id = COMMENT;
                        }
                        break;
                    }
                }
                startState = 0;
                ++tokenIndex;
            }
            return tokenLine;
        }
        protected override nothrow SourceCodeTokenKind GetTokenKind(const Token& token) const
        {
            switch (token.id)
            {
                case ASSERT: case ELIF: case ENDIF: case BOOL: case TRUE: case FALSE:
                case SBYTE: case BYTE: case SHORT: case USHORT: case INT: case UINT:
                case LONG: case ULONG: case FLOAT: case DOUBLE: case CHAR: case WCHAR:
                case UCHAR: case VOID: case ENUM: case CAST: case INTERFACE: case NAMESPACE:
                case USING: case STATIC: case EXTERN: case AS: case IS: case EXPLICIT:
                case DELEGATE: case INLINE: case CDECL: case NOTHROW: case PUBLIC:
                case PROTECTED: case PRIVATE: case INTERNAL: case VIRTUAL: case ABSTRACT:
                case OVERRIDE: case SUPPRESS: case WINAPI: case OPERATOR: case CLASS:
                case RETURN: case IF: case ELSE: case SWITCH: case CASE: case DEFAULT:
                case WHILE: case DO: case FOR: case BREAK: case CONTINUE: case GOTO:
                case TYPEDEF: case TYPENAME: case TYPEID: case CONST: case CONSTEXPR:
                case NULLLIT: case THIS: case BASE: case CONSTRUCT: case DESTROY:
                case NEW: case DELETE: case SIZEOF: case TRY: case CATCH: case THROW:
                case CONCEPT: case WHERE: case AXIOM: case AND: case OR: 
                {
                    return SourceCodeTokenKind.keyword;
                }
                case ID:
                {
                    return SourceCodeTokenKind.identifier;
                }
                case EXCLAMATION: case UNIT_TEST: case EQUIVALENCE: case IMPLICATION:
                case DISJUNCTION: case AMPAMP: case BITOR: case BITXOR: case AMP:
                case EQ: case NEQ: case LEQ: case GEQ: case SHIFTLEFT: case SHIFTRIGHT:
                case PLUS: case MINUS: case STAR: case DIV: case REM: case PLUSPLUS:
                case MINUSMINUS: case CPL: case DOT: case ARROW: case LBRACKET:
                case RBRACKET: case LPAREN: case RPAREN: case LANGLE: case RANGLE:
                case LBRACE: case RBRACE: case COMMA: case ASSIGN: case COLON:
                case SEMICOLON: case HASH: case WS:
                {
                    return SourceCodeTokenKind.plain;
                }
                case FLOATINGLIT: case INTLIT: 
                {
                    return SourceCodeTokenKind.number;
                }
                case CHARLIT:
                {
                    return SourceCodeTokenKind.character;
                }
                case STRINGLIT:
                {
                    return SourceCodeTokenKind.string;
                }
                case COMMENT:
                {
                    return SourceCodeTokenKind.comment;
                }
            }
            return SourceCodeTokenKind.plain;
        }
        public nothrow inline void DoGenerateIdentifierHoverEvents()
        {
            SetFlag(Flags.generateIdentifierHoverEvents);
        }
        public nothrow inline void DontGenerateIdentifierHoverEvents()
        {
            ResetFlag(Flags.generateIdentifierHoverEvents);
        }
        public nothrow inline Event<IdentifierHoverEventHandler, IdentifierHoverEventArgs>& IdentifierHoverEvent()
        {
            return identifierHoverEvent;
        }
        private nothrow inline bool GenerateIdentifierHoverEvents() const
        {
            return GetFlag(Flags.generateIdentifierHoverEvents);
        }
        internal nothrow void SetDebugStrip(DebugStrip* debugStrip_)
        {
            debugStrip = debugStrip_;
        }
        private inline nothrow bool GetFlag(Flags flag) const
        {
            return (flags & flag) != Flags.none;
        }
        private inline nothrow void SetFlag(Flags flag)
        {
            flags = cast<Flags>(flags | flag);
        }
        private inline nothrow void ResetFlag(Flags flag)
        {
            flags = cast<Flags>(flags & ~flag);
        }
        private Flags flags;
        private CmajorLexer lexer;
        private DebugStrip* debugStrip;
        private Token* prevTokenPointed;
        private Event<IdentifierHoverEventHandler, IdentifierHoverEventArgs> identifierHoverEvent;
        private System.Windows.Color debugLocationBackgroundColor;
        private System.Windows.Color debugLocationTextColor;
    }
}

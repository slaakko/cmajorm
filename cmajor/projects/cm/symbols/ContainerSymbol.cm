// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using Span = System.Lex.Span;

namespace Cm.Symbols
{
    public class ContainerSymbol : Symbol
    {
        public nothrow ContainerSymbol(SymbolType symbolType, const Span& span, const Uuid& sourceModuleId, const ustring& name) :
            base(symbolType, span, sourceModuleId, name)
        {
        }
        public override void Write(SymbolWriter& writer)
        {
            base->Write(writer);
            List<Symbol*> exportSymbols;
            for (const UniquePtr<Symbol>& member : members)
            {
                if (member->IsExportSymbol())
                {
                    exportSymbols.Add(member.Get());
                }
            }
            uint n = cast<uint>(exportSymbols.Count());
            writer.GetBinaryWriter().WriteULEB128UInt(n);
            for (uint i = 0u; i < n; ++i)
            {
                writer.Write(exportSymbols[i]);
            }
        }
        public override void Read(SymbolReader& reader)
        {
            base->Read(reader);
            uint n = reader.GetBinaryReader().ReadULEB128UInt();
            for (uint i = 0u; i < n; ++i)
            {
                Symbol* symbol = reader.ReadSymbol(this);
                AddMember(symbol);
            }
        }
        public virtual void AddMember(Symbol* member)
        {
            if (GetModule() != null)
            {
                member->SetModule(GetModule());
            }
            member->SetParent(this);
            member->SetSymbolIndex(cast<int>(members.Count()));
            members.Add(UniquePtr<Symbol>(member));
            if (member is FunctionSymbol*)
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(member);
                FunctionGroupSymbol* functionGroupSymbol = MakeFunctionGroupSymbol(functionSymbol->GroupName(), functionSymbol->GetSpan(),
                    functionSymbol->SourceModuleId());
                functionGroupSymbol->AddFunction(functionSymbol);
                functionIndexMap[functionSymbol->GetIndex()] = functionSymbol;
            }
            else if (member is ClassTypeSymbol*)
            {

            }
            else if (member is ConceptSymbol*)
            {

            }
            else if (member is GlobalVariableSymbol*)
            {

            }
            else
            {
                containerScope.Install(member);
            }
        }
        public void AddOwnedMember(Symbol* ownedMember)
        {
            if (ownedMember is FunctionSymbol*)
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(ownedMember);
                FunctionGroupSymbol* functionGroupSymbol = MakeFunctionGroupSymbol(functionSymbol->GroupName(), functionSymbol->GetSpan(),
                    functionSymbol->SourceModuleId());
                functionGroupSymbol->AddFunction(functionSymbol);
                functionIndexMap[functionSymbol->GetIndex()] = functionSymbol;
            }
            else if (ownedMember is ClassTypeSymbol*)
            {

            }
            else if (ownedMember is ConceptSymbol*)
            {
            }
            else if (ownedMember is GlobalVariableSymbol*)
            {
            }
            else
            {
                containerScope.Install(ownedMember);
            }
        }
        public nothrow inline const ContainerScope* GetContainerScope() const
        {
            return &containerScope;
        }
        private FunctionGroupSymbol* MakeFunctionGroupSymbol(const ustring& groupName, const Span& span, const Uuid& sourceModuleId)
        {
            Symbol* symbol = containerScope.Lookup(groupName);
            if (symbol == null)
            {
                FunctionGroupSymbol* functionGroupSymbol = new FunctionGroupSymbol(span, sourceModuleId, groupName);
                AddMember(functionGroupSymbol);
                return functionGroupSymbol;
            }
            else
            {
                if (symbol is FunctionGroupSymbol*)
                {
                    return cast<FunctionGroupSymbol*>(symbol);
                }
                else
                {
                    throw SymbolException("name of symbol '" + ToUtf8(symbol->FullName()) + "' conflicts with function group '" + ToUtf8(groupName) + "'",
                        symbol->GetSpan(), symbol->SourceModuleId(), span, sourceModuleId);
                }
            }
        }
        private ClassGroupTypeSymbol* MakeClassGroupTypeSymbol(const ustring& groupName, const Span& span, const Uuid& sourceModuleId)
        {
            Symbol* symbol = containerScope.Lookup(groupName);
            if (symbol == null)
            {
                ClassGroupTypeSymbol* classGroupTypeSymbol = new ClassGroupTypeSymbol(span, sourceModuleId, groupName);
                AddMember(classGroupTypeSymbol);
                return classGroupTypeSymbol;
            }
            else
            {
                if (symbol is ClassGroupTypeSymbol*)
                {
                    return cast<ClassGroupTypeSymbol*>(symbol);
                }
                else
                {
                    throw SymbolException("name of symbol '" + ToUtf8(symbol->FullName()) + "' conflicts with class group '" + ToUtf8(groupName) + "'",
                        symbol->GetSpan(), symbol->SourceModuleId(), span, sourceModuleId);
                }
            }
        }
        private List<UniquePtr<Symbol>> members;
        private ContainerScope containerScope;
        private HashMap<int, FunctionSymbol*> functionIndexMap;
    }
}

// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using Span = System.Lex.Span;
using System.Collections;
using Node = Cm.Ast.Node;
using NodeList = Cm.Ast.NodeList;
using FunctionNode = Cm.Ast.FunctionNode;
using ConstraintNode = Cm.Ast.ConstraintNode;

namespace Cm.Symbols
{
    public enum FunctionSymbolFlags : uint
    {
        none = 0u,
        inline_ = 1u << 0u,
        constExpr = 1u << 1u,
        cdecl_ = 1u << 2u,
        suppress_ = 1u << 3u,
        default_ = 1u << 4u,
        explicit_ = 1u << 5u,
        virtual_ = 1u << 6u,
        override_ = 1u << 7u,
        abstract_ = 1u << 8u,
        new_ = 1u << 9u,
        const_ = 1u << 10u,
        conversion_ = 1u << 11u,
        linkOnceOdrLinkage_ = 1u << 12u,
        templateSpecialization_ = 1u << 13u,
        hasTry_ = 1u << 14u,
        hasSource_ = 1u << 15u,
        includeConstraint_ = 1u << 16u,
        copy_ = 1u << 17u,
        varArg_ = 1u << 18u,
        winapi_ = 1u << 19u,
        dontReuse_ = 1u << 20u,
        hasArtificialBody_ = 1u << 21u,
        hasCleanup_ = 1u << 22u,
        systemDefault = 1u << 23u,
        immutable = 1u << 24u,
        programMain = 1u << 25u
    }

    public class FunctionGroupSymbol : Symbol
    {
        public nothrow FunctionGroupSymbol(const Span& span, const Uuid& sourceModuleId, const ustring& name) :
            base(SymbolType.functionGroupSymbol, span, sourceModuleId, name)
        {
        }
        public nothrow override bool IsExportSymbol() const
        {
            return false;
        }
        public void AddFunction(FunctionSymbol* functionSymbol)
        {
            if (functionSymbol->GetFlag(FunctionSymbolFlags.programMain)) return;
            #assert(functionSymbol->GroupName() == Name());
            if (functionSymbol->GetFlag(FunctionSymbolFlags.varArg_))
            {
                varArgFunctions.Add(functionSymbol);
            }
            else
            {
                int arity = functionSymbol->Arity();
                List<FunctionSymbol*>& functionList = arityFunctionListMap[arity];
                functionList.Add(functionSymbol);
                functionSymbol->SetFunctionGroup(this);
            }
        }
        public void RemoveFunction(FunctionSymbol* functionSymbol)
        {
            if (functionSymbol->GetFlag(FunctionSymbolFlags.varArg_))
            {
                varArgFunctions.Remove(functionSymbol);
            }
            else
            {
                int arity = functionSymbol->Arity();
                List<FunctionSymbol*>& functionList = arityFunctionListMap[arity];
                functionList.Remove(functionSymbol);
            }
        }
        public nothrow bool IsEmpty() const
        {
            for (const Pair<int, List<FunctionSymbol*>>& p : arityFunctionListMap)
            {
                if (!p.second.IsEmpty()) return false;
            }
            return true;
        }
        private HashMap<int, List<FunctionSymbol*>> arityFunctionListMap;
        private List<FunctionSymbol*> varArgFunctions;
    }

    public class FunctionSymbol : ContainerSymbol
    {
         public nothrow FunctionSymbol(const Span& span, const Uuid& sourceModuleId, const ustring& name) :
             base(SymbolType.functionSymbol, span, sourceModuleId, name), index(-1)
         {
         }
         public nothrow FunctionSymbol(SymbolType symbolType, const Span& span, const Uuid& sourceModuleId, const ustring& name) :
             base(symbolType, span, sourceModuleId, name), index(-1)
         {
         }
         public override void Write(SymbolWriter& writer)
         {
             base->Write(writer);
             #assert(functionId != Uuid());
             writer.GetBinaryWriter().Write(functionId);
             writer.GetBinaryWriter().Write(index);
             writer.GetBinaryWriter().Write(groupName);
             writer.GetBinaryWriter().Write(cast<uint>(flags));
             Uuid functionTemplateId;
             if (functionTemplate != null)
             {
                 functionTemplateId = functionTemplate->FunctionId();
             }
             writer.GetBinaryWriter().Write(functionTemplateId);
             if (!templateParameters.IsEmpty() ||
                 (GetGlobalFlag(GlobalFlags.release) && GetFlag(FunctionSymbolFlags.inline_)) ||
                 GetFlag(FunctionSymbolFlags.constExpr))
             {
                 usingNodes.Write(writer.GetAstWriter());
                 Node* node = GetRootModule()->GetSymbolTable().GetNode(this);
                 writer.GetAstWriter().Write(node);
             }
             Uuid returnTypeId;
             if (returnType != null)
             {
                 returnTypeId = returnType->TypeId();
             }
             writer.GetBinaryWriter().Write(returnTypeId);
             writer.GetBinaryWriter().Write(vmtIndex);
             writer.GetBinaryWriter().Write(imtIndex);
             bool hasReturnParam = !returnParam.IsNull();
             writer.GetBinaryWriter().Write(hasReturnParam);
             if (hasReturnParam)
             {
                 writer.Write(returnParam.Get());
             }
             bool hasConstraint = !constraint.IsNull();
             writer.GetBinaryWriter().Write(hasConstraint);
             if (hasConstraint)
             {
                 writer.GetAstWriter().Write(constraint.Get());
             }
             uint n = cast<uint>(templateArgumentTypes.Count());
             writer.GetBinaryWriter().WriteULEB128UInt(n);
             for (uint i = 0u; i < n; ++i)
             {
                 TypeSymbol* templateArgumentType = templateArgumentTypes[i];
                 writer.GetBinaryWriter().Write(templateArgumentType->TypeId());
             }
             if (GetFlag(FunctionSymbolFlags.conversion_))
             {
                 writer.GetBinaryWriter().Write(conversionSourceType->TypeId());
                 writer.GetBinaryWriter().Write(conversionTargetType->TypeId());
             }
         }
         public override void Read(SymbolReader& reader)
         {
             base->Read(reader);
             functionId = reader.GetBinaryReader().ReadUuid();
             index = reader.GetBinaryReader().ReadInt();
             groupName = reader.GetBinaryReader().ReadUString();
             flags = cast<FunctionSymbolFlags>(reader.GetBinaryReader().ReadUInt());
             Uuid functionTemplateId = reader.GetBinaryReader().ReadUuid();
             if (functionTemplateId != Uuid())
             {
                 reader.GetSymbolTable()->EmplaceFunctionRequest(reader, this, functionTemplateId, 0);
             }
             if (!templateParameters.IsEmpty() ||
                 (GetGlobalFlag(GlobalFlags.release) && GetFlag(FunctionSymbolFlags.inline_)) ||
                 GetFlag(FunctionSymbolFlags.constExpr))
             {
                 usingNodes.Read(reader.GetAstReader());
                 Node* node = reader.GetAstReader().ReadNode();
                 #assert(node is FunctionNode*);
                 functionNode.Reset(cast<FunctionNode*>(node));
             }
             Uuid returnTypeId = reader.GetBinaryReader().ReadUuid();
             if (returnTypeId != Uuid())
             {
                 reader.GetSymbolTable()->EmplaceTypeRequest(reader, this, returnTypeId, 0);
             }
             vmtIndex = reader.GetBinaryReader().ReadInt();
             imtIndex = reader.GetBinaryReader().ReadInt();
             bool hasReturnParam = reader.GetBinaryReader().ReadBool();
             if (hasReturnParam)
             {
                 returnParam.Reset(reader.ReadParameterSymbol(this));
             }
             bool hasConstraint = reader.GetBinaryReader().ReadBool();
             if (hasConstraint)
             {
                 constraint.Reset(reader.GetAstReader().ReadConstraintNode());
             }
             uint n = reader.GetBinaryReader().ReadULEB128UInt();
             templateArgumentTypes.Resize(n);
             for (uint i = 0u; i < n; ++i)
             {
                 Uuid templateArgumentId = reader.GetBinaryReader().ReadUuid();
                 reader.GetSymbolTable()->EmplaceTypeRequest(reader, this, templateArgumentId, -1 - cast<int>(i));
             }
             if (GetFlag(FunctionSymbolFlags.conversion_))
             {
                 Uuid conversionSourceTypeId = reader.GetBinaryReader().ReadUuid();
                 reader.GetSymbolTable()->EmplaceTypeRequest(reader, this, conversionSourceTypeId, 10000);
                 Uuid conversionTargetTypeId = reader.GetBinaryReader().ReadUuid();
                 reader.GetSymbolTable()->EmplaceTypeRequest(reader, this, conversionTargetTypeId, 10001);
                 reader.AddConversion(this);
             }
         }
         public override void EmplaceFunction(FunctionSymbol* functionSymbol, int index)
         {
             #assert(index == 0);
             functionTemplate = functionSymbol;
         }
         public override void EmplaceType(TypeSymbol* typeSymbol, int index)
         {
             if (index == 0)
             {
                 returnType = typeSymbol;
             }
             else if (index == 10000)
             {
                 conversionSourceType = typeSymbol;
             }
             else if (index == 10001)
             {
                 conversionTargetType = typeSymbol;
             }
             else if (index < 0)
             {
                 int templateArgumentIndex = -(index + 1);
                 if (templateArgumentIndex < 0 || templateArgumentIndex >= templateArgumentTypes.Count())
                 {
                     throw SymbolException("invalid emplace template argument index '" + ToString(templateArgumentIndex) + "'", GetSpan(), SourceModuleId());
                 }
                 templateArgumentTypes[templateArgumentIndex] = typeSymbol;
             }
             else
             {
                 throw SymbolException("invalid emplace type index '" + ToString(index) + "'", GetSpan(), SourceModuleId());
             }
         }
         public override void AddMember(Symbol* member)
         {
             base->AddMember(member);
             if (member is ParameterSymbol*)
             {
                 parameters.Add(cast<ParameterSymbol*>(member));
             }
             else if (member is TemplateParameterSymbol*)
             {
                 templateParameters.Add(cast<TemplateParameterSymbol*>(member));
             }
         }
         public nothrow inline const Uuid& FunctionId() const
         {
             #assert(functionId != Uuid());
             return functionId;
         }
         public nothrow void SetFunctionId(const Uuid& functionId_)
         {
             functionId = functionId_;
         }
         public nothrow inline int GetIndex() const
         {
             return index;
         }
         public nothrow void SetIndex(int index_)
         {
             index = index_;
         }
         public nothrow inline const ustring& GroupName() const
         {
             return groupName;
         }
         public nothrow void SetGroupName(const ustring& groupName_)
         {
             groupName = groupName_;
         }
         public nothrow inline FunctionGroupSymbol* FunctionGroup() const
         {
             return functionGroup;
         }
         public nothrow void SetFunctionGroup(FunctionGroupSymbol* functionGroup_)
         {
             functionGroup = functionGroup_;
         }
         public nothrow inline FunctionSymbol* FunctionTemplate() const
         {
             return functionTemplate;
         }
         public nothrow void SetFunctionTemplate(FunctionSymbol* functionTemplate_)
         {
             functionTemplate = functionTemplate_;
         }
         public nothrow inline const List<TypeSymbol*>& TemplateArgumentTypes() const
         {
             return templateArgumentTypes;
         }
         public nothrow void SetTemplateArgumentTypes(const List<TypeSymbol*>& templateArgumentTypes_)
         {
             templateArgumentTypes = templateArgumentTypes_;
         }
         public nothrow inline FunctionSymbol* Master() const
         {
             return master;
         }
         public nothrow void SetMaster(FunctionSymbol* master_)
         {
             master = master_;
         }
         public nothrow inline int Arity() const
         {
             return cast<int>(parameters.Count());
         }
         public nothrow inline TypeSymbol* ConversionSourceType() const
         {
             return conversionSourceType;
         }
         public nothrow void SetConversionSourceType(TypeSymbol* conversionSourceType_)
         {
             conversionSourceType = conversionSourceType_;
         }
         public nothrow inline TypeSymbol* ConversionTargetType() const
         {
             return conversionTargetType;
         }
         public nothrow void SetConversionTargetType(TypeSymbol* conversionTargetType_)
         {
             conversionTargetType = conversionTargetType_;
         }
         public nothrow inline FunctionSymbolFlags GetFunctionSymbolFlags() const
         {
             return flags;
         }
         public nothrow inline bool GetFlag(FunctionSymbolFlags flag) const
         {
             return (flags & flag) != FunctionSymbolFlags.none;
         }
         public nothrow inline void SetFlag(FunctionSymbolFlags flag)
         {
             flags = cast<FunctionSymbolFlags>(flags | flag);
         }
         public nothrow inline void ResetFlag(FunctionSymbolFlags flag)
         {
             flags = cast<FunctionSymbolFlags>(flags & ~flag);
         }
         private Uuid functionId;
         private int index;
         private ustring groupName;
         private FunctionSymbolFlags flags;
         private FunctionGroupSymbol* functionGroup;
         private List<ParameterSymbol*> parameters;
         private List<TemplateParameterSymbol*> templateParameters;
         private FunctionSymbol* functionTemplate;
         private List<TypeSymbol*> templateArgumentTypes;
         private FunctionSymbol* master;
         private NodeList<Node> usingNodes;
         private UniquePtr<FunctionNode> functionNode;
         private TypeSymbol* returnType;
         private int vmtIndex;
         private int imtIndex;
         private UniquePtr<ParameterSymbol> returnParam;
         private UniquePtr<ConstraintNode> constraint;
         private TypeSymbol* conversionSourceType;
         private TypeSymbol* conversionTargetType;
    }
}


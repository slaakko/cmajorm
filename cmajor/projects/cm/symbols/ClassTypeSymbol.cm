// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using Span = System.Lex.Span;
using System.Collections;

namespace Cm.Symbols
{
    public class ClassGroupTypeSymbol : TypeSymbol
    {
         public nothrow ClassGroupTypeSymbol(const Span& span, const Uuid& sourceModuleId, const ustring& name) :
             base(SymbolType.classGroupTypeSymbol, span, sourceModuleId, name)
         {
         }
         public nothrow override bool IsExportSymbol() const
         {
             return false;
         }
         public void AddClass(ClassTypeSymbol* classTypeSymbol)
         {
             // todo
         }
         public void RemoveClass(ClassTypeSymbol* classTypeSymbol)
         {
             // todo
         }
         public nothrow bool IsEmpty() const
         {
             return arityClassMap.IsEmpty();
         }
         private HashMap<int, ClassTypeSymbol*> arityClassMap;
    }

    public class ClassTypeSymbol : TypeSymbol
    {
        public nothrow ClassTypeSymbol(const Span& span, const Uuid& sourceModuleId, const ustring& name) :
            base(SymbolType.classTypeSymbol, span, sourceModuleId, name)
        {
        }
        public nothrow ClassTypeSymbol(SymbolType symbolType, const Span& span, const Uuid& sourceModuleId, const ustring& name) :
            base(symbolType, span, sourceModuleId, name)
        {
        }
        public override void Write(SymbolWriter& writer)
        {
            base->Write(writer);
            // todo
        }
        public override void Read(SymbolReader& reader)
        {
            base->Read(reader);
            // todo
        }
        public override void AddMember(Symbol* member)
        {
            base->AddMember(member);
            // todo
        }
        public nothrow override bool IsParentSymbol() const
        {
            return false;
        }
        public nothrow inline int MinArity() const
        {
            return minArity;
        }
        public nothrow inline int MaxArity() const
        {
            return cast<int>(templateParameters.Count());
        }
        public nothrow void ComputeMinArity()
        {
            bool defaultHit = false;
            int n = cast<int>(templateParameters.Count());
            for (int i = 0; i < n; ++i)
            {
                TemplateParameterSymbol* templateParameter = templateParameters[i];
                if (templateParameter->HasDefault())
                {
                    defaultHit = true;
                    break;
                }
                minArity = i;
            }
            if (!defaultHit)
            {
                minArity = n;
            }
        }
        public nothrow inline ClassTypeSymbol* BaseClass() const
        {
            return baseClass;
        }
        public nothrow void SetBaseClass(ClassTypeSymbol* baseClass_)
        {
            baseClass = baseClass_;
        }    
        private int minArity;
        private ClassTypeSymbol* baseClass;
        private List<TemplateParameterSymbol*> templateParameters;
    }
}

// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using Node = Cm.Ast.Node;

namespace Cm.Symbols
{
    public class TypeOrConceptRequest
    {
        public nothrow TypeOrConceptRequest(Symbol* symbol_, const Uuid& typeId_, int index_) : symbol(symbol_), typeId(typeId_), index(index_)
        {
        }
        public Symbol* symbol;
        public Uuid typeId;
        public int index;
    }

    public class FunctionRequest
    {
        public nothrow FunctionRequest(Symbol* symbol_, const Uuid& functionId_, int index_) : symbol(symbol_), functionId(functionId_), index(index_)
        {
        }
        public Symbol* symbol;
        public Uuid functionId;
        public int index;
    }

    public class SymbolTable
    {
        public nothrow SymbolTable(Module* module_) : module(module_)
        {
        }
        public nothrow inline Module* GetModule() const
        {
            return module;
        }
        public nothrow void MapNode(Node* node, Symbol* symbol)
        {
            nodeSymbolMap[node] = symbol;
            symbolNodeMap[symbol] = node;
        }
        public nothrow Node* GetNodeNothrow(Symbol* symbol) const
        {
            HashMap<Symbol*, Node*>.ConstIterator it = symbolNodeMap.CFind(symbol);
            if (it != symbolNodeMap.CEnd())
            {
                Node* node = it->second;
                return node;
            }
            return null;
        }
        public Node* GetNode(Symbol* symbol) const
        {
            Node* node = GetNodeNothrow(symbol);
            if (node != null)
            {
                return node;
            }
            else
            {
                throw Exception("node for symbol not found");
            }
        }
        public Symbol* GetSymbolNothrow(Node* node) const
        {
            HashMap<Node*, Symbol*>.ConstIterator it = nodeSymbolMap.CFind(node);
            if (it != nodeSymbolMap.CEnd())
            {
                Symbol* symbol = it->second;
                return symbol;
            }
            return null;
        }
        public Symbol* GetSymbol(Node* node) const
        {
            Symbol* symbol = GetSymbolNothrow(node);
            if (symbol != null)
            {
                return symbol;
            }
            else
            {
                throw Exception("symbol for node not found");
            }
        }
        public nothrow NamespaceSymbol* GetMappedNs(NamespaceSymbol* fromNs) const
        {
            HashMap<NamespaceSymbol*, NamespaceSymbol*>.ConstIterator it = nsMap.CFind(fromNs);
            if (it != nsMap.CEnd())
            {
                return it->second;
            }
            return null;
        }
        public nothrow void MapNs(NamespaceSymbol* fromNs, NamespaceSymbol* toNs)
        {
            nsMap[fromNs] = toNs;
        }
        public nothrow void EmplaceFunctionRequest(SymbolReader& reader, Symbol* forSymbol, const Uuid& functionId, int index)
        {
            HashMap<Uuid, FunctionSymbol*>.ConstIterator it = functionIdMap.CFind(functionId);
            if (it != functionIdMap.CEnd())
            {
                FunctionSymbol* functionSymbol = it->second;
                forSymbol->EmplaceFunction(functionSymbol, index);
            }
            else
            {
                reader.AddFunctionRequest(FunctionRequest(forSymbol, functionId, index));
            }
        }
        public void EmplaceTypeRequest(SymbolReader& reader, Symbol* forSymbol, const Uuid& typeId, int index)
        {
            HashMap<Uuid, Symbol*>.ConstIterator it = typeIdMap.CFind(typeId);
            if (it != typeIdMap.CEnd())
            {
                Symbol* symbol = it->second;
                if (symbol is TypeSymbol*)
                {
                    forSymbol->EmplaceType(cast<TypeSymbol*>(symbol), index);
                }
                else
                {
                    throw Exception("internal error: type symbol expected");
                }
            }
            else
            {
                reader.AddTypeOrConceptRequest(TypeOrConceptRequest(forSymbol, typeId, index));
            }
        }
        private Module* module;
        private HashMap<Symbol*, Node*> symbolNodeMap;
        private HashMap<Node*, Symbol*> nodeSymbolMap;
        private HashMap<NamespaceSymbol*, NamespaceSymbol*> nsMap;
        private HashMap<Uuid, Symbol*> typeIdMap;
        private HashMap<Uuid, FunctionSymbol*> functionIdMap;
    }
}

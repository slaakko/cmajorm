using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using System;
using Cm.Ast;
using Cm.NothrowParser;
using CmajorNothrowTokens;

// this file has been automatically generated from 'C:/work/cmajorm/cmajor/projects/cm/nothrowparser/Statement.parser' using soulcm parser generator scmpg version 3.10.0

public static class NothrowStatementParser
{
    public static nothrow Match Statement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Statement");
            }
        #endif
        UniquePtr<StatementNode> labeledStatement;
        UniquePtr<StatementNode> controlStatement;
        UniquePtr<StatementNode> expressionStatement;
        UniquePtr<StatementNode> assignmentStatement;
        UniquePtr<ConstructionStatementNode> constructionStatement;
        UniquePtr<StatementNode> deleteStatement;
        UniquePtr<StatementNode> destroyStatement;
        UniquePtr<StatementNode> emptyStatement;
        UniquePtr<StatementNode> throwStatement;
        UniquePtr<TryStatementNode> tryStatement;
        UniquePtr<StatementNode> assertStatement;
        UniquePtr<ConditionalCompilationStatementNode> condCompStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = NothrowStatementParser.LabeledStatement(lexer, ctx);
                                                            labeledStatement.Reset(cast<StatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                    #endif
                                                                    return Match(true, labeledStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch11 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch14 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = NothrowStatementParser.ControlStatement(lexer, ctx);
                                                                    controlStatement.Reset(cast<StatementNode*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        {
                                                                            #if (DEBUG)
                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                            #endif
                                                                            return Match(true, controlStatement.Release());
                                                                        }
                                                                    }
                                                                    *parentMatch14 = match;
                                                                }
                                                                *parentMatch13 = match;
                                                            }
                                                            *parentMatch11 = match;
                                                        }
                                                    }
                                                    *parentMatch10 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch15 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch16 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match = NothrowStatementParser.ExpressionStatement(lexer, ctx);
                                                                expressionStatement.Reset(cast<StatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    {
                                                                        #if (DEBUG)
                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                        #endif
                                                                        return Match(true, expressionStatement.Release());
                                                                    }
                                                                }
                                                                *parentMatch16 = match;
                                                            }
                                                            *parentMatch15 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                }
                                                *parentMatch9 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch17 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch18 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = NothrowStatementParser.AssignmentStatement(lexer, ctx);
                                                            assignmentStatement.Reset(cast<StatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                    #endif
                                                                    return Match(true, assignmentStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch18 = match;
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch20 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = NothrowStatementParser.ConstructionStatement(lexer, ctx);
                                                        constructionStatement.Reset(cast<ConstructionStatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                #endif
                                                                return Match(true, constructionStatement.Release());
                                                            }
                                                        }
                                                        *parentMatch20 = match;
                                                    }
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch21 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch22 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = NothrowStatementParser.DeleteStatement(lexer, ctx);
                                                    deleteStatement.Reset(cast<StatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                            #endif
                                                            return Match(true, deleteStatement.Release());
                                                        }
                                                    }
                                                    *parentMatch22 = match;
                                                }
                                                *parentMatch21 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch23 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch24 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = NothrowStatementParser.DestroyStatement(lexer, ctx);
                                                destroyStatement.Reset(cast<StatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                        #endif
                                                        return Match(true, destroyStatement.Release());
                                                    }
                                                }
                                                *parentMatch24 = match;
                                            }
                                            *parentMatch23 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch25 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowStatementParser.EmptyStatement(lexer, ctx);
                                            emptyStatement.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                    #endif
                                                    return Match(true, emptyStatement.Release());
                                                }
                                            }
                                            *parentMatch26 = match;
                                        }
                                        *parentMatch25 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch27 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch28 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = NothrowStatementParser.ThrowStatement(lexer, ctx);
                                        throwStatement.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                #endif
                                                return Match(true, throwStatement.Release());
                                            }
                                        }
                                        *parentMatch28 = match;
                                    }
                                    *parentMatch27 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch29 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch30 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = NothrowStatementParser.TryStatement(lexer, ctx);
                                    tryStatement.Reset(cast<TryStatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                            #endif
                                            return Match(true, tryStatement.Release());
                                        }
                                    }
                                    *parentMatch30 = match;
                                }
                                *parentMatch29 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch31 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch32 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = NothrowStatementParser.AssertStatement(lexer, ctx);
                                assertStatement.Reset(cast<StatementNode*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                        #endif
                                        return Match(true, assertStatement.Release());
                                    }
                                }
                                *parentMatch32 = match;
                            }
                            *parentMatch31 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch33 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch34 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = NothrowStatementParser.ConditionalCompilationStatement(lexer, ctx);
                            condCompStatement.Reset(cast<ConditionalCompilationStatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                    #endif
                                    return Match(true, condCompStatement.Release());
                                }
                            }
                            *parentMatch34 = match;
                        }
                        *parentMatch33 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch35 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch36 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = NothrowStatementParser.SyncStmt(lexer);
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                #endif
                                return Match(true, new SyncStatementNode(span, ctx->ModuleId()));
                            }
                        }
                        *parentMatch36 = match;
                    }
                    *parentMatch35 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Statement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match SyncStmt(CmajorNothrowLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SyncStmt");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            bool pass = true;
            Match match(true);
            if (match.hit)
            {
                if (lexer.Synchronize())
                {
                    ++lexer;
                }
                else
                {
                    pass = false;
                }
            }
            if (match.hit && !pass)
            {
                match = Match(false);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SyncStmt");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SyncStmt");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match Label(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Label");
            }
        #endif
        Span s;
        ustring label;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                            label = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == COLON)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                    #endif
                    return Match(true, new LabelNode(s, ctx->ModuleId(), label));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Label");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match LabeledStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LabeledStatement");
            }
        #endif
        UniquePtr<LabeledStatementNode> stmt;
        UniquePtr<LabelNode> lbl;
        UniquePtr<StatementNode> s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = NothrowStatementParser.Label(lexer, ctx);
            lbl.Reset(cast<LabelNode*>(match.value));
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = NothrowStatementParser.Statement(lexer, ctx);
                    s.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        stmt.Reset(new LabeledStatementNode(span, ctx->ModuleId(), s.Release()));
                        stmt->SetLabelNode(lbl.Release());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LabeledStatement");
                            #endif
                            return Match(true, stmt.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LabeledStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LabeledStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ControlStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ControlStatement");
            }
        #endif
        UniquePtr<CompoundStatementNode> compoundStatement;
        UniquePtr<StatementNode> returnStatement;
        UniquePtr<IfStatementNode> ifStatement;
        UniquePtr<WhileStatementNode> whileStatement;
        UniquePtr<DoStatementNode> doStatement;
        UniquePtr<RangeForStatementNode> rangeForStatement;
        UniquePtr<ForStatementNode> forStatement;
        UniquePtr<StatementNode> breakStatement;
        UniquePtr<StatementNode> continueStatement;
        UniquePtr<StatementNode> gotoStatement;
        UniquePtr<SwitchStatementNode> switchStatement;
        UniquePtr<StatementNode> gotoCaseStatement;
        UniquePtr<StatementNode> gotoDefaultStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = NothrowStatementParser.CompoundStatement(lexer, ctx);
                                                            compoundStatement.Reset(cast<CompoundStatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                    #endif
                                                                    return Match(true, compoundStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch11 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch14 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = NothrowStatementParser.ReturnStatement(lexer, ctx);
                                                                    returnStatement.Reset(cast<StatementNode*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        {
                                                                            #if (DEBUG)
                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                            #endif
                                                                            return Match(true, returnStatement.Release());
                                                                        }
                                                                    }
                                                                    *parentMatch14 = match;
                                                                }
                                                                *parentMatch13 = match;
                                                            }
                                                            *parentMatch11 = match;
                                                        }
                                                    }
                                                    *parentMatch10 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch15 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch16 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match = NothrowStatementParser.IfStatement(lexer, ctx);
                                                                ifStatement.Reset(cast<IfStatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    {
                                                                        #if (DEBUG)
                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                        #endif
                                                                        return Match(true, ifStatement.Release());
                                                                    }
                                                                }
                                                                *parentMatch16 = match;
                                                            }
                                                            *parentMatch15 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                }
                                                *parentMatch9 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch17 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch18 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = NothrowStatementParser.WhileStatement(lexer, ctx);
                                                            whileStatement.Reset(cast<WhileStatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                    #endif
                                                                    return Match(true, whileStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch18 = match;
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch20 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = NothrowStatementParser.DoStatement(lexer, ctx);
                                                        doStatement.Reset(cast<DoStatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                #endif
                                                                return Match(true, doStatement.Release());
                                                            }
                                                        }
                                                        *parentMatch20 = match;
                                                    }
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch21 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch22 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = NothrowStatementParser.RangeForStatement(lexer, ctx);
                                                    rangeForStatement.Reset(cast<RangeForStatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                            #endif
                                                            return Match(true, rangeForStatement.Release());
                                                        }
                                                    }
                                                    *parentMatch22 = match;
                                                }
                                                *parentMatch21 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch23 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch24 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = NothrowStatementParser.ForStatement(lexer, ctx);
                                                forStatement.Reset(cast<ForStatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                        #endif
                                                        return Match(true, forStatement.Release());
                                                    }
                                                }
                                                *parentMatch24 = match;
                                            }
                                            *parentMatch23 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch25 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowStatementParser.BreakStatement(lexer, ctx);
                                            breakStatement.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                    #endif
                                                    return Match(true, breakStatement.Release());
                                                }
                                            }
                                            *parentMatch26 = match;
                                        }
                                        *parentMatch25 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch27 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch28 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = NothrowStatementParser.ContinueStatement(lexer, ctx);
                                        continueStatement.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                #endif
                                                return Match(true, continueStatement.Release());
                                            }
                                        }
                                        *parentMatch28 = match;
                                    }
                                    *parentMatch27 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch29 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch30 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = NothrowStatementParser.GotoStatement(lexer, ctx);
                                    gotoStatement.Reset(cast<StatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                            #endif
                                            return Match(true, gotoStatement.Release());
                                        }
                                    }
                                    *parentMatch30 = match;
                                }
                                *parentMatch29 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch31 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch32 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = NothrowStatementParser.SwitchStatement(lexer, ctx);
                                switchStatement.Reset(cast<SwitchStatementNode*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                        #endif
                                        return Match(true, switchStatement.Release());
                                    }
                                }
                                *parentMatch32 = match;
                            }
                            *parentMatch31 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch33 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch34 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = NothrowStatementParser.GotoCaseStatement(lexer, ctx);
                            gotoCaseStatement.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                    #endif
                                    return Match(true, gotoCaseStatement.Release());
                                }
                            }
                            *parentMatch34 = match;
                        }
                        *parentMatch33 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch35 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch36 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = NothrowStatementParser.GotoDefaultStatement(lexer, ctx);
                        gotoDefaultStatement.Reset(cast<StatementNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                #endif
                                return Match(true, gotoDefaultStatement.Release());
                            }
                        }
                        *parentMatch36 = match;
                    }
                    *parentMatch35 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ControlStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match CompoundStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CompoundStatement");
            }
        #endif
        UniquePtr<CompoundStatementNode> compoundStatement;
        UniquePtr<StatementNode> stmt;
        UniquePtr<StatementNode> statement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == LBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        compoundStatement.Reset(new CompoundStatementNode(span, ctx->ModuleId()));
                        compoundStatement->SetBeginBraceSpan(span);
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = NothrowStatementParser.Statement(lexer, ctx);
                                        statement.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            stmt.Reset(statement.Release());
                                            bool isSyncNode = (stmt.Get() is SyncStatementNode*);
                                            if (!isSyncNode)
                                            {
                                                lexer.ResetFlag(LexerFlags.synchronized);
                                            }
                                            compoundStatement->AddStatement(stmt.Release());
                                        }
                                        *parentMatch6 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch4 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch9 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch9 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch9 = match;
                            lexer.AddError(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        compoundStatement->SetEndBraceSpan(span);
                        compoundStatement->SetSpanEnd(span.end);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompoundStatement");
                            #endif
                            return Match(true, compoundStatement.Release());
                        }
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompoundStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CompoundStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ReturnStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ReturnStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RETURN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch4 = &match;
                    {
                        Match match = NothrowExpressionParser.Expression(lexer, ctx);
                        expr.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch7 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        ReturnStatementNode* node = new ReturnStatementNode(s, ctx->ModuleId(), expr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ReturnStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match IfStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IfStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        Span elseSpan;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> thenS;
        UniquePtr<StatementNode> elseS;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == IF)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            s = span;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                leftParenSpan = span;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                    cond.Reset(cast<Node*>(match.value));
                                    *parentMatch10 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        rightParenSpan = span;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch13 = &match;
                        {
                            Match match(false);
                            Match* parentMatch14 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = NothrowStatementParser.Statement(lexer, ctx);
                                thenS.Reset(cast<StatementNode*>(match.value));
                                if (match.hit)
                                {
                                    s.end = span.end;
                                }
                                *parentMatch14 = match;
                            }
                            *parentMatch13 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch16 = &match;
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == ELSE)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            elseSpan = span;
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                                            elseS.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                            }
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch20 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch17 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch16 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                IfStatementNode* value = new IfStatementNode(s, ctx->ModuleId(), cond.Release(), thenS.Release(), elseS.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetElseSpan(elseSpan);
                value->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IfStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IfStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IfStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match WhileStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"WhileStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == WHILE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s = span;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch9 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch9 = match;
                                            }
                                            else
                                            {
                                                match.hit = true;
                                                *parentMatch9 = match;
                                                lexer.AddError(span, GetTokenName(LPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            leftParenSpan = span;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                cond.Reset(cast<Node*>(match.value));
                                *parentMatch10 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch13 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch13 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch13 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch12 = match;
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch14 = &match;
                    {
                        Match match(false);
                        Match* parentMatch15 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                            stmt.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch15 = match;
                        }
                        *parentMatch14 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                WhileStatementNode* value = new WhileStatementNode(s, ctx->ModuleId(), cond.Release(), stmt.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"WhileStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"WhileStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"WhileStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match DoStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DoStatement");
            }
        #endif
        Span s;
        Span whileSpan;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<StatementNode> stmt;
        UniquePtr<Node> cond;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == DO)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                s = span;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                                            stmt.Reset(cast<StatementNode*>(match.value));
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(true);
                                            Match* parentMatch12 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == WHILE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch12 = match;
                                                }
                                                else
                                                {
                                                    match.hit = true;
                                                    *parentMatch12 = match;
                                                    lexer.AddError(span, GetTokenName(WHILE));
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                whileSpan = span;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch13 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch15 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch15 = match;
                                            }
                                            else
                                            {
                                                match.hit = true;
                                                *parentMatch15 = match;
                                                lexer.AddError(span, GetTokenName(LPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            leftParenSpan = span;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch13 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch16 = &match;
                            {
                                Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                cond.Reset(cast<Node*>(match.value));
                                *parentMatch16 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch17 = &match;
                        {
                            Match match(false);
                            Match* parentMatch18 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch19 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch19 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch19 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch18 = match;
                            }
                            *parentMatch17 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch20 = &match;
                    {
                        Match match(false);
                        Match* parentMatch21 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch22 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == SEMICOLON)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch22 = match;
                                }
                                else
                                {
                                    match.hit = true;
                                    *parentMatch22 = match;
                                    lexer.AddError(span, GetTokenName(SEMICOLON));
                                }
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch21 = match;
                        }
                        *parentMatch20 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                DoStatementNode* value = new DoStatementNode(s, ctx->ModuleId(), stmt.Release(), cond.Release());
                value->SetWhileSpan(whileSpan);
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DoStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ForStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<StatementNode> init;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> loop;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == FOR)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        leftParenSpan = span;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match = NothrowStatementParser.ForInitStatement(lexer, ctx);
                                            init.Reset(cast<StatementNode*>(match.value));
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match(true);
                                        long save = lexer.GetPos();
                                        Match* parentMatch14 = &match;
                                        {
                                            Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                            cond.Reset(cast<Node*>(match.value));
                                            if (match.hit)
                                            {
                                                *parentMatch14 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                            }
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch15 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch16 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == SEMICOLON)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch16 = match;
                                        }
                                        else
                                        {
                                            match.hit = true;
                                            *parentMatch16 = match;
                                            lexer.AddError(span, GetTokenName(SEMICOLON));
                                        }
                                    }
                                    *parentMatch15 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            {
                                Match match = NothrowStatementParser.ForLoopStatementExpr(lexer, ctx);
                                loop.Reset(cast<StatementNode*>(match.value));
                                *parentMatch17 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch18 = &match;
                        {
                            Match match(false);
                            Match* parentMatch19 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch20 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch20 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch20 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch19 = match;
                            }
                            *parentMatch18 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch21 = &match;
                    {
                        Match match(false);
                        Match* parentMatch22 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                            stmt.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch22 = match;
                        }
                        *parentMatch21 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                ForStatementNode* value = new ForStatementNode(s, ctx->ModuleId(), init.Release(), cond.Release(), loop.Release(), stmt.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ForInitStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForInitStatement");
            }
        #endif
        UniquePtr<StatementNode> assignmentStatement;
        UniquePtr<ConstructionStatementNode> constructionStatement;
        UniquePtr<StatementNode> emptyStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = NothrowStatementParser.AssignmentStatement(lexer, ctx);
                    assignmentStatement.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                            #endif
                            return Match(true, assignmentStatement.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = NothrowStatementParser.ConstructionStatement(lexer, ctx);
                            constructionStatement.Reset(cast<ConstructionStatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                                    #endif
                                    return Match(true, constructionStatement.Release());
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = NothrowStatementParser.EmptyStatement(lexer, ctx);
                        emptyStatement.Reset(cast<StatementNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                                #endif
                                return Match(true, emptyStatement.Release());
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForInitStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ForLoopStatementExpr(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForLoopStatementExpr");
            }
        #endif
        UniquePtr<StatementNode> assignmentStatementExpr;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = NothrowStatementParser.AssignmentStatementExpr(lexer, ctx);
                    assignmentStatementExpr.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                            #endif
                            return Match(true, assignmentStatementExpr.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = NothrowExpressionParser.Expression(lexer, ctx);
                            expr.Reset(cast<Node*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                                    #endif
                                    return Match(true, new ExpressionStatementNode(span, ctx->ModuleId(), expr.Release()));
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                                #endif
                                return Match(true, new EmptyStatementNode(span, ctx->ModuleId()));
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForLoopStatementExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match RangeForStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RangeForStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        Span colonSpan;
        UniquePtr<Node> type;
        UniquePtr<IdentifierNode> id;
        UniquePtr<Node> container;
        UniquePtr<StatementNode> action;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == FOR)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        leftParenSpan = span;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match = NothrowTypeExprParser.TypeExpr(lexer, ctx);
                                            type.Reset(cast<Node*>(match.value));
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match = NothrowIdentifierParser.Identifier(lexer, ctx);
                                        id.Reset(cast<IdentifierNode*>(match.value));
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == COLON)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            colonSpan = span;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch16 = &match;
                            {
                                Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                container.Reset(cast<Node*>(match.value));
                                *parentMatch16 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch17 = &match;
                        {
                            Match match(false);
                            Match* parentMatch18 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch19 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch19 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch19 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch18 = match;
                            }
                            *parentMatch17 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch20 = &match;
                    {
                        Match match(false);
                        Match* parentMatch21 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                            action.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch21 = match;
                        }
                        *parentMatch20 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                RangeForStatementNode* value = new RangeForStatementNode(s, ctx->ModuleId(), type.Release(), id.Release(), container.Release(), action.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetColonSpan(colonSpan);
                value->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RangeForStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RangeForStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RangeForStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match BreakStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BreakStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == BREAK)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch4 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        BreakStatementNode* node = new BreakStatementNode(s, ctx->ModuleId());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BreakStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BreakStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BreakStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ContinueStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ContinueStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == CONTINUE)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch4 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        ContinueStatementNode* node = new ContinueStatementNode(s, ctx->ModuleId());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ContinueStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ContinueStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ContinueStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match GotoStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoStatement");
            }
        #endif
        ustring label;
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == GOTO)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            label = lexer.GetMatch(span);
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch7 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        GotoStatementNode* node = new GotoStatementNode(s, ctx->ModuleId(), label);
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match SwitchStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SwitchStatement");
            }
        #endif
        UniquePtr<SwitchStatementNode> switchStatement;
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        Span beginBraceSpan;
        Span endBraceSpan;
        UniquePtr<Node> cond;
        UniquePtr<CaseStatementNode> caseStatement;
        UniquePtr<DefaultStatementNode> defaultStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == SWITCH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s = span;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch9 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch9 = match;
                                            }
                                            else
                                            {
                                                match.hit = true;
                                                *parentMatch9 = match;
                                                lexer.AddError(span, GetTokenName(LPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            leftParenSpan = span;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                cond.Reset(cast<Node*>(match.value));
                                *parentMatch10 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch13 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch13 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch13 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                    switchStatement.Reset(new SwitchStatementNode(s, ctx->ModuleId(), cond.Release()));
                                    switchStatement->SetLeftParenSpan(leftParenSpan);
                                    switchStatement->SetRightParenSpan(rightParenSpan);
                                }
                                *parentMatch12 = match;
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch14 = &match;
                    {
                        Match match(false);
                        Match* parentMatch15 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch16 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch16 = match;
                                }
                                else
                                {
                                    match.hit = true;
                                    *parentMatch16 = match;
                                    lexer.AddError(span, GetTokenName(LBRACE));
                                }
                            }
                            if (match.hit)
                            {
                                beginBraceSpan = span;
                            }
                            *parentMatch15 = match;
                        }
                        *parentMatch14 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch17 = &match;
                {
                    Match match(true);
                    Match* parentMatch18 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch19 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowStatementParser.CaseStatement(lexer, ctx);
                                            caseStatement.Reset(cast<CaseStatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                switchStatement->AddCase(caseStatement.Release());
                                            }
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch20 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = NothrowStatementParser.DefaultStatement(lexer, ctx);
                                                    defaultStatement.Reset(cast<DefaultStatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        switchStatement->SetDefault(defaultStatement.Release());
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            *parentMatch20 = match;
                                        }
                                    }
                                    *parentMatch19 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch18 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch17 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch24 = &match;
            {
                Match match(false);
                Match* parentMatch25 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch26 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch26 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch26 = match;
                            lexer.AddError(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        endBraceSpan = span;
                        switchStatement->SetBeginBraceSpan(beginBraceSpan);
                        switchStatement->SetEndBraceSpan(endBraceSpan);
                        switchStatement->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchStatement");
                            #endif
                            return Match(true, switchStatement.Release());
                        }
                    }
                    *parentMatch25 = match;
                }
                *parentMatch24 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SwitchStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match CaseStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CaseStatement");
            }
        #endif
        UniquePtr<CaseStatementNode> caseS;
        Span s;
        Span caseSpan;
        UniquePtr<Node> caseExpr;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(true);
                if (match.hit)
                {
                    caseS.Reset(new CaseStatementNode(span, ctx->ModuleId()));
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Span span = lexer.GetSpan();
                                                        Match match(false);
                                                        if (*lexer == CASE)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            caseSpan = span;
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch14 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                                            caseExpr.Reset(cast<Node*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                caseS->AddCaseSpan(caseSpan);
                                                                caseS->AddCaseExpr(caseExpr.Release());
                                                            }
                                                            *parentMatch14 = match;
                                                        }
                                                        *parentMatch13 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch15 = &match;
                                                {
                                                    Match match(true);
                                                    Match* parentMatch16 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match(false);
                                                        if (*lexer == COLON)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch16 = match;
                                                        }
                                                        else
                                                        {
                                                            match.hit = true;
                                                            *parentMatch16 = match;
                                                            lexer.AddError(span, GetTokenName(COLON));
                                                        }
                                                    }
                                                    *parentMatch15 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(true);
                                        Match* parentMatch17 = &match;
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch18 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch19 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch20 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch21 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == CASE)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    caseSpan = span;
                                                                }
                                                                *parentMatch21 = match;
                                                            }
                                                            *parentMatch20 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch22 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch23 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                                                    caseExpr.Reset(cast<Node*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        caseS->AddCaseSpan(caseSpan);
                                                                        caseS->AddCaseExpr(caseExpr.Release());
                                                                    }
                                                                    *parentMatch23 = match;
                                                                }
                                                                *parentMatch22 = match;
                                                            }
                                                            *parentMatch20 = match;
                                                        }
                                                        *parentMatch19 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch24 = &match;
                                                        {
                                                            Match match(true);
                                                            Match* parentMatch25 = &match;
                                                            {
                                                                System.Lex.Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == COLON)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch25 = match;
                                                                }
                                                                else
                                                                {
                                                                    match.hit = true;
                                                                    *parentMatch25 = match;
                                                                    lexer.AddError(span, GetTokenName(COLON));
                                                                }
                                                            }
                                                            *parentMatch24 = match;
                                                        }
                                                        *parentMatch19 = match;
                                                    }
                                                    *parentMatch18 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch17 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    caseS->SetSpan(s);
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch26 = &match;
                            {
                                Match match(true);
                                Match* parentMatch27 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch28 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch29 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = NothrowStatementParser.Statement(lexer, ctx);
                                                    stmt.Reset(cast<StatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        caseS->AddStatement(stmt.Release());
                                                    }
                                                    *parentMatch29 = match;
                                                }
                                                *parentMatch28 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch27 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch26 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        caseS->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CaseStatement");
                            #endif
                            return Match(true, caseS.Release());
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CaseStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CaseStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match DefaultStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DefaultStatement");
            }
        #endif
        UniquePtr<DefaultStatementNode> defaultS;
        Span s;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == DEFAULT)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch7 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == COLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch7 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch7 = match;
                                        lexer.AddError(span, GetTokenName(COLON));
                                    }
                                }
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    defaultS.Reset(new DefaultStatementNode(s, ctx->ModuleId()));
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        Match* parentMatch9 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowStatementParser.Statement(lexer, ctx);
                                            stmt.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                defaultS->AddStatement(stmt.Release());
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                defaultS->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DefaultStatement");
                    #endif
                    return Match(true, defaultS.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DefaultStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DefaultStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match GotoCaseStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoCaseStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> caseExpr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == GOTO)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        if (*lexer == CASE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                    caseExpr.Reset(cast<Node*>(match.value));
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch6 = &match;
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch8 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch8 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch8 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        GotoCaseStatementNode* node = new GotoCaseStatementNode(s, ctx->ModuleId(), caseExpr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoCaseStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch7 = match;
                }
                *parentMatch6 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoCaseStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoCaseStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match GotoDefaultStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoDefaultStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == GOTO)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(false);
                    if (*lexer == DEFAULT)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch6 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        GotoDefaultStatementNode* node = new GotoDefaultStatementNode(s, ctx->ModuleId());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoDefaultStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoDefaultStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoDefaultStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match AssignmentStatementExpr(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssignmentStatementExpr");
            }
        #endif
        Span s;
        UniquePtr<Node> target;
        UniquePtr<Node> source;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        if (match.hit)
                        {
                            ctx->PushParsingLvalue(true);
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = NothrowExpressionParser.Expression(lexer, ctx);
                            target.Reset(cast<Node*>(match.value));
                            if (match.hit)
                            {
                                ctx->PopParsingLvalue();
                            }
                            else
                            {
                                ctx->PopParsingLvalue();
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(false);
                    if (*lexer == ASSIGN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                    source.Reset(cast<Node*>(match.value));
                    if (match.hit)
                    {
                        s.end = span.end;
                        AssignmentStatementNode* node = new AssignmentStatementNode(s, ctx->ModuleId(), target.Release(), source.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatementExpr");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatementExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssignmentStatementExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match AssignmentStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssignmentStatement");
            }
        #endif
        UniquePtr<StatementNode> statement;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = NothrowStatementParser.AssignmentStatementExpr(lexer, ctx);
            stmt.Reset(cast<StatementNode*>(match.value));
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == SEMICOLON)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        statement.Reset(stmt.Release());
                        statement->SetSpanEnd(span.end);
                        statement->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatement");
                            #endif
                            return Match(true, statement.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssignmentStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConstructionStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConstructionStatement");
            }
        #endif
        UniquePtr<ConstructionStatementNode> constructionStatement;
        Span s;
        UniquePtr<Node> type;
        UniquePtr<IdentifierNode> id;
        UniquePtr<Node> value;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = NothrowTypeExprParser.TypeExpr(lexer, ctx);
                        type.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = NothrowIdentifierParser.Identifier(lexer, ctx);
                            id.Reset(cast<IdentifierNode*>(match.value));
                            if (match.hit)
                            {
                                s.end = span.end;
                                constructionStatement.Reset(new ConstructionStatementNode(s, ctx->ModuleId(), type.Release(), id.Release()));
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == ASSIGN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch10 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                            value.Reset(cast<Node*>(match.value));
                                            if (match.hit)
                                            {
                                                constructionStatement->AddArgument(value.Release());
                                                constructionStatement->SetAssignment();
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch14 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == LPAREN)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch15 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch16 = &match;
                                                {
                                                    Match match = NothrowExpressionParser.ArgumentList(lexer, ctx, constructionStatement.Get());
                                                    *parentMatch16 = match;
                                                }
                                                *parentMatch15 = match;
                                            }
                                            *parentMatch14 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch17 = &match;
                                            {
                                                Match match(true);
                                                Match* parentMatch18 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == RPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch18 = match;
                                                    }
                                                    else
                                                    {
                                                        match.hit = true;
                                                        *parentMatch18 = match;
                                                        lexer.AddError(span, GetTokenName(RPAREN));
                                                    }
                                                }
                                                *parentMatch17 = match;
                                            }
                                            *parentMatch14 = match;
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch9 = match;
                                }
                            }
                            *parentMatch8 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch19 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(true);
                                        if (match.hit)
                                        {
                                            constructionStatement->SetEmpty();
                                        }
                                        *parentMatch20 = match;
                                    }
                                    *parentMatch19 = match;
                                }
                                *parentMatch8 = match;
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch21 = &match;
            {
                Match match(false);
                Match* parentMatch22 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch23 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch23 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch23 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        constructionStatement->SetSpanEnd(span.end);
                        constructionStatement->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConstructionStatement");
                            #endif
                            return Match(true, constructionStatement.Release());
                        }
                    }
                    *parentMatch22 = match;
                }
                *parentMatch21 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConstructionStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConstructionStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match DeleteStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DeleteStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == DELETE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                    ptr.Reset(cast<Node*>(match.value));
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch6 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        DeleteStatementNode* node = new DeleteStatementNode(s, ctx->ModuleId(), ptr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DeleteStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DeleteStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DeleteStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match DestroyStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DestroyStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == DESTROY)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                    ptr.Reset(cast<Node*>(match.value));
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch6 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        DestroyStatementNode* node = new DestroyStatementNode(s, ctx->ModuleId(), ptr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DestroyStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DestroyStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DestroyStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ExpressionStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ExpressionStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                if (match.hit)
                {
                    ctx->PushParsingExpressionStatement(true);
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = NothrowExpressionParser.Expression(lexer, ctx);
                                expr.Reset(cast<Node*>(match.value));
                                if (match.hit)
                                {
                                    s = span;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == SEMICOLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s.end = span.end;
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        ctx->PopParsingExpressionStatement();
                        ExpressionStatementNode* node = new ExpressionStatementNode(s, ctx->ModuleId(), expr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExpressionStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    else
                    {
                        ctx->PopParsingExpressionStatement();
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExpressionStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ExpressionStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match EmptyStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EmptyStatement");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == SEMICOLON)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                EmptyStatementNode* node = new EmptyStatementNode(span, ctx->ModuleId());
                node->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EmptyStatement");
                    #endif
                    return Match(true, node);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EmptyStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EmptyStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ThrowStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ThrowStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> exception;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == THROW)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch4 = &match;
                    {
                        Match match = NothrowExpressionParser.Expression(lexer, ctx);
                        exception.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch7 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        ThrowStatementNode* node = new ThrowStatementNode(s, ctx->ModuleId(), exception.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ThrowStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ThrowStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ThrowStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match TryStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TryStatement");
            }
        #endif
        UniquePtr<TryStatementNode> tryStatement;
        Span s;
        UniquePtr<CompoundStatementNode> tryBlock;
        UniquePtr<CatchNode> ctch;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == TRY)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = NothrowStatementParser.CompoundStatement(lexer, ctx);
                                tryBlock.Reset(cast<CompoundStatementNode*>(match.value));
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    tryStatement.Reset(new TryStatementNode(s, ctx->ModuleId(), tryBlock.Release()));
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = NothrowStatementParser.Catch(lexer, ctx);
                                    ctch.Reset(cast<CatchNode*>(match.value));
                                    if (match.hit)
                                    {
                                        tryStatement->AddCatch(ctch.Release());
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch11 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch13 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = NothrowStatementParser.Catch(lexer, ctx);
                                            ctch.Reset(cast<CatchNode*>(match.value));
                                            if (match.hit)
                                            {
                                                tryStatement->AddCatch(ctch.Release());
                                            }
                                            *parentMatch13 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch11 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                tryStatement->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TryStatement");
                    #endif
                    return Match(true, tryStatement.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TryStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TryStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match Catch(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Catch");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<Node> catchType;
        UniquePtr<IdentifierNode> catchId;
        UniquePtr<CompoundStatementNode> catchBlock;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == CATCH)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    s = span;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(true);
                                    Match* parentMatch8 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == LPAREN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch8 = match;
                                        }
                                        else
                                        {
                                            match.hit = true;
                                            *parentMatch8 = match;
                                            lexer.AddError(span, GetTokenName(LPAREN));
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        leftParenSpan = span;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match = NothrowTypeExprParser.TypeExpr(lexer, ctx);
                            catchType.Reset(cast<Node*>(match.value));
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch11 = &match;
                        {
                            Match match = NothrowIdentifierParser.Identifier(lexer, ctx);
                            catchId.Reset(cast<IdentifierNode*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch12 = &match;
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        Match* parentMatch14 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch14 = match;
                            }
                            else
                            {
                                match.hit = true;
                                *parentMatch14 = match;
                                lexer.AddError(span, GetTokenName(RPAREN));
                            }
                        }
                        if (match.hit)
                        {
                            rightParenSpan = span;
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch12 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch15 = &match;
            {
                Match match(false);
                Match* parentMatch16 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = NothrowStatementParser.CompoundStatement(lexer, ctx);
                    catchBlock.Reset(cast<CompoundStatementNode*>(match.value));
                    if (match.hit)
                    {
                        s.end = span.end;
                        CatchNode* value = new CatchNode(s, ctx->ModuleId(), catchType.Release(), catchId.Release(), catchBlock.Release());
                        value->SetLeftParenSpan(leftParenSpan);
                        value->SetRightParenSpan(rightParenSpan);
                        value->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Catch");
                            #endif
                            return Match(true, value);
                        }
                    }
                    *parentMatch16 = match;
                }
                *parentMatch15 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Catch");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Catch");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match AssertStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssertStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == HASH)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        if (*lexer == ASSERT)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match = NothrowExpressionParser.Expression(lexer, ctx);
                    expr.Reset(cast<Node*>(match.value));
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch6 = &match;
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch8 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch8 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch8 = match;
                            lexer.AddError(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        AssertStatementNode* node = new AssertStatementNode(s, ctx->ModuleId(), expr.Release());
                        node->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssertStatement");
                            #endif
                            return Match(true, node);
                        }
                    }
                    *parentMatch7 = match;
                }
                *parentMatch6 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssertStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssertStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationStatement(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationStatement");
            }
        #endif
        UniquePtr<ConditionalCompilationStatementNode> condCompStatement;
        Span s;
        Span keywordSpan;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<ConditionalCompilationExpressionNode> ifExpr;
        UniquePtr<StatementNode> ifS;
        UniquePtr<ConditionalCompilationExpressionNode> elifExpr;
        UniquePtr<StatementNode> elifS;
        UniquePtr<StatementNode> elseS;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == HASH)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                    keywordSpan = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == IF)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        keywordSpan.end = span.end;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch13 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(true);
                                                Match* parentMatch14 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch14 = match;
                                                    }
                                                    else
                                                    {
                                                        match.hit = true;
                                                        *parentMatch14 = match;
                                                        lexer.AddError(span, GetTokenName(LPAREN));
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    leftParenSpan = span;
                                                }
                                                *parentMatch13 = match;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch16 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = NothrowStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                            ifExpr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                                condCompStatement.Reset(new ConditionalCompilationStatementNode(s, ctx->ModuleId(), ifExpr.Release()));
                                                condCompStatement->IfPart()->SetKeywordSpan(keywordSpan);
                                            }
                                            *parentMatch16 = match;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch17 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch18 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch19 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == RPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch19 = match;
                                            }
                                            else
                                            {
                                                match.hit = true;
                                                *parentMatch19 = match;
                                                lexer.AddError(span, GetTokenName(RPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            rightParenSpan = span;
                                            condCompStatement->IfPart()->SetLeftParenSpan(leftParenSpan);
                                            condCompStatement->IfPart()->SetRightParenSpan(rightParenSpan);
                                        }
                                        *parentMatch18 = match;
                                    }
                                    *parentMatch17 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            {
                                Match match(true);
                                Match* parentMatch21 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = NothrowStatementParser.Statement(lexer, ctx);
                                                    ifS.Reset(cast<StatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        condCompStatement->AddIfStatement(ifS.Release());
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch21 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch24 = &match;
                        {
                            Match match(true);
                            Match* parentMatch25 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch27 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch28 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch29 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch30 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch31 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch32 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Span span = lexer.GetSpan();
                                                                    Match match(false);
                                                                    if (*lexer == HASH)
                                                                    {
                                                                        ++lexer;
                                                                        match.hit = true;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        keywordSpan = span;
                                                                    }
                                                                    *parentMatch32 = match;
                                                                }
                                                                *parentMatch31 = match;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch33 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch34 = &match;
                                                                    {
                                                                        long pos = lexer.GetPos();
                                                                        Span span = lexer.GetSpan();
                                                                        Match match(false);
                                                                        if (*lexer == ELIF)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            keywordSpan.end = span.end;
                                                                        }
                                                                        *parentMatch34 = match;
                                                                    }
                                                                    *parentMatch33 = match;
                                                                }
                                                                *parentMatch31 = match;
                                                            }
                                                            *parentMatch30 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch35 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch36 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Span span = lexer.GetSpan();
                                                                    Match match(true);
                                                                    Match* parentMatch37 = &match;
                                                                    {
                                                                        System.Lex.Span span = lexer.GetSpan();
                                                                        Match match(false);
                                                                        if (*lexer == LPAREN)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            *parentMatch37 = match;
                                                                        }
                                                                        else
                                                                        {
                                                                            match.hit = true;
                                                                            *parentMatch37 = match;
                                                                            lexer.AddError(span, GetTokenName(LPAREN));
                                                                        }
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        leftParenSpan = span;
                                                                    }
                                                                    *parentMatch36 = match;
                                                                }
                                                                *parentMatch35 = match;
                                                            }
                                                            *parentMatch30 = match;
                                                        }
                                                        *parentMatch29 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch38 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch39 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match = NothrowStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                                                elifExpr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    condCompStatement->AddElifExpr(span, ctx->ModuleId(), elifExpr.Release());
                                                                }
                                                                *parentMatch39 = match;
                                                            }
                                                            *parentMatch38 = match;
                                                        }
                                                        *parentMatch29 = match;
                                                    }
                                                    *parentMatch28 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch40 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch41 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Span span = lexer.GetSpan();
                                                            Match match(true);
                                                            Match* parentMatch42 = &match;
                                                            {
                                                                System.Lex.Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == RPAREN)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch42 = match;
                                                                }
                                                                else
                                                                {
                                                                    match.hit = true;
                                                                    *parentMatch42 = match;
                                                                    lexer.AddError(span, GetTokenName(RPAREN));
                                                                }
                                                            }
                                                            if (match.hit)
                                                            {
                                                                rightParenSpan = span;
                                                                condCompStatement->SetElifLeftParenSpan(leftParenSpan);
                                                                condCompStatement->SetElifRightParenSpan(rightParenSpan);
                                                                condCompStatement->SetElifKeywordSpan(keywordSpan);
                                                            }
                                                            *parentMatch41 = match;
                                                        }
                                                        *parentMatch40 = match;
                                                    }
                                                    *parentMatch28 = match;
                                                }
                                                *parentMatch27 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch43 = &match;
                                                {
                                                    Match match(true);
                                                    Match* parentMatch44 = &match;
                                                    {
                                                        while (true)
                                                        {
                                                            long save = lexer.GetPos();
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch45 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch46 = &match;
                                                                    {
                                                                        long pos = lexer.GetPos();
                                                                        Match match = NothrowStatementParser.Statement(lexer, ctx);
                                                                        elifS.Reset(cast<StatementNode*>(match.value));
                                                                        if (match.hit)
                                                                        {
                                                                            condCompStatement->AddElifStatement(elifS.Release());
                                                                        }
                                                                        *parentMatch46 = match;
                                                                    }
                                                                    *parentMatch45 = match;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch44 = match;
                                                                }
                                                                else
                                                                {
                                                                    lexer.SetPos(save);
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *parentMatch43 = match;
                                                }
                                                *parentMatch27 = match;
                                            }
                                            *parentMatch26 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch25 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch24 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch47 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch48 = &match;
                        {
                            Match match(false);
                            Match* parentMatch49 = &match;
                            {
                                Match match(false);
                                Match* parentMatch50 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch51 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch52 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch53 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == HASH)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    keywordSpan = span;
                                                }
                                                *parentMatch53 = match;
                                            }
                                            *parentMatch52 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch54 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == ELSE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch54 = match;
                                            }
                                            *parentMatch52 = match;
                                        }
                                        *parentMatch51 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch55 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch56 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch57 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch58 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match = NothrowStatementParser.Statement(lexer, ctx);
                                                                elseS.Reset(cast<StatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    condCompStatement->AddElseStatement(span, ctx->ModuleId(), elseS.Release());
                                                                }
                                                                *parentMatch58 = match;
                                                            }
                                                            *parentMatch57 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch56 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch55 = match;
                                        }
                                        *parentMatch51 = match;
                                    }
                                    *parentMatch50 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch59 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch60 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            if (match.hit)
                                            {
                                                condCompStatement->ElsePart()->SetKeywordSpan(keywordSpan);
                                            }
                                            *parentMatch60 = match;
                                        }
                                        *parentMatch59 = match;
                                    }
                                    *parentMatch50 = match;
                                }
                                *parentMatch49 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch48 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch47 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch61 = &match;
                {
                    Match match(false);
                    Match* parentMatch62 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == HASH)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            keywordSpan = span;
                        }
                        *parentMatch62 = match;
                    }
                    *parentMatch61 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch63 = &match;
            {
                Match match(false);
                Match* parentMatch64 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch65 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ENDIF)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch65 = match;
                        }
                        else
                        {
                            match.hit = true;
                            *parentMatch65 = match;
                            lexer.AddError(span, GetTokenName(ENDIF));
                        }
                    }
                    if (match.hit)
                    {
                        keywordSpan.end = span.end;
                        condCompStatement->SetEndIfSpan(keywordSpan);
                        condCompStatement->SetLexerFlags(lexer.Flags());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationStatement");
                            #endif
                            return Match(true, condCompStatement.Release());
                        }
                    }
                    *parentMatch64 = match;
                }
                *parentMatch63 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationExpression(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationExpression");
            }
        #endif
        UniquePtr<ConditionalCompilationExpressionNode> disjunction;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match = NothrowStatementParser.ConditionalCompilationDisjunction(lexer, ctx);
            disjunction.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationExpression");
                    #endif
                    return Match(true, disjunction.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationExpression");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationExpression");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationDisjunction(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationDisjunction");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> left;
        UniquePtr<ConditionalCompilationExpressionNode> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = NothrowStatementParser.ConditionalCompilationConjunction(lexer, ctx);
                        left.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                        if (match.hit)
                        {
                            s = span;
                            condCompExpr.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == DISJUNCTION)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match = NothrowStatementParser.ConditionalCompilationConjunction(lexer, ctx);
                                                    right.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.end = span.end;
                                                        condCompExpr.Reset(new ConditionalCompilationDisjunctionNode(s, ctx->ModuleId(), condCompExpr.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                condCompExpr->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationDisjunction");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationDisjunction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationDisjunction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationConjunction(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationConjunction");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> left;
        UniquePtr<ConditionalCompilationExpressionNode> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = NothrowStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                        left.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                        if (match.hit)
                        {
                            s = span;
                            condCompExpr.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == AMPAMP)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match = NothrowStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                                                    right.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.end = span.end;
                                                        condCompExpr.Reset(new ConditionalCompilationConjunctionNode(s, ctx->ModuleId(), condCompExpr.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                condCompExpr->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationConjunction");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationConjunction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationConjunction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationPrefix(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationPrefix");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> prefix;
        UniquePtr<ConditionalCompilationExpressionNode> primary;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == EXCLAMATION)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = NothrowStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                                prefix.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    condCompExpr.Reset(new ConditionalCompilationNotNode(s, ctx->ModuleId(), prefix.Release()));
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = NothrowStatementParser.ConditionalCompilationPrimary(lexer, ctx);
                                primary.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                if (match.hit)
                                {
                                    condCompExpr.Reset(primary.Release());
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                condCompExpr->SetLexerFlags(lexer.Flags());
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrefix");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrefix");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationPrefix");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static nothrow Match ConditionalCompilationPrimary(CmajorNothrowLexer& lexer, NothrowParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationPrimary");
            }
        #endif
        ustring symbol;
        UniquePtr<ConditionalCompilationExpressionNode> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == ID)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    symbol = lexer.GetMatch(span);
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                        #endif
                        return Match(true, new ConditionalCompilationPrimaryNode(span, ctx->ModuleId(), symbol));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == LPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = NothrowStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                expr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch8 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch8 = match;
                                    }
                                    else
                                    {
                                        match.hit = true;
                                        *parentMatch8 = match;
                                        lexer.AddError(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    ParenthesizedConditionalCompilationExpressionNode* node = new ParenthesizedConditionalCompilationExpressionNode(span, ctx->ModuleId(), expr.Release());
                                    node->SetLexerFlags(lexer.Flags());
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                                        #endif
                                        return Match(true, node);
                                    }
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationPrimary");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

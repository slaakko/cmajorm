<parseSourceRequest>
    <base>
        <created value="714522689317100"/>
        <received value="714522689395400"/>
    </base>
    <projectFilePath value="C:/work/cmajorm/cmajor/projects/examples/Calculator/Calculator.cmp"/>
    <backend value="cpp"/>
    <config value="debug"/>
    <sourceFilePath value="C:/work/cmajorm/cmajor/projects/examples/Calculator/Parser.cm"/>
    <sourceCode value="using System;

namespace Calculator
{
    public void Parse(const ustring&amp; input)
    {
        Scanner scanner(input);
        scanner.NextToken();
        if (scanner.CurrentToken() is PrintToken*)
        {
            SymbolTable.Instance().Print();
            return;
        }
        else if (scanner.CurrentToken() is VariableNameToken*)
        {
            VariableNameToken* token = cast&lt;VariableNameToken*>(scanner.CurrentToken());
            ustring variableName = token->VariableName();
            scanner.NextToken();
            if (scanner.CurrentToken() is OperatorToken*)
            {
                OperatorToken* token = cast&lt;OperatorToken*>(scanner.CurrentToken());
                if (token->Char() == '=')
                {
                    scanner.NextToken();
                    double value = Expr(scanner);
                    Token* token = scanner.CurrentToken();
                    if (token is EndToken*)
                    {
                        SymbolTable.Instance().SetVariable(variableName, value);
                        Console.Out() &lt;&lt; variableName &lt;&lt; &quot; = &quot; &lt;&lt; value &lt;&lt; endl();
                        return;
                    }
                    else
                    {
                        throw ParsingException(&quot;invalid input&quot;);
                    }
                }
            }
        }
        scanner.Rewind();
        scanner.NextToken();
        double value = Expr(scanner);
        Token* token = scanner.CurrentToken();
        if (token is EndToken*)
        {
            Console.Out() &lt;&lt; &quot;= &quot; &lt;&lt; value &lt;&lt; endl();
        }
        else
        {
            throw ParsingException(&quot;invalid input&quot;);
        }
    }

    internal double Expr(Scanner&amp; scanner)
    {
$    double value = Term(scanner);
        Token* token = scanner.CurrentToken();
        OperatorToken* op = token as OperatorToken*;
        while (op != null &amp;&amp; op->IsAdditiveOperator())
        {
            uchar opChar = op->Char();
            scanner.NextToken();
            double right = Term(scanner);
            if (opChar == '+')
            {
                value = value + right;
            }
            else if (opChar == '-')
            {
                value = value - right;
            }
            else
            {
                throw LogicErrorException(&quot;logic error&quot;);
            }
            token = scanner.CurrentToken();
            op = token as OperatorToken*;
        }
        return value;
    }

    internal double Term(Scanner&amp; scanner)
    {
        double value = Factor(scanner);
        Token* token = scanner.CurrentToken();
        OperatorToken* op = token as OperatorToken*;
        while (op != null &amp;&amp; op->IsMultiplicativeOperator())
        {
            uchar opChar = op->Char();
            scanner.NextToken();
            double right = Factor(scanner);
            if (opChar == '*')
            {
                value = value * right;
            }
            else if (opChar == '/')
            {
                if (right == 0)
                {
                    throw DivisionByZeroException(&quot;division by zero&quot;);
                }
                value = value / right;
            }
            else
            {
                throw LogicErrorException(&quot;logic error&quot;);
            }
            token = scanner.CurrentToken();
            op = token as OperatorToken*;
        }
        return value;
    }

    internal double Factor(Scanner&amp; scanner)
    {
        Token* token = scanner.CurrentToken();
        OperatorToken* op = token as OperatorToken*;
        bool neg = false;
        if (op != null &amp;&amp; op->IsAdditiveOperator())
        {
            if (op->Char() == '-')
            {
                neg = true;
            }
            scanner.NextToken();
        }
        double value = Primary(scanner);
        if (neg)
        {
            return -value;
        }
        return value;
    }

    internal double Primary(Scanner&amp; scanner)
    {
        Token* token = scanner.CurrentToken();
        if (token is NumberToken*)
        {
            NumberToken* number = cast&lt;NumberToken*>(token);
            double value = number->Value();
            scanner.NextToken();
            return value;
        }
        else if (token is VariableNameToken*)
        {
            VariableNameToken* variableNameToken = cast&lt;VariableNameToken*>(token);
            double value = SymbolTable.Instance().GetVariableValue(variableNameToken->VariableName());
            scanner.NextToken();
            return value;
        }
        else if (token is OperatorToken*)
        {
            OperatorToken* op = cast&lt;OperatorToken*>(token);
            if (op->Char() == '(')
            {
                scanner.NextToken();
                double value = Expr(scanner);
                token = scanner.CurrentToken();
                if (token is OperatorToken*)
                {
                    op = cast&lt;OperatorToken*>(token);
                    if (op->Char() == ')')
                    {
                        scanner.NextToken();
                        return value;
                    }
                    else
                    {
                        throw ParsingException(&quot;')' expected&quot;);
                    }
                }
            }
        }
        throw ParsingException(&quot;number, variable name or subexpression expected&quot;);
    }
}
"/>
</parseSourceRequest>

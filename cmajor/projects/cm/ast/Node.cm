using System;
using System.Collections;

namespace Cm.Ast
{
    public enum NodeType : byte
    {
        boolNode, sbyteNode, byteNode, shortNode, ushortNode, intNode, uintNode, longNode, ulongNode, floatNode, doubleNode, charNode, wcharNode, ucharNode, voidNode, booleanLiteralNode, sbyteLiteralNode, byteLiteralNode, shortLiteralNode, ushortLiteralNode, intLiteralNode, uintLiteralNode, longLiteralNode, ulongLiteralNode, floatLiteralNode, doubleLiteralNode, charLiteralNode, wcharLiteralNode, ucharLiteralNode, stringLiteralNode, wstringLiteralNode, ustringLiteralNode, nullLiteralNode, arrayLiteralNode, structuredLiteralNode, compileUnitNode, namespaceNode, aliasNode, namespaceImportNode, identifierNode, templateIdNode, functionNode, classNode, thisInitializerNode, baseInitializerNode, memberInitializerNode, staticConstructorNode, constructorNode, destructorNode, memberFunctionNode, conversionFunctionNode, memberVariableNode, interfaceNode, delegateNode, classDelegateNode, parenthesizedConstraintNode, disjunctiveConstraintNode, conjunctiveConstraintNode, whereConstraintNode, predicateConstraintNode, isConstraintNode, multiParamConstraintNode, typeNameConstraintNode, constructorConstraintNode, destructorConstraintNode, memberFunctionConstraintNode, functionConstraintNode, sameConstraintNode, derivedConstraintNode, convertibleConstraintNode, explicitlyConvertibleConstraintNode, commonConstraintNode, nonreferenceTypeConstraintNode, axiomStatementNode, axiomNode, conceptIdNode, conceptNode, sameConceptNode, derivedConceptNode, convertibleConceptNode, explicitlyConvertibleConceptNode, commonConceptNode, nonreferenceTypeConceptNode, labelNode, compoundStatementNode, returnStatementNode, ifStatementNode, whileStatementNode, doStatementNode, forStatementNode, breakStatementNode, continueStatementNode, gotoStatementNode, constructionStatementNode, deleteStatementNode, destroyStatementNode, assignmentStatementNode, expressionStatementNode, emptyStatementNode, rangeForStatementNode, switchStatementNode, caseStatementNode, defaultStatementNode, gotoCaseStatementNode, gotoDefaultStatementNode, throwStatementNode, catchNode, tryStatementNode, assertStatementNode, typedefNode, constantNode, enumTypeNode, enumConstantNode, parameterNode, templateParameterNode, constNode, lvalueRefNode, rvalueRefNode, pointerNode, arrayNode, dotNode, arrowNode, equivalenceNode, implicationNode, disjunctionNode, conjunctionNode, bitOrNode, bitXorNode, bitAndNode, equalNode, notEqualNode, lessNode, greaterNode, lessOrEqualNode, greaterOrEqualNode, shiftLeftNode, shiftRightNode, addNode, subNode, mulNode, divNode, remNode, notNode, unaryPlusNode, unaryMinusNode, prefixIncrementNode, prefixDecrementNode, complementNode, derefNode, addrOfNode, isNode, asNode, indexingNode, invokeNode, postfixIncrementNode, postfixDecrementNode, sizeOfNode, typeNameNode, typeIdNode, castNode, constructNode, newNode, thisNode, baseNode, conditionalCompilationDisjunctionNode, conditionalCompilationConjunctionNode, conditionalCompilationNotNode, conditionalCompilationPrimaryNode, conditionalCompilationPartNode, conditionalCompilationStatementNode, uuidLiteralNode, cursorIdNode, parenthesizedExpressionNode, globalVariableNode, parenthesizedCondCompExpressionNode, labeledStatementNode, commentNode, functionPtrNode, syncNode, syncStatementNode, attributeNode, attributesNode, maxNode
    }
    public abstract class Node
    {
        public suppress nothrow Node(const Node&);
        public nothrow Node(NodeType nodeType_, const System.Lex.Span& span_, const Uuid& moduleId_) :
            nodeType(nodeType_), span(span_), moduleId(moduleId_), parent(null)
        {
        }
        public virtual ~Node()
        {
        }
        public suppress nothrow Node& operator=(const Node&);
        public nothrow NodeType GetNodeType() const
        {
            return nodeType;
        }
        public nothrow const System.Lex.Span& GetSpan() const
        {
            return span;
        }
        public nothrow void SetSpan(const System.Lex.Span& span_)
        {
            span = span_;
        }
        public nothrow void SetSpanStart(int spanStart)
        {
            span.start = spanStart;
        }
        public nothrow void SetSpanEnd(int end)
        {
            span.end = end;
        }
        public nothrow inline const Uuid& ModuleId() const
        {
            return moduleId;
        }
        public nothrow const Node* Parent() const
        {
            return parent;
        }
        public nothrow Node* Parent()
        {
            return parent;
        }
        public nothrow void SetParent(Node* parent_)
        {
            parent = parent_;
        }
        public abstract Node* Clone(CloneContext& cloneContext) const;
        public abstract void Accept(Visitor& visitor);
        public virtual nothrow string ToString() const
        {
            return string();
        }
        public virtual void AddArgument(Node* argument)
        {
            throw Exception("AddArgument not overridden");
        }
        public virtual void AddParameter(ParameterNode* parameter)
        {
            throw Exception("AddParameter not overridden");
        }
        public virtual void AddTemplateParameter(TemplateParameterNode* templateParameter)
        {
            throw Exception("AddTemplateParameter not overridden");
        }
        public virtual nothrow bool IsUnsignedTypeNode() const
        {
            return false;
        }
        public virtual nothrow bool IsStatementNode() const
        {
            return false;
        }
        public virtual nothrow bool NodeIsConstraintNode() const
        {
            return false;
        }
        public virtual nothrow bool IsConceptNode() const
        {
            return false;
        }
        public virtual nothrow bool IsFunctionNode() const
        {
            return false;
        }
        public virtual nothrow bool IsIntrinsicConceptNode() const
        {
            return false;
        }
        public virtual nothrow bool IsConditionalCompilationExpressionNode() const
        {
            return false;
        }
        public virtual nothrow Specifiers GetSpecifiers() const
        {
            return Specifiers.none;
        }
        public virtual nothrow void Write(AstWriter& writer)
        {
        }
        public virtual void Read(AstReader& reader)
        {
        }
        public virtual nothrow void SetFullSpan()
        {
        }
        public inline nothrow const System.Lex.LexerFlags GetLexerFlags() const
        {
            return lexerFlags;
        }
        public inline nothrow void SetLexerFlags(const System.Lex.LexerFlags& lexerFlags_)
        {
            lexerFlags = lexerFlags_;
        }
        private NodeType nodeType;
        private System.Lex.Span span;
        private Uuid moduleId;
        private Node* parent;
        private System.Lex.LexerFlags lexerFlags;
    }

    public class SyncNode : Node
    {
        public nothrow SyncNode(const System.Lex.Span& span_, const Uuid& moduleId_) :
            base(NodeType.syncNode, span_, moduleId_)
        {
        }
        public override Node* Clone(CloneContext& cloneContext) const
        {
            return new SyncNode(GetSpan(), ModuleId());
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
    }
    
    public abstract class UnaryNode : Node
    {
        public nothrow UnaryNode(NodeType nodeType_, const System.Lex.Span& span_, const Uuid& moduleId_) :
            base(nodeType_, span_, moduleId_), subject()
        {
        }
        public nothrow UnaryNode(NodeType nodeType_, const System.Lex.Span& span_, const Uuid& moduleId_, Node* subject_) :
            base(nodeType_, span_, moduleId_), subject(subject_)
        {
        }
        public nothrow const Node* Subject() const
        {
            return subject.Get();
        }
        public nothrow Node* Subject()
        {
            return subject.Get();
        }
        public override nothrow void Write(AstWriter& writer)
        {
            base->Write(writer);
            writer.Write(subject.Get());
        }
        public override void Read(AstReader& reader)
        {
            base->Read(reader);
            subject.Reset(reader.ReadNode());
            subject->SetParent(this);
        }
        public override nothrow void SetFullSpan()
        {
            if (!subject.IsNull())
            {
                const System.Lex.Span& thisSpan = GetSpan();
                subject->SetFullSpan();
                const System.Lex.Span& childSpan = subject->GetSpan();
                SetSpanStart(Min(thisSpan.start, childSpan.start));
                SetSpanEnd(Max(thisSpan.end, childSpan.end));
            }
        }
        private UniquePtr<Node> subject;
    }
    
    public abstract class BinaryNode : Node
    {
        public nothrow BinaryNode(NodeType nodeType, const System.Lex.Span& span_, const Uuid& moduleId_) :
            base(nodeType, span_, moduleId_), left(), right()
        {
        }
        public nothrow BinaryNode(NodeType nodeType, const System.Lex.Span& span_, const Uuid& moduleId_, Node* left_, Node* right_) :
            base(nodeType, span_, moduleId_), left(left_), right(right_)
        {
            left->SetParent(this);
            right->SetParent(this);
        }
        public nothrow const Node* Left() const
        {
            return left.Get();
        }
        public nothrow Node* Left()
        {
            return left.Get();
        }
        public nothrow const Node* Right() const
        {
            return right.Get();
        }
        public nothrow Node* Right()
        {
            return right.Get();
        }
        public override nothrow void Write(AstWriter& writer)
        {
            base->Write(writer);
            writer.Write(left.Get());
            writer.Write(right.Get());
        }
        public override void Read(AstReader& reader)
        {
            base->Read(reader);
            left.Reset(reader.ReadNode());
            left->SetParent(this);
            right.Reset(reader.ReadNode());
            right->SetParent(this);
        }
        public override nothrow void SetFullSpan()
        {
            const System.Lex.Span& thisSpan = GetSpan();
            left->SetFullSpan();
            right->SetFullSpan();
            const System.Lex.Span& leftSpan = left->GetSpan();
            const System.Lex.Span& rightSpan = right->GetSpan();
            SetSpanStart(Min(thisSpan.start, Min(leftSpan.start, rightSpan.start)));
            SetSpanEnd(Max(thisSpan.end, Max(leftSpan.end, rightSpan.end)));
        }
        private UniquePtr<Node> left;
        private UniquePtr<Node> right;
    }
    public abstract class NodeCreator
    {
        public suppress nothrow NodeCreator(const NodeCreator&);
        public nothrow NodeCreator()
        {
        }
        public virtual ~NodeCreator()
        {
        }
        public suppress nothrow NodeCreator& operator=(const NodeCreator&);
        public abstract Node* CreateNode(const System.Lex.Span& span, const Uuid& moduleId);
    }
    public class NodeFactory
    {
        static NodeFactory()
        {
            instance.Reset(new NodeFactory());
        }
        public suppress nothrow NodeFactory(const NodeFactory&);
        public nothrow NodeFactory()
        {
            creators.Resize(cast<long>(cast<byte>(NodeType.maxNode)));
            Register(NodeType.boolNode, new ConcreteNodeCreator<BoolNode>());
            Register(NodeType.sbyteNode, new ConcreteNodeCreator<SByteNode>());
            Register(NodeType.byteNode, new ConcreteNodeCreator<ByteNode>());
            Register(NodeType.shortNode, new ConcreteNodeCreator<ShortNode>());
            Register(NodeType.ushortNode, new ConcreteNodeCreator<UShortNode>());
            Register(NodeType.intNode, new ConcreteNodeCreator<IntNode>());
            Register(NodeType.uintNode, new ConcreteNodeCreator<UIntNode>());
            Register(NodeType.longNode, new ConcreteNodeCreator<LongNode>());
            Register(NodeType.ulongNode, new ConcreteNodeCreator<ULongNode>());
            Register(NodeType.floatNode, new ConcreteNodeCreator<FloatNode>());
            Register(NodeType.doubleNode, new ConcreteNodeCreator<DoubleNode>());
            Register(NodeType.charNode, new ConcreteNodeCreator<CharNode>());
            Register(NodeType.wcharNode, new ConcreteNodeCreator<WCharNode>());
            Register(NodeType.ucharNode, new ConcreteNodeCreator<UCharNode>());
            Register(NodeType.voidNode, new ConcreteNodeCreator<VoidNode>());
            Register(NodeType.booleanLiteralNode, new ConcreteNodeCreator<BooleanLiteralNode>());
            Register(NodeType.sbyteLiteralNode, new ConcreteNodeCreator<SByteLiteralNode>());
            Register(NodeType.byteLiteralNode, new ConcreteNodeCreator<ByteLiteralNode>());
            Register(NodeType.shortLiteralNode, new ConcreteNodeCreator<ShortLiteralNode>());
            Register(NodeType.ushortLiteralNode, new ConcreteNodeCreator<UShortLiteralNode>());
            Register(NodeType.intLiteralNode, new ConcreteNodeCreator<IntLiteralNode>());
            Register(NodeType.uintLiteralNode, new ConcreteNodeCreator<UIntLiteralNode>());
            Register(NodeType.longLiteralNode, new ConcreteNodeCreator<LongLiteralNode>());
            Register(NodeType.ulongLiteralNode, new ConcreteNodeCreator<ULongLiteralNode>());
            Register(NodeType.floatLiteralNode, new ConcreteNodeCreator<FloatLiteralNode>());
            Register(NodeType.doubleLiteralNode, new ConcreteNodeCreator<DoubleLiteralNode>());
            Register(NodeType.charLiteralNode, new ConcreteNodeCreator<CharLiteralNode>());
            Register(NodeType.wcharLiteralNode, new ConcreteNodeCreator<WCharLiteralNode>());
            Register(NodeType.ucharLiteralNode, new ConcreteNodeCreator<UCharLiteralNode>());
            Register(NodeType.stringLiteralNode, new ConcreteNodeCreator<StringLiteralNode>());
            Register(NodeType.wstringLiteralNode, new ConcreteNodeCreator<WStringLiteralNode>());
            Register(NodeType.ustringLiteralNode, new ConcreteNodeCreator<UStringLiteralNode>());
            Register(NodeType.nullLiteralNode, new ConcreteNodeCreator<NullLiteralNode>());
            Register(NodeType.arrayLiteralNode, new ConcreteNodeCreator<ArrayLiteralNode>());
            Register(NodeType.structuredLiteralNode, new ConcreteNodeCreator<StructuredLiteralNode>());
            Register(NodeType.compileUnitNode, new ConcreteNodeCreator<CompileUnitNode>());
            Register(NodeType.namespaceNode, new ConcreteNodeCreator<NamespaceNode>());
            Register(NodeType.aliasNode, new ConcreteNodeCreator<AliasNode>());
            Register(NodeType.namespaceImportNode, new ConcreteNodeCreator<NamespaceImportNode>());
            Register(NodeType.identifierNode, new ConcreteNodeCreator<IdentifierNode>());
            Register(NodeType.templateIdNode, new ConcreteNodeCreator<TemplateIdNode>());
            Register(NodeType.functionNode, new ConcreteNodeCreator<FunctionNode>());
            Register(NodeType.classNode, new ConcreteNodeCreator<ClassNode>());
            Register(NodeType.thisInitializerNode, new ConcreteNodeCreator<ThisInitializerNode>());
            Register(NodeType.baseInitializerNode, new ConcreteNodeCreator<BaseInitializerNode>());
            Register(NodeType.memberInitializerNode, new ConcreteNodeCreator<MemberInitializerNode>());
            Register(NodeType.staticConstructorNode, new ConcreteNodeCreator<StaticConstructorNode>());
            Register(NodeType.constructorNode, new ConcreteNodeCreator<ConstructorNode>());
            Register(NodeType.destructorNode, new ConcreteNodeCreator<DestructorNode>());
            Register(NodeType.memberFunctionNode, new ConcreteNodeCreator<MemberFunctionNode>());
            Register(NodeType.conversionFunctionNode, new ConcreteNodeCreator<ConversionFunctionNode>());
            Register(NodeType.memberVariableNode, new ConcreteNodeCreator<MemberVariableNode>());
            Register(NodeType.interfaceNode, new ConcreteNodeCreator<InterfaceNode>());
            Register(NodeType.delegateNode, new ConcreteNodeCreator<DelegateNode>());
            Register(NodeType.classDelegateNode, new ConcreteNodeCreator<ClassDelegateNode>());
            Register(NodeType.parenthesizedConstraintNode, new ConcreteNodeCreator<ParenthesizedConstraintNode>());
            Register(NodeType.disjunctiveConstraintNode, new ConcreteNodeCreator<DisjunctiveConstraintNode>());
            Register(NodeType.conjunctiveConstraintNode, new ConcreteNodeCreator<ConjunctiveConstraintNode>());
            Register(NodeType.whereConstraintNode, new ConcreteNodeCreator<WhereConstraintNode>());
            Register(NodeType.predicateConstraintNode, new ConcreteNodeCreator<PredicateConstraintNode>());
            Register(NodeType.isConstraintNode, new ConcreteNodeCreator<IsConstraintNode>());
            Register(NodeType.multiParamConstraintNode, new ConcreteNodeCreator<MultiParamConstraintNode>());
            Register(NodeType.typeNameConstraintNode, new ConcreteNodeCreator<TypeNameConstraintNode>());
            Register(NodeType.constructorConstraintNode, new ConcreteNodeCreator<ConstructorConstraintNode>());
            Register(NodeType.destructorConstraintNode, new ConcreteNodeCreator<DestructorConstraintNode>());
            Register(NodeType.memberFunctionConstraintNode, new ConcreteNodeCreator<MemberFunctionConstraintNode>());
            Register(NodeType.functionConstraintNode, new ConcreteNodeCreator<FunctionConstraintNode>());
            Register(NodeType.sameConstraintNode, new ConcreteNodeCreator<SameConstraintNode>());
            Register(NodeType.derivedConstraintNode, new ConcreteNodeCreator<DerivedConstraintNode>());
            Register(NodeType.convertibleConstraintNode, new ConcreteNodeCreator<ConvertibleConstraintNode>());
            Register(NodeType.explicitlyConvertibleConstraintNode, new ConcreteNodeCreator<ExplicitlyConvertibleConstraintNode>());
            Register(NodeType.commonConstraintNode, new ConcreteNodeCreator<CommonConstraintNode>());
            Register(NodeType.nonreferenceTypeConstraintNode, new ConcreteNodeCreator<NonreferenceTypeConstraintNode>());
            Register(NodeType.axiomStatementNode, new ConcreteNodeCreator<AxiomStatementNode>());
            Register(NodeType.axiomNode, new ConcreteNodeCreator<AxiomNode>());
            Register(NodeType.conceptIdNode, new ConcreteNodeCreator<ConceptIdNode>());
            Register(NodeType.conceptNode, new ConcreteNodeCreator<ConceptNode>());
            Register(NodeType.sameConceptNode, new ConcreteNodeCreator<SameConceptNode>());
            Register(NodeType.derivedConceptNode, new ConcreteNodeCreator<DerivedConceptNode>());
            Register(NodeType.convertibleConceptNode, new ConcreteNodeCreator<ConvertibleConceptNode>());
            Register(NodeType.explicitlyConvertibleConceptNode, new ConcreteNodeCreator<ExplicitlyConvertibleConceptNode>());
            Register(NodeType.commonConceptNode, new ConcreteNodeCreator<CommonConceptNode>());
            Register(NodeType.nonreferenceTypeConceptNode, new ConcreteNodeCreator<NonreferenceTypeConceptNode>());
            Register(NodeType.labelNode, new ConcreteNodeCreator<LabelNode>());
            Register(NodeType.labeledStatementNode, new ConcreteNodeCreator<LabeledStatementNode>());
            Register(NodeType.compoundStatementNode, new ConcreteNodeCreator<CompoundStatementNode>());
            Register(NodeType.returnStatementNode, new ConcreteNodeCreator<ReturnStatementNode>());
            Register(NodeType.ifStatementNode, new ConcreteNodeCreator<IfStatementNode>());
            Register(NodeType.whileStatementNode, new ConcreteNodeCreator<WhileStatementNode>());
            Register(NodeType.doStatementNode, new ConcreteNodeCreator<DoStatementNode>());
            Register(NodeType.forStatementNode, new ConcreteNodeCreator<ForStatementNode>());
            Register(NodeType.breakStatementNode, new ConcreteNodeCreator<BreakStatementNode>());
            Register(NodeType.continueStatementNode, new ConcreteNodeCreator<ContinueStatementNode>());
            Register(NodeType.gotoStatementNode, new ConcreteNodeCreator<GotoStatementNode>());
            Register(NodeType.constructionStatementNode, new ConcreteNodeCreator<ConstructionStatementNode>());
            Register(NodeType.deleteStatementNode, new ConcreteNodeCreator<DeleteStatementNode>());
            Register(NodeType.destroyStatementNode, new ConcreteNodeCreator<DestroyStatementNode>());
            Register(NodeType.assignmentStatementNode, new ConcreteNodeCreator<AssignmentStatementNode>());
            Register(NodeType.expressionStatementNode, new ConcreteNodeCreator<ExpressionStatementNode>());
            Register(NodeType.emptyStatementNode, new ConcreteNodeCreator<EmptyStatementNode>());
            Register(NodeType.rangeForStatementNode, new ConcreteNodeCreator<RangeForStatementNode>());
            Register(NodeType.switchStatementNode, new ConcreteNodeCreator<SwitchStatementNode>());
            Register(NodeType.caseStatementNode, new ConcreteNodeCreator<CaseStatementNode>());
            Register(NodeType.defaultStatementNode, new ConcreteNodeCreator<DefaultStatementNode>());
            Register(NodeType.gotoCaseStatementNode, new ConcreteNodeCreator<GotoCaseStatementNode>());
            Register(NodeType.gotoDefaultStatementNode, new ConcreteNodeCreator<GotoDefaultStatementNode>());
            Register(NodeType.throwStatementNode, new ConcreteNodeCreator<ThrowStatementNode>());
            Register(NodeType.catchNode, new ConcreteNodeCreator<CatchNode>());
            Register(NodeType.tryStatementNode, new ConcreteNodeCreator<TryStatementNode>());
            Register(NodeType.assertStatementNode, new ConcreteNodeCreator<AssertStatementNode>());
            Register(NodeType.typedefNode, new ConcreteNodeCreator<TypedefNode>());
            Register(NodeType.constantNode, new ConcreteNodeCreator<ConstantNode>());
            Register(NodeType.enumTypeNode, new ConcreteNodeCreator<EnumTypeNode>());
            Register(NodeType.enumConstantNode, new ConcreteNodeCreator<EnumConstantNode>());
            Register(NodeType.parameterNode, new ConcreteNodeCreator<ParameterNode>());
            Register(NodeType.templateParameterNode, new ConcreteNodeCreator<TemplateParameterNode>());
            Register(NodeType.constNode, new ConcreteNodeCreator<ConstNode>());
            Register(NodeType.lvalueRefNode, new ConcreteNodeCreator<LValueRefNode>());
            Register(NodeType.rvalueRefNode, new ConcreteNodeCreator<RValueRefNode>());
            Register(NodeType.pointerNode, new ConcreteNodeCreator<PointerNode>());
            Register(NodeType.dotNode, new ConcreteNodeCreator<DotNode>());
            Register(NodeType.arrowNode, new ConcreteNodeCreator<ArrowNode>());
            Register(NodeType.arrayNode, new ConcreteNodeCreator<ArrayNode>());
            Register(NodeType.equivalenceNode, new ConcreteNodeCreator<EquivalenceNode>());
            Register(NodeType.implicationNode, new ConcreteNodeCreator<ImplicationNode>());
            Register(NodeType.disjunctionNode, new ConcreteNodeCreator<DisjunctionNode>());
            Register(NodeType.conjunctionNode, new ConcreteNodeCreator<ConjunctionNode>());
            Register(NodeType.bitOrNode, new ConcreteNodeCreator<BitOrNode>());
            Register(NodeType.bitXorNode, new ConcreteNodeCreator<BitXorNode>());
            Register(NodeType.bitAndNode, new ConcreteNodeCreator<BitAndNode>());
            Register(NodeType.equalNode, new ConcreteNodeCreator<EqualNode>());
            Register(NodeType.notEqualNode, new ConcreteNodeCreator<NotEqualNode>());
            Register(NodeType.lessNode, new ConcreteNodeCreator<LessNode>());
            Register(NodeType.greaterNode, new ConcreteNodeCreator<GreaterNode>());
            Register(NodeType.lessOrEqualNode, new ConcreteNodeCreator<LessOrEqualNode>());
            Register(NodeType.greaterOrEqualNode, new ConcreteNodeCreator<GreaterOrEqualNode>());
            Register(NodeType.shiftLeftNode, new ConcreteNodeCreator<ShiftLeftNode>());
            Register(NodeType.shiftRightNode, new ConcreteNodeCreator<ShiftRightNode>());
            Register(NodeType.addNode, new ConcreteNodeCreator<AddNode>());
            Register(NodeType.subNode, new ConcreteNodeCreator<SubNode>());
            Register(NodeType.mulNode, new ConcreteNodeCreator<MulNode>());
            Register(NodeType.divNode, new ConcreteNodeCreator<DivNode>());
            Register(NodeType.remNode, new ConcreteNodeCreator<RemNode>());
            Register(NodeType.notNode, new ConcreteNodeCreator<NotNode>());
            Register(NodeType.unaryPlusNode, new ConcreteNodeCreator<UnaryPlusNode>());
            Register(NodeType.unaryMinusNode, new ConcreteNodeCreator<UnaryMinusNode>());
            Register(NodeType.prefixIncrementNode, new ConcreteNodeCreator<PrefixIncrementNode>());
            Register(NodeType.prefixDecrementNode, new ConcreteNodeCreator<PrefixDecrementNode>());
            Register(NodeType.complementNode, new ConcreteNodeCreator<ComplementNode>());
            Register(NodeType.derefNode, new ConcreteNodeCreator<DerefNode>());
            Register(NodeType.addrOfNode, new ConcreteNodeCreator<AddrOfNode>());
            Register(NodeType.isNode, new ConcreteNodeCreator<IsNode>());
            Register(NodeType.asNode, new ConcreteNodeCreator<AsNode>());
            Register(NodeType.indexingNode, new ConcreteNodeCreator<IndexingNode>());
            Register(NodeType.invokeNode, new ConcreteNodeCreator<InvokeNode>());
            Register(NodeType.postfixIncrementNode, new ConcreteNodeCreator<PostfixIncrementNode>());
            Register(NodeType.postfixDecrementNode, new ConcreteNodeCreator<PostfixDecrementNode>());
            Register(NodeType.sizeOfNode, new ConcreteNodeCreator<SizeOfNode>());
            Register(NodeType.typeNameNode, new ConcreteNodeCreator<TypeNameNode>());
            Register(NodeType.typeIdNode, new ConcreteNodeCreator<TypeIdNode>());
            Register(NodeType.castNode, new ConcreteNodeCreator<CastNode>());
            Register(NodeType.constructNode, new ConcreteNodeCreator<ConstructNode>());
            Register(NodeType.newNode, new ConcreteNodeCreator<NewNode>());
            Register(NodeType.thisNode, new ConcreteNodeCreator<ThisNode>());
            Register(NodeType.baseNode, new ConcreteNodeCreator<BaseNode>());
            Register(NodeType.conditionalCompilationDisjunctionNode, new ConcreteNodeCreator<ConditionalCompilationDisjunctionNode>());
            Register(NodeType.conditionalCompilationConjunctionNode, new ConcreteNodeCreator<ConditionalCompilationConjunctionNode>());
            Register(NodeType.conditionalCompilationNotNode, new ConcreteNodeCreator<ConditionalCompilationNotNode>());
            Register(NodeType.conditionalCompilationPrimaryNode, new ConcreteNodeCreator<ConditionalCompilationPrimaryNode>());
            Register(NodeType.conditionalCompilationPartNode, new ConcreteNodeCreator<ConditionalCompilationPartNode>());
            Register(NodeType.parenthesizedCondCompExpressionNode, new ConcreteNodeCreator<ParenthesizedConditionalCompilationExpressionNode>());
            Register(NodeType.conditionalCompilationStatementNode, new ConcreteNodeCreator<ConditionalCompilationStatementNode>());
            Register(NodeType.uuidLiteralNode, new ConcreteNodeCreator<UuidLiteralNode>());
            Register(NodeType.cursorIdNode, new ConcreteNodeCreator<CursorIdNode>());
            Register(NodeType.parenthesizedExpressionNode, new ConcreteNodeCreator<ParenthesizedExpressionNode>());
            Register(NodeType.globalVariableNode, new ConcreteNodeCreator<GlobalVariableNode>());
            Register(NodeType.commentNode, new ConcreteNodeCreator<CommentNode>());
            Register(NodeType.attributeNode, new ConcreteNodeCreator<AttributeNode>());
            Register(NodeType.attributesNode, new ConcreteNodeCreator<AttributesNode>());
        }
        public suppress nothrow NodeFactory& operator=(const NodeFactory&);
        public static nothrow NodeFactory& Instance()
        {
            return *instance;
        }
        public static UniquePtr<NodeFactory> instance;
        public nothrow void Register(NodeType nodeType, NodeCreator* creator)
        {
            creators[cast<long>(cast<byte>(nodeType))] = UniquePtr<NodeCreator>(creator);
        }
        public Node* CreateNode(NodeType nodeType, const System.Lex.Span& span, const Uuid& moduleId)
        {
            const UniquePtr<NodeCreator>& creator = creators[cast<long>(cast<byte>(nodeType))];
            if (!creator.IsNull())
            {
                Node* value = creator->CreateNode(span, moduleId);
                if ((value != null))
                {
                    return value;
                }
                else
                {
                    throw Exception("could not create node");
                }
            }
            else
            {
                throw Exception("no creator for node type \'" + NodeTypeStr(nodeType) + "\'");
            }
        }
        private List<UniquePtr<NodeCreator>> creators;
    }
    public class ConcreteNodeCreator<T> : NodeCreator
    {
        public nothrow ConcreteNodeCreator() :
            base()
        {
        }
        public suppress nothrow ConcreteNodeCreator(const ConcreteNodeCreator&);
        public suppress nothrow ConcreteNodeCreator& operator=(const ConcreteNodeCreator&);
        public override Node* CreateNode(const System.Lex.Span& span, const Uuid& moduleId)
        {
            return new T(span, moduleId);
        }
    }
    public string NodeTypeStr(NodeType nodeType)
    {
        switch (nodeType)
        {
            case NodeType.boolNode: return "boolNode";
            case NodeType.sbyteNode: return "sbyteNode";
            case NodeType.byteNode: return "byteNode";
            case NodeType.shortNode: return "shortNode";
            case NodeType.ushortNode: return "ushortNode";
            case NodeType.intNode: return "intNode";
            case NodeType.uintNode: return "uintNode";
            case NodeType.longNode: return "longNode";
            case NodeType.ulongNode: return "ulongNode";
            case NodeType.floatNode: return "floatNode";
            case NodeType.doubleNode: return "doubleNode";
            case NodeType.charNode: return "charNode";
            case NodeType.wcharNode: return "wcharNode";
            case NodeType.ucharNode: return "ucharNode";
            case NodeType.voidNode: return "voidNode";
            case NodeType.booleanLiteralNode: return "booleanLiteralNode";
            case NodeType.sbyteLiteralNode: return "sbyteLiteralNode";
            case NodeType.byteLiteralNode: return "byteLiteralNode";
            case NodeType.shortLiteralNode: return "shortLiteralNode";
            case NodeType.ushortLiteralNode: return "ushortLiteralNode";
            case NodeType.intLiteralNode: return "intLiteralNode";
            case NodeType.uintLiteralNode: return "uintLiteralNode";
            case NodeType.longLiteralNode: return "longLiteralNode";
            case NodeType.ulongLiteralNode: return "ulongLiteralNode";
            case NodeType.floatLiteralNode: return "floatLiteralNode";
            case NodeType.doubleLiteralNode: return "doubleLiteralNode";
            case NodeType.charLiteralNode: return "charLiteralNode";
            case NodeType.wcharLiteralNode: return "wcharLiteralNode";
            case NodeType.ucharLiteralNode: return "ucharLiteralNode";
            case NodeType.stringLiteralNode: return "stringLiteralNode";
            case NodeType.wstringLiteralNode: return "wstringLiteralNode";
            case NodeType.ustringLiteralNode: return "ustringLiteralNode";
            case NodeType.nullLiteralNode: return "nullLiteralNode";
            case NodeType.arrayLiteralNode: return "arrayLiteralNode";
            case NodeType.structuredLiteralNode: return "structuredLiteralNode";
            case NodeType.compileUnitNode: return "compileUnitNode";
            case NodeType.namespaceNode: return "namespaceNode";
            case NodeType.aliasNode: return "aliasNode";
            case NodeType.namespaceImportNode: return "namespaceImportNode";
            case NodeType.identifierNode: return "identifierNode";
            case NodeType.templateIdNode: return "templateIdNode";
            case NodeType.functionNode: return "functionNode";
            case NodeType.classNode: return "classNode";
            case NodeType.thisInitializerNode: return "thisInitializerNode";
            case NodeType.baseInitializerNode: return "baseInitializerNode";
            case NodeType.memberInitializerNode: return "memberInitializerNode";
            case NodeType.staticConstructorNode: return "staticConstructorNode";
            case NodeType.constructorNode: return "constructorNode";
            case NodeType.destructorNode: return "destructorNode";
            case NodeType.memberFunctionNode: return "memberFunctionNode";
            case NodeType.conversionFunctionNode: return "conversionFunctionNode";
            case NodeType.memberVariableNode: return "memberVariableNode";
            case NodeType.interfaceNode: return "interfaceNode";
            case NodeType.delegateNode: return "delegateNode";
            case NodeType.classDelegateNode: return "classDelegateNode";
            case NodeType.parenthesizedConstraintNode: return "parenthesizedConstraintNode";
            case NodeType.disjunctiveConstraintNode: return "disjunctiveConstraintNode";
            case NodeType.conjunctiveConstraintNode: return "conjunctiveConstraintNode";
            case NodeType.whereConstraintNode: return "whereConstraintNode";
            case NodeType.predicateConstraintNode: return "predicateConstraintNode";
            case NodeType.isConstraintNode: return "isConstraintNode";
            case NodeType.multiParamConstraintNode: return "multiParamConstraintNode";
            case NodeType.typeNameConstraintNode: return "typeNameConstraintNode";
            case NodeType.constructorConstraintNode: return "constructorConstraintNode";
            case NodeType.destructorConstraintNode: return "destructorConstraintNode";
            case NodeType.memberFunctionConstraintNode: return "memberFunctionConstraintNode";
            case NodeType.functionConstraintNode: return "functionConstraintNode";
            case NodeType.sameConstraintNode: return "sameConstraintNode";
            case NodeType.derivedConstraintNode: return "derivedConstraintNode";
            case NodeType.convertibleConstraintNode: return "convertibleConstraintNode";
            case NodeType.explicitlyConvertibleConstraintNode: return "explicitlyConvertibleConstraintNode";
            case NodeType.commonConstraintNode: return "commonConstraintNode";
            case NodeType.nonreferenceTypeConstraintNode: return "nonreferenceTypeConstraintNode";
            case NodeType.axiomStatementNode: return "axiomStatementNode";
            case NodeType.axiomNode: return "axiomNode";
            case NodeType.conceptIdNode: return "conceptIdNode";
            case NodeType.conceptNode: return "conceptNode";
            case NodeType.sameConceptNode: return "sameConceptNode";
            case NodeType.derivedConceptNode: return "derivedConceptNode";
            case NodeType.convertibleConceptNode: return "convertibleConceptNode";
            case NodeType.explicitlyConvertibleConceptNode: return "explicitlyConvertibleConceptNode";
            case NodeType.commonConceptNode: return "commonConceptNode";
            case NodeType.nonreferenceTypeConceptNode: return "nonreferenceTypeConceptNode";
            case NodeType.labelNode: return "labelNode";
            case NodeType.compoundStatementNode: return "compoundStatementNode";
            case NodeType.returnStatementNode: return "returnStatementNode";
            case NodeType.ifStatementNode: return "ifStatementNode";
            case NodeType.whileStatementNode: return "whileStatementNode";
            case NodeType.doStatementNode: return "doStatementNode";
            case NodeType.forStatementNode: return "forStatementNode";
            case NodeType.breakStatementNode: return "breakStatementNode";
            case NodeType.continueStatementNode: return "continueStatementNode";
            case NodeType.gotoStatementNode: return "gotoStatementNode";
            case NodeType.constructionStatementNode: return "constructionStatementNode";
            case NodeType.deleteStatementNode: return "deleteStatementNode";
            case NodeType.destroyStatementNode: return "destroyStatementNode";
            case NodeType.assignmentStatementNode: return "assignmentStatementNode";
            case NodeType.expressionStatementNode: return "expressionStatementNode";
            case NodeType.emptyStatementNode: return "emptyStatementNode";
            case NodeType.rangeForStatementNode: return "rangeForStatementNode";
            case NodeType.switchStatementNode: return "switchStatementNode";
            case NodeType.caseStatementNode: return "caseStatementNode";
            case NodeType.defaultStatementNode: return "defaultStatementNode";
            case NodeType.gotoCaseStatementNode: return "gotoCaseStatementNode";
            case NodeType.gotoDefaultStatementNode: return "gotoDefaultStatementNode";
            case NodeType.throwStatementNode: return "throwStatementNode";
            case NodeType.catchNode: return "catchNode";
            case NodeType.tryStatementNode: return "tryStatementNode";
            case NodeType.assertStatementNode: return "assertStatementNode";
            case NodeType.typedefNode: return "typedefNode";
            case NodeType.constantNode: return "constantNode";
            case NodeType.enumTypeNode: return "enumTypeNode";
            case NodeType.enumConstantNode: return "enumConstantNode";
            case NodeType.parameterNode: return "parameterNode";
            case NodeType.templateParameterNode: return "templateParameterNode";
            case NodeType.constNode: return "constNode";
            case NodeType.lvalueRefNode: return "lvalueRefNode";
            case NodeType.rvalueRefNode: return "rvalueRefNode";
            case NodeType.pointerNode: return "pointerNode";
            case NodeType.arrayNode: return "arrayNode";
            case NodeType.dotNode: return "dotNode";
            case NodeType.arrowNode: return "arrowNode";
            case NodeType.equivalenceNode: return "equivalenceNode";
            case NodeType.implicationNode: return "implicationNode";
            case NodeType.disjunctionNode: return "disjunctionNode";
            case NodeType.conjunctionNode: return "conjunctionNode";
            case NodeType.bitOrNode: return "bitOrNode";
            case NodeType.bitXorNode: return "bitXorNode";
            case NodeType.bitAndNode: return "bitAndNode";
            case NodeType.equalNode: return "equalNode";
            case NodeType.notEqualNode: return "notEqualNode";
            case NodeType.lessNode: return "lessNode";
            case NodeType.greaterNode: return "greaterNode";
            case NodeType.lessOrEqualNode: return "lessOrEqualNode";
            case NodeType.greaterOrEqualNode: return "greaterOrEqualNode";
            case NodeType.shiftLeftNode: return "shiftLeftNode";
            case NodeType.shiftRightNode: return "shiftRightNode";
            case NodeType.addNode: return "addNode";
            case NodeType.subNode: return "subNode";
            case NodeType.mulNode: return "mulNode";
            case NodeType.divNode: return "divNode";
            case NodeType.remNode: return "remNode";
            case NodeType.notNode: return "notNode";
            case NodeType.unaryPlusNode: return "unaryPlusNode";
            case NodeType.unaryMinusNode: return "unaryMinusNode";
            case NodeType.prefixIncrementNode: return "prefixIncrementNode";
            case NodeType.prefixDecrementNode: return "prefixDecrementNode";
            case NodeType.complementNode: return "complementNode";
            case NodeType.derefNode: return "derefNode";
            case NodeType.addrOfNode: return "addrOfNode";
            case NodeType.isNode: return "isNode";
            case NodeType.asNode: return "asNode";
            case NodeType.indexingNode: return "indexingNode";
            case NodeType.invokeNode: return "invokeNode";
            case NodeType.postfixIncrementNode: return "postfixIncrementNode";
            case NodeType.postfixDecrementNode: return "postfixDecrementNode";
            case NodeType.sizeOfNode: return "sizeOfNode";
            case NodeType.typeNameNode: return "typeNameNode";
            case NodeType.typeIdNode: return "typeIdNode";
            case NodeType.castNode: return "castNode";
            case NodeType.constructNode: return "constructNode";
            case NodeType.newNode: return "newNode";
            case NodeType.thisNode: return "thisNode";
            case NodeType.baseNode: return "baseNode";
            case NodeType.conditionalCompilationDisjunctionNode: return "conditionalCompilationDisjunctionNode";
            case NodeType.conditionalCompilationConjunctionNode: return "conditionalCompilationConjunctionNode";
            case NodeType.conditionalCompilationNotNode: return "conditionalCompilationNotNode";
            case NodeType.conditionalCompilationPrimaryNode: return "conditionalCompilationPrimaryNode";
            case NodeType.conditionalCompilationPartNode: return "conditionalCompilationPartNode";
            case NodeType.conditionalCompilationStatementNode: return "conditionalCompilationStatementNode";
            case NodeType.uuidLiteralNode: return "uuidLiteralNode";
            case NodeType.cursorIdNode: return "cursorIdNode";
            case NodeType.parenthesizedExpressionNode: return "parenthesizedExpressionNode";
            case NodeType.globalVariableNode: return "globalVariableNode";
            case NodeType.parenthesizedCondCompExpressionNode: return "parenthesizedCondCompExpressionNode";
            case NodeType.labeledStatementNode: return "labeledStatementNode";
            case NodeType.commentNode: return "commentNode";
            case NodeType.attributeNode: return "attributeNode";
            case NodeType.attributesNode: return "attributesNode";
        }
        return string();
    }
} // namespace Cm.Ast

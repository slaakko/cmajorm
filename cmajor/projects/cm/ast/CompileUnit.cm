using System;
using System.Collections;
using System.Security;

// this file has been semiautomatically generated from 'D:/work/soulng-project/sngcm/ast/CompileUnit.hpp' using cpp2cm version 1.0.0

// this file has been semiautomatically generated from 'D:/work/soulng-project/sngcm/ast/CompileUnit.cpp' using cpp2cm version 1.0.0

namespace Cm.Ast
{
    public class CompileUnitNode : Node
    {
        public nothrow CompileUnitNode(const System.Lex.Span& span_) :
            base(NodeType.compileUnitNode, span_), globalNs(), isSynthesizedUnit(false)
        {
        }
        public nothrow CompileUnitNode(const System.Lex.Span& span_, const string& filePath_) :
            base(NodeType.compileUnitNode, span_), filePath(filePath_), globalNs(new NamespaceNode(span_, new IdentifierNode(span_, u""))), isSynthesizedUnit(false)
        {
        }
        public nothrow const string& FilePath() const
        {
            return filePath;
        }
        public nothrow const NamespaceNode* GlobalNs() const
        {
            return globalNs.Get();
        }
        public nothrow NamespaceNode* GlobalNs()
        {
            return globalNs.Get();
        }
        public nothrow const List<int>& LineStarts()
        {
            return lineStarts;
        }
        public nothrow void SetSynthesizedUnit()
        {
            isSynthesizedUnit = true;
        }
        public nothrow bool IsSynthesizedUnit() const
        {
            return isSynthesizedUnit;
        }
        public nothrow void ComputeLineStarts(const ustring& sourceFileContent)
        {
            int index = 0;
            bool startOfLine = true;
            for (const uchar& c : sourceFileContent)
            {
                if (startOfLine)
                {
                    lineStarts.Add(index);
                    startOfLine = false;
                }
                if (c == '\n')
                {
                    startOfLine = true;
                }
                ++index;
            }
        }
        public nothrow const string& Id()
        {
            if (id.IsEmpty())
            {
                id = GetSha1MessageDigest(filePath);
            }
            return id;
        }
        public override Node* Clone(CloneContext& cloneContext) const
        {
            CompileUnitNode* clone = new CompileUnitNode(GetSpan(), filePath);
            clone->globalNs.Reset(cast<NamespaceNode*>(globalNs->Clone(cloneContext)));
            return clone;
        }
        public override void Accept(Visitor& visitor)
        {
            visitor.Visit(*this);
        }
        private string filePath;
        private UniquePtr<NamespaceNode> globalNs;
        private List<int> lineStarts;
        private bool isSynthesizedUnit;
        private string id;
    }
    public class NamespaceCombinder : Visitor
    {
        public override void Visit(CompileUnitNode& compileUnitNode)
        {
            compileUnitNode.GlobalNs()->Accept(*this);
        }
        public override void Visit(NamespaceNode& namespaceNode)
        {
            int n = namespaceNode.Members().Count();
            for (int i = 0; i < n; ++i)
            {
                namespaceNode.Members()[i]->Accept(*this);
            }
            if (n == 1 && !namespaceNode.Id()->Str().IsEmpty())
            {
                Node* node = namespaceNode.Members()[0];
                if (node->GetNodeType() == NodeType.namespaceNode)
                {
                    UniquePtr<NamespaceNode> childNs(cast<NamespaceNode*>(namespaceNode.Members().Release(0)));
                    namespaceNode.Id()->SetStr(namespaceNode.Id()->Str() + u"." + childNs->Id()->Str());
                    namespaceNode.Members().Clear();
                    namespaceNode.Members().SetContent(childNs->Members().Content());
                    namespaceNode.Members().SetParent(&namespaceNode);
                }
            }
        }
    }
    public nothrow void CombineNamespaces(CompileUnitNode& cu)
    {
        NamespaceCombinder combiner;
        cu.Accept(combiner);
    }
    public class ClassMemberArranger : Visitor
    {
        public override void Visit(CompileUnitNode& compileUnitNode)
        {
            compileUnitNode.GlobalNs()->Accept(*this);
        }
        public override void Visit(NamespaceNode& namespaceNode)
        {
            int n = namespaceNode.Members().Count();
            for (int i = 0; i < n; ++i)
            {
                namespaceNode.Members()[i]->Accept(*this);
            }
        }
        public override void Visit(ClassNode& classNode)
        {
            int n = classNode.Members().Count();
            for (int i = 0; i < n; ++i)
            {
                classNode.Members()[i]->Accept(*this);
            }
            classNode.ArrangeMembers();
        }
    }
    public nothrow void ArrangeClassMembers(CompileUnitNode& cu)
    {
        ClassMemberArranger arranger;
        cu.Accept(arranger);
    }
} // namespace Cm.Ast

using System;

namespace ParserFileTokens
{
    public const int END = 0;
    public const int PARSER = 1;
    public const int MAIN = 2;
    public const int USELEXER = 3;
    public const int RULEINFO = 4;
    public const int EMPTY = 5;
    public const int VAR = 6;
    public const int PRODUCES = 7;
    public const int ASSERT = 8;
    public const int ELIF = 9;
    public const int ENDIF = 10;
    public const int BOOL = 11;
    public const int TRUE = 12;
    public const int FALSE = 13;
    public const int SBYTE = 14;
    public const int BYTE = 15;
    public const int SHORT = 16;
    public const int USHORT = 17;
    public const int INT = 18;
    public const int UINT = 19;
    public const int LONG = 20;
    public const int ULONG = 21;
    public const int FLOAT = 22;
    public const int DOUBLE = 23;
    public const int CHAR = 24;
    public const int WCHAR = 25;
    public const int UCHAR = 26;
    public const int VOID = 27;
    public const int ENUM = 28;
    public const int CAST = 29;
    public const int INTERFACE = 30;
    public const int NAMESPACE = 31;
    public const int USING = 32;
    public const int STATIC = 33;
    public const int EXTERN = 34;
    public const int AS = 35;
    public const int IS = 36;
    public const int EXPLICIT = 37;
    public const int DELEGATE = 38;
    public const int INLINE = 39;
    public const int CDECL = 40;
    public const int NOTHROW = 41;
    public const int PUBLIC = 42;
    public const int PROTECTED = 43;
    public const int PRIVATE = 44;
    public const int INTERNAL = 45;
    public const int VIRTUAL = 46;
    public const int ABSTRACT = 47;
    public const int OVERRIDE = 48;
    public const int SUPPRESS = 49;
    public const int OPERATOR = 50;
    public const int CLASS = 51;
    public const int RETURN = 52;
    public const int IF = 53;
    public const int ELSE = 54;
    public const int SWITCH = 55;
    public const int CASE = 56;
    public const int DEFAULT = 57;
    public const int WHILE = 58;
    public const int DO = 59;
    public const int FOR = 60;
    public const int BREAK = 61;
    public const int CONTINUE = 62;
    public const int GOTO = 63;
    public const int TYPEDEF = 64;
    public const int TYPENAME = 65;
    public const int TYPEID = 66;
    public const int CONST = 67;
    public const int CONSTEXPR = 68;
    public const int NULLLIT = 69;
    public const int THIS = 70;
    public const int BASE = 71;
    public const int CONSTRUCT = 72;
    public const int DESTROY = 73;
    public const int NEW = 74;
    public const int DELETE = 75;
    public const int SIZEOF = 76;
    public const int TRY = 77;
    public const int CATCH = 78;
    public const int THROW = 79;
    public const int CONCEPT = 80;
    public const int WHERE = 81;
    public const int AXIOM = 82;
    public const int AND = 83;
    public const int OR = 84;
    public const int EXCLAMATION = 85;
    public const int UNIT_TEST = 86;
    public const int ID = 87;
    public const int FLOATINGLIT = 88;
    public const int INTLIT = 89;
    public const int CHARLIT = 90;
    public const int STRINGLIT = 91;
    public const int EQUIVALENCE = 92;
    public const int IMPLICATION = 93;
    public const int DISJUNCTION = 94;
    public const int AMPAMP = 95;
    public const int BITOR = 96;
    public const int BITXOR = 97;
    public const int AMP = 98;
    public const int EQ = 99;
    public const int NEQ = 100;
    public const int LEQ = 101;
    public const int GEQ = 102;
    public const int SHIFTLEFT = 103;
    public const int SHIFTRIGHT = 104;
    public const int PLUS = 105;
    public const int MINUS = 106;
    public const int STAR = 107;
    public const int DIV = 108;
    public const int REM = 109;
    public const int PLUSPLUS = 110;
    public const int MINUSMINUS = 111;
    public const int CPL = 112;
    public const int DOT = 113;
    public const int ARROW = 114;
    public const int LBRACKET = 115;
    public const int RBRACKET = 116;
    public const int LPAREN = 117;
    public const int RPAREN = 118;
    public const int LANGLE = 119;
    public const int RANGLE = 120;
    public const int LBRACE = 121;
    public const int RBRACE = 122;
    public const int COMMA = 123;
    public const int ASSIGN = 124;
    public const int COLON = 125;
    public const int SEMICOLON = 126;
    public const int HASH = 127;
    public const int QUEST = 128u;
    internal class TokenMap
    {
        static TokenMap() :
            instance(new TokenMap())
        {
        }
        public static TokenMap& Instance()
        {
            return *instance;
        }
        public int GetTokenId(const ustring& tokenName)
        {
            System.Collections.Map<ustring, int>.ConstIterator it = tokenIdMap.CFind(tokenName);
            if (it != tokenIdMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return -1;
            }
        }
        public ustring GetTokenName(int tokenId)
        {
            return tokenNameList[tokenId];
        }
        public ustring GetTokenInfo(int tokenId)
        {
            return tokenInfoList[tokenId];
        }
        private TokenMap()
        {
            tokenIdMap[u"ABSTRACT"] = 47;
            tokenIdMap[u"AMP"] = 98;
            tokenIdMap[u"AMPAMP"] = 95;
            tokenIdMap[u"AND"] = 83;
            tokenIdMap[u"ARROW"] = 114;
            tokenIdMap[u"AS"] = 35;
            tokenIdMap[u"ASSERT"] = 8;
            tokenIdMap[u"ASSIGN"] = 124;
            tokenIdMap[u"AXIOM"] = 82;
            tokenIdMap[u"BASE"] = 71;
            tokenIdMap[u"BITOR"] = 96;
            tokenIdMap[u"BITXOR"] = 97;
            tokenIdMap[u"BOOL"] = 11;
            tokenIdMap[u"BREAK"] = 61;
            tokenIdMap[u"BYTE"] = 15;
            tokenIdMap[u"CASE"] = 56;
            tokenIdMap[u"CAST"] = 29;
            tokenIdMap[u"CATCH"] = 78;
            tokenIdMap[u"CDECL"] = 40;
            tokenIdMap[u"CHAR"] = 24;
            tokenIdMap[u"CHARLIT"] = 90;
            tokenIdMap[u"CLASS"] = 51;
            tokenIdMap[u"COLON"] = 125;
            tokenIdMap[u"COMMA"] = 123;
            tokenIdMap[u"CONCEPT"] = 80;
            tokenIdMap[u"CONST"] = 67;
            tokenIdMap[u"CONSTEXPR"] = 68;
            tokenIdMap[u"CONSTRUCT"] = 72;
            tokenIdMap[u"CONTINUE"] = 62;
            tokenIdMap[u"CPL"] = 112;
            tokenIdMap[u"DEFAULT"] = 57;
            tokenIdMap[u"DELEGATE"] = 38;
            tokenIdMap[u"DELETE"] = 75;
            tokenIdMap[u"DESTROY"] = 73;
            tokenIdMap[u"DISJUNCTION"] = 94;
            tokenIdMap[u"DIV"] = 108;
            tokenIdMap[u"DO"] = 59;
            tokenIdMap[u"DOT"] = 113;
            tokenIdMap[u"DOUBLE"] = 23;
            tokenIdMap[u"ELIF"] = 9;
            tokenIdMap[u"ELSE"] = 54;
            tokenIdMap[u"EMPTY"] = 5;
            tokenIdMap[u"ENDIF"] = 10;
            tokenIdMap[u"ENUM"] = 28;
            tokenIdMap[u"EQ"] = 99;
            tokenIdMap[u"EQUIVALENCE"] = 92;
            tokenIdMap[u"EXCLAMATION"] = 85;
            tokenIdMap[u"EXPLICIT"] = 37;
            tokenIdMap[u"EXTERN"] = 34;
            tokenIdMap[u"FALSE"] = 13;
            tokenIdMap[u"FLOAT"] = 22;
            tokenIdMap[u"FLOATINGLIT"] = 88;
            tokenIdMap[u"FOR"] = 60;
            tokenIdMap[u"GEQ"] = 102;
            tokenIdMap[u"GOTO"] = 63;
            tokenIdMap[u"HASH"] = 127;
            tokenIdMap[u"ID"] = 87;
            tokenIdMap[u"IF"] = 53;
            tokenIdMap[u"IMPLICATION"] = 93;
            tokenIdMap[u"INLINE"] = 39;
            tokenIdMap[u"INT"] = 18;
            tokenIdMap[u"INTERFACE"] = 30;
            tokenIdMap[u"INTERNAL"] = 45;
            tokenIdMap[u"INTLIT"] = 89;
            tokenIdMap[u"IS"] = 36;
            tokenIdMap[u"LANGLE"] = 119;
            tokenIdMap[u"LBRACE"] = 121;
            tokenIdMap[u"LBRACKET"] = 115;
            tokenIdMap[u"LEQ"] = 101;
            tokenIdMap[u"LONG"] = 20;
            tokenIdMap[u"LPAREN"] = 117;
            tokenIdMap[u"MAIN"] = 2;
            tokenIdMap[u"MINUS"] = 106;
            tokenIdMap[u"MINUSMINUS"] = 111;
            tokenIdMap[u"NAMESPACE"] = 31;
            tokenIdMap[u"NEQ"] = 100;
            tokenIdMap[u"NEW"] = 74;
            tokenIdMap[u"NOTHROW"] = 41;
            tokenIdMap[u"NULLLIT"] = 69;
            tokenIdMap[u"OPERATOR"] = 50;
            tokenIdMap[u"OR"] = 84;
            tokenIdMap[u"OVERRIDE"] = 48;
            tokenIdMap[u"PARSER"] = 1;
            tokenIdMap[u"PLUS"] = 105;
            tokenIdMap[u"PLUSPLUS"] = 110;
            tokenIdMap[u"PRIVATE"] = 44;
            tokenIdMap[u"PRODUCES"] = 7;
            tokenIdMap[u"PROTECTED"] = 43;
            tokenIdMap[u"PUBLIC"] = 42;
            tokenIdMap[u"QUEST"] = 128u;
            tokenIdMap[u"RANGLE"] = 120;
            tokenIdMap[u"RBRACE"] = 122;
            tokenIdMap[u"RBRACKET"] = 116;
            tokenIdMap[u"REM"] = 109;
            tokenIdMap[u"RETURN"] = 52;
            tokenIdMap[u"RPAREN"] = 118;
            tokenIdMap[u"RULEINFO"] = 4;
            tokenIdMap[u"SBYTE"] = 14;
            tokenIdMap[u"SEMICOLON"] = 126;
            tokenIdMap[u"SHIFTLEFT"] = 103;
            tokenIdMap[u"SHIFTRIGHT"] = 104;
            tokenIdMap[u"SHORT"] = 16;
            tokenIdMap[u"SIZEOF"] = 76;
            tokenIdMap[u"STAR"] = 107;
            tokenIdMap[u"STATIC"] = 33;
            tokenIdMap[u"STRINGLIT"] = 91;
            tokenIdMap[u"SUPPRESS"] = 49;
            tokenIdMap[u"SWITCH"] = 55;
            tokenIdMap[u"THIS"] = 70;
            tokenIdMap[u"THROW"] = 79;
            tokenIdMap[u"TRUE"] = 12;
            tokenIdMap[u"TRY"] = 77;
            tokenIdMap[u"TYPEDEF"] = 64;
            tokenIdMap[u"TYPEID"] = 66;
            tokenIdMap[u"TYPENAME"] = 65;
            tokenIdMap[u"UCHAR"] = 26;
            tokenIdMap[u"UINT"] = 19;
            tokenIdMap[u"ULONG"] = 21;
            tokenIdMap[u"UNIT_TEST"] = 86;
            tokenIdMap[u"USELEXER"] = 3;
            tokenIdMap[u"USHORT"] = 17;
            tokenIdMap[u"USING"] = 32;
            tokenIdMap[u"VAR"] = 6;
            tokenIdMap[u"VIRTUAL"] = 46;
            tokenIdMap[u"VOID"] = 27;
            tokenIdMap[u"WCHAR"] = 25;
            tokenIdMap[u"WHERE"] = 81;
            tokenIdMap[u"WHILE"] = 58;
            tokenNameList.Add(u"END");
            tokenInfoList.Add(u"end of file");
            tokenNameList.Add(u"PARSER");
            tokenInfoList.Add(u"\'parser\'");
            tokenNameList.Add(u"MAIN");
            tokenInfoList.Add(u"\'main\'");
            tokenNameList.Add(u"USELEXER");
            tokenInfoList.Add(u"\'uselexer\'");
            tokenNameList.Add(u"RULEINFO");
            tokenInfoList.Add(u"\'ruleinfo\'");
            tokenNameList.Add(u"EMPTY");
            tokenInfoList.Add(u"\'empty\'");
            tokenNameList.Add(u"VAR");
            tokenInfoList.Add(u"\'var\'");
            tokenNameList.Add(u"PRODUCES");
            tokenInfoList.Add(u"\'::=\'");
            tokenNameList.Add(u"ASSERT");
            tokenInfoList.Add(u"\'assert\'");
            tokenNameList.Add(u"ELIF");
            tokenInfoList.Add(u"\'elif\'");
            tokenNameList.Add(u"ENDIF");
            tokenInfoList.Add(u"\'endif\'");
            tokenNameList.Add(u"BOOL");
            tokenInfoList.Add(u"\'bool\'");
            tokenNameList.Add(u"TRUE");
            tokenInfoList.Add(u"\'true\'");
            tokenNameList.Add(u"FALSE");
            tokenInfoList.Add(u"\'false\'");
            tokenNameList.Add(u"SBYTE");
            tokenInfoList.Add(u"\'sbyte\'");
            tokenNameList.Add(u"BYTE");
            tokenInfoList.Add(u"\'byte\'");
            tokenNameList.Add(u"SHORT");
            tokenInfoList.Add(u"\'short\'");
            tokenNameList.Add(u"USHORT");
            tokenInfoList.Add(u"\'ushort\'");
            tokenNameList.Add(u"INT");
            tokenInfoList.Add(u"\'int\'");
            tokenNameList.Add(u"UINT");
            tokenInfoList.Add(u"\'uint\'");
            tokenNameList.Add(u"LONG");
            tokenInfoList.Add(u"\'long\'");
            tokenNameList.Add(u"ULONG");
            tokenInfoList.Add(u"\'ulong\'");
            tokenNameList.Add(u"FLOAT");
            tokenInfoList.Add(u"\'float\'");
            tokenNameList.Add(u"DOUBLE");
            tokenInfoList.Add(u"\'double\'");
            tokenNameList.Add(u"CHAR");
            tokenInfoList.Add(u"\'char\'");
            tokenNameList.Add(u"WCHAR");
            tokenInfoList.Add(u"\'wchar\'");
            tokenNameList.Add(u"UCHAR");
            tokenInfoList.Add(u"\'uchar\'");
            tokenNameList.Add(u"VOID");
            tokenInfoList.Add(u"\'void\'");
            tokenNameList.Add(u"ENUM");
            tokenInfoList.Add(u"\'enum\'");
            tokenNameList.Add(u"CAST");
            tokenInfoList.Add(u"\'cast\'");
            tokenNameList.Add(u"INTERFACE");
            tokenInfoList.Add(u"\'interface\'");
            tokenNameList.Add(u"NAMESPACE");
            tokenInfoList.Add(u"\'namespace\'");
            tokenNameList.Add(u"USING");
            tokenInfoList.Add(u"\'using\'");
            tokenNameList.Add(u"STATIC");
            tokenInfoList.Add(u"\'static\'");
            tokenNameList.Add(u"EXTERN");
            tokenInfoList.Add(u"\'extern\'");
            tokenNameList.Add(u"AS");
            tokenInfoList.Add(u"\'as\'");
            tokenNameList.Add(u"IS");
            tokenInfoList.Add(u"\'is\'");
            tokenNameList.Add(u"EXPLICIT");
            tokenInfoList.Add(u"\'explicit\'");
            tokenNameList.Add(u"DELEGATE");
            tokenInfoList.Add(u"\'delegate\'");
            tokenNameList.Add(u"INLINE");
            tokenInfoList.Add(u"\'inline\'");
            tokenNameList.Add(u"CDECL");
            tokenInfoList.Add(u"\'cdecl\'");
            tokenNameList.Add(u"NOTHROW");
            tokenInfoList.Add(u"\'nothrow\'");
            tokenNameList.Add(u"PUBLIC");
            tokenInfoList.Add(u"\'public\'");
            tokenNameList.Add(u"PROTECTED");
            tokenInfoList.Add(u"\'protected\'");
            tokenNameList.Add(u"PRIVATE");
            tokenInfoList.Add(u"\'private\'");
            tokenNameList.Add(u"INTERNAL");
            tokenInfoList.Add(u"\'internal\'");
            tokenNameList.Add(u"VIRTUAL");
            tokenInfoList.Add(u"\'virtual\'");
            tokenNameList.Add(u"ABSTRACT");
            tokenInfoList.Add(u"\'abstract\'");
            tokenNameList.Add(u"OVERRIDE");
            tokenInfoList.Add(u"\'override\'");
            tokenNameList.Add(u"SUPPRESS");
            tokenInfoList.Add(u"\'suppress\'");
            tokenNameList.Add(u"OPERATOR");
            tokenInfoList.Add(u"\'operator\'");
            tokenNameList.Add(u"CLASS");
            tokenInfoList.Add(u"\'class\'");
            tokenNameList.Add(u"RETURN");
            tokenInfoList.Add(u"\'return\'");
            tokenNameList.Add(u"IF");
            tokenInfoList.Add(u"\'if\'");
            tokenNameList.Add(u"ELSE");
            tokenInfoList.Add(u"\'else\'");
            tokenNameList.Add(u"SWITCH");
            tokenInfoList.Add(u"\'switch\'");
            tokenNameList.Add(u"CASE");
            tokenInfoList.Add(u"\'case\'");
            tokenNameList.Add(u"DEFAULT");
            tokenInfoList.Add(u"\'default\'");
            tokenNameList.Add(u"WHILE");
            tokenInfoList.Add(u"\'while\'");
            tokenNameList.Add(u"DO");
            tokenInfoList.Add(u"\'do\'");
            tokenNameList.Add(u"FOR");
            tokenInfoList.Add(u"\'for\'");
            tokenNameList.Add(u"BREAK");
            tokenInfoList.Add(u"\'break\'");
            tokenNameList.Add(u"CONTINUE");
            tokenInfoList.Add(u"\'continue\'");
            tokenNameList.Add(u"GOTO");
            tokenInfoList.Add(u"\'goto\'");
            tokenNameList.Add(u"TYPEDEF");
            tokenInfoList.Add(u"\'typedef\'");
            tokenNameList.Add(u"TYPENAME");
            tokenInfoList.Add(u"\'typename\'");
            tokenNameList.Add(u"TYPEID");
            tokenInfoList.Add(u"\'typeid\'");
            tokenNameList.Add(u"CONST");
            tokenInfoList.Add(u"\'const\'");
            tokenNameList.Add(u"CONSTEXPR");
            tokenInfoList.Add(u"\'constexpr\'");
            tokenNameList.Add(u"NULLLIT");
            tokenInfoList.Add(u"\'null\'");
            tokenNameList.Add(u"THIS");
            tokenInfoList.Add(u"\'this\'");
            tokenNameList.Add(u"BASE");
            tokenInfoList.Add(u"\'base\'");
            tokenNameList.Add(u"CONSTRUCT");
            tokenInfoList.Add(u"\'construct\'");
            tokenNameList.Add(u"DESTROY");
            tokenInfoList.Add(u"\'destroy\'");
            tokenNameList.Add(u"NEW");
            tokenInfoList.Add(u"\'new\'");
            tokenNameList.Add(u"DELETE");
            tokenInfoList.Add(u"\'delete\'");
            tokenNameList.Add(u"SIZEOF");
            tokenInfoList.Add(u"\'sizeof\'");
            tokenNameList.Add(u"TRY");
            tokenInfoList.Add(u"\'try\'");
            tokenNameList.Add(u"CATCH");
            tokenInfoList.Add(u"\'catch\'");
            tokenNameList.Add(u"THROW");
            tokenInfoList.Add(u"\'throw\'");
            tokenNameList.Add(u"CONCEPT");
            tokenInfoList.Add(u"\'concept\'");
            tokenNameList.Add(u"WHERE");
            tokenInfoList.Add(u"\'where\'");
            tokenNameList.Add(u"AXIOM");
            tokenInfoList.Add(u"\'axiom\'");
            tokenNameList.Add(u"AND");
            tokenInfoList.Add(u"\'and\'");
            tokenNameList.Add(u"OR");
            tokenInfoList.Add(u"\'or\'");
            tokenNameList.Add(u"EXCLAMATION");
            tokenInfoList.Add(u"\'!\'");
            tokenNameList.Add(u"UNIT_TEST");
            tokenInfoList.Add(u"\'unit_test\'");
            tokenNameList.Add(u"ID");
            tokenInfoList.Add(u"identifier");
            tokenNameList.Add(u"FLOATINGLIT");
            tokenInfoList.Add(u"floating literal");
            tokenNameList.Add(u"INTLIT");
            tokenInfoList.Add(u"integer literal");
            tokenNameList.Add(u"CHARLIT");
            tokenInfoList.Add(u"character literal");
            tokenNameList.Add(u"STRINGLIT");
            tokenInfoList.Add(u"string literal");
            tokenNameList.Add(u"EQUIVALENCE");
            tokenInfoList.Add(u"\'<=>\'");
            tokenNameList.Add(u"IMPLICATION");
            tokenInfoList.Add(u"\'=>\'");
            tokenNameList.Add(u"DISJUNCTION");
            tokenInfoList.Add(u"\'||\'");
            tokenNameList.Add(u"AMPAMP");
            tokenInfoList.Add(u"\'&&\'");
            tokenNameList.Add(u"BITOR");
            tokenInfoList.Add(u"\'|\'");
            tokenNameList.Add(u"BITXOR");
            tokenInfoList.Add(u"\'^\'");
            tokenNameList.Add(u"AMP");
            tokenInfoList.Add(u"\'&\'");
            tokenNameList.Add(u"EQ");
            tokenInfoList.Add(u"\'==\'");
            tokenNameList.Add(u"NEQ");
            tokenInfoList.Add(u"\'!=\'");
            tokenNameList.Add(u"LEQ");
            tokenInfoList.Add(u"\'<=\'");
            tokenNameList.Add(u"GEQ");
            tokenInfoList.Add(u"\'>=\'");
            tokenNameList.Add(u"SHIFTLEFT");
            tokenInfoList.Add(u"\'<<\'");
            tokenNameList.Add(u"SHIFTRIGHT");
            tokenInfoList.Add(u"\'>>\'");
            tokenNameList.Add(u"PLUS");
            tokenInfoList.Add(u"\'+\'");
            tokenNameList.Add(u"MINUS");
            tokenInfoList.Add(u"\'-\'");
            tokenNameList.Add(u"STAR");
            tokenInfoList.Add(u"\'*\'");
            tokenNameList.Add(u"DIV");
            tokenInfoList.Add(u"\'/\'");
            tokenNameList.Add(u"REM");
            tokenInfoList.Add(u"\'%\'");
            tokenNameList.Add(u"PLUSPLUS");
            tokenInfoList.Add(u"\'++\'");
            tokenNameList.Add(u"MINUSMINUS");
            tokenInfoList.Add(u"\'--\'");
            tokenNameList.Add(u"CPL");
            tokenInfoList.Add(u"\'~\'");
            tokenNameList.Add(u"DOT");
            tokenInfoList.Add(u"\'.\'");
            tokenNameList.Add(u"ARROW");
            tokenInfoList.Add(u"\'->\'");
            tokenNameList.Add(u"LBRACKET");
            tokenInfoList.Add(u"\'[\'");
            tokenNameList.Add(u"RBRACKET");
            tokenInfoList.Add(u"\']\'");
            tokenNameList.Add(u"LPAREN");
            tokenInfoList.Add(u"\'(\'");
            tokenNameList.Add(u"RPAREN");
            tokenInfoList.Add(u"\')\'");
            tokenNameList.Add(u"LANGLE");
            tokenInfoList.Add(u"\'<\'");
            tokenNameList.Add(u"RANGLE");
            tokenInfoList.Add(u"\'>\'");
            tokenNameList.Add(u"LBRACE");
            tokenInfoList.Add(u"\'{\'");
            tokenNameList.Add(u"RBRACE");
            tokenInfoList.Add(u"\'}\'");
            tokenNameList.Add(u"COMMA");
            tokenInfoList.Add(u"\',\'");
            tokenNameList.Add(u"ASSIGN");
            tokenInfoList.Add(u"\'=\'");
            tokenNameList.Add(u"COLON");
            tokenInfoList.Add(u"\':\'");
            tokenNameList.Add(u"SEMICOLON");
            tokenInfoList.Add(u"\';\'");
            tokenNameList.Add(u"HASH");
            tokenInfoList.Add(u"\'#\'");
            tokenNameList.Add(u"QUEST");
            tokenInfoList.Add(u"\'?\'");
        }
        private static System.UniquePtr<TokenMap> instance;
        private System.Collections.Map<ustring, int> tokenIdMap;
        private System.Collections.List<ustring> tokenNameList;
        private System.Collections.List<ustring> tokenInfoList;
    }
    public int GetTokenId(const ustring& tokenName)
    {
        return TokenMap.Instance().GetTokenId(tokenName);
    }
    public ustring GetTokenName(int tokenId)
    {
        return TokenMap.Instance().GetTokenName(tokenId);
    }
    public ustring GetTokenInfo(int tokenId)
    {
        return TokenMap.Instance().GetTokenInfo(tokenId);
    }
} // namespace ParserFileTokens

using System;
using System.Collections;
using System.IO;
using System.Text;
using Cm.Ast;

// this file has been semiautomatically generated from 'D:/work/soulngcm/soulngcm/sngcmlg/Model.hpp' using cpp2cm version 1.0.0

// this file has been semiautomatically generated from 'D:/work/soulngcm/soulngcm/sngcmlg/Model.cpp' using cpp2cm version 1.0.0

namespace soulcm.scmlg
{
    public abstract class Parser
    {
        public virtual ~Parser()
        {
        }
        public abstract Nfa Parse(const ustring& expression, LexerContext* lexerContext, int line);
    }
    public abstract class Declaration
    {
        public Declaration(const ustring& name_) :
            name(name_)
        {
        }
        public virtual ~Declaration()
        {
        }
        public const ustring& Name() const
        {
            return name;
        }
        public abstract void FillContext(LexerContext& lexerContext);
        public abstract void Process(const string& root, bool verbose, LexerContext& lexerContext);
        private ustring name;
    }
    public class ClassMap : Declaration
    {
        public ClassMap(const ustring& name_) :
            base(name_)
        {
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            lexerContext.SetClassMap(this);
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
        }
    }
    public class Usings : Declaration
    {
        public Usings() :
            base(u"usings")
        {
        }
        public const List<UniquePtr<Cm.Ast.Node>>& UsingNodes() const
        {
            return usingNodes;
        }
        public void AddMember(Cm.Ast.Node* usingNode)
        {
            usingNodes.Add(UniquePtr<Cm.Ast.Node>(usingNode));
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            for (const UniquePtr<Cm.Ast.Node>& usingNode : usingNodes)
            {
                lexerContext.AddUsingNode(usingNode.Get());
            }
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
        }
        private List<UniquePtr<Cm.Ast.Node>> usingNodes;
    }
    public class Token
    {
        public Token() :
            name(), info()
        {
        }
        public Token(const ustring& name_, const string& info_) :
            name(name_), info(info_)
        {
        }
        public ustring name;
        public string info;
    }
    public class Tokens : Declaration
    {
        public Tokens(const ustring& name_) :
            base(name_)
        {
        }
        public void Add(const Token& token)
        {
            tokens.Add(token);
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            lexerContext.SetTokens(this);
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
            string tokenFileName = ToUtf8(Name()) + ".cm";
            string tokenFilePath = GetFullPath(Path.Combine(root, tokenFileName));
            Cm.Ast.CompileUnitNode compileUnit(System.Lex.Span(), tokenFilePath);
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.NamespaceImportNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System")));
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.CommentNode(System.Lex.Span(), u"this file has been automatically generated from \'" + ToUtf32(lexerContext.FileName()) + u"\' using soulcm lexer generator scmlg version " + ToUtf32(LexerGeneratorVersionStr())));
            UniquePtr<Cm.Ast.NamespaceNode> ns(new Cm.Ast.NamespaceNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), Name())));
            UniquePtr<Cm.Ast.ConstantNode> end(new Cm.Ast.ConstantNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"END"), new Cm.Ast.IntLiteralNode(System.Lex.Span(), 0)));
            ns->AddMember(end.Release());
            Map<ustring, int> tokenIdMap;
            int i = 1;
            for (const Token& t : tokens)
            {
                tokenIdMap[t.name] = i;
                UniquePtr<Cm.Ast.ConstantNode> token(new Cm.Ast.ConstantNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), t.name), new Cm.Ast.IntLiteralNode(System.Lex.Span(), i++)));
                ns->AddMember(token.Release());
            }
            UniquePtr<Cm.Ast.ClassNode> tokenMapClass(new Cm.Ast.ClassNode(System.Lex.Span(), Specifiers.internal_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"), null));
            UniquePtr<Cm.Ast.StaticConstructorNode> staticConstructor(new Cm.Ast.StaticConstructorNode(System.Lex.Span(), Specifiers.static_, null));
            staticConstructor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"));
            staticConstructor->SetBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.MemberInitializerNode> init(new Cm.Ast.MemberInitializerNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance")));
            Cm.Ast.TemplateIdNode instanceType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"UniquePtr")));
            instanceType.AddTemplateArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"));
            Cm.Ast.CloneContext cloneContext;
            Cm.Ast.NewNode* newNode = new Cm.Ast.NewNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"));
            init->AddArgument(newNode);
            staticConstructor->AddInitializer(init.Release());
            tokenMapClass->AddMember(staticConstructor.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> instanceMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_ | Specifiers.static_, new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap")), u"Instance", null));
            UniquePtr<Cm.Ast.CompoundStatementNode> instanceBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            instanceBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.DerefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance"))));
            instanceMemFun->SetBody(instanceBody.Release());
            tokenMapClass->AddMember(instanceMemFun.Release());
            UniquePtr<Cm.Ast.TemplateIdNode> mapType(new Cm.Ast.TemplateIdNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Collections")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Map"))));
            mapType->AddTemplateArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"));
            mapType->AddTemplateArgument(new Cm.Ast.IntNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.TemplateIdNode> listType(new Cm.Ast.TemplateIdNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Collections")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"List"))));
            listType->AddTemplateArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"));
            UniquePtr<Cm.Ast.MemberFunctionNode> getTokenIdMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IntNode(System.Lex.Span()), u"GetTokenId", null));
            getTokenIdMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenName")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenIdBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.DotNode> iteratorType(new Cm.Ast.DotNode(System.Lex.Span(), mapType->Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ConstIterator")));
            UniquePtr<Cm.Ast.ConstructionStatementNode> constructIt(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), iteratorType.Release(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"it")));
            UniquePtr<Cm.Ast.InvokeNode> invokeCFind(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenIdMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CFind"))));
            invokeCFind->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenName"));
            constructIt->AddArgument(invokeCFind.Release());
            constructIt->SetAssignment();
            getTokenIdBody->AddStatement(constructIt.Release());
            UniquePtr<Cm.Ast.CompoundStatementNode> thenS(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnIt(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.ArrowNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"it"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"second"))));
            thenS->AddStatement(returnIt.Release());
            UniquePtr<Cm.Ast.CompoundStatementNode> elseS(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnMinusOne(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
            elseS->AddStatement(returnMinusOne.Release());
            UniquePtr<Cm.Ast.IfStatementNode> stmt(new Cm.Ast.IfStatementNode(System.Lex.Span(), new Cm.Ast.NotEqualNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"it"), new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenIdMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CEnd")))), thenS.Release(), elseS.Release()));
            getTokenIdBody->AddStatement(stmt.Release());
            getTokenIdMemFun->SetBody(getTokenIdBody.Release());
            tokenMapClass->AddMember(getTokenIdMemFun.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> getTokenNameMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"), u"GetTokenName", null));
            getTokenNameMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenNameMemFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            Cm.Ast.ReturnStatementNode* getTokenNameStmt = new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IndexingNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenNameList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            getTokenNameMemFunBody->AddStatement(getTokenNameStmt);
            getTokenNameMemFun->SetBody(getTokenNameMemFunBody.Release());
            tokenMapClass->AddMember(getTokenNameMemFun.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> getTokenInfoMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"), u"GetTokenInfo", null));
            getTokenInfoMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenInfoMemFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            Cm.Ast.ReturnStatementNode* getTokenInfoStmt = new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IndexingNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenInfoList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            getTokenInfoMemFunBody->AddStatement(getTokenInfoStmt);
            getTokenInfoMemFun->SetBody(getTokenInfoMemFunBody.Release());
            tokenMapClass->AddMember(getTokenInfoMemFun.Release());
            UniquePtr<Cm.Ast.ConstructorNode> ctor(new Cm.Ast.ConstructorNode(System.Lex.Span(), Specifiers.private_, null));
            ctor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"));
            UniquePtr<Cm.Ast.CompoundStatementNode> ctorBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            for (const Pair<ustring, int>& p : tokenIdMap)
            {
                UniquePtr<Cm.Ast.AssignmentStatementNode> stmt(new Cm.Ast.AssignmentStatementNode(System.Lex.Span(), new Cm.Ast.IndexingNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenIdMap"), new Cm.Ast.UStringLiteralNode(System.Lex.Span(), p.first)), new Cm.Ast.IntLiteralNode(System.Lex.Span(), p.second)));
                ctorBody->AddStatement(stmt.Release());
            }
            Cm.Ast.DotNode* addToTokenNameList = new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenNameList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"));
            Cm.Ast.InvokeNode* invokeAdd = new Cm.Ast.InvokeNode(System.Lex.Span(), addToTokenNameList);
            invokeAdd->AddArgument(new Cm.Ast.UStringLiteralNode(System.Lex.Span(), u"END"));
            Cm.Ast.ExpressionStatementNode* addExpr = new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAdd);
            ctorBody->AddStatement(addExpr);
            Cm.Ast.DotNode* addToTokenInfoList = new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenInfoList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"));
            Cm.Ast.InvokeNode* invokeAddTokenInfo = new Cm.Ast.InvokeNode(System.Lex.Span(), addToTokenInfoList);
            invokeAddTokenInfo->AddArgument(new Cm.Ast.UStringLiteralNode(System.Lex.Span(), u"end of file"));
            Cm.Ast.ExpressionStatementNode* addTokenInfoExpr = new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAddTokenInfo);
            ctorBody->AddStatement(addTokenInfoExpr);
            for (const Token& t : tokens)
            {
                Cm.Ast.DotNode* addToTokenNameList = new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenNameList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"));
                Cm.Ast.InvokeNode* invokeAdd = new Cm.Ast.InvokeNode(System.Lex.Span(), addToTokenNameList);
                invokeAdd->AddArgument(new Cm.Ast.UStringLiteralNode(System.Lex.Span(), t.name));
                Cm.Ast.ExpressionStatementNode* addExpr = new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAdd);
                ctorBody->AddStatement(addExpr);
                Cm.Ast.DotNode* addToTokenInfoList = new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenInfoList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"));
                Cm.Ast.InvokeNode* invokeAddTokenInfo = new Cm.Ast.InvokeNode(System.Lex.Span(), addToTokenInfoList);
                invokeAddTokenInfo->AddArgument(new Cm.Ast.UStringLiteralNode(System.Lex.Span(), ToUtf32(t.info)));
                Cm.Ast.ExpressionStatementNode* addTokenInfoExpr = new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAddTokenInfo);
                ctorBody->AddStatement(addTokenInfoExpr);
            }
            ctor->SetBody(ctorBody.Release());
            tokenMapClass->AddMember(ctor.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> instanceMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_ | Specifiers.static_, instanceType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance"), null));
            tokenMapClass->AddMember(instanceMemVar.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> tokenIdMapMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_, mapType->Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenIdMap"), null));
            tokenMapClass->AddMember(tokenIdMapMemVar.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> tokenNameListMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_, listType->Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenNameList"), null));
            tokenMapClass->AddMember(tokenNameListMemVar.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> tokenInfoListMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_, listType->Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenInfoList"), null));
            tokenMapClass->AddMember(tokenInfoListMemVar.Release());
            ns->AddMember(tokenMapClass.Release());
            UniquePtr<Cm.Ast.FunctionNode> getTokenIdFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IntNode(System.Lex.Span()), u"GetTokenId", null));
            getTokenIdFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenName")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenIdFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetTokenIdMemFun(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Instance"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetTokenId"))));
            invokeGetTokenIdMemFun->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenName"));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnTokenId(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), invokeGetTokenIdMemFun.Release()));
            getTokenIdFunBody->AddStatement(returnTokenId.Release());
            getTokenIdFun->SetBody(getTokenIdFunBody.Release());
            ns->AddMember(getTokenIdFun.Release());
            UniquePtr<Cm.Ast.FunctionNode> getTokenNameFun(new Cm.Ast.FunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"), u"GetTokenName", null));
            getTokenNameFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenNameFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetTokenNameMemFun(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Instance"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetTokenName"))));
            invokeGetTokenNameMemFun->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId"));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnTokenName(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), invokeGetTokenNameMemFun.Release()));
            getTokenNameFunBody->AddStatement(returnTokenName.Release());
            getTokenNameFun->SetBody(getTokenNameFunBody.Release());
            ns->AddMember(getTokenNameFun.Release());
            UniquePtr<Cm.Ast.FunctionNode> getTokenInfoFun(new Cm.Ast.FunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"), u"GetTokenInfo", null));
            getTokenInfoFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenInfoFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetTokenInfoMemFun(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"TokenMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Instance"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetTokenInfo"))));
            invokeGetTokenInfoMemFun->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId"));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnTokenInfo(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), invokeGetTokenInfoMemFun.Release()));
            getTokenInfoFunBody->AddStatement(returnTokenInfo.Release());
            getTokenInfoFun->SetBody(getTokenInfoFunBody.Release());
            ns->AddMember(getTokenInfoFun.Release());
            compileUnit.GlobalNs()->AddMember(ns.Release());
            System.IO.StreamWriter tokenFile(System.IO.File.CreateText(tokenFilePath));
            CodeFormatter formatter(tokenFile);
            Cm.Ast.SourceWriter writer(formatter);
            compileUnit.Accept(writer);
            if (verbose)
            {
                Console.Out() << "==> " << tokenFilePath << endl();
            }
        }
        private List<Token> tokens;
    }
    public class Keyword
    {
        public Keyword(const ustring& kw_, const ustring& token_) :
            kw(kw_), token(token_)
        {
        }
        public ustring kw;
        public ustring token;
    }
    public class Keywords : Declaration
    {
        public Keywords(const ustring& name_) :
            base(name_)
        {
        }
        public void Add(Keyword* keyword)
        {
            keywords.Add(UniquePtr<Keyword>(keyword));
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            lexerContext.SetKeywords(this);
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
            string keywordFileName = ToUtf8(Name()) + ".cm";
            string keywordFilePath = GetFullPath(Path.Combine(root, keywordFileName));
            Cm.Ast.CompileUnitNode compileUnit(System.Lex.Span(), keywordFilePath);
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.NamespaceImportNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System")));
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.CommentNode(System.Lex.Span(), u"this file has been automatically generated from \'" + ToUtf32(lexerContext.FileName()) + u"\' using soulcm lexer generator scmlg version " + ToUtf32(LexerGeneratorVersionStr())));
            UniquePtr<Cm.Ast.NamespaceNode> ns(new Cm.Ast.NamespaceNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), Name())));
            UniquePtr<Cm.Ast.ClassNode> keywordsClass(new Cm.Ast.ClassNode(System.Lex.Span(), Specifiers.internal_, new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"), null));
            UniquePtr<Cm.Ast.StaticConstructorNode> staticConstructor(new Cm.Ast.StaticConstructorNode(System.Lex.Span(), Specifiers.static_, null));
            staticConstructor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"));
            staticConstructor->SetBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.MemberInitializerNode> init(new Cm.Ast.MemberInitializerNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance")));
            Cm.Ast.TemplateIdNode instanceType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"UniquePtr")));
            instanceType.AddTemplateArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"));
            Cm.Ast.CloneContext cloneContext;
            Cm.Ast.NewNode* newNode = new Cm.Ast.NewNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"));
            init->AddArgument(newNode);
            staticConstructor->AddInitializer(init.Release());
            keywordsClass->AddMember(staticConstructor.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> instanceMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_ | Specifiers.static_, new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords")), u"Instance", null));
            UniquePtr<Cm.Ast.CompoundStatementNode> instanceBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            instanceBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.DerefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance"))));
            instanceMemFun->SetBody(instanceBody.Release());
            keywordsClass->AddMember(instanceMemFun.Release());
            Cm.Ast.DotNode keywordType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lex")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keyword"));
            Cm.Ast.TemplateIdNode uniquePtrKeywordMapType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"UniquePtr")));
            Cm.Ast.DotNode keywordMapType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lex")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"KeywordMap"));
            uniquePtrKeywordMapType.AddTemplateArgument(keywordMapType.Clone(cloneContext));
            UniquePtr<Cm.Ast.MemberFunctionNode> getkeywordMapMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.PointerNode(System.Lex.Span(), keywordMapType.Clone(cloneContext)), u"GetKeywordMap", null));
            UniquePtr<Cm.Ast.CompoundStatementNode> getkeywordMapMemFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetKeywordMap(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Get"))));
            UniquePtr<Cm.Ast.ReturnStatementNode> getKeywordMapStmt(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), invokeGetKeywordMap.Release()));
            getkeywordMapMemFunBody->AddStatement(getKeywordMapStmt.Release());
            getkeywordMapMemFun->SetBody(getkeywordMapMemFunBody.Release());
            keywordsClass->AddMember(getkeywordMapMemFun.Release());
            UniquePtr<Cm.Ast.ConstructorNode> ctor(new Cm.Ast.ConstructorNode(System.Lex.Span(), Specifiers.private_, null));
            ctor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"));
            UniquePtr<Cm.Ast.CompoundStatementNode> ctorBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            int index = 0;
            for (const UniquePtr<Keyword>& k : keywords)
            {
                UniquePtr<Cm.Ast.ConstructionStatementNode> constructKeyword(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), keywordType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keyword" + ToUtf32(ToString(index)))));
                constructKeyword->AddArgument(new Cm.Ast.UStringLiteralNode(System.Lex.Span(), k->kw));
                constructKeyword->AddArgument(new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), lexerContext.GetTokens()->Name()), new Cm.Ast.IdentifierNode(System.Lex.Span(), k->token)));
                ctorBody->AddStatement(constructKeyword.Release());
                UniquePtr<Cm.Ast.InvokeNode> invokeAdd(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"))));
                invokeAdd->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keyword" + ToUtf32(ToString(index))));
                UniquePtr<Cm.Ast.ExpressionStatementNode> addToKeywordList(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAdd.Release()));
                ctorBody->AddStatement(addToKeywordList.Release());
                ++index;
            }
            UniquePtr<Cm.Ast.ConstructionStatementNode> constructNullKeyword(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), keywordType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"nullKeyword")));
            constructNullKeyword->AddArgument(new Cm.Ast.NullLiteralNode(System.Lex.Span()));
            constructNullKeyword->AddArgument(new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1));
            ctorBody->AddStatement(constructNullKeyword.Release());
            UniquePtr<Cm.Ast.InvokeNode> invokeAdd(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Add"))));
            invokeAdd->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"nullKeyword"));
            UniquePtr<Cm.Ast.ExpressionStatementNode> addToKeywordList(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeAdd.Release()));
            ctorBody->AddStatement(addToKeywordList.Release());
            UniquePtr<Cm.Ast.InvokeNode> invokeReset(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordMap"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Reset"))));
            UniquePtr<Cm.Ast.NewNode> newKeywordMap(new Cm.Ast.NewNode(System.Lex.Span(), keywordMapType.Clone(cloneContext)));
            UniquePtr<Cm.Ast.InvokeNode> invokeCBegin(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordList"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CBegin"))));
            UniquePtr<Cm.Ast.InvokeNode> invokePtr(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), invokeCBegin.Release(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Ptr"))));
            newKeywordMap->AddArgument(invokePtr.Release());
            invokeReset->AddArgument(newKeywordMap.Release());
            UniquePtr<Cm.Ast.ExpressionStatementNode> resetKeywordMap(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeReset.Release()));
            ctorBody->AddStatement(resetKeywordMap.Release());
            ctor->SetBody(ctorBody.Release());
            keywordsClass->AddMember(ctor.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> instanceMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_ | Specifiers.static_, instanceType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"instance"), null));
            keywordsClass->AddMember(instanceMemVar.Release());
            Cm.Ast.TemplateIdNode keywordListType(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Collections")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"List")));
            keywordListType.AddTemplateArgument(keywordType.Clone(cloneContext));
            UniquePtr<Cm.Ast.MemberVariableNode> keywordListMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_, keywordListType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordList"), null));
            keywordsClass->AddMember(keywordListMemVar.Release());
            UniquePtr<Cm.Ast.MemberVariableNode> keywordMapMemVar(new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.private_, uniquePtrKeywordMapType.Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"keywordMap"), null));
            keywordsClass->AddMember(keywordMapMemVar.Release());
            ns->AddMember(keywordsClass.Release());
            UniquePtr<Cm.Ast.FunctionNode> getKeywordMapFun(new Cm.Ast.FunctionNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.PointerNode(System.Lex.Span(), keywordMapType.Clone(cloneContext)), u"GetKeywordMap", null));
            UniquePtr<Cm.Ast.CompoundStatementNode> getKeywordMapFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetKeywordMapMemFun(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Keywords"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Instance"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetKeywordMap"))));
            UniquePtr<Cm.Ast.ReturnStatementNode> returnKeywordMap(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), invokeGetKeywordMapMemFun.Release()));
            getKeywordMapFunBody->AddStatement(returnKeywordMap.Release());
            getKeywordMapFun->SetBody(getKeywordMapFunBody.Release());
            ns->AddMember(getKeywordMapFun.Release());
            compileUnit.GlobalNs()->AddMember(ns.Release());
            System.IO.StreamWriter keywordFile(System.IO.File.CreateText(keywordFilePath));
            CodeFormatter formatter(keywordFile);
            Cm.Ast.SourceWriter writer(formatter);
            compileUnit.Accept(writer);
            if (verbose)
            {
                Console.Out() << "==> " << keywordFilePath << endl();
            }
        }
        private List<UniquePtr<Keyword>> keywords;
    }
    public class Expression
    {
        public Expression(int index_, const ustring& id_, const ustring& value_, int line_) :
            index(index_), id(id_), value(value_), line(line_)
        {
        }
        public int Index() const
        {
            return index;
        }
        public const ustring& Id() const
        {
            return id;
        }
        public const ustring& Value() const
        {
            return value;
        }
        public int Line() const
        {
            return line;
        }
        private int index;
        private ustring id;
        private ustring value;
        private int line;
    }
    public class Expressions : Declaration
    {
        public Expressions() :
            base(u"expressions")
        {
        }
        public void Add(Expression* expression)
        {
            expressions.Add(UniquePtr<Expression>(expression));
            exprMap[expression->Id()] = expression->Index();
        }
        public Expression* Get(const ustring& id) const
        {
            Map<ustring, int>.ConstIterator it = exprMap.CFind(id);
            if (it != exprMap.CEnd())
            {
                int index = it->second;
                return expressions[index].Get();
            }
            else
            {
                throw Exception("expression \'" + ToUtf8(id) + "\' not found");
            }
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            lexerContext.SetExpressions(this);
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
        }
        private List<UniquePtr<Expression>> expressions;
        private Map<ustring, int> exprMap;
    }
    public class Variable
    {
        public Variable(Cm.Ast.Node* type_, const ustring& name_) :
            type(type_), name(name_)
        {
        }
        public Cm.Ast.Node* GetType() const
        {
            return type.Get();
        }
        public const ustring& Name() const
        {
            return name;
        }
        private UniquePtr<Cm.Ast.Node> type;
        private ustring name;
    }
    public class LexerStatement
    {
        public LexerStatement(const ustring& expr_, Cm.Ast.CompoundStatementNode* stmt_, int action_, int line_) :
            index(-1), expr(expr_), stmt(stmt_), retract(true), action(action_), line(line_)
        {
        }
        public void SetIndex(int index_)
        {
            index = index_;
        }
        public int Index() const
        {
            return index;
        }
        public const Nfa& GetNfa() const
        {
            return nfa;
        }
        public Cm.Ast.CompoundStatementNode* Code() const
        {
            return stmt.Get();
        }
        public bool Retract() const
        {
            return retract;
        }
        public int Action() const
        {
            return action;
        }
        public int Line() const
        {
            return line;
        }
        public void Process(LexerContext& lexerContext)
        {
            nfa = lexerContext.GetParser()->Parse(expr, &lexerContext, line);
            nfa.End()->SetStatementIndex(index);
        }
        private int index;
        private ustring expr;
        private Nfa nfa;
        private UniquePtr<Cm.Ast.CompoundStatementNode> stmt;
        private bool retract;
        private int action;
        private int line;
    }
    public class Action
    {
        public Action(int id_, Cm.Ast.CompoundStatementNode* stmt_) :
            id(id_), stmt(stmt_)
        {
        }
        public int Id() const
        {
            return id;
        }
        public Cm.Ast.CompoundStatementNode* Code() const
        {
            return stmt.Get();
        }
        private int id;
        private UniquePtr<Cm.Ast.CompoundStatementNode> stmt;
    }
    public class Actions : Declaration
    {
        public Actions() :
            base(u"actions")
        {
        }
        public void Add(Action* action)
        {
            actions.Add(UniquePtr<Action>(action));
            actionMap[action->Id()] = action;
        }
        public Action* Get(int id) const
        {
            Map<int, Action*>.ConstIterator it = actionMap.CFind(id);
            if (it != actionMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        public override void FillContext(LexerContext& lexerContext)
        {
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
        }
        private List<UniquePtr<Action>> actions;
        private Map<int, Action*> actionMap;
    }
    public class Lexer : Declaration
    {
        public Lexer(const ustring& api_, const ustring& name_) :
            base(name_), api(api_)
        {
        }
        public void AddStatement(LexerStatement* stmt)
        {
            stmt->SetIndex(cast<int>(statements.Count()));
            statements.Add(UniquePtr<LexerStatement>(stmt));
        }
        public void AddVariable(Variable* variable)
        {
            variables.Add(UniquePtr<Variable>(variable));
        }
        public void AddAction(Action* action)
        {
            actions.Add(action);
        }
        public void MakeMasterNfa(LexerContext& lexerContext)
        {
            NfaState* start = lexerContext.MakeNfaState();
            masterNfa.SetStart(start);
            for (const UniquePtr<LexerStatement>& statement : statements)
            {
                start->AddEdge(NfaEdge(lexerContext.MakeEpsilon(), statement->GetNfa().Start()));
            }
        }
        public void MakeDfa(LexerContext& lexerContext)
        {
            dfa = Compile(lexerContext, masterNfa);
        }
        public void WriteAutomaton(const string& root, bool verbose, LexerContext& lexerContext)
        {
            Cm.Ast.CloneContext cloneContext;
            string lexerFileName = ToUtf8(Name()) + ".cm";
            string lexerFilePath = GetFullPath(Path.Combine(root, lexerFileName));
            Cm.Ast.CompileUnitNode compileUnit(System.Lex.Span(), lexerFilePath);
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.NamespaceImportNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System")));
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.NamespaceImportNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System.Lex")));
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.NamespaceImportNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), lexerContext.GetTokens()->Name())));
            for (Cm.Ast.Node* usingNode : lexerContext.GetUsingNodes())
            {
                compileUnit.GlobalNs()->AddMember(usingNode->Clone(cloneContext));
            }
            compileUnit.GlobalNs()->AddMember(new Cm.Ast.CommentNode(System.Lex.Span(), u"this file has been automatically generated from \'" + ToUtf32(lexerContext.FileName()) + u"\' using soulcm lexer generator scmlg version " + ToUtf32(LexerGeneratorVersionStr())));
            UniquePtr<Cm.Ast.ClassNode> classNode(new Cm.Ast.ClassNode(System.Lex.Span(), Specifiers.public_, new Cm.Ast.IdentifierNode(System.Lex.Span(), Name()), null));
            classNode->AddBaseClassOrInterface(new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lex")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lexer")));
            UniquePtr<Cm.Ast.ConstructorNode> contentCtor(new Cm.Ast.ConstructorNode(System.Lex.Span(), Specifiers.public_, null));
            contentCtor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), Name()));
            contentCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"ustring"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"content_")));
            contentCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"string"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileName_")));
            contentCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileIndex_")));
            Cm.Ast.BaseInitializerNode* baseInitializer = new Cm.Ast.BaseInitializerNode(System.Lex.Span());
            baseInitializer->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"content_"));
            baseInitializer->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileName_"));
            baseInitializer->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileIndex_"));
            contentCtor->AddInitializer(baseInitializer);
            for (const UniquePtr<Variable>& variable : variables)
            {
                Cm.Ast.MemberInitializerNode* memInit = new Cm.Ast.MemberInitializerNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), variable->Name()));
                contentCtor->AddInitializer(memInit);
            }
            UniquePtr<Cm.Ast.CompoundStatementNode> contentCtorBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            if ((lexerContext.GetKeywords() != null))
            {
                UniquePtr<Cm.Ast.InvokeNode> invokeSetKeywordMap(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"SetKeywordMap")));
                invokeSetKeywordMap->AddArgument(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), lexerContext.GetKeywords()->Name()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetKeywordMap"))));
                UniquePtr<Cm.Ast.ExpressionStatementNode> setKeywordMapStmt(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeSetKeywordMap.Release()));
                contentCtorBody->AddStatement(setKeywordMapStmt.Release());
            }
            contentCtor->SetBody(contentCtorBody.Release());
            classNode->AddMember(contentCtor.Release());
            UniquePtr<Cm.Ast.ConstructorNode> startCtor(new Cm.Ast.ConstructorNode(System.Lex.Span(), Specifiers.public_, null));
            startCtor->SetClassId(new Cm.Ast.IdentifierNode(System.Lex.Span(), Name()));
            startCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.PointerNode(System.Lex.Span(), new Cm.Ast.UCharNode(System.Lex.Span()))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"start_")));
            startCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.PointerNode(System.Lex.Span(), new Cm.Ast.UCharNode(System.Lex.Span()))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"end_")));
            startCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.ConstNode(System.Lex.Span(), new Cm.Ast.LValueRefNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"string"))), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileName_")));
            startCtor->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileIndex_")));
            Cm.Ast.BaseInitializerNode* baseInit = new Cm.Ast.BaseInitializerNode(System.Lex.Span());
            baseInit->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"start_"));
            baseInit->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"end_"));
            baseInit->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileName_"));
            baseInit->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"fileIndex_"));
            startCtor->AddInitializer(baseInit);
            for (const UniquePtr<Variable>& variable : variables)
            {
                Cm.Ast.MemberInitializerNode* memInit = new Cm.Ast.MemberInitializerNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), variable->Name()));
                startCtor->AddInitializer(memInit);
            }
            UniquePtr<Cm.Ast.CompoundStatementNode> startCtorBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            if ((lexerContext.GetKeywords() != null))
            {
                UniquePtr<Cm.Ast.InvokeNode> invokeSetKeywordMap2(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"SetKeywordMap")));
                invokeSetKeywordMap2->AddArgument(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), lexerContext.GetKeywords()->Name()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetKeywordMap"))));
                UniquePtr<Cm.Ast.ExpressionStatementNode> setKeywordMapStmt2(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeSetKeywordMap2.Release()));
                startCtorBody->AddStatement(setKeywordMapStmt2.Release());
            }
            startCtor->SetBody(startCtorBody.Release());
            classNode->AddMember(startCtor.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> nextStateMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.public_ | Specifiers.override_, new Cm.Ast.IntNode(System.Lex.Span()), u"NextState", null));
            nextStateMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"state")));
            nextStateMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.UCharNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"c")));
            UniquePtr<Cm.Ast.CompoundStatementNode> nextStateMemFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            string classMapName = "ClassMap";
            if ((lexerContext.GetClassMap() != null))
            {
                classMapName = ToUtf8(lexerContext.GetClassMap()->Name());
            }
            UniquePtr<Cm.Ast.ConstructionStatementNode> constructI(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"i")));
            UniquePtr<Cm.Ast.InvokeNode> invokeGetClass(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), ToUtf32(classMapName)), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetClass"))));
            invokeGetClass->AddArgument(new Cm.Ast.IdentifierNode(System.Lex.Span(), u"c"));
            constructI->SetAssignment();
            constructI->AddArgument(invokeGetClass.Release());
            nextStateMemFunBody->AddStatement(constructI.Release());
            UniquePtr<Cm.Ast.SwitchStatementNode> switchStmt(new Cm.Ast.SwitchStatementNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"state")));
            for (DfaState* state : dfa.States())
            {
                UniquePtr<Cm.Ast.CaseStatementNode> caseStmt(new Cm.Ast.CaseStatementNode(System.Lex.Span()));
                caseStmt->AddCaseExpr(new Cm.Ast.IntLiteralNode(System.Lex.Span(), state->Id()));
                UniquePtr<Cm.Ast.CompoundStatementNode> caseBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                if (state->Accept())
                {
                    UniquePtr<Cm.Ast.ConstructionStatementNode> constructPrevMatch(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"System"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lex")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Lexeme")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"prevMatch")));
                    constructPrevMatch->SetAssignment();
                    constructPrevMatch->AddArgument(new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"token"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"match")));
                    UniquePtr<Cm.Ast.AssignmentStatementNode> assignmentStmt(new Cm.Ast.AssignmentStatementNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"token"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"match")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"lexeme")));
                    caseBody->AddStatement(constructPrevMatch.Release());
                    caseBody->AddStatement(assignmentStmt.Release());
                    UniquePtr<Cm.Ast.ConstructionStatementNode> constructTokenId(new Cm.Ast.ConstructionStatementNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
                    constructTokenId->SetAssignment();
                    UniquePtr<Cm.Ast.InvokeNode> invokeGetTokenId(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"GetTokenId")));
                    invokeGetTokenId->AddArgument(new Cm.Ast.IntLiteralNode(System.Lex.Span(), state->StatementIndex()));
                    constructTokenId->AddArgument(invokeGetTokenId.Release());
                    caseBody->AddStatement(constructTokenId.Release());
                    UniquePtr<Cm.Ast.CompoundStatementNode> thenS(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                    UniquePtr<Cm.Ast.AssignmentStatementNode> assignTokenIdStmt(new Cm.Ast.AssignmentStatementNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"token"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"id")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CONTINUE_TOKEN")));
                    thenS->AddStatement(assignTokenIdStmt.Release());
                    thenS->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
                    UniquePtr<Cm.Ast.CompoundStatementNode> elseS(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                    UniquePtr<Cm.Ast.CompoundStatementNode> thenS2(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                    UniquePtr<Cm.Ast.AssignmentStatementNode> assignStmt2(new Cm.Ast.AssignmentStatementNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"token"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"id")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId")));
                    thenS2->AddStatement(assignStmt2.Release());
                    UniquePtr<Cm.Ast.CompoundStatementNode> elseS2(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                    elseS2->AddStatement(new Cm.Ast.AssignmentStatementNode(System.Lex.Span(), new Cm.Ast.DotNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"token"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"match")), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"prevMatch")));
                    UniquePtr<Cm.Ast.IfStatementNode> ifStmt2(new Cm.Ast.IfStatementNode(System.Lex.Span(), new Cm.Ast.NotEqualNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"INVALID_TOKEN")), thenS2.Release(), elseS2.Release()));
                    elseS->AddStatement(ifStmt2.Release());
                    UniquePtr<Cm.Ast.IfStatementNode> ifStmt(new Cm.Ast.IfStatementNode(System.Lex.Span(), new Cm.Ast.EqualNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"tokenId"), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CONTINUE_TOKEN")), thenS.Release(), elseS.Release()));
                    caseBody->AddStatement(ifStmt.Release());
                }
                Map<int, Set<int>> m;
                for (Class* cls : lexerContext.Partition())
                {
                    DfaState* next = state->Next(cls->Index());
                    if (next != null)
                    {
                        m[next->Id()].Insert(cls->Index());
                    }
                }
                if (m.IsEmpty())
                {
                    caseBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
                }
                else
                {
                    UniquePtr<Cm.Ast.SwitchStatementNode> switchStmt(new Cm.Ast.SwitchStatementNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"i")));
                    for (const Pair<int, Set<int>>& p : m)
                    {
                        int n = p.first;
                        const Set<int>& s = p.second;
                        UniquePtr<Cm.Ast.CaseStatementNode> caseS(new Cm.Ast.CaseStatementNode(System.Lex.Span()));
                        for (int k : s)
                        {
                            caseS->AddCaseExpr(new Cm.Ast.IntLiteralNode(System.Lex.Span(), k));
                        }
                        UniquePtr<Cm.Ast.CompoundStatementNode> caseBlock(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                        caseBlock->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), n)));
                        caseS->AddStatement(caseBlock.Release());
                        switchStmt->AddCase(caseS.Release());
                        UniquePtr<Cm.Ast.DefaultStatementNode> defaultS(new Cm.Ast.DefaultStatementNode(System.Lex.Span()));
                        UniquePtr<Cm.Ast.CompoundStatementNode> defaultBlock(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                        defaultBlock->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
                        defaultS->AddStatement(defaultBlock.Release());
                        switchStmt->SetDefault(defaultS.Release());
                    }
                    caseBody->AddStatement(switchStmt.Release());
                    caseBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
                }
                caseStmt->AddStatement(caseBody.Release());
                switchStmt->AddCase(caseStmt.Release());
            }
            nextStateMemFunBody->AddStatement(switchStmt.Release());
            nextStateMemFunBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IntLiteralNode(System.Lex.Span(), -1)));
            nextStateMemFun->SetBody(nextStateMemFunBody.Release());
            classNode->AddMember(nextStateMemFun.Release());
            UniquePtr<Cm.Ast.MemberFunctionNode> getTokenIdMemFun(new Cm.Ast.MemberFunctionNode(System.Lex.Span(), Specifiers.private_, new Cm.Ast.IntNode(System.Lex.Span()), u"GetTokenId", null));
            getTokenIdMemFun->AddParameter(new Cm.Ast.ParameterNode(System.Lex.Span(), new Cm.Ast.IntNode(System.Lex.Span()), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"statementIndex")));
            UniquePtr<Cm.Ast.CompoundStatementNode> getTokenIdMemFunBody(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
            UniquePtr<Cm.Ast.SwitchStatementNode> switchStmt2(new Cm.Ast.SwitchStatementNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"statementIndex")));
            for (const UniquePtr<LexerStatement>& statement : statements)
            {
                UniquePtr<Cm.Ast.CaseStatementNode> caseS(new Cm.Ast.CaseStatementNode(System.Lex.Span()));
                caseS->AddCaseExpr(new Cm.Ast.IntLiteralNode(System.Lex.Span(), statement->Index()));
                UniquePtr<Cm.Ast.CompoundStatementNode> caseBlock(new Cm.Ast.CompoundStatementNode(System.Lex.Span()));
                if (statement->Retract())
                {
                    UniquePtr<Cm.Ast.InvokeNode> invokeRetract(new Cm.Ast.InvokeNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"Retract")));
                    UniquePtr<Cm.Ast.ExpressionStatementNode> retractStmt(new Cm.Ast.ExpressionStatementNode(System.Lex.Span(), invokeRetract.Release()));
                    caseBlock->AddStatement(retractStmt.Release());
                }
                if (statement->Action() != -1)
                {
                    Action* action = actions.Get(statement->Action());
                    if (action != null)
                    {
                        int n = action->Code()->Statements().Count();
                        for (int i = 0; i < n; ++i)
                        {
                            Cm.Ast.StatementNode* stmt = action->Code()->Statements()[i];
                            caseBlock->AddStatement(cast<Cm.Ast.StatementNode*>(stmt->Clone(cloneContext)));
                        }
                    }
                    else
                    {
                        throw Exception("action " + ToString(statement->Action()) + " not found");
                    }
                }
                int n = statement->Code()->Statements().Count();
                for (int i = 0; i < n; ++i)
                {
                    caseBlock->AddStatement(cast<Cm.Ast.StatementNode*>(statement->Code()->Statements()[i]->Clone(cloneContext)));
                }
                caseBlock->AddStatement(new Cm.Ast.BreakStatementNode(System.Lex.Span()));
                caseS->AddStatement(caseBlock.Release());
                switchStmt2->AddCase(caseS.Release());
            }
            getTokenIdMemFunBody->AddStatement(switchStmt2.Release());
            getTokenIdMemFunBody->AddStatement(new Cm.Ast.ReturnStatementNode(System.Lex.Span(), new Cm.Ast.IdentifierNode(System.Lex.Span(), u"CONTINUE_TOKEN")));
            getTokenIdMemFun->SetBody(getTokenIdMemFunBody.Release());
            classNode->AddMember(getTokenIdMemFun.Release());
            for (const UniquePtr<Variable>& variable : variables)
            {
                Cm.Ast.MemberVariableNode* var = new Cm.Ast.MemberVariableNode(System.Lex.Span(), Specifiers.public_, variable->GetType()->Clone(cloneContext), new Cm.Ast.IdentifierNode(System.Lex.Span(), variable->Name()), null);
                classNode->AddMember(var);
            }
            compileUnit.GlobalNs()->AddMember(classNode.Release());
            System.IO.StreamWriter lexerFile(System.IO.File.CreateText(lexerFilePath));
            CodeFormatter formatter(lexerFile);
            Cm.Ast.SourceWriter writer(formatter);
            compileUnit.Accept(writer);
            if (verbose)
            {
                Console.Out() << "==> " << lexerFilePath << endl();
            }
        }
        public override void FillContext(LexerContext& lexerContext)
        {
            lexerContext.SetApi(api);
            lexerContext.SetLexer(this);
        }
        public override void Process(const string& root, bool verbose, LexerContext& lexerContext)
        {
            for (const UniquePtr<LexerStatement>& statement : statements)
            {
                statement->Process(lexerContext);
            }
        }
        private ustring api;
        private List<UniquePtr<LexerStatement>> statements;
        private List<UniquePtr<Variable>> variables;
        private Actions actions;
        private Nfa masterNfa;
        private Dfa dfa;
    }
    public class LexerFile
    {
        public void Add(Declaration* declaration)
        {
            declarations.Add(UniquePtr<Declaration>(declaration));
            declarationMap[declaration->Name()] = declaration;
        }
        public void Process(const string& root, bool verbose, bool debug, LexerContext& lexerContext)
        {
            for (UniquePtr<Declaration>& d : declarations)
            {
                d->FillContext(lexerContext);
            }
            if (!(lexerContext.GetTokens() != null))
            {
                throw Exception("error: no tokens defined");
            }
            if (!(lexerContext.GetLexer() != null))
            {
                throw Exception("error: no lexer defined");
            }
            for (UniquePtr<Declaration>& d : declarations)
            {
                d->Process(root, verbose, lexerContext);
            }
            lexerContext.MakeCanonicalClasses();
            lexerContext.MakeClassPartition(debug);
            lexerContext.MakeClassMap(root, verbose);
            lexerContext.GetLexer()->MakeMasterNfa(lexerContext);
            lexerContext.GetLexer()->MakeDfa(lexerContext);
            lexerContext.GetLexer()->WriteAutomaton(root, verbose, lexerContext);
        }
        private List<UniquePtr<Declaration>> declarations;
        private Map<ustring, Declaration*> declarationMap;
    }
    public const char* LexerGeneratorVersionStr()
    {
        return "3.0.0";
    }
} // namespace soulcm.scmlg

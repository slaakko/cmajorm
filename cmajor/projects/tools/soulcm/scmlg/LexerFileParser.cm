using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using System.Cmajor.Ast;
using LexerFileTokens;

public static class LexerFileParser
{
    public static UniquePtr<soulcm.scmlg.LexerFile> Parse(LexerFileLexer& lexer, ParsingContext* parsingContext)
    {
        UniquePtr<soulcm.scmlg.LexerFile> value;
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->WriteBeginRule(u"parse");
                lexer.Log()->IncIndent();
            }
        #endif
        ++lexer;
        Match match = LexerFile(lexer, parsingContext);
        value.Reset(cast<soulcm.scmlg.LexerFile*>(match.value));
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->DecIndent();
                lexer.Log()->WriteEndRule(u"parse");
            }
        #endif
        if (match.hit)
        {
            if (*lexer == System.Lex.END_TOKEN)
            {
                return value;
            }
            else
            {
                lexer.ThrowExpectationFailure(lexer.GetPos(), GetEndTokenInfo());
            }
        }
        else
        {
            lexer.ThrowExpectationFailure(lexer.GetPos(), u"lexer file");
        }
        return value;
    }
    public static Match LexerFile(LexerFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LexerFile");
            }
        #endif
        UniquePtr<soulcm.scmlg.LexerFile> lexerFile;
        UniquePtr<soulcm.scmlg.Declaration> declaration;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                if (match.hit)
                {
                    lexerFile.Reset(new soulcm.scmlg.LexerFile());
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexerFileParser.Declaration(lexer, parsingContext);
                                            declaration.Reset(cast<soulcm.scmlg.Declaration*>(match.value));
                                            if (match.hit)
                                            {
                                                lexerFile->Add(declaration.Release());
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LexerFile");
                            #endif
                            return Match(true, lexerFile.Release());
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LexerFile");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LexerFile");
                }
            }
        #endif
        return match;
    }
    public static Match Declaration(LexerFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Declaration");
            }
        #endif
        UniquePtr<soulcm.scmlg.ClassMap> classMapDeclaration;
        UniquePtr<soulcm.scmlg.Usings> usingDeclarations;
        UniquePtr<soulcm.scmlg.Tokens> tokensDeclaration;
        UniquePtr<soulcm.scmlg.Keywords> keywordsDeclaration;
        UniquePtr<soulcm.scmlg.Expressions> expressionsDeclaration;
        UniquePtr<soulcm.scmlg.Lexer> lexerDeclaration;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = LexerFileParser.ClassMap(lexer);
                                classMapDeclaration.Reset(cast<soulcm.scmlg.ClassMap*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                        #endif
                                        return Match(true, classMapDeclaration.Release());
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexerFileParser.Usings(lexer);
                                        usingDeclarations.Reset(cast<soulcm.scmlg.Usings*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                                #endif
                                                return Match(true, usingDeclarations.Release());
                                            }
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexerFileParser.Tokens(lexer);
                                    tokensDeclaration.Reset(cast<soulcm.scmlg.Tokens*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                            #endif
                                            return Match(true, tokensDeclaration.Release());
                                        }
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = LexerFileParser.Keywords(lexer);
                                keywordsDeclaration.Reset(cast<soulcm.scmlg.Keywords*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                        #endif
                                        return Match(true, keywordsDeclaration.Release());
                                    }
                                }
                                *parentMatch11 = match;
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch13 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexerFileParser.Expressions(lexer);
                            expressionsDeclaration.Reset(cast<soulcm.scmlg.Expressions*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                    #endif
                                    return Match(true, expressionsDeclaration.Release());
                                }
                            }
                            *parentMatch13 = match;
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch14 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = LexerFileParser.Lexer(lexer, parsingContext);
                        lexerDeclaration.Reset(cast<soulcm.scmlg.Lexer*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                                #endif
                                return Match(true, lexerDeclaration.Release());
                            }
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch14 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Declaration");
                }
            }
        #endif
        return match;
    }
    public static Match ClassMap(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ClassMap");
            }
        #endif
        ustring classMapName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == CLASSMAP)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                            }
                        }
                        if (match.hit)
                        {
                            classMapName = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ClassMap");
                            #endif
                            return Match(true, new soulcm.scmlg.ClassMap(classMapName));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ClassMap");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ClassMap");
                }
            }
        #endif
        return match;
    }
    public static Match Usings(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Usings");
            }
        #endif
        UniquePtr<soulcm.scmlg.Usings> usings;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                if (match.hit)
                {
                    usings.Reset(new soulcm.scmlg.Usings());
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = LexerFileParser.UsingDirectives(lexer, usings.Get());
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Usings");
                            #endif
                            return Match(true, usings.Release());
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Usings");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Usings");
                }
            }
        #endif
        return match;
    }
    public static Match UsingDirectives(LexerFileLexer& lexer, soulcm.scmlg.Usings* usings)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingDirectives");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = LexerFileParser.UsingDirective(lexer, usings);
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(true);
            Match* parentMatch1 = &match;
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match = LexerFileParser.UsingDirective(lexer, usings);
                    if (match.hit)
                    {
                        *parentMatch1 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingDirectives");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingDirectives");
                }
            }
        #endif
        return match;
    }
    public static Match UsingDirective(LexerFileLexer& lexer, soulcm.scmlg.Usings* usings)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingDirective");
            }
        #endif
        UniquePtr<Node> usingAlias;
        UniquePtr<Node> usingNs;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = LexerFileParser.UsingAliasDirective(lexer);
                usingAlias.Reset(cast<Node*>(match.value));
                if (match.hit)
                {
                    usings->AddMember(usingAlias.Release());
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = LexerFileParser.UsingNamespaceDirective(lexer);
                        usingNs.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            usings->AddMember(usingNs.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingDirective");
                }
            }
        #endif
        return match;
    }
    public static Match UsingAliasDirective(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingAliasDirective");
            }
        #endif
        Span s;
        UniquePtr<IdentifierNode> id;
        UniquePtr<IdentifierNode> qid;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == USING)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match = IdentifierParser.Identifier(lexer);
                            id.Reset(cast<IdentifierNode*>(match.value));
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        if (*lexer == ASSIGN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    Match match(true);
                    Match* parentMatch8 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IdentifierParser.QualifiedId(lexer);
                        qid.Reset(cast<IdentifierNode*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch8 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, u"identifier");
                        }
                    }
                    *parentMatch7 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch11 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingAliasDirective");
                            #endif
                            return Match(true, new AliasNode(s, id.Release(), qid.Release()));
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingAliasDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingAliasDirective");
                }
            }
        #endif
        return match;
    }
    public static Match UsingNamespaceDirective(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingNamespaceDirective");
            }
        #endif
        Span s;
        UniquePtr<IdentifierNode> ns;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == USING)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = IdentifierParser.QualifiedId(lexer);
                        ns.Reset(cast<IdentifierNode*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, u"identifier");
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingNamespaceDirective");
                            #endif
                            return Match(true, new NamespaceImportNode(s, ns.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingNamespaceDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingNamespaceDirective");
                }
            }
        #endif
        return match;
    }
    public static Match Tokens(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Tokens");
            }
        #endif
        ustring tokensDeclarationName;
        UniquePtr<soulcm.scmlg.Tokens> tokens;
        UniquePtr<Value<soulcm.scmlg.Token>> token;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == TOKENS)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                                    }
                                }
                                if (match.hit)
                                {
                                    tokensDeclarationName = lexer.GetMatch(span);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(true);
                            Match* parentMatch9 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                                }
                            }
                            if (match.hit)
                            {
                                tokens.Reset(new soulcm.scmlg.Tokens(tokensDeclarationName));
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch11 = &match;
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            Match match(false);
                            Match* parentMatch13 = &match;
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexerFileParser.Token(lexer);
                                    token.Reset(cast<Value<soulcm.scmlg.Token>*>(match.value));
                                    if (match.hit)
                                    {
                                        tokens->Add(token->value);
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch13 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch15 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch16 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch17 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch18 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch19 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexerFileParser.Token(lexer);
                                                            token.Reset(cast<Value<soulcm.scmlg.Token>*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                tokens->Add(token->value);
                                                            }
                                                            *parentMatch19 = match;
                                                        }
                                                        *parentMatch18 = match;
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch16 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch15 = match;
                                }
                                *parentMatch13 = match;
                            }
                            *parentMatch12 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch20 = &match;
            {
                Match match(false);
                Match* parentMatch21 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch22 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch22 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Tokens");
                            #endif
                            return Match(true, tokens.Release());
                        }
                    }
                    *parentMatch21 = match;
                }
                *parentMatch20 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Tokens");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Tokens");
                }
            }
        #endif
        return match;
    }
    public static Match Token(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Token");
            }
        #endif
        ustring tokenName;
        ustring tokenInfo;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == LPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                                    }
                                }
                                if (match.hit)
                                {
                                    tokenName = lexer.GetMatch(span);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        Match* parentMatch8 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == COMMA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch8 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(COMMA));
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch11 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == STRINGLIT)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(STRINGLIT));
                            }
                        }
                        if (match.hit)
                        {
                            tokenInfo = soulcm.scmlg.MakeStrValue(lexer.FileName(), lexer.GetToken(pos));
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch9 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(false);
                Match* parentMatch13 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch14 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch14 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RPAREN));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Token");
                            #endif
                            return Match(true, new Value<soulcm.scmlg.Token>(soulcm.scmlg.Token(tokenName, ToUtf8(tokenInfo))));
                        }
                    }
                    *parentMatch13 = match;
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Token");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Token");
                }
            }
        #endif
        return match;
    }
    public static Match Keywords(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Keywords");
            }
        #endif
        ustring keywordsDeclarationName;
        UniquePtr<soulcm.scmlg.Keywords> keywords;
        UniquePtr<soulcm.scmlg.Keyword> keyword;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == KEYWORDS)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                                    }
                                }
                                if (match.hit)
                                {
                                    keywordsDeclarationName = lexer.GetMatch(span);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(true);
                            Match* parentMatch9 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                                }
                            }
                            if (match.hit)
                            {
                                keywords.Reset(new soulcm.scmlg.Keywords(keywordsDeclarationName));
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch11 = &match;
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            Match match(false);
                            Match* parentMatch13 = &match;
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexerFileParser.Keyword(lexer);
                                    keyword.Reset(cast<soulcm.scmlg.Keyword*>(match.value));
                                    if (match.hit)
                                    {
                                        keywords->Add(keyword.Release());
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch13 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch15 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch16 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch17 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch18 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch19 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexerFileParser.Keyword(lexer);
                                                            keyword.Reset(cast<soulcm.scmlg.Keyword*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                keywords->Add(keyword.Release());
                                                            }
                                                            *parentMatch19 = match;
                                                        }
                                                        *parentMatch18 = match;
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch16 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch15 = match;
                                }
                                *parentMatch13 = match;
                            }
                            *parentMatch12 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch20 = &match;
            {
                Match match(false);
                Match* parentMatch21 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch22 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch22 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Keywords");
                            #endif
                            return Match(true, keywords.Release());
                        }
                    }
                    *parentMatch21 = match;
                }
                *parentMatch20 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Keywords");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Keywords");
                }
            }
        #endif
        return match;
    }
    public static Match Keyword(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Keyword");
            }
        #endif
        ustring kw;
        ustring tokenName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == LPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == STRINGLIT)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, GetTokenName(STRINGLIT));
                                    }
                                }
                                if (match.hit)
                                {
                                    kw = soulcm.scmlg.MakeStrValue(lexer.FileName(), lexer.GetToken(pos));
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        Match* parentMatch8 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == COMMA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch8 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(COMMA));
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        Match* parentMatch11 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                            }
                        }
                        if (match.hit)
                        {
                            tokenName = lexer.GetMatch(span);
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch9 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(false);
                Match* parentMatch13 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch14 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch14 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RPAREN));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Keyword");
                            #endif
                            return Match(true, new soulcm.scmlg.Keyword(kw, tokenName));
                        }
                    }
                    *parentMatch13 = match;
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Keyword");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Keyword");
                }
            }
        #endif
        return match;
    }
    public static Match Expressions(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Expressions");
            }
        #endif
        int index;
        UniquePtr<soulcm.scmlg.Expressions> expressions;
        UniquePtr<soulcm.scmlg.Expression> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == EXPRESSIONS)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            index = 0;
                            expressions.Reset(new soulcm.scmlg.Expressions());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch9 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexerFileParser.Expression(lexer, index);
                                        expr.Reset(cast<soulcm.scmlg.Expression*>(match.value));
                                        if (match.hit)
                                        {
                                            expressions->Add(expr.Release());
                                            index = index + 1;
                                        }
                                        *parentMatch9 = match;
                                    }
                                    *parentMatch8 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch7 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch10 = &match;
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch12 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch12 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Expressions");
                            #endif
                            return Match(true, expressions.Release());
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch10 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Expressions");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Expressions");
                }
            }
        #endif
        return match;
    }
    public static Match Expression(LexerFileLexer& lexer, int index)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Expression");
            }
        #endif
        ustring exprName;
        int line;
        UniquePtr<Value<ustring>> exprValue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            exprName = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        if (*lexer == ASSIGN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch7 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexerFileParser.ExprString(lexer);
                            exprValue.Reset(cast<Value<ustring>*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch7 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, u"regular expression string");
                            }
                        }
                        if (match.hit)
                        {
                            line = lexer.GetToken(pos).line;
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch8 = &match;
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch10 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch10 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Expression");
                            #endif
                            return Match(true, new soulcm.scmlg.Expression(index, exprName, exprValue->value, line));
                        }
                    }
                    *parentMatch9 = match;
                }
                *parentMatch8 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Expression");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Expression");
                }
            }
        #endif
        return match;
    }
    public static Match ExprString(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ExprString");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            if (*lexer == STRINGLIT)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExprString");
                    #endif
                    return Match(true, new Value<ustring>(soulcm.scmlg.MakeExprStringValue(lexer.FileName(), lexer.GetToken(pos))));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExprString");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ExprString");
                }
            }
        #endif
        return match;
    }
    public static Match Lexer(LexerFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Lexer");
            }
        #endif
        ustring lexerDeclarationName;
        UniquePtr<soulcm.scmlg.Lexer> currentLexer;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == LEXER)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == ID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, GetTokenName(ID));
                                    }
                                }
                                if (match.hit)
                                {
                                    lexerDeclarationName = lexer.GetMatch(span);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(true);
                            Match* parentMatch9 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                                }
                            }
                            if (match.hit)
                            {
                                currentLexer.Reset(new soulcm.scmlg.Lexer(u"", lexerDeclarationName));
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    Match* parentMatch11 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match = LexerFileParser.LexerClause(lexer, currentLexer.Get(), parsingContext);
                                    *parentMatch12 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch11 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch15 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Lexer");
                            #endif
                            return Match(true, currentLexer.Release());
                        }
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Lexer");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Lexer");
                }
            }
        #endif
        return match;
    }
    public static Match LexerClause(LexerFileLexer& lexer, soulcm.scmlg.Lexer* currentLexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LexerClause");
            }
        #endif
        int line;
        UniquePtr<Value<ustring>> expr;
        UniquePtr<Value<int>> action;
        UniquePtr<CompoundStatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexerFileParser.ExprString(lexer);
                                    expr.Reset(cast<Value<ustring>*>(match.value));
                                    if (match.hit)
                                    {
                                        line = lexer.GetToken(pos).line;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match = LexerFileParser.Action(lexer);
                                    action.Reset(cast<Value<int>*>(match.value));
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = StatementParser.CompoundStatement(lexer, parsingContext);
                                    stmt.Reset(cast<CompoundStatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(pos, u"compound statement");
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        currentLexer->AddStatement(new soulcm.scmlg.LexerStatement(expr->value, stmt.Release(), action->value, line));
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = LexerFileParser.Variables(lexer, currentLexer, parsingContext);
                        *parentMatch10 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                lexer.SetPos(save);
                {
                    Match match = LexerFileParser.Actions(lexer, currentLexer, parsingContext);
                    *parentMatch11 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LexerClause");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LexerClause");
                }
            }
        #endif
        return match;
    }
    public static Match Variables(LexerFileLexer& lexer, soulcm.scmlg.Lexer* currentLexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Variables");
            }
        #endif
        UniquePtr<soulcm.scmlg.Variable> variable;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == VARIABLES)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexerFileParser.Variable(lexer, parsingContext);
                                        variable.Reset(cast<soulcm.scmlg.Variable*>(match.value));
                                        if (match.hit)
                                        {
                                            currentLexer->AddVariable(variable.Release());
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(true);
                Match* parentMatch10 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == RBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch10 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                    }
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Variables");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Variables");
                }
            }
        #endif
        return match;
    }
    public static Match Variable(LexerFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Variable");
            }
        #endif
        ustring name;
        UniquePtr<Node> type;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match = TypeExprParser.TypeExpr(lexer, parsingContext);
                type.Reset(cast<Node*>(match.value));
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            name = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == SEMICOLON)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Variable");
                            #endif
                            return Match(true, new soulcm.scmlg.Variable(type.Release(), name));
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Variable");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Variable");
                }
            }
        #endif
        return match;
    }
    public static Match Actions(LexerFileLexer& lexer, soulcm.scmlg.Lexer* currentLexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Actions");
            }
        #endif
        UniquePtr<Value<int>> action;
        UniquePtr<CompoundStatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == ACTIONS)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(pos, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        bool pass = true;
                                                        Match match = LexerFileParser.Action(lexer);
                                                        action.Reset(cast<Value<int>*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            pass = action->value != -1;
                                                        }
                                                        if (match.hit && !pass)
                                                        {
                                                            match = Match(false);
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == ASSIGN)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch13 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch14 = &match;
                                                {
                                                    Match match(true);
                                                    Match* parentMatch15 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = StatementParser.CompoundStatement(lexer, parsingContext);
                                                        stmt.Reset(cast<CompoundStatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            *parentMatch15 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(pos, u"compound statement");
                                                        }
                                                    }
                                                    *parentMatch14 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        if (match.hit)
                                        {
                                            currentLexer->AddAction(new soulcm.scmlg.Action(action->value, stmt.Release()));
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch16 = &match;
            {
                Match match(true);
                Match* parentMatch17 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == RBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch17 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(pos, GetTokenName(RBRACE));
                    }
                }
                *parentMatch16 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Actions");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Actions");
                }
            }
        #endif
        return match;
    }
    public static Match Action(LexerFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Action");
            }
        #endif
        int actionId;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == DOLLAR)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        if (*lexer == LPAREN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch7 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(pos, GetTokenName(LPAREN));
                                        }
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(true);
                                    Match* parentMatch10 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        if (*lexer == INTLIT)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch10 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(pos, GetTokenName(INTLIT));
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        actionId = soulcm.scmlg.MakeActionIntValue(lexer.FileName(), lexer.GetToken(pos));
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match(true);
                            Match* parentMatch12 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == RPAREN)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch12 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(pos, GetTokenName(RPAREN));
                                }
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Action");
                        #endif
                        return Match(true, new Value<int>(actionId));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch13 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch14 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Action");
                                #endif
                                return Match(true, new Value<int>(-1));
                            }
                        }
                        *parentMatch14 = match;
                    }
                    *parentMatch13 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Action");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Action");
                }
            }
        #endif
        return match;
    }
}

using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using System.Lex;
using Cm.Ast;
using ParserFileTokens;

// this file has been automatically generated from 'D:/work/soulng-project/tools/cpp2cm/projects/soulcm/scm2html/parser/ParserFileParser.parser' using soulcm parser generator scmpg version 3.0.0

public static class ParserFileParser
{
    public static UniquePtr<soulcm.scm2html.ParserFile> Parse(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        UniquePtr<soulcm.scm2html.ParserFile> value;
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->WriteBeginRule(u"parse");
                lexer.Log()->IncIndent();
            }
        #endif
        ++lexer;
        System.Lex.Span span = lexer.GetSpan();
        Match match = ParserFile(lexer, parsingContext);
        value.Reset(cast<soulcm.scm2html.ParserFile*>(match.value));
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->DecIndent();
                lexer.Log()->WriteEndRule(u"parse");
            }
        #endif
        if (match.hit)
        {
            if (*lexer == System.Lex.END_TOKEN)
            {
                return value;
            }
            else
            {
                lexer.ThrowExpectationFailure(lexer.GetSpan(), GetEndTokenInfo());
            }
        }
        else
        {
            lexer.ThrowExpectationFailure(span, u"ParserFile");
        }
        return value;
    }
    public static Match ParserFile(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ParserFile");
            }
        #endif
        UniquePtr<soulcm.scm2html.ParserFile> parserFile;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        if (match.hit)
                        {
                            parserFile.Reset(new soulcm.scm2html.ParserFile(lexer.FileName()));
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match = ParserFileParser.Declaration(lexer, parserFile.Get(), parsingContext);
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParserFile");
                    #endif
                    return Match(true, parserFile.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParserFile");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ParserFile");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Declaration(ParserFileLexer& lexer, soulcm.scm2html.ParserFile* parserFile, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Declaration");
            }
        #endif
        UniquePtr<Node> usingDirective;
        UniquePtr<soulcm.scm2html.GrammarParser> parserDeclaration;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = ParserFileParser.UsingDirective(lexer);
                usingDirective.Reset(cast<Node*>(match.value));
                if (match.hit)
                {
                    parserFile->AddUsingDirective(usingDirective.Release());
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.ParserDeclaration(lexer, parsingContext);
                        parserDeclaration.Reset(cast<soulcm.scm2html.GrammarParser*>(match.value));
                        if (match.hit)
                        {
                            parserFile->AddParser(parserDeclaration.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Declaration");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Declaration");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UsingDirective(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingDirective");
            }
        #endif
        UniquePtr<Node> usingAlias;
        UniquePtr<Node> usingNs;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = ParserFileParser.UsingAliasDirective(lexer);
                usingAlias.Reset(cast<Node*>(match.value));
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingDirective");
                        #endif
                        return Match(true, usingAlias.Release());
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.UsingNamespaceDirective(lexer);
                        usingNs.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingDirective");
                                #endif
                                return Match(true, usingNs.Release());
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingDirective");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UsingAliasDirective(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingAliasDirective");
            }
        #endif
        Span s;
        UniquePtr<IdentifierNode> id;
        UniquePtr<IdentifierNode> qid;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == USING)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match = ParIdentifierParser.Identifier(lexer);
                            id.Reset(cast<IdentifierNode*>(match.value));
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        if (*lexer == ASSIGN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    Match match(true);
                    Match* parentMatch8 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = ParIdentifierParser.QualifiedId(lexer);
                        qid.Reset(cast<IdentifierNode*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch8 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"identifier");
                        }
                    }
                    *parentMatch7 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch11 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingAliasDirective");
                            #endif
                            return Match(true, new AliasNode(s, id.Release(), qid.Release()));
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingAliasDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingAliasDirective");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UsingNamespaceDirective(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingNamespaceDirective");
            }
        #endif
        Span s;
        UniquePtr<IdentifierNode> ns;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == USING)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = ParIdentifierParser.QualifiedId(lexer);
                        ns.Reset(cast<IdentifierNode*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"identifier");
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingNamespaceDirective");
                            #endif
                            return Match(true, new NamespaceImportNode(s, ns.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingNamespaceDirective");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingNamespaceDirective");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ParserDeclaration(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ParserDeclaration");
            }
        #endif
        UniquePtr<soulcm.scm2html.GrammarParser> grammarParser;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == PARSER)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == ID)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            grammarParser.Reset(new soulcm.scm2html.GrammarParser(lexer.GetMatch(span), u""));
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == LBRACE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            Match match(true);
                            Match* parentMatch11 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match = ParserFileParser.Statement(lexer, grammarParser.Get(), parsingContext);
                                        if (match.hit)
                                        {
                                            *parentMatch11 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        Match match(true);
                        Match* parentMatch13 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch13 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                            }
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParserDeclaration");
                    #endif
                    return Match(true, grammarParser.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParserDeclaration");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ParserDeclaration");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Statement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Statement");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match = ParserFileParser.MainStatement(lexer, grammarParser);
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch4 = &match;
                            lexer.SetPos(save);
                            {
                                Match match = ParserFileParser.UsingStatement(lexer, grammarParser);
                                *parentMatch4 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        lexer.SetPos(save);
                        {
                            Match match = ParserFileParser.LexerStatement(lexer, grammarParser);
                            *parentMatch5 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = ParserFileParser.RuleInfoStatement(lexer, grammarParser);
                        *parentMatch6 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                lexer.SetPos(save);
                {
                    Match match = ParserFileParser.RuleStatement(lexer, grammarParser, parsingContext);
                    *parentMatch7 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Statement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MainStatement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MainStatement");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == MAIN)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch3 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch3 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        grammarParser->SetMain();
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MainStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MainStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UsingStatement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingStatement");
            }
        #endif
        UniquePtr<Value<ustring>> parserId;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == USING)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(true);
                    Match* parentMatch3 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = ParserFileParser.UsingQualifiedId(lexer);
                        parserId.Reset(cast<Value<ustring>*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch3 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"UsingQualifiedId");
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        grammarParser->AddUsing(parserId->value);
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match UsingQualifiedId(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"UsingQualifiedId");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == DOT)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == ID)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.end = span.end;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingQualifiedId");
                    #endif
                    return Match(true, new Value<ustring>(lexer.GetMatch(s)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"UsingQualifiedId");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"UsingQualifiedId");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LexerStatement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LexerStatement");
            }
        #endif
        ustring lexerName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == USELEXER)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == ID)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(ID));
                            }
                        }
                        if (match.hit)
                        {
                            lexerName = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        grammarParser->SetLexer(lexerName);
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LexerStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LexerStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RuleInfoStatement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RuleInfoStatement");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == RULEINFO)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == LBRACE)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match = ParserFileParser.RuleInfo(lexer, grammarParser);
                                *parentMatch8 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch10 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        Match match = ParserFileParser.RuleInfo(lexer, grammarParser);
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch10 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(true);
                Match* parentMatch14 = &match;
                {
                    System.Lex.Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch14 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                    }
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleInfoStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RuleInfoStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RuleInfo(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RuleInfo");
            }
        #endif
        ustring ruleName;
        ustring ruleInfo;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == LPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == ID)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(ID));
                                    }
                                }
                                if (match.hit)
                                {
                                    ruleName = lexer.GetMatch(span);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        Match* parentMatch8 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == COMMA)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch8 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(COMMA));
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        Match* parentMatch11 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == STRINGLIT)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(STRINGLIT));
                            }
                        }
                        if (match.hit)
                        {
                            ruleInfo = soulcm.scm2html.ParseStringLiteral(lexer.FileName(), lexer.GetToken(pos));
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch9 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(false);
                Match* parentMatch13 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch14 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch14 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                        }
                    }
                    if (match.hit)
                    {
                        grammarParser->AddRuleInfo(ruleName, ruleInfo);
                    }
                    *parentMatch13 = match;
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleInfo");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RuleInfo");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RuleStatement(ParserFileLexer& lexer, soulcm.scm2html.GrammarParser* grammarParser, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RuleStatement");
            }
        #endif
        UniquePtr<soulcm.scm2html.RuleParser> rule;
        UniquePtr<Node> returnType;
        UniquePtr<soulcm.scm2html.Parser> definition;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == ID)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    ustring id = lexer.GetMatch(span);
                                    rule.Reset(new soulcm.scm2html.RuleParser(id));
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch7 = &match;
                                {
                                    Match match = ParserFileParser.ParametersAndVariables(lexer, rule.Get(), parsingContext);
                                    if (match.hit)
                                    {
                                        *parentMatch7 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch9 = &match;
                            {
                                Match match = ParserFileParser.ReturnType(lexer, parsingContext);
                                returnType.Reset(cast<Node*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        Match match(false);
                        if (*lexer == PRODUCES)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    Match match(true);
                    Match* parentMatch12 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = ParserFileParser.RuleBody(lexer, parsingContext);
                        definition.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch12 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"RuleBody");
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(true);
                    Match* parentMatch15 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        rule->SetDefinition(definition.Release());
                        rule->SetReturnType(returnType.Release());
                        grammarParser->AddRule(rule.Release());
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RuleStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ParametersAndVariables(ParserFileLexer& lexer, soulcm.scm2html.RuleParser* rule, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ParametersAndVariables");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parameter> paramOrVariable;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == LPAREN)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = ParserFileParser.ParamOrVariable(lexer, parsingContext);
                                    paramOrVariable.Reset(cast<soulcm.scm2html.Parameter*>(match.value));
                                    if (match.hit)
                                    {
                                        rule->AddParamOrVariable(paramOrVariable.Release());
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch8 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == COMMA)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch10 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch11 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = ParserFileParser.ParamOrVariable(lexer, parsingContext);
                                                            paramOrVariable.Reset(cast<soulcm.scm2html.Parameter*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                rule->AddParamOrVariable(paramOrVariable.Release());
                                                            }
                                                            *parentMatch11 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch8 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch3 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(true);
                Match* parentMatch13 = &match;
                {
                    System.Lex.Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RPAREN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        *parentMatch13 = match;
                    }
                    else
                    {
                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                    }
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParametersAndVariables");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ParametersAndVariables");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ParamOrVariable(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ParamOrVariable");
            }
        #endif
        UniquePtr<Node> varType;
        UniquePtr<IdentifierNode> varName;
        UniquePtr<Node> paramType;
        UniquePtr<IdentifierNode> paramName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == VAR)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match = ParTypeExprParser.TypeExpr(lexer, parsingContext);
                        varType.Reset(cast<Node*>(match.value));
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    Match match(false);
                    Match* parentMatch5 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParIdentifierParser.Identifier(lexer);
                        varName.Reset(cast<IdentifierNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParamOrVariable");
                                #endif
                                return Match(true, new soulcm.scm2html.Variable(varType.Release(), varName.Release()));
                            }
                        }
                        *parentMatch5 = match;
                    }
                    *parentMatch4 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match = ParTypeExprParser.TypeExpr(lexer, parsingContext);
                        paramType.Reset(cast<Node*>(match.value));
                        *parentMatch7 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = ParIdentifierParser.Identifier(lexer);
                                paramName.Reset(cast<IdentifierNode*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParamOrVariable");
                                        #endif
                                        return Match(true, new soulcm.scm2html.Parameter(paramType.Release(), paramName.Release()));
                                    }
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ParamOrVariable");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ParamOrVariable");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ReturnType(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ReturnType");
            }
        #endif
        UniquePtr<Node> type;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            if (*lexer == COLON)
            {
                ++lexer;
                match.hit = true;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = ParTypeExprParser.TypeExpr(lexer, parsingContext);
                    type.Reset(cast<Node*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnType");
                            #endif
                            return Match(true, type.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ReturnType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RuleBody(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RuleBody");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> alt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match = ParserFileParser.Alternative(lexer, parsingContext);
            alt.Reset(cast<soulcm.scm2html.Parser*>(match.value));
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleBody");
                    #endif
                    return Match(true, alt.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleBody");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RuleBody");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Alternative(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Alternative");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> left;
        UniquePtr<soulcm.scm2html.Parser> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.Sequence(lexer, parsingContext);
                        left.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            value.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == BITOR)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(true);
                                                    Match* parentMatch10 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match = ParserFileParser.Sequence(lexer, parsingContext);
                                                        right.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            *parentMatch10 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(span, u"Sequence");
                                                        }
                                                    }
                                                    if (match.hit)
                                                    {
                                                        value.Reset(new soulcm.scm2html.AlternativeParser(value.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Alternative");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Alternative");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Alternative");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Sequence(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Sequence");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> left;
        UniquePtr<soulcm.scm2html.Parser> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.Difference(lexer, parsingContext);
                        left.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            value.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = ParserFileParser.Difference(lexer, parsingContext);
                                            right.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                            if (match.hit)
                                            {
                                                value.Reset(new soulcm.scm2html.SequenceParser(value.Release(), right.Release()));
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Sequence");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Sequence");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Sequence");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Difference(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Difference");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> left;
        UniquePtr<soulcm.scm2html.Parser> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.List(lexer, parsingContext);
                        left.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            value.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == MINUS)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(true);
                                                    Match* parentMatch10 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match = ParserFileParser.List(lexer, parsingContext);
                                                        right.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            *parentMatch10 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(span, u"List");
                                                        }
                                                    }
                                                    if (match.hit)
                                                    {
                                                        value.Reset(new soulcm.scm2html.DifferenceParser(value.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Difference");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Difference");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Difference");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match List(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"List");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> left;
        UniquePtr<soulcm.scm2html.Parser> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.Postfix(lexer, parsingContext);
                        left.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            value.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == REM)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            Match* parentMatch10 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = ParserFileParser.Postfix(lexer, parsingContext);
                                                right.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch10 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"Postfix");
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                value.Reset(new soulcm.scm2html.ListParser(value.Release(), right.Release()));
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"List");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"List");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"List");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Postfix(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Postfix");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> primary;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.Primary(lexer, parsingContext);
                        primary.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                        if (match.hit)
                        {
                            value.Reset(primary.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == STAR)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                value.Reset(new soulcm.scm2html.KleeneParser(value.Release()));
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == PLUS)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        value.Reset(new soulcm.scm2html.PositiveParser(value.Release()));
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                    }
                                    *parentMatch7 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch13 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == QUEST)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    value.Reset(new soulcm.scm2html.OptionalParser(value.Release()));
                                                }
                                                *parentMatch13 = match;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Postfix");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Postfix");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Postfix");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Primary(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Primary");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> value;
        UniquePtr<soulcm.scm2html.Parser> ruleCall;
        UniquePtr<soulcm.scm2html.Parser> primitive;
        UniquePtr<soulcm.scm2html.Parser> grouping;
        UniquePtr<CompoundStatementNode> successCode;
        UniquePtr<CompoundStatementNode> failureCode;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = ParserFileParser.RuleCall(lexer, parsingContext);
                                        ruleCall.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                        if (match.hit)
                                        {
                                            value.Reset(ruleCall.Release());
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = ParserFileParser.Primitive(lexer);
                                                primitive.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                                if (match.hit)
                                                {
                                                    value.Reset(primitive.Release());
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = ParserFileParser.Grouping(lexer, parsingContext);
                                            grouping.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                                            if (match.hit)
                                            {
                                                value.Reset(grouping.Release());
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch13 = &match;
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        if (*lexer == EXCLAMATION)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            value.Reset(new soulcm.scm2html.ExpectationParser(value.Release()));
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch14 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch13 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch12 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch16 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch17 = &match;
                        {
                            Match match(false);
                            Match* parentMatch18 = &match;
                            {
                                Match match(false);
                                Match* parentMatch19 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            {
                                                Match match = ParStatementParser.CompoundStatement(lexer, parsingContext);
                                                successCode.Reset(cast<CompoundStatementNode*>(match.value));
                                                *parentMatch22 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch24 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch25 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch26 = &match;
                                                            {
                                                                Match match(false);
                                                                if (*lexer == DIV)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                *parentMatch26 = match;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch27 = &match;
                                                                {
                                                                    Match match = ParStatementParser.CompoundStatement(lexer, parsingContext);
                                                                    failureCode.Reset(cast<CompoundStatementNode*>(match.value));
                                                                    *parentMatch27 = match;
                                                                }
                                                                *parentMatch26 = match;
                                                            }
                                                            *parentMatch25 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch24 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            *parentMatch21 = match;
                                        }
                                        if (match.hit)
                                        {
                                            value.Reset(new soulcm.scm2html.ActionParser(value.Release()));
                                        }
                                        *parentMatch20 = match;
                                    }
                                    *parentMatch19 = match;
                                }
                                *parentMatch18 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch17 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch16 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primary");
                    #endif
                    return Match(true, value.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primary");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Primary");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RuleCall(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RuleCall");
            }
        #endif
        ustring ruleName;
        UniquePtr<InvokeNode> invoke;
        long nonterminalPos;
        UniquePtr<Value<ustring>> nt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = ParserFileParser.Nonterminal(lexer);
                        nt.Reset(cast<Value<ustring>*>(match.value));
                        if (match.hit)
                        {
                            ruleName = nt->value;
                            nonterminalPos = pos;
                            invoke.Reset(new InvokeNode(Span()));
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            bool pass = true;
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                pass = NoWhiteSpaceBetweenTokens(lexer.GetToken(nonterminalPos), lexer.GetToken(pos));
                                            }
                                            if (match.hit && !pass)
                                            {
                                                match = Match(false);
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch10 = &match;
                                        {
                                            Match match = ParExpressionParser.ExpressionList(lexer, parsingContext, invoke.Get());
                                            *parentMatch10 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == RPAREN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch12 = &match;
                {
                    Match match(false);
                    if (*lexer == COLON)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch12 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch15 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(ID));
                        }
                    }
                    if (match.hit)
                    {
                        ustring name = lexer.GetMatch(span);
                        soulcm.scm2html.NonterminalParser* nonterminalParser = new soulcm.scm2html.NonterminalParser(name, ruleName);
                        nonterminalParser->SetArguments(invoke.Get());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleCall");
                            #endif
                            return Match(true, nonterminalParser);
                        }
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RuleCall");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RuleCall");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Nonterminal(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Nonterminal");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == ID)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Nonterminal");
                    #endif
                    return Match(true, new Value<ustring>(lexer.GetMatch(span)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Nonterminal");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Nonterminal");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Primitive(ParserFileLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Primitive");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case EMPTY: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                    #endif
                    return Match(true, new soulcm.scm2html.EmptyParser());
                }
                break;
            }
            case ANY: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                    #endif
                    return Match(true, new soulcm.scm2html.AnyParser());
                }
                break;
            }
            case ID: 
            {
                ++lexer;
                ustring tokenName = lexer.GetMatch(span);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                    #endif
                    return Match(true, new soulcm.scm2html.TokenParser(tokenName));
                }
                break;
            }
            case CHARLIT: 
            {
                ++lexer;
                uchar charLit = soulcm.scm2html.ParseCharLiteral(lexer.FileName(), lexer.GetToken(pos));
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                    #endif
                    return Match(true, new soulcm.scm2html.CharParser(charLit));
                }
                break;
            }
            case STRINGLIT: 
            {
                ++lexer;
                ustring strLit = soulcm.scm2html.ParseStringLiteral(lexer.FileName(), lexer.GetToken(pos));
                if (strLit.Length() > 0 && strLit[0] == '[' && strLit[strLit.Length() - 1] == ']')
                {
                    soulcm.scm2html.CharSet charSet = soulcm.scm2html.ParseCharSet(lexer.FileName(), lexer.GetToken(pos), strLit);
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                        #endif
                        return Match(true, new soulcm.scm2html.CharSetParser(charSet));
                    }
                }
                else
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                        #endif
                        return Match(true, new soulcm.scm2html.StringParser(strLit));
                    }
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Primitive");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Primitive");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Grouping(ParserFileLexer& lexer, ParsingContext* parsingContext)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Grouping");
            }
        #endif
        UniquePtr<soulcm.scm2html.Parser> alt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == LPAREN)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = ParserFileParser.Alternative(lexer, parsingContext);
                            alt.Reset(cast<soulcm.scm2html.Parser*>(match.value));
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch5 = &match;
                    {
                        Match match(true);
                        Match* parentMatch6 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch6 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                            }
                        }
                        *parentMatch5 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Grouping");
                    #endif
                    return Match(true, new soulcm.scm2html.GroupingParser(alt.Release()));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Grouping");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Grouping");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using Cm.Ast;
using LexerFileTokens;

// this file has been automatically generated from 'C:/work/cmajorm/cmajor/projects/tools/soulcm/scm2html/LexStatement.parser' using soulcm parser generator scmpg version 3.10.0

public static class LexStatementParser
{
    public static Match Statement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Statement");
            }
        #endif
        UniquePtr<StatementNode> labeledStatement;
        UniquePtr<StatementNode> controlStatement;
        UniquePtr<StatementNode> expressionStatement;
        UniquePtr<StatementNode> assignmentStatement;
        UniquePtr<ConstructionStatementNode> constructionStatement;
        UniquePtr<StatementNode> deleteStatement;
        UniquePtr<StatementNode> destroyStatement;
        UniquePtr<StatementNode> emptyStatement;
        UniquePtr<StatementNode> throwStatement;
        UniquePtr<TryStatementNode> tryStatement;
        UniquePtr<StatementNode> assertStatement;
        UniquePtr<ConditionalCompilationStatementNode> condCompStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = LexStatementParser.LabeledStatement(lexer, ctx);
                                                        labeledStatement.Reset(cast<StatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                #endif
                                                                return Match(true, labeledStatement.Release());
                                                            }
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match = LexStatementParser.ControlStatement(lexer, ctx);
                                                                controlStatement.Reset(cast<StatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    {
                                                                        #if (DEBUG)
                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                        #endif
                                                                        return Match(true, controlStatement.Release());
                                                                    }
                                                                }
                                                                *parentMatch13 = match;
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                }
                                                *parentMatch9 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch14 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch15 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexStatementParser.ExpressionStatement(lexer, ctx);
                                                            expressionStatement.Reset(cast<StatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                    #endif
                                                                    return Match(true, expressionStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch15 = match;
                                                        }
                                                        *parentMatch14 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch16 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch17 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = LexStatementParser.AssignmentStatement(lexer, ctx);
                                                        assignmentStatement.Reset(cast<StatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                                #endif
                                                                return Match(true, assignmentStatement.Release());
                                                            }
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                    *parentMatch16 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch18 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = LexStatementParser.ConstructionStatement(lexer, ctx);
                                                    constructionStatement.Reset(cast<ConstructionStatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                            #endif
                                                            return Match(true, constructionStatement.Release());
                                                        }
                                                    }
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch18 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch20 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch21 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = LexStatementParser.DeleteStatement(lexer, ctx);
                                                deleteStatement.Reset(cast<StatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                        #endif
                                                        return Match(true, deleteStatement.Release());
                                                    }
                                                }
                                                *parentMatch21 = match;
                                            }
                                            *parentMatch20 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch22 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch23 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexStatementParser.DestroyStatement(lexer, ctx);
                                            destroyStatement.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                    #endif
                                                    return Match(true, destroyStatement.Release());
                                                }
                                            }
                                            *parentMatch23 = match;
                                        }
                                        *parentMatch22 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch24 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch25 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexStatementParser.EmptyStatement(lexer, ctx);
                                        emptyStatement.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                                #endif
                                                return Match(true, emptyStatement.Release());
                                            }
                                        }
                                        *parentMatch25 = match;
                                    }
                                    *parentMatch24 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch26 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch27 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexStatementParser.ThrowStatement(lexer, ctx);
                                    throwStatement.Reset(cast<StatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                            #endif
                                            return Match(true, throwStatement.Release());
                                        }
                                    }
                                    *parentMatch27 = match;
                                }
                                *parentMatch26 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch28 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch29 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = LexStatementParser.TryStatement(lexer, ctx);
                                tryStatement.Reset(cast<TryStatementNode*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                        #endif
                                        return Match(true, tryStatement.Release());
                                    }
                                }
                                *parentMatch29 = match;
                            }
                            *parentMatch28 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch30 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch31 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexStatementParser.AssertStatement(lexer, ctx);
                            assertStatement.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                    #endif
                                    return Match(true, assertStatement.Release());
                                }
                            }
                            *parentMatch31 = match;
                        }
                        *parentMatch30 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch32 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch33 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = LexStatementParser.ConditionalCompilationStatement(lexer, ctx);
                        condCompStatement.Reset(cast<ConditionalCompilationStatementNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                                #endif
                                return Match(true, condCompStatement.Release());
                            }
                        }
                        *parentMatch33 = match;
                    }
                    *parentMatch32 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Statement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Statement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Label(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Label");
            }
        #endif
        Span s;
        ustring label;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                            label = lexer.GetMatch(span);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == COLON)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                    #endif
                    return Match(true, new LabelNode(s, ctx->ModuleId(), label));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Label");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Label");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match LabeledStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"LabeledStatement");
            }
        #endif
        UniquePtr<LabeledStatementNode> stmt;
        UniquePtr<LabelNode> lbl;
        UniquePtr<StatementNode> s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = LexStatementParser.Label(lexer, ctx);
            lbl.Reset(cast<LabelNode*>(match.value));
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = LexStatementParser.Statement(lexer, ctx);
                    s.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        stmt.Reset(new LabeledStatementNode(span, ctx->ModuleId(), s.Release()));
                        stmt->SetLabelNode(lbl.Release());
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LabeledStatement");
                            #endif
                            return Match(true, stmt.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"LabeledStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"LabeledStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ControlStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ControlStatement");
            }
        #endif
        UniquePtr<CompoundStatementNode> compoundStatement;
        UniquePtr<StatementNode> returnStatement;
        UniquePtr<IfStatementNode> ifStatement;
        UniquePtr<WhileStatementNode> whileStatement;
        UniquePtr<DoStatementNode> doStatement;
        UniquePtr<RangeForStatementNode> rangeForStatement;
        UniquePtr<ForStatementNode> forStatement;
        UniquePtr<StatementNode> breakStatement;
        UniquePtr<StatementNode> continueStatement;
        UniquePtr<StatementNode> gotoStatement;
        UniquePtr<SwitchStatementNode> switchStatement;
        UniquePtr<StatementNode> gotoCaseStatement;
        UniquePtr<StatementNode> gotoDefaultStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexStatementParser.CompoundStatement(lexer, ctx);
                                                            compoundStatement.Reset(cast<CompoundStatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                    #endif
                                                                    return Match(true, compoundStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch11 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch13 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch14 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = LexStatementParser.ReturnStatement(lexer, ctx);
                                                                    returnStatement.Reset(cast<StatementNode*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        {
                                                                            #if (DEBUG)
                                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                            #endif
                                                                            return Match(true, returnStatement.Release());
                                                                        }
                                                                    }
                                                                    *parentMatch14 = match;
                                                                }
                                                                *parentMatch13 = match;
                                                            }
                                                            *parentMatch11 = match;
                                                        }
                                                    }
                                                    *parentMatch10 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch15 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch16 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match = LexStatementParser.IfStatement(lexer, ctx);
                                                                ifStatement.Reset(cast<IfStatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    {
                                                                        #if (DEBUG)
                                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                        #endif
                                                                        return Match(true, ifStatement.Release());
                                                                    }
                                                                }
                                                                *parentMatch16 = match;
                                                            }
                                                            *parentMatch15 = match;
                                                        }
                                                        *parentMatch10 = match;
                                                    }
                                                }
                                                *parentMatch9 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch17 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch18 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexStatementParser.WhileStatement(lexer, ctx);
                                                            whileStatement.Reset(cast<WhileStatementNode*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                {
                                                                    #if (DEBUG)
                                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                    #endif
                                                                    return Match(true, whileStatement.Release());
                                                                }
                                                            }
                                                            *parentMatch18 = match;
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                            }
                                            *parentMatch8 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch20 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = LexStatementParser.DoStatement(lexer, ctx);
                                                        doStatement.Reset(cast<DoStatementNode*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            {
                                                                #if (DEBUG)
                                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                                #endif
                                                                return Match(true, doStatement.Release());
                                                            }
                                                        }
                                                        *parentMatch20 = match;
                                                    }
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                        }
                                        *parentMatch7 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch21 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch22 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = LexStatementParser.RangeForStatement(lexer, ctx);
                                                    rangeForStatement.Reset(cast<RangeForStatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        {
                                                            #if (DEBUG)
                                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                            #endif
                                                            return Match(true, rangeForStatement.Release());
                                                        }
                                                    }
                                                    *parentMatch22 = match;
                                                }
                                                *parentMatch21 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch23 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch24 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = LexStatementParser.ForStatement(lexer, ctx);
                                                forStatement.Reset(cast<ForStatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    {
                                                        #if (DEBUG)
                                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                        #endif
                                                        return Match(true, forStatement.Release());
                                                    }
                                                }
                                                *parentMatch24 = match;
                                            }
                                            *parentMatch23 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch25 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexStatementParser.BreakStatement(lexer, ctx);
                                            breakStatement.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                {
                                                    #if (DEBUG)
                                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                    #endif
                                                    return Match(true, breakStatement.Release());
                                                }
                                            }
                                            *parentMatch26 = match;
                                        }
                                        *parentMatch25 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch27 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch28 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexStatementParser.ContinueStatement(lexer, ctx);
                                        continueStatement.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            {
                                                #if (DEBUG)
                                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                                #endif
                                                return Match(true, continueStatement.Release());
                                            }
                                        }
                                        *parentMatch28 = match;
                                    }
                                    *parentMatch27 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch29 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch30 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexStatementParser.GotoStatement(lexer, ctx);
                                    gotoStatement.Reset(cast<StatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                            #endif
                                            return Match(true, gotoStatement.Release());
                                        }
                                    }
                                    *parentMatch30 = match;
                                }
                                *parentMatch29 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch31 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch32 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = LexStatementParser.SwitchStatement(lexer, ctx);
                                switchStatement.Reset(cast<SwitchStatementNode*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                        #endif
                                        return Match(true, switchStatement.Release());
                                    }
                                }
                                *parentMatch32 = match;
                            }
                            *parentMatch31 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch33 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch34 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexStatementParser.GotoCaseStatement(lexer, ctx);
                            gotoCaseStatement.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                    #endif
                                    return Match(true, gotoCaseStatement.Release());
                                }
                            }
                            *parentMatch34 = match;
                        }
                        *parentMatch33 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch35 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch36 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = LexStatementParser.GotoDefaultStatement(lexer, ctx);
                        gotoDefaultStatement.Reset(cast<StatementNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                                #endif
                                return Match(true, gotoDefaultStatement.Release());
                            }
                        }
                        *parentMatch36 = match;
                    }
                    *parentMatch35 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ControlStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ControlStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CompoundStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CompoundStatement");
            }
        #endif
        UniquePtr<CompoundStatementNode> compoundStatement;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == LBRACE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        compoundStatement.Reset(new CompoundStatementNode(span, ctx->ModuleId()));
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = LexStatementParser.Statement(lexer, ctx);
                                        stmt.Reset(cast<StatementNode*>(match.value));
                                        if (match.hit)
                                        {
                                            compoundStatement->AddStatement(stmt.Release());
                                        }
                                        *parentMatch6 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch4 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch9 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch9 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        compoundStatement->SetSpanEnd(span.end);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompoundStatement");
                            #endif
                            return Match(true, compoundStatement.Release());
                        }
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CompoundStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CompoundStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ReturnStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ReturnStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == RETURN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch4 = &match;
                    {
                        Match match = LexExpressionParser.Expression(lexer, ctx);
                        expr.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnStatement");
                            #endif
                            return Match(true, new ReturnStatementNode(s, ctx->ModuleId(), expr.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ReturnStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ReturnStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match IfStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IfStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        Span elseSpan;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> thenS;
        UniquePtr<StatementNode> elseS;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == IF)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            s = span;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                leftParenSpan = span;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match = LexExpressionParser.Expression(lexer, ctx);
                                    cond.Reset(cast<Node*>(match.value));
                                    *parentMatch10 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        rightParenSpan = span;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch13 = &match;
                        {
                            Match match(false);
                            Match* parentMatch14 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = LexStatementParser.Statement(lexer, ctx);
                                thenS.Reset(cast<StatementNode*>(match.value));
                                if (match.hit)
                                {
                                    s.end = span.end;
                                }
                                *parentMatch14 = match;
                            }
                            *parentMatch13 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch16 = &match;
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == ELSE)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            elseSpan = span;
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = LexStatementParser.Statement(lexer, ctx);
                                            elseS.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                            }
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch20 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch17 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch16 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                IfStatementNode* value = new IfStatementNode(s, ctx->ModuleId(), cond.Release(), thenS.Release(), elseS.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetElseSpan(elseSpan);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IfStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IfStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IfStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match WhileStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"WhileStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == WHILE)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s = span;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch9 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch9 = match;
                                            }
                                            else
                                            {
                                                lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            leftParenSpan = span;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match(true);
                                Match* parentMatch11 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexExpressionParser.Expression(lexer, ctx);
                                    cond.Reset(cast<Node*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch11 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"expression");
                                    }
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            Match match(false);
                            Match* parentMatch13 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch14 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch14 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch13 = match;
                            }
                            *parentMatch12 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(false);
                        Match* parentMatch16 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch17 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = LexStatementParser.Statement(lexer, ctx);
                                stmt.Reset(cast<StatementNode*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch17 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"statement");
                                }
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch16 = match;
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                WhileStatementNode* value = new WhileStatementNode(s, ctx->ModuleId(), cond.Release(), stmt.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"WhileStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"WhileStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"WhileStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DoStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DoStatement");
            }
        #endif
        Span s;
        Span whileSpan;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<StatementNode> stmt;
        UniquePtr<Node> cond;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == DO)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                s = span;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch10 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = LexStatementParser.Statement(lexer, ctx);
                                                stmt.Reset(cast<StatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch10 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"statement");
                                                }
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(true);
                                            Match* parentMatch13 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == WHILE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch13 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, GetTokenName(WHILE));
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                whileSpan = span;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch16 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == LPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch16 = match;
                                            }
                                            else
                                            {
                                                lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            leftParenSpan = span;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            {
                                Match match(true);
                                Match* parentMatch18 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexExpressionParser.Expression(lexer, ctx);
                                    cond.Reset(cast<Node*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch18 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"expression");
                                    }
                                }
                                *parentMatch17 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch19 = &match;
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch21 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch21 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch19 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch22 = &match;
                    {
                        Match match(false);
                        Match* parentMatch23 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch24 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == SEMICOLON)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch24 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                                }
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch23 = match;
                        }
                        *parentMatch22 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                DoStatementNode* value = new DoStatementNode(s, ctx->ModuleId(), stmt.Release(), cond.Release());
                value->SetWhileSpan(whileSpan);
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DoStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DoStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ForStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<StatementNode> init;
        UniquePtr<Node> cond;
        UniquePtr<StatementNode> loop;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == FOR)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        leftParenSpan = span;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch13 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = LexStatementParser.ForInitStatement(lexer, ctx);
                                                init.Reset(cast<StatementNode*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch13 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"for initialization statement");
                                                }
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match(true);
                                        long save = lexer.GetPos();
                                        Match* parentMatch15 = &match;
                                        {
                                            Match match = LexExpressionParser.Expression(lexer, ctx);
                                            cond.Reset(cast<Node*>(match.value));
                                            if (match.hit)
                                            {
                                                *parentMatch15 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                            }
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch16 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch17 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == SEMICOLON)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch17 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                                        }
                                    }
                                    *parentMatch16 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch18 = &match;
                            {
                                Match match(true);
                                Match* parentMatch19 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexStatementParser.ForLoopStatementExpr(lexer, ctx);
                                    loop.Reset(cast<StatementNode*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch19 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"for loop expression");
                                    }
                                }
                                *parentMatch18 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch20 = &match;
                        {
                            Match match(false);
                            Match* parentMatch21 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch22 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch22 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch21 = match;
                            }
                            *parentMatch20 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch23 = &match;
                    {
                        Match match(false);
                        Match* parentMatch24 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch25 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = LexStatementParser.Statement(lexer, ctx);
                                stmt.Reset(cast<StatementNode*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch25 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"statement");
                                }
                            }
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch24 = match;
                        }
                        *parentMatch23 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                ForStatementNode* value = new ForStatementNode(s, ctx->ModuleId(), init.Release(), cond.Release(), loop.Release(), stmt.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ForInitStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForInitStatement");
            }
        #endif
        UniquePtr<StatementNode> assignmentStatement;
        UniquePtr<ConstructionStatementNode> constructionStatement;
        UniquePtr<StatementNode> emptyStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = LexStatementParser.AssignmentStatement(lexer, ctx);
                    assignmentStatement.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                            #endif
                            return Match(true, assignmentStatement.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexStatementParser.ConstructionStatement(lexer, ctx);
                            constructionStatement.Reset(cast<ConstructionStatementNode*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                                    #endif
                                    return Match(true, constructionStatement.Release());
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = LexStatementParser.EmptyStatement(lexer, ctx);
                        emptyStatement.Reset(cast<StatementNode*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                                #endif
                                return Match(true, emptyStatement.Release());
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForInitStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForInitStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ForLoopStatementExpr(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ForLoopStatementExpr");
            }
        #endif
        UniquePtr<StatementNode> assignmentStatementExpr;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = LexStatementParser.AssignmentStatementExpr(lexer, ctx);
                    assignmentStatementExpr.Reset(cast<StatementNode*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                            #endif
                            return Match(true, assignmentStatementExpr.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = LexExpressionParser.Expression(lexer, ctx);
                            expr.Reset(cast<Node*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                                    #endif
                                    return Match(true, new ExpressionStatementNode(span, ctx->ModuleId(), expr.Release()));
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                                #endif
                                return Match(true, new EmptyStatementNode(span, ctx->ModuleId()));
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ForLoopStatementExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ForLoopStatementExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match RangeForStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"RangeForStatement");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        Span colonSpan;
        UniquePtr<Node> type;
        UniquePtr<IdentifierNode> id;
        UniquePtr<Node> container;
        UniquePtr<StatementNode> action;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == FOR)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        leftParenSpan = span;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match = LexTypeExprParser.TypeExpr(lexer, ctx);
                                            type.Reset(cast<Node*>(match.value));
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match = LexIdentifierParser.Identifier(lexer, ctx);
                                        id.Reset(cast<IdentifierNode*>(match.value));
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == COLON)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            colonSpan = span;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch16 = &match;
                            {
                                Match match(true);
                                Match* parentMatch17 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexExpressionParser.Expression(lexer, ctx);
                                    container.Reset(cast<Node*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch17 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"expression");
                                    }
                                }
                                *parentMatch16 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch18 = &match;
                        {
                            Match match(false);
                            Match* parentMatch19 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch20 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch20 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    rightParenSpan = span;
                                }
                                *parentMatch19 = match;
                            }
                            *parentMatch18 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch21 = &match;
                    {
                        Match match(false);
                        Match* parentMatch22 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = LexStatementParser.Statement(lexer, ctx);
                            action.Reset(cast<StatementNode*>(match.value));
                            if (match.hit)
                            {
                                s.end = span.end;
                            }
                            *parentMatch22 = match;
                        }
                        *parentMatch21 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                RangeForStatementNode* value = new RangeForStatementNode(s, ctx->ModuleId(), type.Release(), id.Release(), container.Release(), action.Release());
                value->SetLeftParenSpan(leftParenSpan);
                value->SetRightParenSpan(rightParenSpan);
                value->SetColonSpan(colonSpan);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RangeForStatement");
                    #endif
                    return Match(true, value);
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"RangeForStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"RangeForStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match BreakStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"BreakStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == BREAK)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BreakStatement");
                            #endif
                            return Match(true, new BreakStatementNode(s, ctx->ModuleId()));
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"BreakStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"BreakStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ContinueStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ContinueStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == CONTINUE)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ContinueStatement");
                            #endif
                            return Match(true, new ContinueStatementNode(s, ctx->ModuleId()));
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ContinueStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ContinueStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match GotoStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoStatement");
            }
        #endif
        ustring label;
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == GOTO)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ID)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            label = lexer.GetMatch(span);
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoStatement");
                            #endif
                            return Match(true, new GotoStatementNode(s, ctx->ModuleId(), label));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SwitchStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SwitchStatement");
            }
        #endif
        UniquePtr<SwitchStatementNode> switchStatement;
        Span leftParenSpan;
        Span rightParenSpan;
        Span beginBraceSpan;
        Span endBraceSpan;
        UniquePtr<Node> cond;
        UniquePtr<CaseStatementNode> caseStatement;
        UniquePtr<DefaultStatementNode> defaultStatement;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == SWITCH)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(true);
                                                Match* parentMatch10 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch10 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    leftParenSpan = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(true);
                                        Match* parentMatch12 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match = LexExpressionParser.Expression(lexer, ctx);
                                            cond.Reset(cast<Node*>(match.value));
                                            if (match.hit)
                                            {
                                                *parentMatch12 = match;
                                            }
                                            else
                                            {
                                                lexer.ThrowExpectationFailure(span, u"expression");
                                            }
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch13 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch14 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == RPAREN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch14 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                        }
                                    }
                                    *parentMatch13 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            rightParenSpan = span;
                            switchStatement.Reset(new SwitchStatementNode(span, ctx->ModuleId(), cond.Release()));
                            switchStatement->SetLeftParenSpan(leftParenSpan);
                            switchStatement->SetRightParenSpan(rightParenSpan);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(false);
                        Match* parentMatch16 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            Match* parentMatch17 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == LBRACE)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    *parentMatch17 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, GetTokenName(LBRACE));
                                }
                            }
                            if (match.hit)
                            {
                                beginBraceSpan = span;
                            }
                            *parentMatch16 = match;
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch18 = &match;
                {
                    Match match(true);
                    Match* parentMatch19 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch20 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch21 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch22 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexStatementParser.CaseStatement(lexer, ctx);
                                            caseStatement.Reset(cast<CaseStatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                switchStatement->AddCase(caseStatement.Release());
                                            }
                                            *parentMatch22 = match;
                                        }
                                        *parentMatch21 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch23 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch24 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = LexStatementParser.DefaultStatement(lexer, ctx);
                                                    defaultStatement.Reset(cast<DefaultStatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        switchStatement->SetDefault(defaultStatement.Release());
                                                    }
                                                    *parentMatch24 = match;
                                                }
                                                *parentMatch23 = match;
                                            }
                                            *parentMatch21 = match;
                                        }
                                    }
                                    *parentMatch20 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch19 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch18 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch25 = &match;
            {
                Match match(false);
                Match* parentMatch26 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch27 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == RBRACE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch27 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(RBRACE));
                        }
                    }
                    if (match.hit)
                    {
                        endBraceSpan = span;
                        switchStatement->SetBeginBraceSpan(beginBraceSpan);
                        switchStatement->SetEndBraceSpan(endBraceSpan);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchStatement");
                            #endif
                            return Match(true, switchStatement.Release());
                        }
                    }
                    *parentMatch26 = match;
                }
                *parentMatch25 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SwitchStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SwitchStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CaseStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CaseStatement");
            }
        #endif
        UniquePtr<CaseStatementNode> caseS;
        Span s;
        Span caseSpan;
        UniquePtr<Node> caseExpr;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(true);
                if (match.hit)
                {
                    caseS.Reset(new CaseStatementNode(span, ctx->ModuleId()));
                    s = span;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Span span = lexer.GetSpan();
                                                        Match match(false);
                                                        if (*lexer == CASE)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            caseSpan = span;
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch14 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = LexExpressionParser.Expression(lexer, ctx);
                                                            caseExpr.Reset(cast<Node*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                caseS->AddCaseSpan(caseSpan);
                                                                caseS->AddCaseExpr(caseExpr.Release());
                                                            }
                                                            *parentMatch14 = match;
                                                        }
                                                        *parentMatch13 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch15 = &match;
                                                {
                                                    Match match(true);
                                                    Match* parentMatch16 = &match;
                                                    {
                                                        System.Lex.Span span = lexer.GetSpan();
                                                        Match match(false);
                                                        if (*lexer == COLON)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch16 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.ThrowExpectationFailure(span, GetTokenName(COLON));
                                                        }
                                                    }
                                                    *parentMatch15 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(true);
                                        Match* parentMatch17 = &match;
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch18 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch19 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch20 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch21 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == CASE)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    caseSpan = span;
                                                                }
                                                                *parentMatch21 = match;
                                                            }
                                                            *parentMatch20 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch22 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch23 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match = LexExpressionParser.Expression(lexer, ctx);
                                                                    caseExpr.Reset(cast<Node*>(match.value));
                                                                    if (match.hit)
                                                                    {
                                                                        caseS->AddCaseSpan(caseSpan);
                                                                        caseS->AddCaseExpr(caseExpr.Release());
                                                                    }
                                                                    *parentMatch23 = match;
                                                                }
                                                                *parentMatch22 = match;
                                                            }
                                                            *parentMatch20 = match;
                                                        }
                                                        *parentMatch19 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch24 = &match;
                                                        {
                                                            Match match(true);
                                                            Match* parentMatch25 = &match;
                                                            {
                                                                System.Lex.Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == COLON)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch25 = match;
                                                                }
                                                                else
                                                                {
                                                                    lexer.ThrowExpectationFailure(span, GetTokenName(COLON));
                                                                }
                                                            }
                                                            *parentMatch24 = match;
                                                        }
                                                        *parentMatch19 = match;
                                                    }
                                                    *parentMatch18 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch17 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    caseS->SetSpan(s);
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch26 = &match;
                            {
                                Match match(true);
                                Match* parentMatch27 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch28 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch29 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = LexStatementParser.Statement(lexer, ctx);
                                                    stmt.Reset(cast<StatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        caseS->AddStatement(stmt.Release());
                                                    }
                                                    *parentMatch29 = match;
                                                }
                                                *parentMatch28 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch27 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch26 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CaseStatement");
                            #endif
                            return Match(true, caseS.Release());
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CaseStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CaseStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DefaultStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DefaultStatement");
            }
        #endif
        UniquePtr<DefaultStatementNode> defaultS;
        Span s;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == DEFAULT)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch7 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == COLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch7 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(COLON));
                                    }
                                }
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    defaultS.Reset(new DefaultStatementNode(s, ctx->ModuleId()));
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        Match* parentMatch9 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexStatementParser.Statement(lexer, ctx);
                                            stmt.Reset(cast<StatementNode*>(match.value));
                                            if (match.hit)
                                            {
                                                defaultS->AddStatement(stmt.Release());
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DefaultStatement");
                    #endif
                    return Match(true, defaultS.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DefaultStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DefaultStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match GotoCaseStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoCaseStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> caseExpr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == GOTO)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        if (*lexer == CASE)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match = LexExpressionParser.Expression(lexer, ctx);
                    caseExpr.Reset(cast<Node*>(match.value));
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch6 = &match;
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch8 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch8 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoCaseStatement");
                            #endif
                            return Match(true, new GotoCaseStatementNode(s, ctx->ModuleId(), caseExpr.Release()));
                        }
                    }
                    *parentMatch7 = match;
                }
                *parentMatch6 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoCaseStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoCaseStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match GotoDefaultStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GotoDefaultStatement");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == GOTO)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(false);
                    if (*lexer == DEFAULT)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoDefaultStatement");
                            #endif
                            return Match(true, new GotoDefaultStatementNode(s, ctx->ModuleId()));
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GotoDefaultStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GotoDefaultStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AssignmentStatementExpr(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssignmentStatementExpr");
            }
        #endif
        Span s;
        UniquePtr<Node> target;
        UniquePtr<Node> source;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        if (match.hit)
                        {
                            ctx->PushParsingLvalue(true);
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = LexExpressionParser.Expression(lexer, ctx);
                            target.Reset(cast<Node*>(match.value));
                            if (match.hit)
                            {
                                ctx->PopParsingLvalue();
                            }
                            else
                            {
                                ctx->PopParsingLvalue();
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(false);
                    if (*lexer == ASSIGN)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = LexExpressionParser.Expression(lexer, ctx);
                    source.Reset(cast<Node*>(match.value));
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatementExpr");
                            #endif
                            return Match(true, new AssignmentStatementNode(s, ctx->ModuleId(), target.Release(), source.Release()));
                        }
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatementExpr");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssignmentStatementExpr");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AssignmentStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssignmentStatement");
            }
        #endif
        UniquePtr<StatementNode> statement;
        UniquePtr<StatementNode> stmt;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = LexStatementParser.AssignmentStatementExpr(lexer, ctx);
            stmt.Reset(cast<StatementNode*>(match.value));
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == SEMICOLON)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        statement.Reset(stmt.Release());
                        statement->SetSpanEnd(span.end);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatement");
                            #endif
                            return Match(true, statement.Release());
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssignmentStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssignmentStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConstructionStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConstructionStatement");
            }
        #endif
        UniquePtr<ConstructionStatementNode> constructionStatement;
        UniquePtr<Node> type;
        UniquePtr<IdentifierNode> id;
        UniquePtr<Node> value;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = LexTypeExprParser.TypeExpr(lexer, ctx);
                            type.Reset(cast<Node*>(match.value));
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexIdentifierParser.Identifier(lexer, ctx);
                                    id.Reset(cast<IdentifierNode*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"identifier");
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        constructionStatement.Reset(new ConstructionStatementNode(span, ctx->ModuleId(), type.Release(), id.Release()));
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == ASSIGN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch11 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch13 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            Match* parentMatch14 = &match;
                                            {
                                                System.Lex.Span span = lexer.GetSpan();
                                                Match match = LexExpressionParser.Expression(lexer, ctx);
                                                value.Reset(cast<Node*>(match.value));
                                                if (match.hit)
                                                {
                                                    *parentMatch14 = match;
                                                }
                                                else
                                                {
                                                    lexer.ThrowExpectationFailure(span, u"expression");
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                constructionStatement->AddArgument(value.Release());
                                                constructionStatement->SetAssignment();
                                            }
                                            *parentMatch13 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                                *parentMatch10 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch16 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch17 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == LPAREN)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch17 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch18 = &match;
                                                {
                                                    Match match = LexExpressionParser.ArgumentList(lexer, ctx, constructionStatement.Get());
                                                    *parentMatch18 = match;
                                                }
                                                *parentMatch17 = match;
                                            }
                                            *parentMatch16 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch19 = &match;
                                            {
                                                Match match(true);
                                                Match* parentMatch20 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == RPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch20 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                                    }
                                                }
                                                *parentMatch19 = match;
                                            }
                                            *parentMatch16 = match;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                            }
                            *parentMatch9 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch21 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch22 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(true);
                                        if (match.hit)
                                        {
                                            constructionStatement->SetEmpty();
                                        }
                                        *parentMatch22 = match;
                                    }
                                    *parentMatch21 = match;
                                }
                                *parentMatch9 = match;
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch7 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch23 = &match;
            {
                Match match(false);
                Match* parentMatch24 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch25 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch25 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        constructionStatement->SetSpanEnd(span.end);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConstructionStatement");
                            #endif
                            return Match(true, constructionStatement.Release());
                        }
                    }
                    *parentMatch24 = match;
                }
                *parentMatch23 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConstructionStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConstructionStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DeleteStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DeleteStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == DELETE)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = LexExpressionParser.Expression(lexer, ctx);
                        ptr.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"expression");
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DeleteStatement");
                            #endif
                            return Match(true, new DeleteStatementNode(s, ctx->ModuleId(), ptr.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DeleteStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DeleteStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DestroyStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DestroyStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> ptr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == DESTROY)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = LexExpressionParser.Expression(lexer, ctx);
                        ptr.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"expression");
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DestroyStatement");
                            #endif
                            return Match(true, new DestroyStatementNode(s, ctx->ModuleId(), ptr.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DestroyStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DestroyStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ExpressionStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ExpressionStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                if (match.hit)
                {
                    ctx->PushParsingExpressionStatement(true);
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = LexExpressionParser.Expression(lexer, ctx);
                                expr.Reset(cast<Node*>(match.value));
                                if (match.hit)
                                {
                                    s = span;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == SEMICOLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s.end = span.end;
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        ctx->PopParsingExpressionStatement();
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExpressionStatement");
                            #endif
                            return Match(true, new ExpressionStatementNode(s, ctx->ModuleId(), expr.Release()));
                        }
                    }
                    else
                    {
                        ctx->PopParsingExpressionStatement();
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExpressionStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ExpressionStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EmptyStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EmptyStatement");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            if (*lexer == SEMICOLON)
            {
                ++lexer;
                match.hit = true;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EmptyStatement");
                    #endif
                    return Match(true, new EmptyStatementNode(span, ctx->ModuleId()));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EmptyStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EmptyStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ThrowStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ThrowStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> exception;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(false);
                    if (*lexer == THROW)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        s = span;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch4 = &match;
                    {
                        Match match = LexExpressionParser.Expression(lexer, ctx);
                        exception.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch4 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch7 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch7 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ThrowStatement");
                            #endif
                            return Match(true, new ThrowStatementNode(s, ctx->ModuleId(), exception.Release()));
                        }
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ThrowStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ThrowStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TryStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TryStatement");
            }
        #endif
        UniquePtr<TryStatementNode> tryStatement;
        UniquePtr<CompoundStatementNode> tryBlock;
        UniquePtr<CatchNode> ctch;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == TRY)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = LexStatementParser.CompoundStatement(lexer, ctx);
                                    tryBlock.Reset(cast<CompoundStatementNode*>(match.value));
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            tryStatement.Reset(new TryStatementNode(span, ctx->ModuleId(), tryBlock.Release()));
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = LexStatementParser.Catch(lexer, ctx);
                                    ctch.Reset(cast<CatchNode*>(match.value));
                                    if (match.hit)
                                    {
                                        tryStatement->AddCatch(ctch.Release());
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch11 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch13 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = LexStatementParser.Catch(lexer, ctx);
                                            ctch.Reset(cast<CatchNode*>(match.value));
                                            if (match.hit)
                                            {
                                                tryStatement->AddCatch(ctch.Release());
                                            }
                                            *parentMatch13 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch11 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TryStatement");
                    #endif
                    return Match(true, tryStatement.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TryStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TryStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Catch(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Catch");
            }
        #endif
        Span s;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<Node> catchType;
        UniquePtr<IdentifierNode> catchId;
        UniquePtr<CompoundStatementNode> catchBlock;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(false);
                                if (*lexer == CATCH)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    s = span;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(true);
                                    Match* parentMatch8 = &match;
                                    {
                                        System.Lex.Span span = lexer.GetSpan();
                                        Match match(false);
                                        if (*lexer == LPAREN)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch8 = match;
                                        }
                                        else
                                        {
                                            lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        leftParenSpan = span;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(true);
                            Match* parentMatch10 = &match;
                            {
                                System.Lex.Span span = lexer.GetSpan();
                                Match match = LexTypeExprParser.TypeExpr(lexer, ctx);
                                catchType.Reset(cast<Node*>(match.value));
                                if (match.hit)
                                {
                                    *parentMatch10 = match;
                                }
                                else
                                {
                                    lexer.ThrowExpectationFailure(span, u"type expression");
                                }
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch11 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch12 = &match;
                        {
                            Match match = LexIdentifierParser.Identifier(lexer, ctx);
                            catchId.Reset(cast<IdentifierNode*>(match.value));
                            if (match.hit)
                            {
                                *parentMatch12 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch11 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch13 = &match;
                {
                    Match match(false);
                    Match* parentMatch14 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(true);
                        Match* parentMatch15 = &match;
                        {
                            System.Lex.Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == RPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                *parentMatch15 = match;
                            }
                            else
                            {
                                lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                            }
                        }
                        if (match.hit)
                        {
                            rightParenSpan = span;
                        }
                        *parentMatch14 = match;
                    }
                    *parentMatch13 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch16 = &match;
            {
                Match match(false);
                Match* parentMatch17 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = LexStatementParser.CompoundStatement(lexer, ctx);
                    catchBlock.Reset(cast<CompoundStatementNode*>(match.value));
                    if (match.hit)
                    {
                        s.end = span.end;
                        CatchNode* value = new CatchNode(s, ctx->ModuleId(), catchType.Release(), catchId.Release(), catchBlock.Release());
                        value->SetLeftParenSpan(leftParenSpan);
                        value->SetRightParenSpan(rightParenSpan);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Catch");
                            #endif
                            return Match(true, value);
                        }
                    }
                    *parentMatch17 = match;
                }
                *parentMatch16 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Catch");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Catch");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AssertStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AssertStatement");
            }
        #endif
        Span s;
        UniquePtr<Node> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == HASH)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        if (*lexer == ASSERT)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    Match* parentMatch6 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match = LexExpressionParser.Expression(lexer, ctx);
                        expr.Reset(cast<Node*>(match.value));
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, u"expression");
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch9 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == SEMICOLON)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch9 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(SEMICOLON));
                        }
                    }
                    if (match.hit)
                    {
                        s.end = span.end;
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssertStatement");
                            #endif
                            return Match(true, new AssertStatementNode(s, ctx->ModuleId(), expr.Release()));
                        }
                    }
                    *parentMatch8 = match;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AssertStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AssertStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationStatement(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationStatement");
            }
        #endif
        UniquePtr<ConditionalCompilationStatementNode> condCompStmt;
        Span s;
        Span keywordSpan;
        Span leftParenSpan;
        Span rightParenSpan;
        UniquePtr<ConditionalCompilationExpressionNode> ifExpr;
        UniquePtr<StatementNode> ifS;
        UniquePtr<ConditionalCompilationExpressionNode> elifExpr;
        UniquePtr<StatementNode> elifS;
        UniquePtr<StatementNode> elseS;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == HASH)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s = span;
                                                    keywordSpan = span;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == IF)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        keywordSpan.end = span.end;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch13 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(true);
                                                Match* parentMatch14 = &match;
                                                {
                                                    System.Lex.Span span = lexer.GetSpan();
                                                    Match match(false);
                                                    if (*lexer == LPAREN)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch14 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    leftParenSpan = span;
                                                }
                                                *parentMatch13 = match;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch16 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = LexStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                            ifExpr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                                condCompStmt.Reset(new ConditionalCompilationStatementNode(s, ctx->ModuleId(), ifExpr.Release()));
                                                condCompStmt->IfPart()->SetKeywordSpan(keywordSpan);
                                            }
                                            *parentMatch16 = match;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch17 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch18 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Span span = lexer.GetSpan();
                                        Match match(true);
                                        Match* parentMatch19 = &match;
                                        {
                                            System.Lex.Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == RPAREN)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch19 = match;
                                            }
                                            else
                                            {
                                                lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                            }
                                        }
                                        if (match.hit)
                                        {
                                            rightParenSpan = span;
                                            condCompStmt->IfPart()->SetLeftParenSpan(leftParenSpan);
                                            condCompStmt->IfPart()->SetRightParenSpan(rightParenSpan);
                                        }
                                        *parentMatch18 = match;
                                    }
                                    *parentMatch17 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            {
                                Match match(true);
                                Match* parentMatch21 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = LexStatementParser.Statement(lexer, ctx);
                                                    ifS.Reset(cast<StatementNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        condCompStmt->AddIfStatement(ifS.Release());
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch21 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch24 = &match;
                        {
                            Match match(true);
                            Match* parentMatch25 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch27 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch28 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch29 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch30 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch31 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch32 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Span span = lexer.GetSpan();
                                                                    Match match(false);
                                                                    if (*lexer == HASH)
                                                                    {
                                                                        ++lexer;
                                                                        match.hit = true;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        keywordSpan = span;
                                                                    }
                                                                    *parentMatch32 = match;
                                                                }
                                                                *parentMatch31 = match;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch33 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch34 = &match;
                                                                    {
                                                                        long pos = lexer.GetPos();
                                                                        Span span = lexer.GetSpan();
                                                                        Match match(false);
                                                                        if (*lexer == ELIF)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            keywordSpan.end = span.end;
                                                                        }
                                                                        *parentMatch34 = match;
                                                                    }
                                                                    *parentMatch33 = match;
                                                                }
                                                                *parentMatch31 = match;
                                                            }
                                                            *parentMatch30 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch35 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch36 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Span span = lexer.GetSpan();
                                                                    Match match(true);
                                                                    Match* parentMatch37 = &match;
                                                                    {
                                                                        System.Lex.Span span = lexer.GetSpan();
                                                                        Match match(false);
                                                                        if (*lexer == LPAREN)
                                                                        {
                                                                            ++lexer;
                                                                            match.hit = true;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            *parentMatch37 = match;
                                                                        }
                                                                        else
                                                                        {
                                                                            lexer.ThrowExpectationFailure(span, GetTokenName(LPAREN));
                                                                        }
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        leftParenSpan = span;
                                                                    }
                                                                    *parentMatch36 = match;
                                                                }
                                                                *parentMatch35 = match;
                                                            }
                                                            *parentMatch30 = match;
                                                        }
                                                        *parentMatch29 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch38 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch39 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match = LexStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                                                elifExpr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    condCompStmt->AddElifExpr(span, ctx->ModuleId(), elifExpr.Release());
                                                                }
                                                                *parentMatch39 = match;
                                                            }
                                                            *parentMatch38 = match;
                                                        }
                                                        *parentMatch29 = match;
                                                    }
                                                    *parentMatch28 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch40 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch41 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Span span = lexer.GetSpan();
                                                            Match match(true);
                                                            Match* parentMatch42 = &match;
                                                            {
                                                                System.Lex.Span span = lexer.GetSpan();
                                                                Match match(false);
                                                                if (*lexer == RPAREN)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch42 = match;
                                                                }
                                                                else
                                                                {
                                                                    lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                                                }
                                                            }
                                                            if (match.hit)
                                                            {
                                                                rightParenSpan = span;
                                                                condCompStmt->SetElifLeftParenSpan(leftParenSpan);
                                                                condCompStmt->SetElifRightParenSpan(rightParenSpan);
                                                                condCompStmt->SetElifKeywordSpan(keywordSpan);
                                                            }
                                                            *parentMatch41 = match;
                                                        }
                                                        *parentMatch40 = match;
                                                    }
                                                    *parentMatch28 = match;
                                                }
                                                *parentMatch27 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch43 = &match;
                                                {
                                                    Match match(true);
                                                    Match* parentMatch44 = &match;
                                                    {
                                                        while (true)
                                                        {
                                                            long save = lexer.GetPos();
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch45 = &match;
                                                                {
                                                                    Match match(false);
                                                                    Match* parentMatch46 = &match;
                                                                    {
                                                                        long pos = lexer.GetPos();
                                                                        Match match = LexStatementParser.Statement(lexer, ctx);
                                                                        elifS.Reset(cast<StatementNode*>(match.value));
                                                                        if (match.hit)
                                                                        {
                                                                            condCompStmt->AddElifStatement(elifS.Release());
                                                                        }
                                                                        *parentMatch46 = match;
                                                                    }
                                                                    *parentMatch45 = match;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    *parentMatch44 = match;
                                                                }
                                                                else
                                                                {
                                                                    lexer.SetPos(save);
                                                                    break;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    *parentMatch43 = match;
                                                }
                                                *parentMatch27 = match;
                                            }
                                            *parentMatch26 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch25 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch24 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch47 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch48 = &match;
                        {
                            Match match(false);
                            Match* parentMatch49 = &match;
                            {
                                Match match(false);
                                Match* parentMatch50 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch51 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch52 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch53 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Span span = lexer.GetSpan();
                                                Match match(false);
                                                if (*lexer == HASH)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    keywordSpan = span;
                                                }
                                                *parentMatch53 = match;
                                            }
                                            *parentMatch52 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch54 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == ELSE)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch54 = match;
                                            }
                                            *parentMatch52 = match;
                                        }
                                        *parentMatch51 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch55 = &match;
                                        {
                                            Match match(true);
                                            Match* parentMatch56 = &match;
                                            {
                                                while (true)
                                                {
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch57 = &match;
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch58 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Span span = lexer.GetSpan();
                                                                Match match = LexStatementParser.Statement(lexer, ctx);
                                                                elseS.Reset(cast<StatementNode*>(match.value));
                                                                if (match.hit)
                                                                {
                                                                    condCompStmt->AddElseStatement(span, ctx->ModuleId(), elseS.Release());
                                                                }
                                                                *parentMatch58 = match;
                                                            }
                                                            *parentMatch57 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            *parentMatch56 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            *parentMatch55 = match;
                                        }
                                        *parentMatch51 = match;
                                    }
                                    *parentMatch50 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch59 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch60 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(true);
                                            if (match.hit)
                                            {
                                                condCompStmt->ElsePart()->SetKeywordSpan(keywordSpan);
                                            }
                                            *parentMatch60 = match;
                                        }
                                        *parentMatch59 = match;
                                    }
                                    *parentMatch50 = match;
                                }
                                *parentMatch49 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch48 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch47 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch61 = &match;
                {
                    Match match(false);
                    Match* parentMatch62 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == HASH)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            keywordSpan = span;
                        }
                        *parentMatch62 = match;
                    }
                    *parentMatch61 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch63 = &match;
            {
                Match match(false);
                Match* parentMatch64 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match(true);
                    Match* parentMatch65 = &match;
                    {
                        System.Lex.Span span = lexer.GetSpan();
                        Match match(false);
                        if (*lexer == ENDIF)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            *parentMatch65 = match;
                        }
                        else
                        {
                            lexer.ThrowExpectationFailure(span, GetTokenName(ENDIF));
                        }
                    }
                    if (match.hit)
                    {
                        keywordSpan.end = span.end;
                        condCompStmt->SetEndIfSpan(keywordSpan);
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationStatement");
                            #endif
                            return Match(true, condCompStmt.Release());
                        }
                    }
                    *parentMatch64 = match;
                }
                *parentMatch63 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationStatement");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationStatement");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationExpression(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationExpression");
            }
        #endif
        UniquePtr<ConditionalCompilationExpressionNode> disjunction;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match = LexStatementParser.ConditionalCompilationDisjunction(lexer, ctx);
            disjunction.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationExpression");
                    #endif
                    return Match(true, disjunction.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationExpression");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationExpression");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationDisjunction(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationDisjunction");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> left;
        UniquePtr<ConditionalCompilationExpressionNode> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = LexStatementParser.ConditionalCompilationConjunction(lexer, ctx);
                        left.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                        if (match.hit)
                        {
                            s = span;
                            condCompExpr.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == DISJUNCTION)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match = LexStatementParser.ConditionalCompilationConjunction(lexer, ctx);
                                                    right.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.end = span.end;
                                                        condCompExpr.Reset(new ConditionalCompilationDisjunctionNode(s, ctx->ModuleId(), condCompExpr.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationDisjunction");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationDisjunction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationDisjunction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationConjunction(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationConjunction");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> left;
        UniquePtr<ConditionalCompilationExpressionNode> right;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = LexStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                        left.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                        if (match.hit)
                        {
                            s = span;
                            condCompExpr.Reset(left.Release());
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == AMPAMP)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Span span = lexer.GetSpan();
                                                    Match match = LexStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                                                    right.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.end = span.end;
                                                        condCompExpr.Reset(new ConditionalCompilationConjunctionNode(s, ctx->ModuleId(), condCompExpr.Release(), right.Release()));
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationConjunction");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationConjunction");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationConjunction");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationPrefix(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationPrefix");
            }
        #endif
        Span s;
        UniquePtr<ConditionalCompilationExpressionNode> condCompExpr;
        UniquePtr<ConditionalCompilationExpressionNode> prefix;
        UniquePtr<ConditionalCompilationExpressionNode> primary;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == EXCLAMATION)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match = LexStatementParser.ConditionalCompilationPrefix(lexer, ctx);
                                prefix.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                if (match.hit)
                                {
                                    s.end = span.end;
                                    condCompExpr.Reset(new ConditionalCompilationNotNode(s, ctx->ModuleId(), prefix.Release()));
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match = LexStatementParser.ConditionalCompilationPrimary(lexer, ctx);
                                    primary.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, u"conditional compilation primary expression");
                                    }
                                }
                                if (match.hit)
                                {
                                    condCompExpr.Reset(primary.Release());
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrefix");
                    #endif
                    return Match(true, condCompExpr.Release());
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrefix");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationPrefix");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ConditionalCompilationPrimary(LexerFileLexer& lexer, ParsingContext* ctx)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ConditionalCompilationPrimary");
            }
        #endif
        ustring symbol;
        UniquePtr<ConditionalCompilationExpressionNode> expr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Span span = lexer.GetSpan();
                Match match(false);
                if (*lexer == ID)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    symbol = lexer.GetMatch(span);
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                        #endif
                        return Match(true, new ConditionalCompilationPrimaryNode(span, ctx->ModuleId(), symbol));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == LPAREN)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = LexStatementParser.ConditionalCompilationExpression(lexer, ctx);
                                expr.Reset(cast<ConditionalCompilationExpressionNode*>(match.value));
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                long pos = lexer.GetPos();
                                Span span = lexer.GetSpan();
                                Match match(true);
                                Match* parentMatch8 = &match;
                                {
                                    System.Lex.Span span = lexer.GetSpan();
                                    Match match(false);
                                    if (*lexer == RPAREN)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch8 = match;
                                    }
                                    else
                                    {
                                        lexer.ThrowExpectationFailure(span, GetTokenName(RPAREN));
                                    }
                                }
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                                        #endif
                                        return Match(true, new ParenthesizedConditionalCompilationExpressionNode(span, ctx->ModuleId(), expr.Release()));
                                    }
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ConditionalCompilationPrimary");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ConditionalCompilationPrimary");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

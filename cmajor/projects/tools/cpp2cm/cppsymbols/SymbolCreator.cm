using System;
using System.Collections;
using cppast;

namespace cppsymbols
{
    public class SymbolCreator : Visitor
    {
        public nothrow SymbolCreator(SymbolTable& symbolTable_, List<UniquePtr<Exception>>& errors_) : symbolTable(symbolTable_), errors(errors_)
        {
        }
        public override void Visit(CompileUnitNode& compileUnitNode) 
        {
            for (const UniquePtr<SourceFileNode>& sourceFileNode : compileUnitNode.nodes)
            {
                sourceFileNode->Accept(*this);
            }
        }
        public override void Visit(SourceFileNode& sourceFileNode) 
        {
            for (const UniquePtr<Node>& node : sourceFileNode.nodes)
            {
                node->Accept(*this);
            }
        }
        public override void Visit(TemplateDeclarationNode& templateDeclarationNode) 
        {
            List<UniquePtr<TemplateParameterSymbol>>* prevTemplateParameterList = currentTemplateParameterList;
            List<UniquePtr<TemplateParameterSymbol>> templateParameterList;
            currentTemplateParameterList = &templateParameterList;
            for (const UniquePtr<Node>& templateParameter : templateDeclarationNode.templateParameters)
            {
                templateParameter->Accept(*this);
            }
            templateDeclarationNode.declaration->Accept(*this);
            currentTemplateParameterList = prevTemplateParameterList;
        }
        public override void Visit(TemplateParameterNode& templateParameterNode) 
        {
            TemplateParameterSymbol* templateParameterSymbol = new TemplateParameterSymbol(templateParameterNode.span, templateParameterNode.id->str);
            if (!templateParameterNode.defaultTemplateArgument.IsNull())
            {
                templateParameterSymbol->hasDefault = true;
                templateParameterSymbol->defaultArg = templateParameterNode.defaultTemplateArgument.Get();
            }
            if (currentTemplateParameterList != null)
            {
                currentTemplateParameterList->Add(UniquePtr<TemplateParameterSymbol>(templateParameterSymbol));
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("internal error: template parameter list not set", templateParameterNode.span)));
            }
        }
        public override void Visit(ExplicitInstantiationNode& explicitInstantiationNode) 
        {
        }
        public override void Visit(ExplicitSpecializationNode& explicitSpecializationNode) 
        {
        }
        public override void Visit(FloatingLiteralNode& floatingLiteralNode) 
        {
        }
        public override void Visit(IntegerLiteralNode& integerLiteralNode) 
        {
        }
        public override void Visit(CharacterLiteralNode& characterLiteralNode) 
        {
        }
        public override void Visit(StringLiteralNode& stringLiteralNode) 
        {
        }
        public override void Visit(BooleanLiteralNode& booleanLiteralNode) 
        {
        }
        public override void Visit(PointerLiteralNode& pointerLiteralNode) 
        {
        }
        public override void Visit(SimpleTypeNode& simpleTypeNode) 
        {
        }
        public override void Visit(IdentifierNode& identifierNode) 
        {
            if (HasSimpleDeclarationNodeParent(&identifierNode) || HasMemberDeclarationNodeParent(&identifierNode))
            {
                if (currentType == null)
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("internal error: current type is null", identifierNode.span)));
                    return;
                }
                if (symbolTable.container is NamespaceSymbol*)
                {
                    Symbol* s = symbolTable.container->scope.Lookup(identifierNode.str, identifierNode.span, errors);
                    if (s != null)
                    {
                        if (!(s is GlobalVariableSymbol*))
                        {
                            errors.Add(UniquePtr<Exception>(new SymbolException("global variable symbol expected", identifierNode.span)));;
                            return;
                        }
                    }
                    else
                    {
                        GlobalVariableSymbol* globalVariable = new GlobalVariableSymbol(identifierNode.span, identifierNode.str, currentType);
                        symbolTable.container->AddSymbol(globalVariable, errors);
                    }
                }
                else if (symbolTable.container is ClassTypeSymbol*)
                {
                    Symbol* s = symbolTable.container->scope.Lookup(identifierNode.str, identifierNode.span, errors);
                    if (s != null)
                    {
                        if (!(s is MemberVariableSymbol*))
                        {
                            errors.Add(UniquePtr<Exception>(new SymbolException("member variable symbol expected", identifierNode.span)));
                            return;
                        }
                    }
                    else
                    {
                        MemberVariableSymbol* memberVariable = new MemberVariableSymbol(identifierNode.span, identifierNode.str, currentType);
                        symbolTable.container->AddSymbol(memberVariable, errors);
                    }
                }
                else if (symbolTable.container is BlockSymbol*)
                {
                    Symbol* s = symbolTable.container->scope.Lookup(identifierNode.str, identifierNode.span, errors);
                    if (s != null)
                    {
                        if (s is LocalVariableSymbol*)
                        {
                            errors.Add(UniquePtr<Exception>(new SymbolException("local variable symbol of the same name already declared in the current scope", identifierNode.span)));
                            return;
                        }
                        else
                        {
                            errors.Add(UniquePtr<Exception>(new SymbolException("conflicting symbol '" + ToUtf8(s->FullName()) + "'", identifierNode.span)));
                            return;
                        }
                    }
                    else
                    {
                        LocalVariableSymbol* localVariable = new LocalVariableSymbol(identifierNode.span, identifierNode.str, currentType);
                        symbolTable.container->AddSymbol(localVariable, errors);
                    }
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("variable can be declared only in namespace, class or block scope", identifierNode.span)));
                    return;
                }
            }
        }
        public override void Visit(ColonColonNode& colonColonNode) 
        {
            if (HasSimpleDeclarationNodeParent(&colonColonNode) || HasMemberDeclarationNodeParent(&colonColonNode))
            {
                Symbol* s = symbolTable.container->scope.Lookup(colonColonNode.left.Get(), ScopeLookup.this_, colonColonNode.span, errors);
                if (s != null)
                {
                    if (s is ContainerSymbol*)
                    {
                        if (colonColonNode.right.Get() is IdentifierNode*)
                        {
                            symbolTable.BeginContainer(cast<ContainerSymbol*>(s));
                            colonColonNode.right->Accept(*this);
                            symbolTable.EndContainer();
                        }
                        else
                        {
                            errors.Add(UniquePtr<Exception>(new SymbolException("identifier expected", colonColonNode.right->span)));
                            return;
                        }
                    }
                    else
                    {
                        errors.Add(UniquePtr<Exception>(new SymbolException("symbol '" + ToUtf8(s->FullName()) + "' does not denote a container symbol", colonColonNode.left->span)));
                        return;
                    }
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("container symbol '" + MakeNodeString(colonColonNode.left.Get()) + "' not found", colonColonNode.left->span)));
                    return;
                }
            }
        }
        public override void Visit(DotNode& dotNode) 
        {
        }
        public override void Visit(ArrowNode& arrowNode) 
        {
        }
        public override void Visit(TemplateIdNode& templateIdNode) 
        {
        }
        public override void Visit(ConstNode& constNode) 
        {
        }
        public override void Visit(VolatileNode& volatileNode) 
        {
        }
        public override void Visit(PointerNode& pointerNode) 
        {
        }
        public override void Visit(RvalueRefNode& rvalueRefNode) 
        {
        }
        public override void Visit(LvalueRefNode& lvalueRefNode) 
        {
        }
        public override void Visit(ArrayTypeNode& arrayTypeNode) 
        {
        }
        public override void Visit(OperatorFunctionIdNode& operatorFunctionIdNode) 
        {
        }
        public override void Visit(ConversionFunctionIdNode& conversionFunctionIdNode) 
        {
        }
        public override void Visit(FunctionPtrIdNode& functionPtrIdNode) 
        {
        }
        public override void Visit(MemberFunctionPtrIdNode& memberFunctionPtrIdNode) 
        {
        }
        public override void Visit(DestructorIdNode& destructorIdNode) 
        {
        }
        public override void Visit(BinaryExpressionNode& binaryExpressionNode) 
        {
        }
        public override void Visit(UnaryExpressionNode& unaryExpressionNode) 
        {
        }
        public override void Visit(ExpressionListNode& expressionListNode) 
        {
        }
        public override void Visit(ConditionalExpressionNode& conditionalExpressionNode) 
        {
        }
        public override void Visit(ThrowExpressionNode& throwExpressionNode) 
        {
        }
        public override void Visit(CastExpressionNode& castExpressionNode) 
        {
        }
        public override void Visit(PrefixIncrementNode& prefixIncrementNode) 
        {
        }
        public override void Visit(PrefixDecrementNode& prefixDecrementNode) 
        {
        }
        public override void Visit(SizeOfExpressionNode& sizeOfExpressionNode) 
        {
        }
        public override void Visit(AlignOfExpressionNode& alignOfExpressionNode) 
        {
        }
        public override void Visit(NewExpressionNode& newExpressionNode) 
        {
        }
        public override void Visit(DeleteExpressionNode& deleteExpressionNode) 
        {
        }
        public override void Visit(SubscriptExpressionNode& subscriptExpressionNode) 
        {
        }
        public override void Visit(InvokeExpressionNode& invokeExpressionNode) 
        {
        }
        public override void Visit(PostfixIncrementNode& postfixIncrementNode) 
        {
        }
        public override void Visit(PostfixDecrementNode& postfixDecrementNode) 
        {
        }
        public override void Visit(AssignCapture& assignCapture) 
        {
        }
        public override void Visit(RefCapture& refCapture) 
        {
        }
        public override void Visit(IdentifierCapture& identifierCapture) 
        {
        }
        public override void Visit(ThisCapture& thisCapture) 
        {
        }
        public override void Visit(LambdaExpressionNode& lambdaExpressionNode) 
        {
        }
        public override void Visit(ParenthesizedExpressionNode& parenthesizedExpressionNode) 
        {
        }
        public override void Visit(ThisNode& thisNode) 
        {
        }
        public override void Visit(CppCastNode& cppCastNode) 
        {
        }
        public override void Visit(TypeIdNode& typeIdNode) 
        {
        }
        public override void Visit(DefinedNode& definedNode) 
        {
        }
        public override void Visit(InitDeclaratorNode& initDeclaratorNode) 
        {
            initDeclaratorNode.left->Accept(*this);
        }
        public override void Visit(ArrayDeclaratorNode& arrayDeclaratorNode) 
        {
        }
        public override void Visit(InitializerListNode& initializerListNode) 
        {
        }
        public override void Visit(BracedInitializerListNode& bracedInitializerListNode) 
        {
        }
        public override void Visit(AssignmentInitializerNode& assignmentInitializerNode) 
        {
        }
        public override void Visit(FunctionNode& functionNode) 
        {
            functionNode.declarator->Accept(*this);
            if (symbolTable.container is FunctionSymbol*)
            {
                FunctionSymbol* prevFunctionSymbol = currentFunctionSymbol;
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(symbolTable.container);
                currentFunctionSymbol = functionSymbol;
                if (functionSymbol->body != null)
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("function '" + ToUtf8(functionSymbol->FullName()) + "' already has a body", functionNode.span)));
                    currentFunctionSymbol = prevFunctionSymbol;
                    if (currentTemplateParameterList != null)
                    {
                        symbolTable.EndFunctionTemplate();
                    }
                    else
                    {
                        symbolTable.EndFunction();
                    }
                    if (symbolTable.container is FunctionGroupSymbol*)
                    {
                        symbolTable.EndFunctionGroup();
                    }
                    return;
                }
                TypeSymbol* returnType = ResolveType(functionNode.returnTypeExpr.Get(), symbolTable, &functionSymbol->scope, functionNode.span, errors);
                if (functionSymbol->returnType == null)
                {
                    functionSymbol->returnType = returnType;
                }
                else if (functionSymbol->returnType != returnType)
                {
                    errors.Add(UniquePtr<Exception>(
                        new SymbolException("conflicting return type for function '" + ToUtf8(functionSymbol->FullName()) + "'. In declaration '" + ToUtf8(functionSymbol->returnType->FullName()) + 
                        "', in definition '" + ToUtf8(returnType->FullName()) + "'.", functionNode.span)));
                    currentFunctionSymbol = prevFunctionSymbol;
                    if (currentTemplateParameterList != null)
                    {
                        symbolTable.EndFunctionTemplate();
                    }
                    else
                    {
                        symbolTable.EndFunction();
                    }
                    if (symbolTable.container is FunctionGroupSymbol*)
                    {
                        symbolTable.EndFunctionGroup();
                    }
                    return;
                }
                if (!functionNode.body.IsNull())
                {
                    functionNode.body->Accept(*this);
                }
                else
                {
                    // todo default or delete
                }
                currentFunctionSymbol = prevFunctionSymbol;
                symbolTable.EndFunction();
                if (symbolTable.container is FunctionGroupSymbol*)
                {
                    symbolTable.EndFunctionGroup();
                }
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("function declarator not supported", functionNode.span)));
                return;
            }
        }
        public override void Visit(FunctionDeclaratorNode& functionDeclaratorNode) 
        {
            Node* idExprNode = functionDeclaratorNode.idExpr.Get();
            if (idExprNode is ColonColonNode*)
            {
                ColonColonNode* qualifiedId = cast<ColonColonNode*>(idExprNode);
                Symbol* s = symbolTable.container->scope.Lookup(qualifiedId->left.Get(), ScopeLookup.this_and_parent, functionDeclaratorNode.span, errors);
                if (s != null)
                {
                    if (s is ContainerSymbol*)
                    {
                        ContainerSymbol* c = cast<ContainerSymbol*>(s);
                        symbolTable.BeginContainer(c);
                        symbolTable.BeginFunctionGroup(qualifiedId->right.Get(), errors);
                        List<UniquePtr<ParameterSymbol>>* prevParameterList = currentParameterList;
                        List<UniquePtr<ParameterSymbol>> parameterList;
                        currentParameterList = &parameterList;
                        List<UniquePtr<TemplateParameterSymbol>>* prevTemplateParameterList = currentTemplateParameterList;
                        currentTemplateParameterList = null;
                        functionDeclaratorNode.parameters->Accept(*this);
                        currentTemplateParameterList = prevTemplateParameterList;
                        if (currentTemplateParameterList != null)
                        {
                            symbolTable.BeginFunctionTemplate(&functionDeclaratorNode, parameterList, functionDeclaratorNode.cvSpecifiers, functionDeclaratorNode.span, *currentTemplateParameterList, errors);
                        }
                        else
                        {
                            symbolTable.BeginFunction(&functionDeclaratorNode, parameterList, functionDeclaratorNode.cvSpecifiers, functionDeclaratorNode.span, errors);
                        }
                        currentParameterList = prevParameterList;
                    }
                    else
                    {
                        errors.Add(UniquePtr<Exception>(new SymbolException("symbol '" + ToUtf8(s->FullName()) + "' does not denote a container symbol", qualifiedId->left->span)));
                        return;
                    }
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("container symbol '" + MakeNodeString(qualifiedId->left.Get()) + "' not found", qualifiedId->left->span)));
                    return;
                }
            }
            else if (idExprNode is IdentifierNode* || idExprNode is DestructorIdNode* || idExprNode is TemplateIdNode* || idExprNode is OperatorFunctionIdNode* || idExprNode is ConversionFunctionIdNode*)
            {
                symbolTable.BeginFunctionGroup(idExprNode, errors);
                List<UniquePtr<ParameterSymbol>>* prevParameterList = currentParameterList;
                List<UniquePtr<ParameterSymbol>> parameterList;
                currentParameterList = &parameterList;
                List<UniquePtr<TemplateParameterSymbol>>* prevTemplateParameterList = currentTemplateParameterList;
                currentTemplateParameterList = null;
                functionDeclaratorNode.parameters->Accept(*this);
                currentTemplateParameterList = prevTemplateParameterList;
                if (currentTemplateParameterList != null)
                {
                    symbolTable.BeginFunctionTemplate(&functionDeclaratorNode, parameterList, functionDeclaratorNode.cvSpecifiers, functionDeclaratorNode.span, *currentTemplateParameterList, errors);
                }
                else
                {
                    symbolTable.BeginFunction(&functionDeclaratorNode, parameterList, functionDeclaratorNode.cvSpecifiers, functionDeclaratorNode.span, errors);
                }
                currentParameterList = prevParameterList;
            }
            else 
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("function declarator '" + MakeNodeString(idExprNode) + "' not supported", idExprNode->span)));
                return;
            }
        }
        public override void Visit(ParameterNode& parameterNode) 
        {
            if (currentTemplateParameterList != null)
            {
                TypeSymbol* parameterType = ResolveType(parameterNode.typeExpr.Get(), symbolTable, &symbolTable.container->scope, parameterNode.span, errors);
                ustring parameterName;
                if (!parameterNode.name.IsNull())
                {
                    parameterName = ToUtf32(MakeNodeString(parameterNode.name.Get()));
                }                
                TemplateParameterSymbol* templateParameterSymbol = new TemplateParameterSymbol(parameterNode.span, parameterName);
                templateParameterSymbol->type = parameterType;
                currentTemplateParameterList->Add(UniquePtr<TemplateParameterSymbol>(templateParameterSymbol));
            }
            else if (currentParameterList != null)
            {
                TypeSymbol* parameterType = ResolveType(parameterNode.typeExpr.Get(), symbolTable, &symbolTable.container->scope, parameterNode.span, errors);
                ustring parameterName;
                if (!parameterNode.name.IsNull())
                {
                    parameterName = ToUtf32(MakeNodeString(parameterNode.name.Get()));
                }                
                ParameterSymbol* parameterSymbol = new ParameterSymbol(parameterNode.span, parameterName, parameterType);
                currentParameterList->Add(UniquePtr<ParameterSymbol>(parameterSymbol));
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("internal error: template parameter list or parameter list not set", parameterNode.span)));
                return;
            }
        }
        public override void Visit(ParameterListNode& parameterListNode) 
        {
            for (const UniquePtr<ParameterNode>& parameterNode : parameterListNode.nodes)
            {
                parameterNode->Accept(*this);
            }
        }
        public override void Visit(SimpleDeclarationNode& simpleDeclarationNode) 
        {
            TypeSymbol* type = ResolveType(simpleDeclarationNode.typeExpr.Get(), symbolTable, &symbolTable.container->scope, simpleDeclarationNode.span, errors);
            TypeSymbol* prevType = currentType;
            currentType = type;
            simpleDeclarationNode.declarator->Accept(*this);
            if (symbolTable.container is FunctionSymbol*)
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(symbolTable.container);
                functionSymbol->returnType = type;
                if (currentTemplateParameterList != null)
                {
                    symbolTable.EndFunctionTemplate();
                }
                else
                {
                    symbolTable.EndFunction();
                }
                if (symbolTable.container is FunctionGroupSymbol*)
                {
                    symbolTable.EndFunctionGroup();
                }
            }
            currentType = prevType;
        }
        public override void Visit(UsingTypeDeclarationNode& usingTypeDeclarationNode) 
        {
            TypeSymbol* type = ResolveType(usingTypeDeclarationNode.typeExpr.Get(), symbolTable, &symbolTable.container->scope, usingTypeDeclarationNode.span, errors);
            TypeAliasSymbol* typeAlias = new TypeAliasSymbol(usingTypeDeclarationNode.span, usingTypeDeclarationNode.id->str, type);
            symbolTable.container->AddSymbol(typeAlias, errors);
        }
        public override void Visit(UsingDirectiveNode& usingDirectiveNode) 
        {
            Symbol* s = symbolTable.container->scope.Lookup(usingDirectiveNode.child.Get(), ScopeLookup.this_and_parent, usingDirectiveNode.span, errors);
            if (s != null)
            {
                if (s is NamespaceSymbol*)
                {
                    NamespaceSymbol* ns = cast<NamespaceSymbol*>(s);
                    NamespaceImportSymbol* namespaceImport = new NamespaceImportSymbol(usingDirectiveNode.span, ns);
                    symbolTable.container->AddSymbol(namespaceImport, errors);
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("namespace symbol expected", usingDirectiveNode.child->span)));
                    return;
                }
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("namespace symbol not found", usingDirectiveNode.child->span)));
                return;
            }
        }
        public override void Visit(UsingDeclarationNode& usingDeclarationNode) 
        {
            Symbol* s = symbolTable.container->scope.Lookup(usingDeclarationNode.child.Get(), ScopeLookup.this_and_bases_and_parent, usingDeclarationNode.span, errors);
            if (s != null)
            {
                AliasSymbol* alias = new AliasSymbol(usingDeclarationNode.span, s->name, s);
                symbolTable.container->AddSymbol(alias, errors);
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("symbol not found", usingDeclarationNode.child->span)));
                return;
            }
        }
        public override void Visit(StaticAssertDeclarationNode& staticAssertDeclarationNode) 
        {
        }
        public override void Visit(TypedefDeclarationNode& typedefDeclarationNode) 
        {
            TypeSymbol* type = ResolveType(typedefDeclarationNode.left.Get(), symbolTable, &symbolTable.container->scope, typedefDeclarationNode.span, errors);
            if (typedefDeclarationNode.right.Get() is IdentifierNode*)
            {
                IdentifierNode* id = cast<IdentifierNode*>(typedefDeclarationNode.right.Get());
                TypedefSymbol* typedefSymbol = new TypedefSymbol(typedefDeclarationNode.span, id->str, type);
                symbolTable.container->AddSymbol(typedefSymbol, errors);
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("identifier expected", typedefDeclarationNode.right->span)));
                return;
            }
        }
        public override void Visit(LinkageSpecificationNode& linkageSpecificationNode) 
        {
        }
        public override void Visit(NamespaceNode& namespaceNode) 
        {
            int idCount = 0;
            NamespaceSymbol* ns = null;
            symbolTable.BeginNamespace(namespaceNode.span, namespaceNode.id.Get(), idCount, errors);
            ns = cast<NamespaceSymbol*>(symbolTable.container);
            symbolTable.MapNode(&namespaceNode, ns);
            for (const UniquePtr<Node>& node : namespaceNode.nodes)
            {
                node->Accept(*this);
            }
            for (int i = 0; i < idCount; ++i)
            {
                symbolTable.EndNamespace();
            }
            if (ns->isUnnamedNs)
            {
                symbolTable.EndNamespace();
                NamespaceImportSymbol* namespaceImport = new NamespaceImportSymbol(namespaceNode.span, ns);
                symbolTable.container->AddSymbol(namespaceImport, errors);
            }
        }
        public override void Visit(ForwardClassDeclarationNode& forwardClassDeclarationNode) 
        {
            Node* classNameNode = forwardClassDeclarationNode.className.Get();
            if (classNameNode is ColonColonNode*)
            {
                ColonColonNode* qualifiedId = cast<ColonColonNode*>(classNameNode);
                Symbol* s = symbolTable.container->scope.Lookup(qualifiedId->left.Get(), ScopeLookup.this_and_parent, forwardClassDeclarationNode.span, errors);
                if (s != null)
                {
                    if (s is ContainerSymbol*)
                    {
                        ContainerSymbol* c = cast<ContainerSymbol*>(s);
                        symbolTable.BeginContainer(c);
                        symbolTable.BeginClassGroup(qualifiedId->right.Get(), errors);
                        if (currentTemplateParameterList != null)
                        { 
                            symbolTable.BeginClassTemplate(&forwardClassDeclarationNode, forwardClassDeclarationNode.classKey, forwardClassDeclarationNode.span, *currentTemplateParameterList, errors);
                            symbolTable.EndClassTemplate();
                        }
                        else
                        {
                            symbolTable.BeginClass(&forwardClassDeclarationNode, forwardClassDeclarationNode.classKey, forwardClassDeclarationNode.span, 0, errors);
                            symbolTable.EndClass();
                        }                
                        symbolTable.EndClassGroup();
                        symbolTable.EndContainer();
                    }
                    else
                    {
                        errors.Add(UniquePtr<Exception>(new SymbolException("symbol '" + ToUtf8(s->FullName()) + "' does not denote a container symbol", qualifiedId->left->span)));
                        return;
                    }
                }  
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("container symbol '" + MakeNodeString(qualifiedId->left.Get()) + "' not found", qualifiedId->left->span)));
                    return;
                }          
            }
            else if (classNameNode is IdentifierNode*)
            {
                symbolTable.BeginClassGroup(classNameNode, errors);
                symbolTable.BeginClass(&forwardClassDeclarationNode, forwardClassDeclarationNode.classKey, forwardClassDeclarationNode.span, 0, errors);
                symbolTable.EndClass();
                symbolTable.EndClassGroup();
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("class declarator '" + MakeNodeString(classNameNode) + "' not supported", classNameNode->span)));
                return;
            }
        }
        public override void Visit(ClassNode& classNode) 
        {
            Node* classNameNode = classNode.className.Get();
            if (classNameNode is ColonColonNode*)
            {
                ColonColonNode* qualifiedId = cast<ColonColonNode*>(classNameNode);
                Symbol* s = symbolTable.container->scope.Lookup(qualifiedId->left.Get(), ScopeLookup.this_and_parent, classNode.span, errors);
                if (s != null)
                {
                    if (s is ContainerSymbol*)
                    {
                        ContainerSymbol* c = cast<ContainerSymbol*>(s);
                        symbolTable.BeginContainer(c);
                        symbolTable.BeginClassGroup(qualifiedId->right.Get(), errors);
                        if (currentTemplateParameterList != null)
                        { 
                            symbolTable.BeginClassTemplate(&classNode, classNode.classKey, classNode.span, *currentTemplateParameterList, errors);
                        }
                        else
                        {
                            symbolTable.BeginClass(&classNode, classNode.classKey, classNode.span, 0, errors);
                        }                
                        if (!classNode.baseClasses.IsNull())
                        {
                            classNode.baseClasses->Accept(*this);
                        }
                        for (const UniquePtr<Node>& memberDeclaration : classNode.memberDeclarations)
                        {
                            memberDeclaration->Accept(*this);
                        }
                        symbolTable.EndClass();
                        symbolTable.EndClassGroup();
                        symbolTable.EndContainer();
                    }
                    else
                    {
                        errors.Add(UniquePtr<Exception>(new SymbolException("symbol '" + ToUtf8(s->FullName()) + "' does not denote a container symbol", qualifiedId->left->span)));
                        return;
                    }
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("container symbol '" + MakeNodeString(qualifiedId->left.Get()) + "' not found", qualifiedId->left->span)));
                    return;
                }
            }
            else if (classNameNode is IdentifierNode*)
            {
                symbolTable.BeginClassGroup(classNameNode, errors);
                if (currentTemplateParameterList != null)
                { 
                    symbolTable.BeginClassTemplate(&classNode, classNode.classKey, classNode.span, *currentTemplateParameterList, errors);
                }
                else
                {
                    symbolTable.BeginClass(&classNode, classNode.classKey, classNode.span, 0, errors);
                }                
                if (!classNode.baseClasses.IsNull())
                {
                    classNode.baseClasses->Accept(*this);
                }
                for (const UniquePtr<Node>& memberDeclaration : classNode.memberDeclarations)
                {
                    memberDeclaration->Accept(*this);
                }
                if (currentTemplateParameterList != null)
                {
                    symbolTable.EndClassTemplate();
                }            
                else
                {
                    symbolTable.EndClass();
                }                
                symbolTable.EndClassGroup();
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("class declarator '" + MakeNodeString(classNameNode) + "' not supported", classNameNode->span)));
                return;
            }
        }
        public override void Visit(BaseClassListNode& baseClassListNode) 
        {
            for (const UniquePtr<BaseClassNode>& baseClassNode : baseClassListNode.nodes)
            {
                baseClassNode->Accept(*this);
            }
        }
        public override void Visit(BaseClassNode& baseClassNode) 
        {
            Node* baseClassName = baseClassNode.baseClassName.Get();
            TypeSymbol* baseType = ResolveType(baseClassName, symbolTable, &symbolTable.container->scope, baseClassNode.span, errors);
            if (baseType is ClassTypeSymbol*)
            {
                ClassTypeSymbol* baseClassType = cast<ClassTypeSymbol*>(baseType);
                if (symbolTable.container is ClassTypeSymbol*)
                {
                    ClassTypeSymbol* classType = cast<ClassTypeSymbol*>(symbolTable.container);
                    classType->AddBaseClass(baseClassType);
                }
                else
                {
                    errors.Add(UniquePtr<Exception>(new SymbolException("internal error: class type expected", baseClassNode.span)));
                    return;
                }
            }
            else if (baseType is ExternalTypeSymbol*)
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("type symbol '" + ToUtf8(baseType->FullName()) + "' is external", baseClassNode.span)));
                return;
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("type symbol '" + ToUtf8(baseType->FullName()) + "' does not denote a class type", baseClassNode.span)));
                return;
            }
        }
        public override void Visit(MemberDeclarationNode& memberDeclarationNode) 
        {
            TypeSymbol* type = null;
            if (!memberDeclarationNode.type.IsNull())
            {
                type = ResolveType(memberDeclarationNode.type.Get(), symbolTable, &symbolTable.container->scope, memberDeclarationNode.span, errors);
            }            
            TypeSymbol* prevType = currentType;
            currentType = type;
            memberDeclarationNode.declarator->Accept(*this);
            currentType = prevType;
            if (symbolTable.container is FunctionSymbol*)
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(symbolTable.container);
                functionSymbol->returnType = type;
                if (currentTemplateParameterList != null)
                {
                    symbolTable.EndFunctionTemplate();
                }
                else
                {
                    symbolTable.EndFunction();
                }
                if (symbolTable.container is FunctionGroupSymbol*)
                {
                    symbolTable.EndFunctionGroup();
                }
            }
        }
        public override void Visit(SpecialMemberFunctionNode& specialMemberFunctionNode) 
        {
            specialMemberFunctionNode.declarator->Accept(*this);
            if (symbolTable.container is FunctionSymbol*)
            {
                FunctionSymbol* functionSymbol = cast<FunctionSymbol*>(symbolTable.container);
                if (!specialMemberFunctionNode.body.IsNull())
                {
                    specialMemberFunctionNode.body->Accept(*this);
                }
                else
                {
                    // todo default or delete
                }
                symbolTable.EndFunction();
                if (symbolTable.container is FunctionGroupSymbol*)
                {
                    symbolTable.EndFunctionGroup();
                }
            }
            else
            {
                errors.Add(UniquePtr<Exception>(new SymbolException("special member function expected", specialMemberFunctionNode.span)));
                return;
            }
        }
        public override void Visit(CtorInitializerNode& ctorInitializerNode) 
        {
        }
        public override void Visit(MemberInitializerNode& memberInitializerNode) 
        {
        }
        public override void Visit(LabeledStatementNode& labeledStatementNode) 
        {
            labeledStatementNode.statement->Accept(*this);
        }
        public override void Visit(CaseStatementNode& caseStatementNode) 
        {
            caseStatementNode.statement->Accept(*this);
        }
        public override void Visit(DefaultStatementNode& defaultStatementNode) 
        {
            defaultStatementNode.statement->Accept(*this);
        }
        public override void Visit(ExpressionStatementNode& expressionStatementNode) 
        {
        }
        public override void Visit(CompoundStatementNode& compoundStatementNode) 
        {
            symbolTable.BeginBlock(&compoundStatementNode, compoundStatementNode.span, errors);
            for (const UniquePtr<StatementNode>& statement : compoundStatementNode.statements)
            {
                statement->Accept(*this);
            }
            symbolTable.EndBlock();
        }
        public override void Visit(EnumTypeNode& enumTypeNode) 
        {
        }
        public override void Visit(EnumeratorNode& enumeratorNode) 
        {
        }
        public override void Visit(IfStatementNode& ifStatementNode) 
        {
            if (ifStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.BeginBlock(&ifStatementNode, ifStatementNode.span, errors);
            }            
            ifStatementNode.condition->Accept(*this);
            ifStatementNode.thenS->Accept(*this);
            if (!ifStatementNode.elseS.IsNull())
            {
                ifStatementNode.elseS->Accept(*this);
            }
            if (ifStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.EndBlock();
            }            
        }
        public override void Visit(SwitchStatementNode& switchStatementNode) 
        {
            if (switchStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.BeginBlock(&switchStatementNode, switchStatementNode.span, errors);
            }            
            switchStatementNode.condition->Accept(*this);
            switchStatementNode.statement->Accept(*this);
            if (switchStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.EndBlock();
            }            
        }
        public override void Visit(WhileStatementNode& whileStatementNode) 
        {
            if (whileStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.BeginBlock(&whileStatementNode, whileStatementNode.span, errors);
            }            
            whileStatementNode.condition->Accept(*this);
            whileStatementNode.statement->Accept(*this);
            if (whileStatementNode.condition.Get() is SimpleDeclarationNode*)
            {
                symbolTable.EndBlock();
            }            
        }
        public override void Visit(DoStatementNode& doStatementNode) 
        {
            doStatementNode.statement->Accept(*this);
        }
        public override void Visit(RangeForStatementNode& rangeForStatementNode) 
        {
            symbolTable.BeginBlock(&rangeForStatementNode, rangeForStatementNode.span, errors);
            rangeForStatementNode.forRangeDeclaration->Accept(*this);
            rangeForStatementNode.statement->Accept(*this);
            symbolTable.EndBlock();
        }
        public override void Visit(ForStatementNode& forStatementNode) 
        {
            if (!forStatementNode.forInitialization.IsNull())
            {
                if (forStatementNode.forInitialization.Get() is SimpleDeclarationNode*)
                {
                    symbolTable.BeginBlock(&forStatementNode, forStatementNode.span, errors);
                }
                forStatementNode.forInitialization->Accept(*this);
            }
            forStatementNode.statement->Accept(*this);
            if (!forStatementNode.forInitialization.IsNull())
            {
                if (forStatementNode.forInitialization.Get() is SimpleDeclarationNode*)
                {
                    symbolTable.EndBlock();
                }
            }
        }
        public override void Visit(BreakStatementNode& breakStatementNode) 
        {
        }
        public override void Visit(ContinueStatementNode& continueStatementNode) 
        {
        }
        public override void Visit(ReturnStatementNode& returnStatementNode) 
        {
        }
        public override void Visit(GotoStatementNode& gotoStatementNode) 
        {
        }
        public override void Visit(DeclarationStatementNode& declarationStatementNode) 
        {
            declarationStatementNode.declaration->Accept(*this);
        }
        public override void Visit(TryStatementNode& tryStatementNode) 
        {
            tryStatementNode.tryBlock->Accept(*this);
            for (const UniquePtr<ExceptionHandlerNode>& handler : tryStatementNode.handlers)
            {
                handler->Accept(*this);
            }
        }
        public override void Visit(ExceptionHandlerNode& exceptionHandlerNode) 
        {
            exceptionHandlerNode.exceptionDeclaration->Accept(*this);
            exceptionHandlerNode.catchBlock->Accept(*this);
        }
        public override void Visit(CatchAllNode& catchAllNode) 
        {
        }
        private List<UniquePtr<Exception>>& errors;
        private SymbolTable& symbolTable;
        private FunctionSymbol* currentFunctionSymbol;
        private List<UniquePtr<ParameterSymbol>>* currentParameterList;
        private List<UniquePtr<TemplateParameterSymbol>>* currentTemplateParameterList;
        private TypeSymbol* currentType;
    }
}

using System;
using System.Collections;
using System.Text.Parsing;
using cppparser;
using cppast;

// this source file has been automatically generated from 'PPFileGrammar.parser' using cmparsergen version 2.0.0.

namespace pp
{
    public class PPNonemptyTokenLineGrammar : System.Text.Parsing.Grammar
    {
        public PPNonemptyTokenLineGrammar() : this(new ParsingDomain())
        {
        }
        public PPNonemptyTokenLineGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("PPNonemptyTokenLineGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("pp")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, bool process, ustring* result, PP* pp, PPTokenFlags flags)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<bool>(process)));
            stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(result)));
            stack.Push(UniquePtr<Object>(new ValueObject<PP*>(pp)));
            stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(flags)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("pp.PPFileGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new pp.PPFileGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("NonemptyTokenLine"), this, ToUtf32("PPFileGrammar.NonemptyTokenLine")));
            SetStartRuleName(ToUtf32("NonemptyTokenLine"));
        }
    }
} // pp
namespace pp
{
    public class PPMacroReplacementGrammar : System.Text.Parsing.Grammar
    {
        public PPMacroReplacementGrammar() : this(new ParsingDomain())
        {
        }
        public PPMacroReplacementGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("PPMacroReplacementGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("pp")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public ustring Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, FunctionMacro* macro, List<ustring>* args, PP* pp, PPTokenFlags flags)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<FunctionMacro*>(macro)));
            stack.Push(UniquePtr<Object>(new ValueObject<List<ustring>*>(args)));
            stack.Push(UniquePtr<Object>(new ValueObject<PP*>(pp)));
            stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(flags)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            ustring result = *cast<ValueObject<ustring>*>(value.Get());
            return result;
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("pp.PPFileGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new pp.PPFileGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("MacroReplacement"), this, ToUtf32("PPFileGrammar.MacroReplacement")));
            SetStartRuleName(ToUtf32("MacroReplacement"));
        }
    }
} // pp
namespace pp
{
    public class PPPossiblyEmptyTokenLineGrammar : System.Text.Parsing.Grammar
    {
        public PPPossiblyEmptyTokenLineGrammar() : this(new ParsingDomain())
        {
        }
        public PPPossiblyEmptyTokenLineGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("PPPossiblyEmptyTokenLineGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("pp")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, bool process, ustring* result, PP* pp, PPTokenFlags flags)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<bool>(process)));
            stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(result)));
            stack.Push(UniquePtr<Object>(new ValueObject<PP*>(pp)));
            stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(flags)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("pp.PPFileGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new pp.PPFileGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("PossiblyEmptyTokenLine"), this, ToUtf32("PPFileGrammar.PossiblyEmptyTokenLine")));
            SetStartRuleName(ToUtf32("PossiblyEmptyTokenLine"));
        }
    }
} // pp
namespace pp
{
    public class PPFileGrammar : System.Text.Parsing.Grammar
    {
        public PPFileGrammar() : this(new ParsingDomain())
        {
        }
        public PPFileGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("PPFileGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("pp")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, PP* pp, ustring* result)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<PP*>(pp)));
            stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(result)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class PPFileRule : System.Text.Parsing.RuleParser
        {
            public PPFileRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* groupNonterminalParser = GetNonterminal(ToUtf32("Group"));
                groupNonterminalParser->SetPre(PreGroup);
            }
            public void PreGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(true)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), result()
                {
                }
                public PP* pp;
                public ustring* result;
            }
        }

        public class GroupRule : System.Text.Parsing.RuleParser
        {
            public GroupRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* ifSectionNonterminalParser = GetNonterminal(ToUtf32("IfSection"));
                ifSectionNonterminalParser->SetPre(PreIfSection);
                NonterminalParser* controlLineNonterminalParser = GetNonterminal(ToUtf32("ControlLine"));
                controlLineNonterminalParser->SetPre(PreControlLine);
                NonterminalParser* textLineNonterminalParser = GetNonterminal(ToUtf32("TextLine"));
                textLineNonterminalParser->SetPre(PreTextLine);
            }
            public void PreIfSection(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreControlLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreTextLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
            }
        }

        public class IfSectionRule : System.Text.Parsing.RuleParser
        {
            public IfSectionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("parentProcess")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("processed")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("processGroup")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> parentProcess_value = stack.Pop();
                context->parentProcess = *cast<ValueObject<bool>*>(parentProcess_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* ifGroupNonterminalParser = GetNonterminal(ToUtf32("IfGroup"));
                ifGroupNonterminalParser->SetPre(PreIfGroup);
                ifGroupNonterminalParser->SetPost(PostIfGroup);
                NonterminalParser* elifGroupNonterminalParser = GetNonterminal(ToUtf32("ElifGroup"));
                elifGroupNonterminalParser->SetPre(PreElifGroup);
                elifGroupNonterminalParser->SetPost(PostElifGroup);
                NonterminalParser* elseGroupNonterminalParser = GetNonterminal(ToUtf32("ElseGroup"));
                elseGroupNonterminalParser->SetPre(PreElseGroup);
                NonterminalParser* endIfLineNonterminalParser = GetNonterminal(ToUtf32("EndIfLine"));
                endIfLineNonterminalParser->SetPre(PreEndIfLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->processed = context->fromIfGroup;
                if (context->parentProcess && !context->processed) context->processGroup = true; else context->processGroup = false;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->fromElifGroup) context->processed = true;
                if (context->parentProcess && !context->processed) context->processGroup = true; else context->processGroup = false;
            }
            public void PreIfGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->parentProcess)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PostIfGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIfGroup_value = stack.Pop();
                    context->fromIfGroup = *cast<ValueObject<bool>*>(fromIfGroup_value.Get());
                }
            }
            public void PreElifGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->processGroup)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PostElifGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromElifGroup_value = stack.Pop();
                    context->fromElifGroup = *cast<ValueObject<bool>*>(fromElifGroup_value.Get());
                }
            }
            public void PreElseGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->processGroup)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreEndIfLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), parentProcess(), result(), processed(), processGroup(), fromIfGroup(), fromElifGroup()
                {
                }
                public PP* pp;
                public bool parentProcess;
                public ustring* result;
                public bool processed;
                public bool processGroup;
                public bool fromIfGroup;
                public bool fromElifGroup;
            }
        }

        public class IfGroupRule : System.Text.Parsing.RuleParser
        {
            public IfGroupRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("parentProcess")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("bool"));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> parentProcess_value = stack.Pop();
                context->parentProcess = *cast<ValueObject<bool>*>(parentProcess_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                NonterminalParser* constantExpressionNonterminalParser = GetNonterminal(ToUtf32("ConstantExpression"));
                constantExpressionNonterminalParser->SetPre(PreConstantExpression);
                constantExpressionNonterminalParser->SetPost(PostConstantExpression);
                NonterminalParser* g1NonterminalParser = GetNonterminal(ToUtf32("g1"));
                g1NonterminalParser->SetPre(Preg1);
                NonterminalParser* i1NonterminalParser = GetNonterminal(ToUtf32("i1"));
                i1NonterminalParser->SetPost(Posti1);
                NonterminalParser* g2NonterminalParser = GetNonterminal(ToUtf32("g2"));
                g2NonterminalParser->SetPre(Preg2);
                NonterminalParser* i2NonterminalParser = GetNonterminal(ToUtf32("i2"));
                i2NonterminalParser->SetPost(Posti2);
                NonterminalParser* g3NonterminalParser = GetNonterminal(ToUtf32("g3"));
                g3NonterminalParser->SetPre(Preg3);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->process;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->process = context->parentProcess && context->fromConstantExpression;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->process;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->process = context->parentProcess && context->pp->Defined(context->fromi1);
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->process;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->process = context->parentProcess && !context->pp->Defined(context->fromi2);
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void PreConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->parentProcess)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
            }
            public void PostConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstantExpression_value = stack.Pop();
                    context->fromConstantExpression = *cast<ValueObject<bool>*>(fromConstantExpression_value.Get());
                }
            }
            public void Preg1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void Posti1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromi1_value = stack.Pop();
                    context->fromi1 = *cast<ValueObject<ustring>*>(fromi1_value.Get());
                }
            }
            public void Preg2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void Posti2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromi2_value = stack.Pop();
                    context->fromi2 = *cast<ValueObject<ustring>*>(fromi2_value.Get());
                }
            }
            public void Preg3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), parentProcess(), result(), value(), process(), fromConstantExpression(), fromi1(), fromi2()
                {
                }
                public PP* pp;
                public bool parentProcess;
                public ustring* result;
                public bool value;
                public bool process;
                public bool fromConstantExpression;
                public ustring fromi1;
                public ustring fromi2;
            }
        }

        public class ElifGroupRule : System.Text.Parsing.RuleParser
        {
            public ElifGroupRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                SetValueTypeName(ToUtf32("bool"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* constantExpressionNonterminalParser = GetNonterminal(ToUtf32("ConstantExpression"));
                constantExpressionNonterminalParser->SetPre(PreConstantExpression);
                constantExpressionNonterminalParser->SetPost(PostConstantExpression);
                NonterminalParser* groupNonterminalParser = GetNonterminal(ToUtf32("Group"));
                groupNonterminalParser->SetPre(PreGroup);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->process;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->process = context->fromConstantExpression;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void PreConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
            }
            public void PostConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstantExpression_value = stack.Pop();
                    context->fromConstantExpression = *cast<ValueObject<bool>*>(fromConstantExpression_value.Get());
                }
            }
            public void PreGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), value(), fromConstantExpression()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public bool value;
                public bool fromConstantExpression;
            }
        }

        public class ElseGroupRule : System.Text.Parsing.RuleParser
        {
            public ElseGroupRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* groupNonterminalParser = GetNonterminal(ToUtf32("Group"));
                groupNonterminalParser->SetPre(PreGroup);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void PreGroup(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
            }
        }

        public class EndIfLineRule : System.Text.Parsing.RuleParser
        {
            public EndIfLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), result()
                {
                }
                public PP* pp;
                public ustring* result;
            }
        }

        public class ControlLineRule : System.Text.Parsing.RuleParser
        {
            public ControlLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* includeDirectiveNonterminalParser = GetNonterminal(ToUtf32("IncludeDirective"));
                includeDirectiveNonterminalParser->SetPre(PreIncludeDirective);
                NonterminalParser* defineFunctionMacroNonterminalParser = GetNonterminal(ToUtf32("DefineFunctionMacro"));
                defineFunctionMacroNonterminalParser->SetPre(PreDefineFunctionMacro);
                NonterminalParser* defineObjectMacroNonterminalParser = GetNonterminal(ToUtf32("DefineObjectMacro"));
                defineObjectMacroNonterminalParser->SetPre(PreDefineObjectMacro);
                NonterminalParser* undefineMacroNonterminalParser = GetNonterminal(ToUtf32("UndefineMacro"));
                undefineMacroNonterminalParser->SetPre(PreUndefineMacro);
                NonterminalParser* pragmaDirectiveNonterminalParser = GetNonterminal(ToUtf32("PragmaDirective"));
                pragmaDirectiveNonterminalParser->SetPre(PrePragmaDirective);
                NonterminalParser* errorDirectiveNonterminalParser = GetNonterminal(ToUtf32("ErrorDirective"));
                errorDirectiveNonterminalParser->SetPre(PreErrorDirective);
                NonterminalParser* lineDirectiveNonterminalParser = GetNonterminal(ToUtf32("LineDirective"));
                lineDirectiveNonterminalParser->SetPre(PreLineDirective);
                NonterminalParser* nullDirectiveNonterminalParser = GetNonterminal(ToUtf32("NullDirective"));
                nullDirectiveNonterminalParser->SetPre(PreNullDirective);
            }
            public void PreIncludeDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreDefineFunctionMacro(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreDefineObjectMacro(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreUndefineMacro(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PrePragmaDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreErrorDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreLineDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void PreNullDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
            }
        }

        public class IncludeDirectiveRule : System.Text.Parsing.RuleParser
        {
            public IncludeDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("headerNameText")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* nonemptyTokenLineNonterminalParser = GetNonterminal(ToUtf32("NonemptyTokenLine"));
                nonemptyTokenLineNonterminalParser->SetPre(PreNonemptyTokenLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) Preprocess(*context->pp, context->pp->ResolveHeaderFilePath(ToUtf8(context->headerNameText)));
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void PreNonemptyTokenLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->headerNameText)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(PPTokenFlags.acceptHeaderName)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), headerNameText()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public ustring headerNameText;
            }
        }

        public class DefineFunctionMacroRule : System.Text.Parsing.RuleParser
        {
            public DefineFunctionMacroRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("replacementList")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("identifier"));
                identifierNonterminalParser->SetPost(Postidentifier);
                NonterminalParser* macroParamsNonterminalParser = GetNonterminal(ToUtf32("MacroParams"));
                macroParamsNonterminalParser->SetPost(PostMacroParams);
                NonterminalParser* possiblyEmptyTokenLineNonterminalParser = GetNonterminal(ToUtf32("PossiblyEmptyTokenLine"));
                possiblyEmptyTokenLineNonterminalParser->SetPre(PrePossiblyEmptyTokenLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->pp->Define(context->fromidentifier, context->fromMacroParams, context->replacementList, span);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void Postidentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context->fromidentifier = *cast<ValueObject<ustring>*>(fromidentifier_value.Get());
                }
            }
            public void PostMacroParams(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromMacroParams_value = stack.Pop();
                    context->fromMacroParams = *cast<ValueObject<List<ustring>>*>(fromMacroParams_value.Get());
                }
            }
            public void PrePossiblyEmptyTokenLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->replacementList)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(PPTokenFlags.acceptHeaderName | PPTokenFlags.acceptHash))));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), replacementList(), fromidentifier(), fromMacroParams()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public ustring replacementList;
                public ustring fromidentifier;
                public List<ustring> fromMacroParams;
            }
        }

        public class MacroParamsRule : System.Text.Parsing.RuleParser
        {
            public MacroParamsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("List<ustring>"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<List<ustring>>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Add(context->fromleft);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Add(context->fromright);
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<ustring>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<ustring>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromleft(), fromright()
                {
                }
                public List<ustring> value;
                public ustring fromleft;
                public ustring fromright;
            }
        }

        public class DefineObjectMacroRule : System.Text.Parsing.RuleParser
        {
            public DefineObjectMacroRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("replacementList")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("identifier"));
                identifierNonterminalParser->SetPost(Postidentifier);
                NonterminalParser* possiblyEmptyTokenLineNonterminalParser = GetNonterminal(ToUtf32("PossiblyEmptyTokenLine"));
                possiblyEmptyTokenLineNonterminalParser->SetPre(PrePossiblyEmptyTokenLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->pp->Define(context->fromidentifier, context->replacementList, false);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void Postidentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context->fromidentifier = *cast<ValueObject<ustring>*>(fromidentifier_value.Get());
                }
            }
            public void PrePossiblyEmptyTokenLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->replacementList)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(PPTokenFlags.acceptHeaderName)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), replacementList(), fromidentifier()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public ustring replacementList;
                public ustring fromidentifier;
            }
        }

        public class UndefineMacroRule : System.Text.Parsing.RuleParser
        {
            public UndefineMacroRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* macroNameNonterminalParser = GetNonterminal(ToUtf32("macroName"));
                macroNameNonterminalParser->SetPost(PostmacroName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->pp->Undefine(context->frommacroName);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public void PostmacroName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frommacroName_value = stack.Pop();
                    context->frommacroName = *cast<ValueObject<ustring>*>(frommacroName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), frommacroName()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public ustring frommacroName;
            }
        }

        public class PragmaDirectiveRule : System.Text.Parsing.RuleParser
        {
            public PragmaDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : result()
                {
                }
                public ustring* result;
            }
        }

        public class ErrorDirectiveRule : System.Text.Parsing.RuleParser
        {
            public ErrorDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process)
                {
                    context->result->Append(ustring(matchBegin, matchEnd));
                    ThrowPreprocessingException(ToUtf8(ustring(matchBegin, matchEnd)));
                }
                else
                {
                    context->result->Append('\n');
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), result()
                {
                }
                public bool process;
                public ustring* result;
            }
        }

        public class LineDirectiveRule : System.Text.Parsing.RuleParser
        {
            public LineDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : result()
                {
                }
                public ustring* result;
            }
        }

        public class NullDirectiveRule : System.Text.Parsing.RuleParser
        {
            public NullDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->result->Append('\n');
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : result()
                {
                }
                public ustring* result;
            }
        }

        public class ConstantExpressionRule : System.Text.Parsing.RuleParser
        {
            public ConstantExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                SetValueTypeName(ToUtf32("bool"));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("constantExpressionText")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* nonemptyTokenLineNonterminalParser = GetNonterminal(ToUtf32("NonemptyTokenLine"));
                nonemptyTokenLineNonterminalParser->SetPre(PreNonemptyTokenLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->value = EvaluateConstantExpression(context->constantExpressionText, context->pp, span.lineNumber); else context->value = false;
            }
            public void PreNonemptyTokenLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->constantExpressionText)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(PPTokenFlags.none)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), pp(), value(), constantExpressionText()
                {
                }
                public bool process;
                public PP* pp;
                public bool value;
                public ustring constantExpressionText;
            }
        }

        public class TextLineRule : System.Text.Parsing.RuleParser
        {
            public TextLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("replacementText")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* possiblyEmptyTokenLineNonterminalParser = GetNonterminal(ToUtf32("PossiblyEmptyTokenLine"));
                possiblyEmptyTokenLineNonterminalParser->SetPre(PrePossiblyEmptyTokenLine);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(context->replacementText);
                context->result->Append('\n');
            }
            public void PrePossiblyEmptyTokenLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->replacementText)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(PPTokenFlags.none)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), process(), result(), replacementText()
                {
                }
                public PP* pp;
                public bool process;
                public ustring* result;
                public ustring replacementText;
            }
        }

        public class PossiblyEmptyTokenLineRule : System.Text.Parsing.RuleParser
        {
            public PossiblyEmptyTokenLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("substituted")));
                AddLocalVariable(AttrOrVar(ToUtf32("int"), ToUtf32("parenCount")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* pPTokenNonterminalParser = GetNonterminal(ToUtf32("PPToken"));
                pPTokenNonterminalParser->SetPre(PrePPToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->substituted = false;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->substituted)
                {
                    *context->result = ParsePossiblyEmptyTokenLine(context->process, *context->result, context->pp, context->flags);
                }
            }
            public void PrePPToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(context->flags | PPTokenFlags.acceptFunctionMacroInvocaction))));
                stack.Push(UniquePtr<Object>(new ValueObject<bool*>(&context->substituted)));
                stack.Push(UniquePtr<Object>(new ValueObject<int*>(&context->parenCount)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), result(), pp(), flags(), substituted(), parenCount()
                {
                }
                public bool process;
                public ustring* result;
                public PP* pp;
                public PPTokenFlags flags;
                public bool substituted;
                public int parenCount;
            }
        }

        public class NonemptyTokenLineRule : System.Text.Parsing.RuleParser
        {
            public NonemptyTokenLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("substituted")));
                AddLocalVariable(AttrOrVar(ToUtf32("int"), ToUtf32("parenCount")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* pPTokenNonterminalParser = GetNonterminal(ToUtf32("PPToken"));
                pPTokenNonterminalParser->SetPre(PrePPToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->substituted = false;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->substituted)
                {
                    *context->result = ParseNonemptyTokenLine(context->process, *context->result, context->pp, context->flags);
                }
            }
            public void PrePPToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(context->flags | PPTokenFlags.acceptFunctionMacroInvocaction))));
                stack.Push(UniquePtr<Object>(new ValueObject<bool*>(&context->substituted)));
                stack.Push(UniquePtr<Object>(new ValueObject<int*>(&context->parenCount)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), result(), pp(), flags(), substituted(), parenCount()
                {
                }
                public bool process;
                public ustring* result;
                public PP* pp;
                public PPTokenFlags flags;
                public bool substituted;
                public int parenCount;
            }
        }

        public class PPTokenRule : System.Text.Parsing.RuleParser
        {
            public PPTokenRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool*"), ToUtf32("substituted")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("int*"), ToUtf32("parenCount")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("stringisize")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> parenCount_value = stack.Pop();
                context->parenCount = *cast<ValueObject<int*>*>(parenCount_value.Get());
                UniquePtr<Object> substituted_value = stack.Pop();
                context->substituted = *cast<ValueObject<bool*>*>(substituted_value.Get());
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                ActionParser* a12ActionParser = GetAction(ToUtf32("A12"));
                a12ActionParser->SetAction(A12Action);
                ActionParser* a13ActionParser = GetAction(ToUtf32("A13"));
                a13ActionParser->SetAction(A13Action);
                ActionParser* a14ActionParser = GetAction(ToUtf32("A14"));
                a14ActionParser->SetAction(A14Action);
                ActionParser* a15ActionParser = GetAction(ToUtf32("A15"));
                a15ActionParser->SetAction(A15Action);
                ActionParser* a16ActionParser = GetAction(ToUtf32("A16"));
                a16ActionParser->SetAction(A16Action);
                ActionParser* a17ActionParser = GetAction(ToUtf32("A17"));
                a17ActionParser->SetAction(A17Action);
                ActionParser* a18ActionParser = GetAction(ToUtf32("A18"));
                a18ActionParser->SetAction(A18Action);
                ActionParser* a19ActionParser = GetAction(ToUtf32("A19"));
                a19ActionParser->SetAction(A19Action);
                ActionParser* a20ActionParser = GetAction(ToUtf32("A20"));
                a20ActionParser->SetAction(A20Action);
                NonterminalParser* headerNameNonterminalParser = GetNonterminal(ToUtf32("HeaderName"));
                headerNameNonterminalParser->SetPost(PostHeaderName);
                NonterminalParser* functionMacroInvocationNonterminalParser = GetNonterminal(ToUtf32("FunctionMacroInvocation"));
                functionMacroInvocationNonterminalParser->SetPre(PreFunctionMacroInvocation);
                NonterminalParser* id1NonterminalParser = GetNonterminal(ToUtf32("id1"));
                id1NonterminalParser->SetPost(Postid1);
                NonterminalParser* id2NonterminalParser = GetNonterminal(ToUtf32("id2"));
                id2NonterminalParser->SetPost(Postid2);
                NonterminalParser* pPNumberNonterminalParser = GetNonterminal(ToUtf32("PPNumber"));
                pPNumberNonterminalParser->SetPost(PostPPNumber);
                NonterminalParser* characterLiteralNonterminalParser = GetNonterminal(ToUtf32("CharacterLiteral"));
                characterLiteralNonterminalParser->SetPost(PostCharacterLiteral);
                NonterminalParser* stringLiteralNonterminalParser = GetNonterminal(ToUtf32("StringLiteral"));
                stringLiteralNonterminalParser->SetPost(PostStringLiteral);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.acceptHash) != PPTokenFlags.none;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append('$');
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append('@');
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.acceptHeaderName) != PPTokenFlags.none;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(context->fromHeaderName);
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.acceptFunctionMacroInvocaction) != PPTokenFlags.none;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.macroArgumentReplacement) != PPTokenFlags.none;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->stringisize = true;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(context->pp->SubstituteMacroArgument(context->fromid1, context->stringisize));
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.macroArgumentReplacement) == PPTokenFlags.none;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(context->pp->SubstituteObjectMacro(context->fromid2, *context->substituted, fileName, span.lineNumber));
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(context->fromPPNumber);
            }
            public void A12Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(ustring(matchBegin, matchEnd));
            }
            public void A13Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(ustring(matchBegin, matchEnd));
            }
            public void A14Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.dontAcceptCommaOrRightParen) != PPTokenFlags.none;
            }
            public void A15Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                *context->parenCount = *context->parenCount + 1;
                if (context->process) context->result->Append('(');
            }
            public void A16Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (*context->parenCount == 0) pass = false;
                else
                {
                    *context->parenCount = *context->parenCount - 1;
                    if (context->process) context->result->Append(')');
                }
            }
            public void A17Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (*context->parenCount == 0) pass = false; else if (context->process) context->result->Append(',');
            }
            public void A18Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(*matchBegin);
            }
            public void A19Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = (context->flags & PPTokenFlags.dontAcceptCommaOrRightParen) == PPTokenFlags.none;
            }
            public void A20Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(*matchBegin);
            }
            public void PostHeaderName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromHeaderName_value = stack.Pop();
                    context->fromHeaderName = *cast<ValueObject<ustring>*>(fromHeaderName_value.Get());
                }
            }
            public void PreFunctionMacroInvocation(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(context->result)));
            }
            public void Postid1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid1_value = stack.Pop();
                    context->fromid1 = *cast<ValueObject<ustring>*>(fromid1_value.Get());
                }
            }
            public void Postid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid2_value = stack.Pop();
                    context->fromid2 = *cast<ValueObject<ustring>*>(fromid2_value.Get());
                }
            }
            public void PostPPNumber(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPPNumber_value = stack.Pop();
                    context->fromPPNumber = *cast<ValueObject<ustring>*>(fromPPNumber_value.Get());
                }
            }
            public void PostCharacterLiteral(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCharacterLiteral_value = stack.Pop();
                    context->fromCharacterLiteral = *cast<ValueObject<CharacterLiteralNode*>*>(fromCharacterLiteral_value.Get());
                }
            }
            public void PostStringLiteral(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStringLiteral_value = stack.Pop();
                    context->fromStringLiteral = *cast<ValueObject<StringLiteralNode*>*>(fromStringLiteral_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), result(), pp(), flags(), substituted(), parenCount(), stringisize(), fromHeaderName(), fromid1(), fromid2(), fromPPNumber(), fromCharacterLiteral(), fromStringLiteral()
                {
                }
                public bool process;
                public ustring* result;
                public PP* pp;
                public PPTokenFlags flags;
                public bool* substituted;
                public int* parenCount;
                public bool stringisize;
                public ustring fromHeaderName;
                public ustring fromid1;
                public ustring fromid2;
                public ustring fromPPNumber;
                public CharacterLiteralNode* fromCharacterLiteral;
                public StringLiteralNode* fromStringLiteral;
            }
        }

        public class FunctionMacroInvocationRule : System.Text.Parsing.RuleParser
        {
            public FunctionMacroInvocationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ustring*"), ToUtf32("result")));
                AddLocalVariable(AttrOrVar(ToUtf32("FunctionMacro*"), ToUtf32("macro")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> result_value = stack.Pop();
                context->result = *cast<ValueObject<ustring*>*>(result_value.Get());
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("identifier"));
                identifierNonterminalParser->SetPost(Postidentifier);
                NonterminalParser* argsNonterminalParser = GetNonterminal(ToUtf32("args"));
                argsNonterminalParser->SetPre(Preargs);
                argsNonterminalParser->SetPost(Postargs);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->process) context->result->Append(DoFunctionMacroReplacement(context->macro, &context->fromargs, context->pp, context->flags));
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->macro = context->pp->GetFunctionMacro(context->fromidentifier);
                pass = context->macro != null;
            }
            public void Postidentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context->fromidentifier = *cast<ValueObject<ustring>*>(fromidentifier_value.Get());
                }
            }
            public void Preargs(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void Postargs(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromargs_value = stack.Pop();
                    context->fromargs = *cast<ValueObject<List<ustring>>*>(fromargs_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), pp(), flags(), result(), macro(), fromidentifier(), fromargs()
                {
                }
                public bool process;
                public PP* pp;
                public PPTokenFlags flags;
                public ustring* result;
                public FunctionMacro* macro;
                public ustring fromidentifier;
                public List<ustring> fromargs;
            }
        }

        public class MacroArgumentListRule : System.Text.Parsing.RuleParser
        {
            public MacroArgumentListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                SetValueTypeName(ToUtf32("List<ustring>"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<List<ustring>>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Add(context->fromleft);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Add(context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<ustring>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<ustring>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), pp(), flags(), value(), fromleft(), fromright()
                {
                }
                public bool process;
                public PP* pp;
                public PPTokenFlags flags;
                public List<ustring> value;
                public ustring fromleft;
                public ustring fromright;
            }
        }

        public class MacroArgumentRule : System.Text.Parsing.RuleParser
        {
            public MacroArgumentRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("bool"), ToUtf32("process")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                SetValueTypeName(ToUtf32("ustring"));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("substituted")));
                AddLocalVariable(AttrOrVar(ToUtf32("int"), ToUtf32("parenCount")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> process_value = stack.Pop();
                context->process = *cast<ValueObject<bool>*>(process_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* pPTokenNonterminalParser = GetNonterminal(ToUtf32("PPToken"));
                pPTokenNonterminalParser->SetPre(PrePPToken);
            }
            public void PrePPToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(context->process)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->value)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(context->flags | PPTokenFlags.dontAcceptCommaOrRightParen))));
                stack.Push(UniquePtr<Object>(new ValueObject<bool*>(&context->substituted)));
                stack.Push(UniquePtr<Object>(new ValueObject<int*>(&context->parenCount)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : process(), pp(), flags(), value(), substituted(), parenCount()
                {
                }
                public bool process;
                public PP* pp;
                public PPTokenFlags flags;
                public ustring value;
                public bool substituted;
                public int parenCount;
            }
        }

        public class PPTokenCatenationRule : System.Text.Parsing.RuleParser
        {
            public PPTokenCatenationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                SetValueTypeName(ToUtf32("ustring"));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("left")));
                AddLocalVariable(AttrOrVar(ToUtf32("ustring"), ToUtf32("right")));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("substituted")));
                AddLocalVariable(AttrOrVar(ToUtf32("int"), ToUtf32("parenCount")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* firstNonterminalParser = GetNonterminal(ToUtf32("first"));
                firstNonterminalParser->SetPre(Prefirst);
                NonterminalParser* nextNonterminalParser = GetNonterminal(ToUtf32("next"));
                nextNonterminalParser->SetPre(Prenext);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->left;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->left.Append(context->right);
                context->right.Clear();
            }
            public void Prefirst(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(true)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->left)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(context->flags | PPTokenFlags.macroArgumentReplacement))));
                stack.Push(UniquePtr<Object>(new ValueObject<bool*>(&context->substituted)));
                stack.Push(UniquePtr<Object>(new ValueObject<int*>(&context->parenCount)));
            }
            public void Prenext(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<bool>(true)));
                stack.Push(UniquePtr<Object>(new ValueObject<ustring*>(&context->right)));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(cast<PPTokenFlags>(context->flags | PPTokenFlags.macroArgumentReplacement))));
                stack.Push(UniquePtr<Object>(new ValueObject<bool*>(&context->substituted)));
                stack.Push(UniquePtr<Object>(new ValueObject<int*>(&context->parenCount)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), flags(), value(), left(), right(), substituted(), parenCount()
                {
                }
                public PP* pp;
                public PPTokenFlags flags;
                public ustring value;
                public ustring left;
                public ustring right;
                public bool substituted;
                public int parenCount;
            }
        }

        public class PPTokenSequenceRule : System.Text.Parsing.RuleParser
        {
            public PPTokenSequenceRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Append(context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<ustring>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<ustring>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : pp(), flags(), value(), fromleft(), fromright()
                {
                }
                public PP* pp;
                public PPTokenFlags flags;
                public ustring value;
                public ustring fromleft;
                public ustring fromright;
            }
        }

        public class MacroReplacementRule : System.Text.Parsing.RuleParser
        {
            public MacroReplacementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("FunctionMacro*"), ToUtf32("macro")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("List<ustring>*"), ToUtf32("args")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PP*"), ToUtf32("pp")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("PPTokenFlags"), ToUtf32("flags")));
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> flags_value = stack.Pop();
                context->flags = *cast<ValueObject<PPTokenFlags>*>(flags_value.Get());
                UniquePtr<Object> pp_value = stack.Pop();
                context->pp = *cast<ValueObject<PP*>*>(pp_value.Get());
                UniquePtr<Object> args_value = stack.Pop();
                context->args = *cast<ValueObject<List<ustring>*>*>(args_value.Get());
                UniquePtr<Object> macro_value = stack.Pop();
                context->macro = *cast<ValueObject<FunctionMacro*>*>(macro_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* pPTokenSequenceNonterminalParser = GetNonterminal(ToUtf32("PPTokenSequence"));
                pPTokenSequenceNonterminalParser->SetPre(PrePPTokenSequence);
                pPTokenSequenceNonterminalParser->SetPost(PostPPTokenSequence);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->pp->PushFunctionMacro(context->macro, context->args);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->pp->PopFunctionMacro();
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPPTokenSequence;
            }
            public void PrePPTokenSequence(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<PP*>(context->pp)));
                stack.Push(UniquePtr<Object>(new ValueObject<PPTokenFlags>(context->flags)));
            }
            public void PostPPTokenSequence(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPPTokenSequence_value = stack.Pop();
                    context->fromPPTokenSequence = *cast<ValueObject<ustring>*>(fromPPTokenSequence_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : macro(), args(), pp(), flags(), value(), fromPPTokenSequence()
                {
                }
                public FunctionMacro* macro;
                public List<ustring>* args;
                public PP* pp;
                public PPTokenFlags flags;
                public ustring value;
                public ustring fromPPTokenSequence;
            }
        }

        public class PPNumberRule : System.Text.Parsing.RuleParser
        {
            public PPNumberRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public class HeaderNameRule : System.Text.Parsing.RuleParser
        {
            public HeaderNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar0 == null)
            {
                grammar0 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.LiteralGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.LiteralGrammar(pd);
            }
            AddGrammarReference(grammar1);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("newline"), this, ToUtf32("System.Text.Parsing.stdlib.newline")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("identifier"), this, ToUtf32("System.Text.Parsing.stdlib.identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("sign"), this, ToUtf32("System.Text.Parsing.stdlib.sign")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("CharacterLiteral"), this, ToUtf32("cppparser.LiteralGrammar.CharacterLiteral")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("StringLiteral"), this, ToUtf32("cppparser.LiteralGrammar.StringLiteral")));
            AddRule(new PPFileRule(ToUtf32("PPFile"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.OptionalParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Group"), ToUtf32("Group"), 3))));
            AddRule(new GroupRule(ToUtf32("Group"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.PositiveParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("IfSection"), ToUtf32("IfSection"), 3),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ControlLine"), ToUtf32("ControlLine"), 3)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TextLine"), ToUtf32("TextLine"), 3))))));
            AddRule(new IfSectionRule(ToUtf32("IfSection"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("IfGroup"), ToUtf32("IfGroup"), 3)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ElifGroup"), ToUtf32("ElifGroup"), 3))))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ElseGroup"), ToUtf32("ElseGroup"), 3))),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("EndIfLine"), ToUtf32("EndIfLine"), 2))));
            AddRule(new IfGroupRule(ToUtf32("IfGroup"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.OptionalParser(
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                                new System.Text.Parsing.CharParser('#')),
                                                            new System.Text.Parsing.OptionalParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("if"))),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ConstantExpression"), ToUtf32("ConstantExpression"), 2))),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("g1"), ToUtf32("Group"), 3))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.OptionalParser(
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                                new System.Text.Parsing.CharParser('#')),
                                                            new System.Text.Parsing.OptionalParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("ifdef"))),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("i1"), ToUtf32("identifier"), 0))),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("g2"), ToUtf32("Group"), 3)))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.OptionalParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                            new System.Text.Parsing.CharParser('#')),
                                                        new System.Text.Parsing.OptionalParser(
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("ifndef"))),
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("i2"), ToUtf32("identifier"), 0))),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("g3"), ToUtf32("Group"), 3))))))));
            AddRule(new ElifGroupRule(ToUtf32("ElifGroup"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.OptionalParser(
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                        new System.Text.Parsing.CharParser('#')),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                new System.Text.Parsing.KeywordParser(ToUtf32("elif"))),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("ConstantExpression"), ToUtf32("ConstantExpression"), 2))),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Group"), ToUtf32("Group"), 3)))))));
            AddRule(new ElseGroupRule(ToUtf32("ElseGroup"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                        new System.Text.Parsing.CharParser('#')),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                new System.Text.Parsing.KeywordParser(ToUtf32("else"))),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Group"), ToUtf32("Group"), 3)))));
            AddRule(new EndIfLineRule(ToUtf32("EndIfLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.CharParser('#')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.KeywordParser(ToUtf32("endif"))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))));
            AddRule(new ControlLineRule(ToUtf32("ControlLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("IncludeDirective"), ToUtf32("IncludeDirective"), 3),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("DefineFunctionMacro"), ToUtf32("DefineFunctionMacro"), 3)),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("DefineObjectMacro"), ToUtf32("DefineObjectMacro"), 3)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("UndefineMacro"), ToUtf32("UndefineMacro"), 3)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("PragmaDirective"), ToUtf32("PragmaDirective"), 1)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ErrorDirective"), ToUtf32("ErrorDirective"), 2)),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("LineDirective"), ToUtf32("LineDirective"), 1)),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("NullDirective"), ToUtf32("NullDirective"), 1))));
            AddRule(new IncludeDirectiveRule(ToUtf32("IncludeDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                new System.Text.Parsing.CharParser('#')),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.KeywordParser(ToUtf32("include"))),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("NonemptyTokenLine"), ToUtf32("NonemptyTokenLine"), 4)),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new DefineFunctionMacroRule(ToUtf32("DefineFunctionMacro"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.OptionalParser(
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                                new System.Text.Parsing.CharParser('#')),
                                                            new System.Text.Parsing.OptionalParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("define"))),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                new System.Text.Parsing.TokenParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("identifier"), ToUtf32("identifier"), 0),
                                                        new System.Text.Parsing.CharParser('(')))),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("MacroParams"), ToUtf32("MacroParams"), 0)),
                                        new System.Text.Parsing.CharParser(')')),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("PossiblyEmptyTokenLine"), ToUtf32("PossiblyEmptyTokenLine"), 4)),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new MacroParamsRule(ToUtf32("MacroParams"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.OptionalParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("identifier"), 0))),
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                    new System.Text.Parsing.CharParser(',')),
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("identifier"), 0)))))),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)))))));
            AddRule(new DefineObjectMacroRule(ToUtf32("DefineObjectMacro"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.OptionalParser(
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                        new System.Text.Parsing.CharParser('#')),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                                new System.Text.Parsing.KeywordParser(ToUtf32("define"))),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("identifier"), ToUtf32("identifier"), 0)),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("PossiblyEmptyTokenLine"), ToUtf32("PossiblyEmptyTokenLine"), 4)),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new UndefineMacroRule(ToUtf32("UndefineMacro"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                    new System.Text.Parsing.CharParser('#')),
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                            new System.Text.Parsing.KeywordParser(ToUtf32("undef"))),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("macroName"), ToUtf32("identifier"), 0)),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new PragmaDirectiveRule(ToUtf32("PragmaDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.CharParser('#')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.KeywordParser(ToUtf32("pragma"))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.DifferenceParser(
                                            new System.Text.Parsing.AnyCharParser(),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new ErrorDirectiveRule(ToUtf32("ErrorDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.CharParser('#')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.KeywordParser(ToUtf32("error"))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.DifferenceParser(
                                            new System.Text.Parsing.AnyCharParser(),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new LineDirectiveRule(ToUtf32("LineDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.CharParser('#')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.KeywordParser(ToUtf32("line"))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.DifferenceParser(
                                            new System.Text.Parsing.AnyCharParser(),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))));
            AddRule(new NullDirectiveRule(ToUtf32("NullDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                    new System.Text.Parsing.CharParser('#')),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))))));
            AddRule(new ConstantExpressionRule(ToUtf32("ConstantExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("NonemptyTokenLine"), ToUtf32("NonemptyTokenLine"), 4))));
            AddRule(new TextLineRule(ToUtf32("TextLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("PossiblyEmptyTokenLine"), ToUtf32("PossiblyEmptyTokenLine"), 4),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))))));
            AddRule(new PossiblyEmptyTokenLineRule(ToUtf32("PossiblyEmptyTokenLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.EmptyParser()),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.TokenParser(
                                new System.Text.Parsing.KleeneStarParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("PPToken"), ToUtf32("PPToken"), 6))))))));
            AddRule(new NonemptyTokenLineRule(ToUtf32("NonemptyTokenLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.EmptyParser()),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.TokenParser(
                                new System.Text.Parsing.PositiveParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("PPToken"), ToUtf32("PPToken"), 6))))))));
            AddRule(new PPTokenRule(ToUtf32("PPToken"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                            new System.Text.Parsing.EmptyParser()),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.AlternativeParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                    new System.Text.Parsing.StringParser(ToUtf32("##"))),
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                    new System.Text.Parsing.CharParser('#'))))),
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                            new System.Text.Parsing.EmptyParser()),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("HeaderName"), ToUtf32("HeaderName"), 0)))),
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                        new System.Text.Parsing.EmptyParser()),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionMacroInvocation"), ToUtf32("FunctionMacroInvocation"), 4))),
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                        new System.Text.Parsing.EmptyParser()),
                                                    new System.Text.Parsing.OptionalParser(
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                                                    new System.Text.Parsing.CharParser('@')),
                                                                new System.Text.Parsing.OptionalParser(
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)))))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("id1"), ToUtf32("identifier"), 0)))),
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                                new System.Text.Parsing.EmptyParser()),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("id2"), ToUtf32("identifier"), 0)))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("PPNumber"), ToUtf32("PPNumber"), 0))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A12"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CharacterLiteral"), ToUtf32("CharacterLiteral"), 0))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A13"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("StringLiteral"), ToUtf32("StringLiteral"), 0))),
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A14"),
                                new System.Text.Parsing.EmptyParser()),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A15"),
                                                new System.Text.Parsing.CharParser('(')),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A16"),
                                                new System.Text.Parsing.CharParser(')'))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A17"),
                                            new System.Text.Parsing.CharParser(','))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A18"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.DifferenceParser(
                                                new System.Text.Parsing.AnyCharParser(),
                                                new System.Text.Parsing.GroupingParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.AlternativeParser(
                                                                new System.Text.Parsing.AlternativeParser(
                                                                    new System.Text.Parsing.CharParser('#'),
                                                                    new System.Text.Parsing.CharParser('(')),
                                                                new System.Text.Parsing.CharParser(')')),
                                                            new System.Text.Parsing.CharParser(',')),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0)))))))))),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A19"),
                            new System.Text.Parsing.EmptyParser()),
                        new System.Text.Parsing.ActionParser(ToUtf32("A20"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.DifferenceParser(
                                    new System.Text.Parsing.AnyCharParser(),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.CharParser('#'),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("newline"), ToUtf32("newline"), 0))))))))));
            AddRule(new FunctionMacroInvocationRule(ToUtf32("FunctionMacroInvocation"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.TokenParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("identifier"), ToUtf32("identifier"), 0)),
                                        new System.Text.Parsing.CharParser('('))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("args"), ToUtf32("MacroArgumentList"), 3)),
                            new System.Text.Parsing.CharParser(')'))))));
            AddRule(new MacroArgumentListRule(ToUtf32("MacroArgumentList"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.OptionalParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("MacroArgument"), 3)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser(','),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("MacroArgument"), 3))))))))));
            AddRule(new MacroArgumentRule(ToUtf32("MacroArgument"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.TokenParser(
                    new System.Text.Parsing.PositiveParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("PPToken"), ToUtf32("PPToken"), 6))))));
            AddRule(new PPTokenCatenationRule(ToUtf32("PPTokenCatenation"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("first"), ToUtf32("PPToken"), 6),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0)),
                                                new System.Text.Parsing.CharParser('$')),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("S"), ToUtf32("S"), 0))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("next"), ToUtf32("PPToken"), 6))))))))));
            AddRule(new PPTokenSequenceRule(ToUtf32("PPTokenSequence"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("PPTokenCatenation"), 2)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("PPTokenCatenation"), 2)))))));
            AddRule(new MacroReplacementRule(ToUtf32("MacroReplacement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.EmptyParser()),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("PPTokenSequence"), ToUtf32("PPTokenSequence"), 2)))))))));
            AddRule(new PPNumberRule(ToUtf32("PPNumber"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.DigitParser(),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('.'),
                                            new System.Text.Parsing.DigitParser())))),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.DigitParser(),
                                                new System.Text.Parsing.CharParser('.')),
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharSetParser(ToUtf32("eE")),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("sign"), ToUtf32("sign"), 0))),
                                        new System.Text.Parsing.CharSetParser(ToUtf32("a-zA-Z_"))))))))));
            AddRule(new HeaderNameRule(ToUtf32("HeaderName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('<'),
                                    new System.Text.Parsing.PositiveParser(
                                        new System.Text.Parsing.CharSetParser(ToUtf32(">"), true))),
                                new System.Text.Parsing.CharParser('>')))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('\"'),
                                    new System.Text.Parsing.PositiveParser(
                                        new System.Text.Parsing.CharSetParser(ToUtf32("\""), true))),
                                new System.Text.Parsing.CharParser('\"')))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("S"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.PositiveParser(
                    new System.Text.Parsing.CharSetParser(ToUtf32(" \t")))));
        }
    }
} // pp

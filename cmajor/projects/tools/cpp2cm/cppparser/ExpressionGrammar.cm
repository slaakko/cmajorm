using System;
using System.Collections;
using System.Text.Parsing;
using cppast;

// this source file has been automatically generated from 'ExpressionGrammar.parser' using cmparsergen version 2.0.0.

namespace cppparser
{
    public class ExpressionGrammar : System.Text.Parsing.Grammar
    {
        public ExpressionGrammar() : this(new ParsingDomain())
        {
        }
        public ExpressionGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("ExpressionGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public ExpressionListNode* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            ExpressionListNode* result = *cast<ValueObject<ExpressionListNode*>*>(value.Get());
            return result;
        }

        public class ExpressionListRule : System.Text.Parsing.RuleParser
        {
            public ExpressionListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ExpressionListNode*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<ExpressionListNode>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ExpressionListNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* ic1NonterminalParser = GetNonterminal(ToUtf32("ic1"));
                ic1NonterminalParser->SetPre(Preic1);
                ic1NonterminalParser->SetPost(Postic1);
                NonterminalParser* ic2NonterminalParser = GetNonterminal(ToUtf32("ic2"));
                ic2NonterminalParser->SetPre(Preic2);
                ic2NonterminalParser->SetPost(Postic2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new ExpressionListNode(span));
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node->AddNode(context->fromic1);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node->AddNode(context->fromic2);
            }
            public void Preic1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postic1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromic1_value = stack.Pop();
                    context->fromic1 = *cast<ValueObject<Node*>*>(fromic1_value.Get());
                }
            }
            public void Preic2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postic2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromic2_value = stack.Pop();
                    context->fromic2 = *cast<ValueObject<Node*>*>(fromic2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromic1(), fromic2()
                {
                }
                public ParsingContext* ctx;
                public ExpressionListNode* value;
                public UniquePtr<ExpressionListNode> node;
                public Node* fromic1;
                public Node* fromic2;
            }
        }

        public class PossiblyEmptyArgumentListRule : System.Text.Parsing.RuleParser
        {
            public PossiblyEmptyArgumentListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ExpressionListNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ExpressionListNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* expressionListNonterminalParser = GetNonterminal(ToUtf32("ExpressionList"));
                expressionListNonterminalParser->SetPre(PreExpressionList);
                expressionListNonterminalParser->SetPost(PostExpressionList);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpressionList;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ExpressionListNode(span);
            }
            public void PreExpressionList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpressionList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpressionList_value = stack.Pop();
                    context->fromExpressionList = *cast<ValueObject<ExpressionListNode*>*>(fromExpressionList_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpressionList()
                {
                }
                public ParsingContext* ctx;
                public ExpressionListNode* value;
                public ExpressionListNode* fromExpressionList;
            }
        }

        public class ExpressionRule : System.Text.Parsing.RuleParser
        {
            public ExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.comma));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class ConstantExpressionRule : System.Text.Parsing.RuleParser
        {
            public ConstantExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* conditionalExpressionNonterminalParser = GetNonterminal(ToUtf32("ConditionalExpression"));
                conditionalExpressionNonterminalParser->SetPre(PreConditionalExpression);
                conditionalExpressionNonterminalParser->SetPost(PostConditionalExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConditionalExpression;
            }
            public void PreConditionalExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConditionalExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConditionalExpression_value = stack.Pop();
                    context->fromConditionalExpression = *cast<ValueObject<Node*>*>(fromConditionalExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromConditionalExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromConditionalExpression;
            }
        }

        public class AssignmentExpressionRule : System.Text.Parsing.RuleParser
        {
            public AssignmentExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* concreteAssignmentExpressionNonterminalParser = GetNonterminal(ToUtf32("ConcreteAssignmentExpression"));
                concreteAssignmentExpressionNonterminalParser->SetPre(PreConcreteAssignmentExpression);
                concreteAssignmentExpressionNonterminalParser->SetPost(PostConcreteAssignmentExpression);
                NonterminalParser* conditionalExpressionNonterminalParser = GetNonterminal(ToUtf32("ConditionalExpression"));
                conditionalExpressionNonterminalParser->SetPre(PreConditionalExpression);
                conditionalExpressionNonterminalParser->SetPost(PostConditionalExpression);
                NonterminalParser* throwExpressionNonterminalParser = GetNonterminal(ToUtf32("ThrowExpression"));
                throwExpressionNonterminalParser->SetPre(PreThrowExpression);
                throwExpressionNonterminalParser->SetPost(PostThrowExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConcreteAssignmentExpression;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConditionalExpression;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromThrowExpression;
            }
            public void PreConcreteAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConcreteAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConcreteAssignmentExpression_value = stack.Pop();
                    context->fromConcreteAssignmentExpression = *cast<ValueObject<Node*>*>(fromConcreteAssignmentExpression_value.Get());
                }
            }
            public void PreConditionalExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConditionalExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConditionalExpression_value = stack.Pop();
                    context->fromConditionalExpression = *cast<ValueObject<Node*>*>(fromConditionalExpression_value.Get());
                }
            }
            public void PreThrowExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostThrowExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromThrowExpression_value = stack.Pop();
                    context->fromThrowExpression = *cast<ValueObject<Node*>*>(fromThrowExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromConcreteAssignmentExpression(), fromConditionalExpression(), fromThrowExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromConcreteAssignmentExpression;
                public Node* fromConditionalExpression;
                public Node* fromThrowExpression;
            }
        }

        public class ConcreteAssignmentExpressionRule : System.Text.Parsing.RuleParser
        {
            public ConcreteAssignmentExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                a2ActionParser->SetFailure(A2ActionFail);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* logicalOrExpressionNonterminalParser = GetNonterminal(ToUtf32("LogicalOrExpression"));
                logicalOrExpressionNonterminalParser->SetPre(PreLogicalOrExpression);
                logicalOrExpressionNonterminalParser->SetPost(PostLogicalOrExpression);
                NonterminalParser* assignmentOperatorNonterminalParser = GetNonterminal(ToUtf32("AssignmentOperator"));
                assignmentOperatorNonterminalParser->SetPost(PostAssignmentOperator);
                NonterminalParser* initializerClauseNonterminalParser = GetNonterminal(ToUtf32("InitializerClause"));
                initializerClauseNonterminalParser->SetPre(PreInitializerClause);
                initializerClauseNonterminalParser->SetPost(PostInitializerClause);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingLvalue();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromLogicalOrExpression);
                context->ctx->EndParsingLvalue();
            }
            public void A2ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingLvalue();
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromInitializerClause, context->fromAssignmentOperator));
            }
            public void PreLogicalOrExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLogicalOrExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLogicalOrExpression_value = stack.Pop();
                    context->fromLogicalOrExpression = *cast<ValueObject<Node*>*>(fromLogicalOrExpression_value.Get());
                }
            }
            public void PostAssignmentOperator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentOperator_value = stack.Pop();
                    context->fromAssignmentOperator = *cast<ValueObject<Operator>*>(fromAssignmentOperator_value.Get());
                }
            }
            public void PreInitializerClause(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostInitializerClause(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromInitializerClause_value = stack.Pop();
                    context->fromInitializerClause = *cast<ValueObject<Node*>*>(fromInitializerClause_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromLogicalOrExpression(), fromAssignmentOperator(), fromInitializerClause()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromLogicalOrExpression;
                public Operator fromAssignmentOperator;
                public Node* fromInitializerClause;
            }
        }

        public class AssignmentOperatorRule : System.Text.Parsing.RuleParser
        {
            public AssignmentOperatorRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Operator"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Operator>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.assign;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.mulAssign;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.divAssign;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.remAssign;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.addAssign;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.subAssign;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.shiftRightAssign;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.shiftLeftAssign;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.andAssign;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.xorAssign;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.orAssign;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Operator value;
            }
        }

        public class ConditionalExpressionRule : System.Text.Parsing.RuleParser
        {
            public ConditionalExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* logicalOrExpressionNonterminalParser = GetNonterminal(ToUtf32("LogicalOrExpression"));
                logicalOrExpressionNonterminalParser->SetPre(PreLogicalOrExpression);
                logicalOrExpressionNonterminalParser->SetPost(PostLogicalOrExpression);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* assignmentExpressionNonterminalParser = GetNonterminal(ToUtf32("AssignmentExpression"));
                assignmentExpressionNonterminalParser->SetPre(PreAssignmentExpression);
                assignmentExpressionNonterminalParser->SetPost(PostAssignmentExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromLogicalOrExpression);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new ConditionalExpressionNode(span, context->node.Release(), context->fromExpression, context->fromAssignmentExpression));
            }
            public void PreLogicalOrExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLogicalOrExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLogicalOrExpression_value = stack.Pop();
                    context->fromLogicalOrExpression = *cast<ValueObject<Node*>*>(fromLogicalOrExpression_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.Get());
                }
            }
            public void PreAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentExpression_value = stack.Pop();
                    context->fromAssignmentExpression = *cast<ValueObject<Node*>*>(fromAssignmentExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromLogicalOrExpression(), fromExpression(), fromAssignmentExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromLogicalOrExpression;
                public Node* fromExpression;
                public Node* fromAssignmentExpression;
            }
        }

        public class ThrowExpressionRule : System.Text.Parsing.RuleParser
        {
            public ThrowExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* assignmentExpressionNonterminalParser = GetNonterminal(ToUtf32("AssignmentExpression"));
                assignmentExpressionNonterminalParser->SetPre(PreAssignmentExpression);
                assignmentExpressionNonterminalParser->SetPost(PostAssignmentExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ThrowExpressionNode(span, context->fromAssignmentExpression);
            }
            public void PreAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentExpression_value = stack.Pop();
                    context->fromAssignmentExpression = *cast<ValueObject<Node*>*>(fromAssignmentExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromAssignmentExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromAssignmentExpression;
            }
        }

        public class LogicalOrExpressionRule : System.Text.Parsing.RuleParser
        {
            public LogicalOrExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingTemplateIdOrLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.logicalOr));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class LogicalAndExpressionRule : System.Text.Parsing.RuleParser
        {
            public LogicalAndExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingTemplateIdOrLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.logicalAnd));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class InclusiveOrExpressionRule : System.Text.Parsing.RuleParser
        {
            public InclusiveOrExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.or_));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class ExclusiveOrExpressionRule : System.Text.Parsing.RuleParser
        {
            public ExclusiveOrExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.xor));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class AndExpressionRule : System.Text.Parsing.RuleParser
        {
            public AndExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, Operator.and_));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class EqualityExpressionRule : System.Text.Parsing.RuleParser
        {
            public EqualityExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.equal;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.notEqual;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class RelationalExpressionRule : System.Text.Parsing.RuleParser
        {
            public RelationalExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingTemplateIdOrLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.lessOrEqual;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.greaterOrEqual;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.less;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.greater;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class ShiftExpressionRule : System.Text.Parsing.RuleParser
        {
            public ShiftExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                a5ActionParser->SetFailure(A5ActionFail);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingArguments();
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.shiftLeft;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.shiftRight;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void A5ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class AdditiveExpressionRule : System.Text.Parsing.RuleParser
        {
            public AdditiveExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.add;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.sub;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class MultiplicativeExpressionRule : System.Text.Parsing.RuleParser
        {
            public MultiplicativeExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (context->ctx->ParsingLvalueAndNotArguments()) pass = false;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.mul;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.div;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.rem;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class PMExpressionRule : System.Text.Parsing.RuleParser
        {
            public PMExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromleft);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.dotStar;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.arrowStar;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new BinaryExpressionNode(span, context->node.Release(), context->fromright, context->op));
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), op(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Operator op;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class CastExpressionRule : System.Text.Parsing.RuleParser
        {
            public CastExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* castExpressionNonterminalParser = GetNonterminal(ToUtf32("CastExpression"));
                castExpressionNonterminalParser->SetPre(PreCastExpression);
                castExpressionNonterminalParser->SetPost(PostCastExpression);
                NonterminalParser* unaryExpressionNonterminalParser = GetNonterminal(ToUtf32("UnaryExpression"));
                unaryExpressionNonterminalParser->SetPre(PreUnaryExpression);
                unaryExpressionNonterminalParser->SetPost(PostUnaryExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new CastExpressionNode(span, context->fromTypeExpr, context->fromCastExpression));
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromUnaryExpression);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCastExpression_value = stack.Pop();
                    context->fromCastExpression = *cast<ValueObject<Node*>*>(fromCastExpression_value.Get());
                }
            }
            public void PreUnaryExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostUnaryExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUnaryExpression_value = stack.Pop();
                    context->fromUnaryExpression = *cast<ValueObject<Node*>*>(fromUnaryExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromTypeExpr(), fromCastExpression(), fromUnaryExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromTypeExpr;
                public Node* fromCastExpression;
                public Node* fromUnaryExpression;
            }
        }

        public class UnaryExpressionRule : System.Text.Parsing.RuleParser
        {
            public UnaryExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* c1NonterminalParser = GetNonterminal(ToUtf32("c1"));
                c1NonterminalParser->SetPre(Prec1);
                c1NonterminalParser->SetPost(Postc1);
                NonterminalParser* c2NonterminalParser = GetNonterminal(ToUtf32("c2"));
                c2NonterminalParser->SetPre(Prec2);
                c2NonterminalParser->SetPost(Postc2);
                NonterminalParser* opNonterminalParser = GetNonterminal(ToUtf32("op"));
                opNonterminalParser->SetPost(Postop);
                NonterminalParser* c3NonterminalParser = GetNonterminal(ToUtf32("c3"));
                c3NonterminalParser->SetPre(Prec3);
                c3NonterminalParser->SetPost(Postc3);
                NonterminalParser* u4NonterminalParser = GetNonterminal(ToUtf32("u4"));
                u4NonterminalParser->SetPre(Preu4);
                u4NonterminalParser->SetPost(Postu4);
                NonterminalParser* t5NonterminalParser = GetNonterminal(ToUtf32("t5"));
                t5NonterminalParser->SetPre(Pret5);
                t5NonterminalParser->SetPost(Postt5);
                NonterminalParser* newExpressionNonterminalParser = GetNonterminal(ToUtf32("NewExpression"));
                newExpressionNonterminalParser->SetPre(PreNewExpression);
                newExpressionNonterminalParser->SetPost(PostNewExpression);
                NonterminalParser* deleteExpressionNonterminalParser = GetNonterminal(ToUtf32("DeleteExpression"));
                deleteExpressionNonterminalParser->SetPre(PreDeleteExpression);
                deleteExpressionNonterminalParser->SetPost(PostDeleteExpression);
                NonterminalParser* postfixExpressionNonterminalParser = GetNonterminal(ToUtf32("PostfixExpression"));
                postfixExpressionNonterminalParser->SetPre(PrePostfixExpression);
                postfixExpressionNonterminalParser->SetPost(PostPostfixExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new PrefixIncrementNode(span, context->fromc1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new PrefixDecrementNode(span, context->fromc2);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new UnaryExpressionNode(span, context->fromc3, context->fromop);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SizeOfExpressionNode(span, context->fromu4);
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AlignOfExpressionNode(span, context->fromt5);
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNewExpression;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDeleteExpression;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPostfixExpression;
            }
            public void Prec1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc1_value = stack.Pop();
                    context->fromc1 = *cast<ValueObject<Node*>*>(fromc1_value.Get());
                }
            }
            public void Prec2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc2_value = stack.Pop();
                    context->fromc2 = *cast<ValueObject<Node*>*>(fromc2_value.Get());
                }
            }
            public void Postop(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromop_value = stack.Pop();
                    context->fromop = *cast<ValueObject<Operator>*>(fromop_value.Get());
                }
            }
            public void Prec3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc3_value = stack.Pop();
                    context->fromc3 = *cast<ValueObject<Node*>*>(fromc3_value.Get());
                }
            }
            public void Preu4(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postu4(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromu4_value = stack.Pop();
                    context->fromu4 = *cast<ValueObject<Node*>*>(fromu4_value.Get());
                }
            }
            public void Pret5(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postt5(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromt5_value = stack.Pop();
                    context->fromt5 = *cast<ValueObject<Node*>*>(fromt5_value.Get());
                }
            }
            public void PreNewExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNewExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNewExpression_value = stack.Pop();
                    context->fromNewExpression = *cast<ValueObject<NewExpressionNode*>*>(fromNewExpression_value.Get());
                }
            }
            public void PreDeleteExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeleteExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeleteExpression_value = stack.Pop();
                    context->fromDeleteExpression = *cast<ValueObject<DeleteExpressionNode*>*>(fromDeleteExpression_value.Get());
                }
            }
            public void PrePostfixExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostPostfixExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPostfixExpression_value = stack.Pop();
                    context->fromPostfixExpression = *cast<ValueObject<Node*>*>(fromPostfixExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromc1(), fromc2(), fromop(), fromc3(), fromu4(), fromt5(), fromNewExpression(), fromDeleteExpression(), fromPostfixExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromc1;
                public Node* fromc2;
                public Operator fromop;
                public Node* fromc3;
                public Node* fromu4;
                public Node* fromt5;
                public NewExpressionNode* fromNewExpression;
                public DeleteExpressionNode* fromDeleteExpression;
                public Node* fromPostfixExpression;
            }
        }

        public class UnaryOperatorRule : System.Text.Parsing.RuleParser
        {
            public UnaryOperatorRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Operator"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Operator>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.deref;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.addrOf;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.unaryPlus;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.unaryMinus;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.not_;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.neg;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Operator value;
            }
        }

        public class NewExpressionRule : System.Text.Parsing.RuleParser
        {
            public NewExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("NewExpressionNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<NewExpressionNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* newPlacementNonterminalParser = GetNonterminal(ToUtf32("NewPlacement"));
                newPlacementNonterminalParser->SetPre(PreNewPlacement);
                newPlacementNonterminalParser->SetPost(PostNewPlacement);
                NonterminalParser* newTypeIdNonterminalParser = GetNonterminal(ToUtf32("NewTypeId"));
                newTypeIdNonterminalParser->SetPre(PreNewTypeId);
                newTypeIdNonterminalParser->SetPost(PostNewTypeId);
                NonterminalParser* newInitializerNonterminalParser = GetNonterminal(ToUtf32("NewInitializer"));
                newInitializerNonterminalParser->SetPre(PreNewInitializer);
                newInitializerNonterminalParser->SetPost(PostNewInitializer);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new NewExpressionNode(span, context->fromNewPlacement, context->fromNewTypeId, context->fromNewInitializer);
            }
            public void PreNewPlacement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNewPlacement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNewPlacement_value = stack.Pop();
                    context->fromNewPlacement = *cast<ValueObject<ExpressionListNode*>*>(fromNewPlacement_value.Get());
                }
            }
            public void PreNewTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNewTypeId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNewTypeId_value = stack.Pop();
                    context->fromNewTypeId = *cast<ValueObject<Node*>*>(fromNewTypeId_value.Get());
                }
            }
            public void PreNewInitializer(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNewInitializer(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNewInitializer_value = stack.Pop();
                    context->fromNewInitializer = *cast<ValueObject<ExpressionListNode*>*>(fromNewInitializer_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromNewPlacement(), fromNewTypeId(), fromNewInitializer()
                {
                }
                public ParsingContext* ctx;
                public NewExpressionNode* value;
                public ExpressionListNode* fromNewPlacement;
                public Node* fromNewTypeId;
                public ExpressionListNode* fromNewInitializer;
            }
        }

        public class NewPlacementRule : System.Text.Parsing.RuleParser
        {
            public NewPlacementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ExpressionListNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ExpressionListNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionListNonterminalParser = GetNonterminal(ToUtf32("ExpressionList"));
                expressionListNonterminalParser->SetPre(PreExpressionList);
                expressionListNonterminalParser->SetPost(PostExpressionList);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpressionList;
            }
            public void PreExpressionList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpressionList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpressionList_value = stack.Pop();
                    context->fromExpressionList = *cast<ValueObject<ExpressionListNode*>*>(fromExpressionList_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpressionList()
                {
                }
                public ParsingContext* ctx;
                public ExpressionListNode* value;
                public ExpressionListNode* fromExpressionList;
            }
        }

        public class NewTypeIdRule : System.Text.Parsing.RuleParser
        {
            public NewTypeIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPre(Pretype);
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* sizeNonterminalParser = GetNonterminal(ToUtf32("size"));
                sizeNonterminalParser->SetPre(Presize);
                sizeNonterminalParser->SetPost(Postsize);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromtype;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ArrayTypeNode(span, context->fromtype, context->fromsize);
            }
            public void Pretype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<Node*>*>(fromtype_value.Get());
                }
            }
            public void Presize(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postsize(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsize_value = stack.Pop();
                    context->fromsize = *cast<ValueObject<Node*>*>(fromsize_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromtype(), fromsize()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromtype;
                public Node* fromsize;
            }
        }

        public class NewDeclaratorRule : System.Text.Parsing.RuleParser
        {
            public NewDeclaratorRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                a2ActionParser->SetFailure(A2ActionFail);
                NonterminalParser* sizeNonterminalParser = GetNonterminal(ToUtf32("size"));
                sizeNonterminalParser->SetPre(Presize);
                sizeNonterminalParser->SetPost(Postsize);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingArguments();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromsize;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
            }
            public void A2ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
            }
            public void Presize(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postsize(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsize_value = stack.Pop();
                    context->fromsize = *cast<ValueObject<Node*>*>(fromsize_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromsize()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromsize;
            }
        }

        public class NewInitializerRule : System.Text.Parsing.RuleParser
        {
            public NewInitializerRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ExpressionListNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ExpressionListNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* argsNonterminalParser = GetNonterminal(ToUtf32("args"));
                argsNonterminalParser->SetPre(Preargs);
                argsNonterminalParser->SetPost(Postargs);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromargs;
            }
            public void Preargs(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postargs(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromargs_value = stack.Pop();
                    context->fromargs = *cast<ValueObject<ExpressionListNode*>*>(fromargs_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromargs()
                {
                }
                public ParsingContext* ctx;
                public ExpressionListNode* value;
                public ExpressionListNode* fromargs;
            }
        }

        public class DeleteExpressionRule : System.Text.Parsing.RuleParser
        {
            public DeleteExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("DeleteExpressionNode*"));
                AddLocalVariable(AttrOrVar(ToUtf32("bool"), ToUtf32("arrayDelete")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DeleteExpressionNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* castExpressionNonterminalParser = GetNonterminal(ToUtf32("CastExpression"));
                castExpressionNonterminalParser->SetPre(PreCastExpression);
                castExpressionNonterminalParser->SetPost(PostCastExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DeleteExpressionNode(span, context->fromCastExpression, context->arrayDelete);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->arrayDelete = true;
            }
            public void PreCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCastExpression_value = stack.Pop();
                    context->fromCastExpression = *cast<ValueObject<Node*>*>(fromCastExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), arrayDelete(), fromCastExpression()
                {
                }
                public ParsingContext* ctx;
                public DeleteExpressionNode* value;
                public bool arrayDelete;
                public Node* fromCastExpression;
            }
        }

        public class PostfixExpressionRule : System.Text.Parsing.RuleParser
        {
            public PostfixExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("node")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                a3ActionParser->SetFailure(A3ActionFail);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                a5ActionParser->SetFailure(A5ActionFail);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                NonterminalParser* primaryExpressionNonterminalParser = GetNonterminal(ToUtf32("PrimaryExpression"));
                primaryExpressionNonterminalParser->SetPre(PrePrimaryExpression);
                primaryExpressionNonterminalParser->SetPost(PostPrimaryExpression);
                NonterminalParser* subscriptNonterminalParser = GetNonterminal(ToUtf32("subscript"));
                subscriptNonterminalParser->SetPre(Presubscript);
                subscriptNonterminalParser->SetPost(Postsubscript);
                NonterminalParser* argumentsNonterminalParser = GetNonterminal(ToUtf32("arguments"));
                argumentsNonterminalParser->SetPre(Prearguments);
                argumentsNonterminalParser->SetPost(Postarguments);
                NonterminalParser* id1NonterminalParser = GetNonterminal(ToUtf32("id1"));
                id1NonterminalParser->SetPre(Preid1);
                id1NonterminalParser->SetPost(Postid1);
                NonterminalParser* id2NonterminalParser = GetNonterminal(ToUtf32("id2"));
                id2NonterminalParser->SetPre(Preid2);
                id2NonterminalParser->SetPost(Postid2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->node.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(context->fromPrimaryExpression);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingArguments();
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new SubscriptExpressionNode(span, context->node.Release(), context->fromsubscript));
                context->ctx->EndParsingArguments();
            }
            public void A3ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->BeginParsingArguments();
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new InvokeExpressionNode(span, context->node.Release(), context->fromarguments));
                context->ctx->EndParsingArguments();
            }
            public void A5ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->EndParsingArguments();
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new DotNode(span, context->node.Release(), context->fromid1));
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new ArrowNode(span, context->node.Release(), context->fromid2));
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new PostfixIncrementNode(span, context->node.Release()));
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->node.Reset(new PostfixDecrementNode(span, context->node.Release()));
            }
            public void PrePrimaryExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostPrimaryExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrimaryExpression_value = stack.Pop();
                    context->fromPrimaryExpression = *cast<ValueObject<Node*>*>(fromPrimaryExpression_value.Get());
                }
            }
            public void Presubscript(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postsubscript(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsubscript_value = stack.Pop();
                    context->fromsubscript = *cast<ValueObject<Node*>*>(fromsubscript_value.Get());
                }
            }
            public void Prearguments(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postarguments(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromarguments_value = stack.Pop();
                    context->fromarguments = *cast<ValueObject<ExpressionListNode*>*>(fromarguments_value.Get());
                }
            }
            public void Preid1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postid1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid1_value = stack.Pop();
                    context->fromid1 = *cast<ValueObject<Node*>*>(fromid1_value.Get());
                }
            }
            public void Preid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid2_value = stack.Pop();
                    context->fromid2 = *cast<ValueObject<Node*>*>(fromid2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), node(), fromPrimaryExpression(), fromsubscript(), fromarguments(), fromid1(), fromid2()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> node;
                public Node* fromPrimaryExpression;
                public Node* fromsubscript;
                public ExpressionListNode* fromarguments;
                public Node* fromid1;
                public Node* fromid2;
            }
        }

        public class PrimaryExpressionRule : System.Text.Parsing.RuleParser
        {
            public PrimaryExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                ActionParser* a12ActionParser = GetAction(ToUtf32("A12"));
                a12ActionParser->SetAction(A12Action);
                NonterminalParser* literalNonterminalParser = GetNonterminal(ToUtf32("Literal"));
                literalNonterminalParser->SetPost(PostLiteral);
                NonterminalParser* definedExprNonterminalParser = GetNonterminal(ToUtf32("DefinedExpr"));
                definedExprNonterminalParser->SetPost(PostDefinedExpr);
                NonterminalParser* exprNonterminalParser = GetNonterminal(ToUtf32("expr"));
                exprNonterminalParser->SetPre(Preexpr);
                exprNonterminalParser->SetPost(Postexpr);
                NonterminalParser* cppCastExpressionNonterminalParser = GetNonterminal(ToUtf32("CppCastExpression"));
                cppCastExpressionNonterminalParser->SetPre(PreCppCastExpression);
                cppCastExpressionNonterminalParser->SetPost(PostCppCastExpression);
                NonterminalParser* typeIdExpressionNonterminalParser = GetNonterminal(ToUtf32("TypeIdExpression"));
                typeIdExpressionNonterminalParser->SetPre(PreTypeIdExpression);
                typeIdExpressionNonterminalParser->SetPost(PostTypeIdExpression);
                NonterminalParser* s1NonterminalParser = GetNonterminal(ToUtf32("s1"));
                s1NonterminalParser->SetPost(Posts1);
                NonterminalParser* args1NonterminalParser = GetNonterminal(ToUtf32("args1"));
                args1NonterminalParser->SetPre(Preargs1);
                args1NonterminalParser->SetPost(Postargs1);
                NonterminalParser* s2NonterminalParser = GetNonterminal(ToUtf32("s2"));
                s2NonterminalParser->SetPost(Posts2);
                NonterminalParser* b1NonterminalParser = GetNonterminal(ToUtf32("b1"));
                b1NonterminalParser->SetPre(Preb1);
                b1NonterminalParser->SetPost(Postb1);
                NonterminalParser* t1NonterminalParser = GetNonterminal(ToUtf32("t1"));
                t1NonterminalParser->SetPre(Pret1);
                t1NonterminalParser->SetPost(Postt1);
                NonterminalParser* args2NonterminalParser = GetNonterminal(ToUtf32("args2"));
                args2NonterminalParser->SetPre(Preargs2);
                args2NonterminalParser->SetPost(Postargs2);
                NonterminalParser* t2NonterminalParser = GetNonterminal(ToUtf32("t2"));
                t2NonterminalParser->SetPre(Pret2);
                t2NonterminalParser->SetPost(Postt2);
                NonterminalParser* b2NonterminalParser = GetNonterminal(ToUtf32("b2"));
                b2NonterminalParser->SetPre(Preb2);
                b2NonterminalParser->SetPost(Postb2);
                NonterminalParser* idExpressionNonterminalParser = GetNonterminal(ToUtf32("IdExpression"));
                idExpressionNonterminalParser->SetPre(PreIdExpression);
                idExpressionNonterminalParser->SetPost(PostIdExpression);
                NonterminalParser* lambdaExpressionNonterminalParser = GetNonterminal(ToUtf32("LambdaExpression"));
                lambdaExpressionNonterminalParser->SetPre(PreLambdaExpression);
                lambdaExpressionNonterminalParser->SetPost(PostLambdaExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLiteral;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ThisNode(span);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                pass = context->ctx->AcceptDefined();
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDefinedExpr;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ParenthesizedExpressionNode(span, context->fromexpr);
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromCppCastExpression;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTypeIdExpression;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new InvokeExpressionNode(span, new SimpleTypeNode(span, context->froms1), context->fromargs1);
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new InvokeExpressionNode(span, new SimpleTypeNode(span, context->froms2), context->fromb1);
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new InvokeExpressionNode(span, context->fromt1, context->fromargs2);
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new InvokeExpressionNode(span, context->fromt2, context->fromb2);
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIdExpression;
            }
            public void A12Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLambdaExpression;
            }
            public void PostLiteral(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLiteral_value = stack.Pop();
                    context->fromLiteral = *cast<ValueObject<LiteralNode*>*>(fromLiteral_value.Get());
                }
            }
            public void PostDefinedExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDefinedExpr_value = stack.Pop();
                    context->fromDefinedExpr = *cast<ValueObject<Node*>*>(fromDefinedExpr_value.Get());
                }
            }
            public void Preexpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postexpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromexpr_value = stack.Pop();
                    context->fromexpr = *cast<ValueObject<Node*>*>(fromexpr_value.Get());
                }
            }
            public void PreCppCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCppCastExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCppCastExpression_value = stack.Pop();
                    context->fromCppCastExpression = *cast<ValueObject<Node*>*>(fromCppCastExpression_value.Get());
                }
            }
            public void PreTypeIdExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeIdExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeIdExpression_value = stack.Pop();
                    context->fromTypeIdExpression = *cast<ValueObject<Node*>*>(fromTypeIdExpression_value.Get());
                }
            }
            public void Posts1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms1_value = stack.Pop();
                    context->froms1 = *cast<ValueObject<SimpleTypeSpecifiers>*>(froms1_value.Get());
                }
            }
            public void Preargs1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postargs1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromargs1_value = stack.Pop();
                    context->fromargs1 = *cast<ValueObject<ExpressionListNode*>*>(fromargs1_value.Get());
                }
            }
            public void Posts2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms2_value = stack.Pop();
                    context->froms2 = *cast<ValueObject<SimpleTypeSpecifiers>*>(froms2_value.Get());
                }
            }
            public void Preb1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postb1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromb1_value = stack.Pop();
                    context->fromb1 = *cast<ValueObject<BracedInitializerListNode*>*>(fromb1_value.Get());
                }
            }
            public void Pret1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postt1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromt1_value = stack.Pop();
                    context->fromt1 = *cast<ValueObject<Node*>*>(fromt1_value.Get());
                }
            }
            public void Preargs2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postargs2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromargs2_value = stack.Pop();
                    context->fromargs2 = *cast<ValueObject<ExpressionListNode*>*>(fromargs2_value.Get());
                }
            }
            public void Pret2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postt2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromt2_value = stack.Pop();
                    context->fromt2 = *cast<ValueObject<Node*>*>(fromt2_value.Get());
                }
            }
            public void Preb2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postb2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromb2_value = stack.Pop();
                    context->fromb2 = *cast<ValueObject<BracedInitializerListNode*>*>(fromb2_value.Get());
                }
            }
            public void PreIdExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostIdExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdExpression_value = stack.Pop();
                    context->fromIdExpression = *cast<ValueObject<Node*>*>(fromIdExpression_value.Get());
                }
            }
            public void PreLambdaExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLambdaExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLambdaExpression_value = stack.Pop();
                    context->fromLambdaExpression = *cast<ValueObject<LambdaExpressionNode*>*>(fromLambdaExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromLiteral(), fromDefinedExpr(), fromexpr(), fromCppCastExpression(), fromTypeIdExpression(), froms1(), fromargs1(), froms2(), fromb1(), fromt1(), fromargs2(), fromt2(), fromb2(), fromIdExpression(), fromLambdaExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public LiteralNode* fromLiteral;
                public Node* fromDefinedExpr;
                public Node* fromexpr;
                public Node* fromCppCastExpression;
                public Node* fromTypeIdExpression;
                public SimpleTypeSpecifiers froms1;
                public ExpressionListNode* fromargs1;
                public SimpleTypeSpecifiers froms2;
                public BracedInitializerListNode* fromb1;
                public Node* fromt1;
                public ExpressionListNode* fromargs2;
                public Node* fromt2;
                public BracedInitializerListNode* fromb2;
                public Node* fromIdExpression;
                public LambdaExpressionNode* fromLambdaExpression;
            }
        }

        public class CppCastExpressionRule : System.Text.Parsing.RuleParser
        {
            public CppCastExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("CppCast"), ToUtf32("cast_")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* t1NonterminalParser = GetNonterminal(ToUtf32("t1"));
                t1NonterminalParser->SetPre(Pret1);
                t1NonterminalParser->SetPost(Postt1);
                NonterminalParser* e1NonterminalParser = GetNonterminal(ToUtf32("e1"));
                e1NonterminalParser->SetPre(Pree1);
                e1NonterminalParser->SetPost(Poste1);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new CppCastNode(span, context->cast_, context->fromt1, context->frome1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->cast_ = CppCast.dynamicCast;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->cast_ = CppCast.staticCast;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->cast_ = CppCast.reinterpretCast;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->cast_ = CppCast.constCast;
            }
            public void Pret1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postt1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromt1_value = stack.Pop();
                    context->fromt1 = *cast<ValueObject<Node*>*>(fromt1_value.Get());
                }
            }
            public void Pree1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poste1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frome1_value = stack.Pop();
                    context->frome1 = *cast<ValueObject<Node*>*>(frome1_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), cast_(), fromt1(), frome1()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public CppCast cast_;
                public Node* fromt1;
                public Node* frome1;
            }
        }

        public class DefinedExprRule : System.Text.Parsing.RuleParser
        {
            public DefinedExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* id1NonterminalParser = GetNonterminal(ToUtf32("id1"));
                id1NonterminalParser->SetPost(Postid1);
                NonterminalParser* id2NonterminalParser = GetNonterminal(ToUtf32("id2"));
                id2NonterminalParser->SetPost(Postid2);
                NonterminalParser* lit1NonterminalParser = GetNonterminal(ToUtf32("lit1"));
                lit1NonterminalParser->SetPost(Postlit1);
                NonterminalParser* lit2NonterminalParser = GetNonterminal(ToUtf32("lit2"));
                lit2NonterminalParser->SetPost(Postlit2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DefinedNode(span, context->fromid1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DefinedNode(span, context->fromid2);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BooleanLiteralNode(span, true);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BooleanLiteralNode(span, true);
            }
            public void Postid1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid1_value = stack.Pop();
                    context->fromid1 = *cast<ValueObject<ustring>*>(fromid1_value.Get());
                }
            }
            public void Postid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid2_value = stack.Pop();
                    context->fromid2 = *cast<ValueObject<ustring>*>(fromid2_value.Get());
                }
            }
            public void Postlit1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlit1_value = stack.Pop();
                    context->fromlit1 = *cast<ValueObject<LiteralNode*>*>(fromlit1_value.Get());
                }
            }
            public void Postlit2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlit2_value = stack.Pop();
                    context->fromlit2 = *cast<ValueObject<LiteralNode*>*>(fromlit2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromid1(), fromid2(), fromlit1(), fromlit2()
                {
                }
                public Node* value;
                public ustring fromid1;
                public ustring fromid2;
                public LiteralNode* fromlit1;
                public LiteralNode* fromlit2;
            }
        }

        public class TypeIdExpressionRule : System.Text.Parsing.RuleParser
        {
            public TypeIdExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* t1NonterminalParser = GetNonterminal(ToUtf32("t1"));
                t1NonterminalParser->SetPre(Pret1);
                t1NonterminalParser->SetPost(Postt1);
                NonterminalParser* e1NonterminalParser = GetNonterminal(ToUtf32("e1"));
                e1NonterminalParser->SetPre(Pree1);
                e1NonterminalParser->SetPost(Poste1);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TypeIdNode(span, context->fromt1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TypeIdNode(span, context->frome1);
            }
            public void Pret1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postt1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromt1_value = stack.Pop();
                    context->fromt1 = *cast<ValueObject<Node*>*>(fromt1_value.Get());
                }
            }
            public void Pree1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poste1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frome1_value = stack.Pop();
                    context->frome1 = *cast<ValueObject<Node*>*>(frome1_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromt1(), frome1()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromt1;
                public Node* frome1;
            }
        }

        public class IdExpressionRule : System.Text.Parsing.RuleParser
        {
            public IdExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* qualifiedIdExprNonterminalParser = GetNonterminal(ToUtf32("QualifiedIdExpr"));
                qualifiedIdExprNonterminalParser->SetPre(PreQualifiedIdExpr);
                qualifiedIdExprNonterminalParser->SetPost(PostQualifiedIdExpr);
                NonterminalParser* unqualifiedIdExprNonterminalParser = GetNonterminal(ToUtf32("UnqualifiedIdExpr"));
                unqualifiedIdExprNonterminalParser->SetPre(PreUnqualifiedIdExpr);
                unqualifiedIdExprNonterminalParser->SetPost(PostUnqualifiedIdExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromQualifiedIdExpr;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUnqualifiedIdExpr;
            }
            public void PreQualifiedIdExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostQualifiedIdExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQualifiedIdExpr_value = stack.Pop();
                    context->fromQualifiedIdExpr = *cast<ValueObject<Node*>*>(fromQualifiedIdExpr_value.Get());
                }
            }
            public void PreUnqualifiedIdExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostUnqualifiedIdExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUnqualifiedIdExpr_value = stack.Pop();
                    context->fromUnqualifiedIdExpr = *cast<ValueObject<Node*>*>(fromUnqualifiedIdExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromQualifiedIdExpr(), fromUnqualifiedIdExpr()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromQualifiedIdExpr;
                public Node* fromUnqualifiedIdExpr;
            }
        }

        public class UnqualifiedIdExprRule : System.Text.Parsing.RuleParser
        {
            public UnqualifiedIdExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* templateIdNonterminalParser = GetNonterminal(ToUtf32("TemplateId"));
                templateIdNonterminalParser->SetPre(PreTemplateId);
                templateIdNonterminalParser->SetPost(PostTemplateId);
                NonterminalParser* id1NonterminalParser = GetNonterminal(ToUtf32("id1"));
                id1NonterminalParser->SetPost(Postid1);
                NonterminalParser* operatorFunctionIdNonterminalParser = GetNonterminal(ToUtf32("OperatorFunctionId"));
                operatorFunctionIdNonterminalParser->SetPost(PostOperatorFunctionId);
                NonterminalParser* conversionFunctionIdNonterminalParser = GetNonterminal(ToUtf32("ConversionFunctionId"));
                conversionFunctionIdNonterminalParser->SetPre(PreConversionFunctionId);
                conversionFunctionIdNonterminalParser->SetPost(PostConversionFunctionId);
                NonterminalParser* id2NonterminalParser = GetNonterminal(ToUtf32("id2"));
                id2NonterminalParser->SetPost(Postid2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTemplateId;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromid1;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromOperatorFunctionId;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConversionFunctionId;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DestructorIdNode(span, context->fromid2);
            }
            public void PreTemplateId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTemplateId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTemplateId_value = stack.Pop();
                    context->fromTemplateId = *cast<ValueObject<TemplateIdNode*>*>(fromTemplateId_value.Get());
                }
            }
            public void Postid1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid1_value = stack.Pop();
                    context->fromid1 = *cast<ValueObject<IdentifierNode*>*>(fromid1_value.Get());
                }
            }
            public void PostOperatorFunctionId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOperatorFunctionId_value = stack.Pop();
                    context->fromOperatorFunctionId = *cast<ValueObject<OperatorFunctionIdNode*>*>(fromOperatorFunctionId_value.Get());
                }
            }
            public void PreConversionFunctionId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConversionFunctionId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConversionFunctionId_value = stack.Pop();
                    context->fromConversionFunctionId = *cast<ValueObject<ConversionFunctionIdNode*>*>(fromConversionFunctionId_value.Get());
                }
            }
            public void Postid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromid2_value = stack.Pop();
                    context->fromid2 = *cast<ValueObject<IdentifierNode*>*>(fromid2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTemplateId(), fromid1(), fromOperatorFunctionId(), fromConversionFunctionId(), fromid2()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public TemplateIdNode* fromTemplateId;
                public IdentifierNode* fromid1;
                public OperatorFunctionIdNode* fromOperatorFunctionId;
                public ConversionFunctionIdNode* fromConversionFunctionId;
                public IdentifierNode* fromid2;
            }
        }

        public class QualifiedIdExprRule : System.Text.Parsing.RuleParser
        {
            public QualifiedIdExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* templateIdNonterminalParser = GetNonterminal(ToUtf32("TemplateId"));
                templateIdNonterminalParser->SetPre(PreTemplateId);
                templateIdNonterminalParser->SetPost(PostTemplateId);
                NonterminalParser* nsNonterminalParser = GetNonterminal(ToUtf32("ns"));
                nsNonterminalParser->SetPre(Prens);
                nsNonterminalParser->SetPost(Postns);
                NonterminalParser* ud1NonterminalParser = GetNonterminal(ToUtf32("ud1"));
                ud1NonterminalParser->SetPre(Preud1);
                ud1NonterminalParser->SetPost(Postud1);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
                NonterminalParser* operatorFunctionIdNonterminalParser = GetNonterminal(ToUtf32("OperatorFunctionId"));
                operatorFunctionIdNonterminalParser->SetPost(PostOperatorFunctionId);
                NonterminalParser* ns2NonterminalParser = GetNonterminal(ToUtf32("ns2"));
                ns2NonterminalParser->SetPre(Prens2);
                ns2NonterminalParser->SetPost(Postns2);
                NonterminalParser* uid2NonterminalParser = GetNonterminal(ToUtf32("uid2"));
                uid2NonterminalParser->SetPre(Preuid2);
                uid2NonterminalParser->SetPost(Postuid2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ColonColonNode(span, null, context->fromTemplateId);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ColonColonNode(span, null, new ColonColonNode(span, context->fromns, context->fromud1));
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ColonColonNode(span, null, context->fromIdentifier);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ColonColonNode(span, null, context->fromOperatorFunctionId);
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ColonColonNode(span, context->fromns2, context->fromuid2);
            }
            public void PreTemplateId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTemplateId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTemplateId_value = stack.Pop();
                    context->fromTemplateId = *cast<ValueObject<TemplateIdNode*>*>(fromTemplateId_value.Get());
                }
            }
            public void Prens(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postns(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromns_value = stack.Pop();
                    context->fromns = *cast<ValueObject<Node*>*>(fromns_value.Get());
                }
            }
            public void Preud1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postud1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromud1_value = stack.Pop();
                    context->fromud1 = *cast<ValueObject<Node*>*>(fromud1_value.Get());
                }
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.Get());
                }
            }
            public void PostOperatorFunctionId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOperatorFunctionId_value = stack.Pop();
                    context->fromOperatorFunctionId = *cast<ValueObject<OperatorFunctionIdNode*>*>(fromOperatorFunctionId_value.Get());
                }
            }
            public void Prens2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postns2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromns2_value = stack.Pop();
                    context->fromns2 = *cast<ValueObject<Node*>*>(fromns2_value.Get());
                }
            }
            public void Preuid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postuid2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromuid2_value = stack.Pop();
                    context->fromuid2 = *cast<ValueObject<Node*>*>(fromuid2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTemplateId(), fromns(), fromud1(), fromIdentifier(), fromOperatorFunctionId(), fromns2(), fromuid2()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public TemplateIdNode* fromTemplateId;
                public Node* fromns;
                public Node* fromud1;
                public IdentifierNode* fromIdentifier;
                public OperatorFunctionIdNode* fromOperatorFunctionId;
                public Node* fromns2;
                public Node* fromuid2;
            }
        }

        public class OperatorFunctionIdRule : System.Text.Parsing.RuleParser
        {
            public OperatorFunctionIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("OperatorFunctionIdNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<OperatorFunctionIdNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* operatorNonterminalParser = GetNonterminal(ToUtf32("Operator"));
                operatorNonterminalParser->SetPost(PostOperator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new OperatorFunctionIdNode(span, context->fromOperator);
            }
            public void PostOperator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOperator_value = stack.Pop();
                    context->fromOperator = *cast<ValueObject<Operator>*>(fromOperator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromOperator()
                {
                }
                public OperatorFunctionIdNode* value;
                public Operator fromOperator;
            }
        }

        public class OperatorRule : System.Text.Parsing.RuleParser
        {
            public OperatorRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Operator"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Operator>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                ActionParser* a12ActionParser = GetAction(ToUtf32("A12"));
                a12ActionParser->SetAction(A12Action);
                ActionParser* a13ActionParser = GetAction(ToUtf32("A13"));
                a13ActionParser->SetAction(A13Action);
                ActionParser* a14ActionParser = GetAction(ToUtf32("A14"));
                a14ActionParser->SetAction(A14Action);
                ActionParser* a15ActionParser = GetAction(ToUtf32("A15"));
                a15ActionParser->SetAction(A15Action);
                ActionParser* a16ActionParser = GetAction(ToUtf32("A16"));
                a16ActionParser->SetAction(A16Action);
                ActionParser* a17ActionParser = GetAction(ToUtf32("A17"));
                a17ActionParser->SetAction(A17Action);
                ActionParser* a18ActionParser = GetAction(ToUtf32("A18"));
                a18ActionParser->SetAction(A18Action);
                ActionParser* a19ActionParser = GetAction(ToUtf32("A19"));
                a19ActionParser->SetAction(A19Action);
                ActionParser* a20ActionParser = GetAction(ToUtf32("A20"));
                a20ActionParser->SetAction(A20Action);
                ActionParser* a21ActionParser = GetAction(ToUtf32("A21"));
                a21ActionParser->SetAction(A21Action);
                ActionParser* a22ActionParser = GetAction(ToUtf32("A22"));
                a22ActionParser->SetAction(A22Action);
                ActionParser* a23ActionParser = GetAction(ToUtf32("A23"));
                a23ActionParser->SetAction(A23Action);
                ActionParser* a24ActionParser = GetAction(ToUtf32("A24"));
                a24ActionParser->SetAction(A24Action);
                ActionParser* a25ActionParser = GetAction(ToUtf32("A25"));
                a25ActionParser->SetAction(A25Action);
                ActionParser* a26ActionParser = GetAction(ToUtf32("A26"));
                a26ActionParser->SetAction(A26Action);
                ActionParser* a27ActionParser = GetAction(ToUtf32("A27"));
                a27ActionParser->SetAction(A27Action);
                ActionParser* a28ActionParser = GetAction(ToUtf32("A28"));
                a28ActionParser->SetAction(A28Action);
                ActionParser* a29ActionParser = GetAction(ToUtf32("A29"));
                a29ActionParser->SetAction(A29Action);
                ActionParser* a30ActionParser = GetAction(ToUtf32("A30"));
                a30ActionParser->SetAction(A30Action);
                ActionParser* a31ActionParser = GetAction(ToUtf32("A31"));
                a31ActionParser->SetAction(A31Action);
                ActionParser* a32ActionParser = GetAction(ToUtf32("A32"));
                a32ActionParser->SetAction(A32Action);
                NonterminalParser* assignmentOperatorNonterminalParser = GetNonterminal(ToUtf32("AssignmentOperator"));
                assignmentOperatorNonterminalParser->SetPost(PostAssignmentOperator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.arrayNew;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.arrayDelete;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.new_;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.delete_;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssignmentOperator;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.inc;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.dec;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.shiftLeft;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.shiftRight;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.logicalAnd;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.logicalOr;
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.equal;
            }
            public void A12Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.notEqual;
            }
            public void A13Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.lessOrEqual;
            }
            public void A14Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.greaterOrEqual;
            }
            public void A15Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.dotStar;
            }
            public void A16Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.arrowStar;
            }
            public void A17Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.arrow;
            }
            public void A18Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.apply;
            }
            public void A19Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.subscript;
            }
            public void A20Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.less;
            }
            public void A21Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.greater;
            }
            public void A22Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.add;
            }
            public void A23Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.sub;
            }
            public void A24Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.mul;
            }
            public void A25Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.div;
            }
            public void A26Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.rem;
            }
            public void A27Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.xor;
            }
            public void A28Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.and_;
            }
            public void A29Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.or_;
            }
            public void A30Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.neg;
            }
            public void A31Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.not_;
            }
            public void A32Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Operator.comma;
            }
            public void PostAssignmentOperator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentOperator_value = stack.Pop();
                    context->fromAssignmentOperator = *cast<ValueObject<Operator>*>(fromAssignmentOperator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromAssignmentOperator()
                {
                }
                public Operator value;
                public Operator fromAssignmentOperator;
            }
        }

        public class ConversionFunctionIdRule : System.Text.Parsing.RuleParser
        {
            public ConversionFunctionIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ConversionFunctionIdNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ConversionFunctionIdNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ConversionFunctionIdNode(span, context->fromTypeExpr);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr()
                {
                }
                public ParsingContext* ctx;
                public ConversionFunctionIdNode* value;
                public Node* fromTypeExpr;
            }
        }

        public class LambdaExpressionRule : System.Text.Parsing.RuleParser
        {
            public LambdaExpressionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("LambdaExpressionNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<LambdaExpressionNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* lambdaCapturesNonterminalParser = GetNonterminal(ToUtf32("LambdaCaptures"));
                lambdaCapturesNonterminalParser->SetPre(PreLambdaCaptures);
                NonterminalParser* parameterListNonterminalParser = GetNonterminal(ToUtf32("ParameterList"));
                parameterListNonterminalParser->SetPre(PreParameterList);
                parameterListNonterminalParser->SetPost(PostParameterList);
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal(ToUtf32("CompoundStatement"));
                compoundStatementNonterminalParser->SetPre(PreCompoundStatement);
                compoundStatementNonterminalParser->SetPost(PostCompoundStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LambdaExpressionNode(span);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->SetParameters(context->fromParameterList);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->SetBody(context->fromCompoundStatement);
            }
            public void PreLambdaCaptures(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<LambdaExpressionNode*>(context->value)));
            }
            public void PreParameterList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostParameterList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromParameterList_value = stack.Pop();
                    context->fromParameterList = *cast<ValueObject<ParameterListNode*>*>(fromParameterList_value.Get());
                }
            }
            public void PreCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context->fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromParameterList(), fromCompoundStatement()
                {
                }
                public ParsingContext* ctx;
                public LambdaExpressionNode* value;
                public ParameterListNode* fromParameterList;
                public CompoundStatementNode* fromCompoundStatement;
            }
        }

        public class LambdaCapturesRule : System.Text.Parsing.RuleParser
        {
            public LambdaCapturesRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("LambdaExpressionNode*"), ToUtf32("lambdaExpression")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> lambdaExpression_value = stack.Pop();
                context->lambdaExpression = *cast<ValueObject<LambdaExpressionNode*>*>(lambdaExpression_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* captureDefaultNonterminalParser = GetNonterminal(ToUtf32("CaptureDefault"));
                captureDefaultNonterminalParser->SetPost(PostCaptureDefault);
                NonterminalParser* capturesNonterminalParser = GetNonterminal(ToUtf32("Captures"));
                capturesNonterminalParser->SetPre(PreCaptures);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->lambdaExpression->AddCapture(context->fromCaptureDefault);
            }
            public void PostCaptureDefault(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCaptureDefault_value = stack.Pop();
                    context->fromCaptureDefault = *cast<ValueObject<Node*>*>(fromCaptureDefault_value.Get());
                }
            }
            public void PreCaptures(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<LambdaExpressionNode*>(context->lambdaExpression)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : lambdaExpression(), fromCaptureDefault()
                {
                }
                public LambdaExpressionNode* lambdaExpression;
                public Node* fromCaptureDefault;
            }
        }

        public class CaptureDefaultRule : System.Text.Parsing.RuleParser
        {
            public CaptureDefaultRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AssignCapture(span);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new RefCapture(span);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Node* value;
            }
        }

        public class CapturesRule : System.Text.Parsing.RuleParser
        {
            public CapturesRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("LambdaExpressionNode*"), ToUtf32("lambdaExpression")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> lambdaExpression_value = stack.Pop();
                context->lambdaExpression = *cast<ValueObject<LambdaExpressionNode*>*>(lambdaExpression_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->lambdaExpression->AddCapture(context->fromleft);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->lambdaExpression->AddCapture(context->fromright);
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<Node*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<Node*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : lambdaExpression(), fromleft(), fromright()
                {
                }
                public LambdaExpressionNode* lambdaExpression;
                public Node* fromleft;
                public Node* fromright;
            }
        }

        public class CaptureRule : System.Text.Parsing.RuleParser
        {
            public CaptureRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new IdentifierCapture(span, context->fromIdentifier);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ThisCapture(span);
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromIdentifier()
                {
                }
                public Node* value;
                public IdentifierNode* fromIdentifier;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.FunctionGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.FunctionGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.TemplateGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.TemplateGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("cppparser.StatementGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new cppparser.StatementGrammar(pd);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = pd->GetGrammar(ToUtf32("cppparser.IdentifierGrammar"));
            if (grammar3 == null)
            {
                grammar3 = new cppparser.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar4 == null)
            {
                grammar4 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar4);
            Grammar* grammar5 = pd->GetGrammar(ToUtf32("cppparser.TypeExprGrammar"));
            if (grammar5 == null)
            {
                grammar5 = new cppparser.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar5);
            Grammar* grammar6 = pd->GetGrammar(ToUtf32("cppparser.DeclaratorGrammar"));
            if (grammar6 == null)
            {
                grammar6 = new cppparser.DeclaratorGrammar(pd);
            }
            AddGrammarReference(grammar6);
            Grammar* grammar7 = pd->GetGrammar(ToUtf32("cppparser.SimpleTypeGrammar"));
            if (grammar7 == null)
            {
                grammar7 = new cppparser.SimpleTypeGrammar(pd);
            }
            AddGrammarReference(grammar7);
            Grammar* grammar8 = pd->GetGrammar(ToUtf32("cppparser.LiteralGrammar"));
            if (grammar8 == null)
            {
                grammar8 = new cppparser.LiteralGrammar(pd);
            }
            AddGrammarReference(grammar8);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("InitializerList"), this, ToUtf32("DeclaratorGrammar.InitializerList")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("InitializerClause"), this, ToUtf32("DeclaratorGrammar.InitializerClause")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("BracedInitializerList"), this, ToUtf32("DeclaratorGrammar.BracedInitializerList")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("SimpleType"), this, ToUtf32("SimpleTypeGrammar.SimpleType")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Literal"), this, ToUtf32("LiteralGrammar.Literal")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("SimpleTypeSpecifier"), this, ToUtf32("SimpleTypeGrammar.SimpleTypeSpecifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TemplateId"), this, ToUtf32("TemplateGrammar.TemplateId")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("NestedNameSpecifier"), this, ToUtf32("IdentifierGrammar.NestedNameSpecifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ParameterList"), this, ToUtf32("FunctionGrammar.ParameterList")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("CompoundStatement"), this, ToUtf32("StatementGrammar.CompoundStatement")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("identifier"), this, ToUtf32("System.Text.Parsing.stdlib.identifier")));
            AddRule(new ExpressionListRule(ToUtf32("ExpressionList"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.EmptyParser()),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ic1"), ToUtf32("InitializerClause"), 1))),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser(','),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("ic2"), ToUtf32("InitializerClause"), 1))))))))));
            AddRule(new PossiblyEmptyArgumentListRule(ToUtf32("PossiblyEmptyArgumentList"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("ExpressionList"), ToUtf32("ExpressionList"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.EmptyParser()))));
            AddRule(new ExpressionRule(ToUtf32("Expression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("AssignmentExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser(','),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("AssignmentExpression"), 1))))))))));
            AddRule(new ConstantExpressionRule(ToUtf32("ConstantExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("ConditionalExpression"), ToUtf32("ConditionalExpression"), 1))));
            AddRule(new AssignmentExpressionRule(ToUtf32("AssignmentExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ConcreteAssignmentExpression"), ToUtf32("ConcreteAssignmentExpression"), 1)),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ConditionalExpression"), ToUtf32("ConditionalExpression"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("ThrowExpression"), ToUtf32("ThrowExpression"), 1)))));
            AddRule(new ConcreteAssignmentExpressionRule(ToUtf32("ConcreteAssignmentExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.EmptyParser()),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("LogicalOrExpression"), ToUtf32("LogicalOrExpression"), 1)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentOperator"), ToUtf32("AssignmentOperator"), 0)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("InitializerClause"), ToUtf32("InitializerClause"), 1))))))));
            AddRule(new AssignmentOperatorRule(ToUtf32("AssignmentOperator"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.DifferenceParser(
                                                                    new System.Text.Parsing.StringParser(ToUtf32("=")),
                                                                    new System.Text.Parsing.StringParser(ToUtf32("=="))))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                            new System.Text.Parsing.StringParser(ToUtf32("*=")))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                        new System.Text.Parsing.StringParser(ToUtf32("/=")))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                    new System.Text.Parsing.StringParser(ToUtf32("%=")))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                new System.Text.Parsing.StringParser(ToUtf32("+=")))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.StringParser(ToUtf32("-=")))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                        new System.Text.Parsing.StringParser(ToUtf32(">>=")))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                    new System.Text.Parsing.StringParser(ToUtf32("<<=")))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                new System.Text.Parsing.StringParser(ToUtf32("&=")))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                            new System.Text.Parsing.StringParser(ToUtf32("^=")))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                        new System.Text.Parsing.StringParser(ToUtf32("|="))))));
            AddRule(new ConditionalExpressionRule(ToUtf32("ConditionalExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("LogicalOrExpression"), ToUtf32("LogicalOrExpression"), 1)),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharParser('?'),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)),
                                            new System.Text.Parsing.CharParser(':')),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentExpression"), ToUtf32("AssignmentExpression"), 1))))))))));
            AddRule(new ThrowExpressionRule(ToUtf32("ThrowExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("throw")),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentExpression"), ToUtf32("AssignmentExpression"), 1)))))));
            AddRule(new LogicalOrExpressionRule(ToUtf32("LogicalOrExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("LogicalAndExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.StringParser(ToUtf32("||"))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("LogicalAndExpression"), 1))))))))));
            AddRule(new LogicalAndExpressionRule(ToUtf32("LogicalAndExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("InclusiveOrExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.StringParser(ToUtf32("&&"))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("InclusiveOrExpression"), 1))))))))));
            AddRule(new InclusiveOrExpressionRule(ToUtf32("InclusiveOrExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("ExclusiveOrExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.DifferenceParser(
                                                    new System.Text.Parsing.CharParser('|'),
                                                    new System.Text.Parsing.GroupingParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.StringParser(ToUtf32("|=")),
                                                            new System.Text.Parsing.StringParser(ToUtf32("||"))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("ExclusiveOrExpression"), 1))))))))));
            AddRule(new ExclusiveOrExpressionRule(ToUtf32("ExclusiveOrExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("AndExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.DifferenceParser(
                                                    new System.Text.Parsing.CharParser('^'),
                                                    new System.Text.Parsing.StringParser(ToUtf32("^="))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("AndExpression"), 1))))))))));
            AddRule(new AndExpressionRule(ToUtf32("AndExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("EqualityExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.DifferenceParser(
                                                    new System.Text.Parsing.CharParser('&'),
                                                    new System.Text.Parsing.GroupingParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.StringParser(ToUtf32("&=")),
                                                            new System.Text.Parsing.StringParser(ToUtf32("&&"))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("EqualityExpression"), 1))))))))));
            AddRule(new EqualityExpressionRule(ToUtf32("EqualityExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("RelationalExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.StringParser(ToUtf32("=="))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                        new System.Text.Parsing.StringParser(ToUtf32("!=")))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("RelationalExpression"), 1))))))))));
            AddRule(new RelationalExpressionRule(ToUtf32("RelationalExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("ShiftExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                                new System.Text.Parsing.StringParser(ToUtf32("<="))),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                                new System.Text.Parsing.StringParser(ToUtf32(">=")))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.DifferenceParser(
                                                                    new System.Text.Parsing.CharParser('<'),
                                                                    new System.Text.Parsing.GroupingParser(
                                                                        new System.Text.Parsing.AlternativeParser(
                                                                            new System.Text.Parsing.StringParser(ToUtf32("<<")),
                                                                            new System.Text.Parsing.StringParser(ToUtf32("<<=")))))))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.CharParser('>'),
                                                                new System.Text.Parsing.GroupingParser(
                                                                    new System.Text.Parsing.AlternativeParser(
                                                                        new System.Text.Parsing.StringParser(ToUtf32(">>")),
                                                                        new System.Text.Parsing.StringParser(ToUtf32(">>=")))))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("ShiftExpression"), 1))))))))));
            AddRule(new ShiftExpressionRule(ToUtf32("ShiftExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("AdditiveExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.StringParser(ToUtf32("<<")),
                                                                new System.Text.Parsing.StringParser(ToUtf32("<<="))))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.StringParser(ToUtf32(">>")),
                                                                new System.Text.Parsing.StringParser(ToUtf32(">>=")))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("AdditiveExpression"), 1)))))))))));
            AddRule(new AdditiveExpressionRule(ToUtf32("AdditiveExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("MultiplicativeExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.CharParser('+'),
                                                                new System.Text.Parsing.StringParser(ToUtf32("+="))))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.CharParser('-'),
                                                                new System.Text.Parsing.StringParser(ToUtf32("-=")))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("MultiplicativeExpression"), 1))))))))));
            AddRule(new MultiplicativeExpressionRule(ToUtf32("MultiplicativeExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("PMExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.DifferenceParser(
                                                                    new System.Text.Parsing.CharParser('*'),
                                                                    new System.Text.Parsing.StringParser(ToUtf32("*="))))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.DifferenceParser(
                                                                    new System.Text.Parsing.CharParser('/'),
                                                                    new System.Text.Parsing.StringParser(ToUtf32("/=")))))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.DifferenceParser(
                                                                new System.Text.Parsing.CharParser('%'),
                                                                new System.Text.Parsing.StringParser(ToUtf32("%=")))))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("PMExpression"), 1))))))))));
            AddRule(new PMExpressionRule(ToUtf32("PMExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("CastExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                    new System.Text.Parsing.StringParser(ToUtf32(".*"))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                    new System.Text.Parsing.StringParser(ToUtf32("->*"))))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("CastExpression"), 1))))))))));
            AddRule(new CastExpressionRule(ToUtf32("CastExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharParser('('),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1)),
                                            new System.Text.Parsing.CharParser(')')),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("CastExpression"), ToUtf32("CastExpression"), 1)))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("UnaryExpression"), ToUtf32("UnaryExpression"), 1)))))));
            AddRule(new UnaryExpressionRule(ToUtf32("UnaryExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                new System.Text.Parsing.GroupingParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.StringParser(ToUtf32("++")),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("c1"), ToUtf32("CastExpression"), 1)))),
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.StringParser(ToUtf32("--")),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("c2"), ToUtf32("CastExpression"), 1)))),
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("op"), ToUtf32("UnaryOperator"), 0),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("c3"), ToUtf32("CastExpression"), 1)))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("sizeof")),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("u4"), ToUtf32("UnaryExpression"), 1))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("alignof")),
                                                    new System.Text.Parsing.CharParser('(')),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("t5"), ToUtf32("TypeExpr"), 1)),
                                            new System.Text.Parsing.CharParser(')'))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("NewExpression"), ToUtf32("NewExpression"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DeleteExpression"), ToUtf32("DeleteExpression"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("PostfixExpression"), ToUtf32("PostfixExpression"), 1)))));
            AddRule(new UnaryOperatorRule(ToUtf32("UnaryOperator"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.DifferenceParser(
                                                new System.Text.Parsing.CharParser('*'),
                                                new System.Text.Parsing.StringParser(ToUtf32("*="))))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.DifferenceParser(
                                                new System.Text.Parsing.CharParser('&'),
                                                new System.Text.Parsing.StringParser(ToUtf32("&=")))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.DifferenceParser(
                                            new System.Text.Parsing.CharParser('+'),
                                            new System.Text.Parsing.StringParser(ToUtf32("+=")))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.DifferenceParser(
                                        new System.Text.Parsing.CharParser('-'),
                                        new System.Text.Parsing.StringParser(ToUtf32("-=")))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                            new System.Text.Parsing.CharParser('!'))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                        new System.Text.Parsing.CharParser('~')))));
            AddRule(new NewExpressionRule(ToUtf32("NewExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("new")),
                                    new System.Text.Parsing.OptionalParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NewPlacement"), ToUtf32("NewPlacement"), 1))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("NewTypeId"), ToUtf32("NewTypeId"), 1)),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("NewInitializer"), ToUtf32("NewInitializer"), 1)))))));
            AddRule(new NewPlacementRule(ToUtf32("NewPlacement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('('),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ExpressionList"), ToUtf32("ExpressionList"), 1)),
                            new System.Text.Parsing.CharParser(')'))))));
            AddRule(new NewTypeIdRule(ToUtf32("NewTypeId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("TypeExpr"), 1)),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("size"), ToUtf32("NewDeclarator"), 1)))))));
            AddRule(new NewDeclaratorRule(ToUtf32("NewDeclarator"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.CharParser('[')),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("size"), ToUtf32("Expression"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.CharParser(']')))));
            AddRule(new NewInitializerRule(ToUtf32("NewInitializer"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('('),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("args"), ToUtf32("PossiblyEmptyArgumentList"), 1)),
                            new System.Text.Parsing.CharParser(')'))))));
            AddRule(new DeleteExpressionRule(ToUtf32("DeleteExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("delete")),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('['),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.CharParser(']')))))),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("CastExpression"), ToUtf32("CastExpression"), 1))))));
            AddRule(new PostfixExpressionRule(ToUtf32("PostfixExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("PrimaryExpression"), ToUtf32("PrimaryExpression"), 1)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                    new System.Text.Parsing.CharParser('[')),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("subscript"), ToUtf32("Expression"), 1)),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                                new System.Text.Parsing.CharParser(']'))),
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                                    new System.Text.Parsing.CharParser('(')),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("arguments"), ToUtf32("PossiblyEmptyArgumentList"), 1)),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                                new System.Text.Parsing.CharParser(')')))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.GroupingParser(
                                                                    new System.Text.Parsing.DifferenceParser(
                                                                        new System.Text.Parsing.CharParser('.'),
                                                                        new System.Text.Parsing.StringParser(ToUtf32(".*")))),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("id1"), ToUtf32("IdExpression"), 1))))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                                    new System.Text.Parsing.GroupingParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.GroupingParser(
                                                                new System.Text.Parsing.DifferenceParser(
                                                                    new System.Text.Parsing.StringParser(ToUtf32("->")),
                                                                    new System.Text.Parsing.StringParser(ToUtf32("->*")))),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("id2"), ToUtf32("IdExpression"), 1))))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                                new System.Text.Parsing.StringParser(ToUtf32("++")))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                            new System.Text.Parsing.StringParser(ToUtf32("--")))))))))));
            AddRule(new PrimaryExpressionRule(ToUtf32("PrimaryExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("Literal"), ToUtf32("Literal"), 0)),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                new System.Text.Parsing.KeywordParser(ToUtf32("this")))),
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                new System.Text.Parsing.EmptyParser()),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("DefinedExpr"), ToUtf32("DefinedExpr"), 0)))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                        new System.Text.Parsing.GroupingParser(
                                                            new System.Text.Parsing.SequenceParser(
                                                                new System.Text.Parsing.SequenceParser(
                                                                    new System.Text.Parsing.CharParser('('),
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("expr"), ToUtf32("Expression"), 1)),
                                                                new System.Text.Parsing.CharParser(')'))))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CppCastExpression"), ToUtf32("CppCastExpression"), 1))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("TypeIdExpression"), ToUtf32("TypeIdExpression"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("s1"), ToUtf32("SimpleTypeSpecifier"), 0),
                                                            new System.Text.Parsing.CharParser('(')),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("args1"), ToUtf32("PossiblyEmptyArgumentList"), 1)),
                                                    new System.Text.Parsing.CharParser(')'))))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("s2"), ToUtf32("SimpleTypeSpecifier"), 0),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("b1"), ToUtf32("BracedInitializerList"), 1))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("t1"), ToUtf32("TypeExpr"), 1),
                                                    new System.Text.Parsing.CharParser('(')),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("args2"), ToUtf32("PossiblyEmptyArgumentList"), 1)),
                                            new System.Text.Parsing.CharParser(')'))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("t2"), ToUtf32("TypeExpr"), 1),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("b2"), ToUtf32("BracedInitializerList"), 1))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("IdExpression"), ToUtf32("IdExpression"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A12"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("LambdaExpression"), ToUtf32("LambdaExpression"), 1)))));
            AddRule(new CppCastExpressionRule(ToUtf32("CppCastExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.GroupingParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.AlternativeParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                    new System.Text.Parsing.KeywordParser(ToUtf32("dynamic_cast"))),
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                    new System.Text.Parsing.KeywordParser(ToUtf32("static_cast")))),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                                new System.Text.Parsing.KeywordParser(ToUtf32("reinterpret_cast")))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                            new System.Text.Parsing.KeywordParser(ToUtf32("const_cast"))))),
                                                new System.Text.Parsing.CharParser('<')),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("t1"), ToUtf32("TypeExpr"), 1)),
                                        new System.Text.Parsing.CharParser('>')),
                                    new System.Text.Parsing.CharParser('(')),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("e1"), ToUtf32("Expression"), 1)),
                            new System.Text.Parsing.CharParser(')'))))));
            AddRule(new DefinedExprRule(ToUtf32("DefinedExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("defined")),
                                                new System.Text.Parsing.CharParser('(')),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("id1"), ToUtf32("identifier"), 0)),
                                        new System.Text.Parsing.CharParser(')')))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("defined")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("id2"), ToUtf32("identifier"), 0))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("defined")),
                                            new System.Text.Parsing.CharParser('(')),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("lit1"), ToUtf32("Literal"), 0)),
                                    new System.Text.Parsing.CharParser(')'))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("defined")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("lit2"), ToUtf32("Literal"), 0)))))));
            AddRule(new TypeIdExpressionRule(ToUtf32("TypeIdExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("typeid")),
                                        new System.Text.Parsing.CharParser('(')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("t1"), ToUtf32("TypeExpr"), 1)),
                                new System.Text.Parsing.CharParser(')')))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("typeid")),
                                        new System.Text.Parsing.CharParser('(')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("e1"), ToUtf32("Expression"), 1)),
                                new System.Text.Parsing.CharParser(')')))))));
            AddRule(new IdExpressionRule(ToUtf32("IdExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("QualifiedIdExpr"), ToUtf32("QualifiedIdExpr"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("UnqualifiedIdExpr"), ToUtf32("UnqualifiedIdExpr"), 1)))));
            AddRule(new UnqualifiedIdExprRule(ToUtf32("UnqualifiedIdExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateId"), ToUtf32("TemplateId"), 1)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("id1"), ToUtf32("Identifier"), 0))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("OperatorFunctionId"), ToUtf32("OperatorFunctionId"), 0))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ConversionFunctionId"), ToUtf32("ConversionFunctionId"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('~'),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("id2"), ToUtf32("Identifier"), 0)))))));
            AddRule(new QualifiedIdExprRule(ToUtf32("QualifiedIdExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.StringParser(ToUtf32("::")),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateId"), ToUtf32("TemplateId"), 1)))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.StringParser(ToUtf32("::")),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ns"), ToUtf32("NestedNameSpecifier"), 1)),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("ud1"), ToUtf32("UnqualifiedIdExpr"), 1))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.StringParser(ToUtf32("::")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.StringParser(ToUtf32("::")),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("OperatorFunctionId"), ToUtf32("OperatorFunctionId"), 0))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ns2"), ToUtf32("NestedNameSpecifier"), 1),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("uid2"), ToUtf32("UnqualifiedIdExpr"), 1)))))));
            AddRule(new OperatorFunctionIdRule(ToUtf32("OperatorFunctionId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("operator")),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Operator"), ToUtf32("Operator"), 0))))));
            AddRule(new OperatorRule(ToUtf32("Operator"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.AlternativeParser(
                                                                new System.Text.Parsing.AlternativeParser(
                                                                    new System.Text.Parsing.AlternativeParser(
                                                                        new System.Text.Parsing.AlternativeParser(
                                                                            new System.Text.Parsing.AlternativeParser(
                                                                                new System.Text.Parsing.AlternativeParser(
                                                                                    new System.Text.Parsing.AlternativeParser(
                                                                                        new System.Text.Parsing.AlternativeParser(
                                                                                            new System.Text.Parsing.AlternativeParser(
                                                                                                new System.Text.Parsing.AlternativeParser(
                                                                                                    new System.Text.Parsing.AlternativeParser(
                                                                                                        new System.Text.Parsing.AlternativeParser(
                                                                                                            new System.Text.Parsing.AlternativeParser(
                                                                                                                new System.Text.Parsing.AlternativeParser(
                                                                                                                    new System.Text.Parsing.AlternativeParser(
                                                                                                                        new System.Text.Parsing.AlternativeParser(
                                                                                                                            new System.Text.Parsing.AlternativeParser(
                                                                                                                                new System.Text.Parsing.AlternativeParser(
                                                                                                                                    new System.Text.Parsing.AlternativeParser(
                                                                                                                                        new System.Text.Parsing.AlternativeParser(
                                                                                                                                            new System.Text.Parsing.AlternativeParser(
                                                                                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                                                                                                    new System.Text.Parsing.GroupingParser(
                                                                                                                                                        new System.Text.Parsing.SequenceParser(
                                                                                                                                                            new System.Text.Parsing.KeywordParser(ToUtf32("new")),
                                                                                                                                                            new System.Text.Parsing.StringParser(ToUtf32("[]"))))),
                                                                                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                                                                                                    new System.Text.Parsing.GroupingParser(
                                                                                                                                                        new System.Text.Parsing.SequenceParser(
                                                                                                                                                            new System.Text.Parsing.KeywordParser(ToUtf32("delete")),
                                                                                                                                                            new System.Text.Parsing.StringParser(ToUtf32("[]")))))),
                                                                                                                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                                                                                                new System.Text.Parsing.KeywordParser(ToUtf32("new")))),
                                                                                                                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                                                                                                            new System.Text.Parsing.KeywordParser(ToUtf32("delete")))),
                                                                                                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                                                                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentOperator"), ToUtf32("AssignmentOperator"), 0))),
                                                                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                                                                                                    new System.Text.Parsing.StringParser(ToUtf32("++")))),
                                                                                                                            new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                                                                                                new System.Text.Parsing.StringParser(ToUtf32("--")))),
                                                                                                                        new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                                                                                                            new System.Text.Parsing.StringParser(ToUtf32("<<")))),
                                                                                                                    new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                                                                                                        new System.Text.Parsing.StringParser(ToUtf32(">>")))),
                                                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                                                                                                    new System.Text.Parsing.StringParser(ToUtf32("&&")))),
                                                                                                            new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                                                                                                                new System.Text.Parsing.StringParser(ToUtf32("||")))),
                                                                                                        new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                                                                                                            new System.Text.Parsing.StringParser(ToUtf32("==")))),
                                                                                                    new System.Text.Parsing.ActionParser(ToUtf32("A12"),
                                                                                                        new System.Text.Parsing.StringParser(ToUtf32("!=")))),
                                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A13"),
                                                                                                    new System.Text.Parsing.StringParser(ToUtf32("<=")))),
                                                                                            new System.Text.Parsing.ActionParser(ToUtf32("A14"),
                                                                                                new System.Text.Parsing.StringParser(ToUtf32(">=")))),
                                                                                        new System.Text.Parsing.ActionParser(ToUtf32("A15"),
                                                                                            new System.Text.Parsing.StringParser(ToUtf32(".*")))),
                                                                                    new System.Text.Parsing.ActionParser(ToUtf32("A16"),
                                                                                        new System.Text.Parsing.StringParser(ToUtf32("->*")))),
                                                                                new System.Text.Parsing.ActionParser(ToUtf32("A17"),
                                                                                    new System.Text.Parsing.StringParser(ToUtf32("->")))),
                                                                            new System.Text.Parsing.ActionParser(ToUtf32("A18"),
                                                                                new System.Text.Parsing.StringParser(ToUtf32("()")))),
                                                                        new System.Text.Parsing.ActionParser(ToUtf32("A19"),
                                                                            new System.Text.Parsing.StringParser(ToUtf32("[]")))),
                                                                    new System.Text.Parsing.ActionParser(ToUtf32("A20"),
                                                                        new System.Text.Parsing.CharParser('<'))),
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A21"),
                                                                    new System.Text.Parsing.CharParser('>'))),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A22"),
                                                                new System.Text.Parsing.CharParser('+'))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A23"),
                                                            new System.Text.Parsing.CharParser('-'))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A24"),
                                                        new System.Text.Parsing.CharParser('*'))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A25"),
                                                    new System.Text.Parsing.CharParser('/'))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A26"),
                                                new System.Text.Parsing.CharParser('%'))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A27"),
                                            new System.Text.Parsing.CharParser('^'))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A28"),
                                        new System.Text.Parsing.CharParser('&'))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A29"),
                                    new System.Text.Parsing.CharParser('|'))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A30"),
                                new System.Text.Parsing.CharParser('~'))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A31"),
                            new System.Text.Parsing.CharParser('!'))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A32"),
                        new System.Text.Parsing.CharParser(',')))));
            AddRule(new ConversionFunctionIdRule(ToUtf32("ConversionFunctionId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("operator")),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1))))));
            AddRule(new LambdaExpressionRule(ToUtf32("LambdaExpression"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.CharParser('[')),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("LambdaCaptures"), ToUtf32("LambdaCaptures"), 1)),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(']'))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ParameterList"), ToUtf32("ParameterList"), 1))))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("CompoundStatement"), ToUtf32("CompoundStatement"), 1)))))));
            AddRule(new LambdaCapturesRule(ToUtf32("LambdaCaptures"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("CaptureDefault"), ToUtf32("CaptureDefault"), 0)))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Captures"), ToUtf32("Captures"), 1)))));
            AddRule(new CaptureDefaultRule(ToUtf32("CaptureDefault"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.CharParser('=')),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.CharParser('&')))));
            AddRule(new CapturesRule(ToUtf32("Captures"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Capture"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(','),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Capture"), 0))))))));
            AddRule(new CaptureRule(ToUtf32("Capture"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("this"))))));
        }
    }
} // cppparser
namespace cppparser
{
    public class ConstantExpressionGrammar : System.Text.Parsing.Grammar
    {
        public ConstantExpressionGrammar() : this(new ParsingDomain())
        {
        }
        public ConstantExpressionGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("ConstantExpressionGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public Node* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            Node* result = *cast<ValueObject<Node*>*>(value.Get());
            return result;
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.ExpressionGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar1 == null)
            {
                grammar1 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar1);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ConstantExpression"), this, ToUtf32("ExpressionGrammar.ConstantExpression")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("spaces"), this, ToUtf32("System.Text.Parsing.stdlib.spaces")));
            SetStartRuleName(ToUtf32("ConstantExpression"));
            SetSkipRuleName(ToUtf32("spaces"));
        }
    }
} // cppparser

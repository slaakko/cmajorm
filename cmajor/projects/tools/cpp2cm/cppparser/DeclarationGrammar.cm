using System;
using System.Collections;
using System.Text.Parsing;
using cppast;

// this source file has been automatically generated from 'DeclarationGrammar.parser' using cmparsergen version 2.0.0.

namespace cppparser
{
    public class DeclarationGrammar : System.Text.Parsing.Grammar
    {
        public DeclarationGrammar() : this(new ParsingDomain())
        {
        }
        public DeclarationGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("DeclarationGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx, CompositeNode<Node>* parent)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            stack.Push(UniquePtr<Object>(new ValueObject<CompositeNode<Node>*>(parent)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class DeclarationsRule : System.Text.Parsing.RuleParser
        {
            public DeclarationsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("CompositeNode<Node>*"), ToUtf32("parent")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> parent_value = stack.Pop();
                context->parent = *cast<ValueObject<CompositeNode<Node>*>*>(parent_value.Get());
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* declarationNonterminalParser = GetNonterminal(ToUtf32("Declaration"));
                declarationNonterminalParser->SetPre(PreDeclaration);
                declarationNonterminalParser->SetPost(PostDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->parent->AddNode(context->fromDeclaration);
            }
            public void PreDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclaration_value = stack.Pop();
                    context->fromDeclaration = *cast<ValueObject<Node*>*>(fromDeclaration_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), parent(), fromDeclaration()
                {
                }
                public ParsingContext* ctx;
                public CompositeNode<Node>* parent;
                public Node* fromDeclaration;
            }
        }

        public class DeclarationRule : System.Text.Parsing.RuleParser
        {
            public DeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                NonterminalParser* namespaceDefinitionNonterminalParser = GetNonterminal(ToUtf32("NamespaceDefinition"));
                namespaceDefinitionNonterminalParser->SetPre(PreNamespaceDefinition);
                namespaceDefinitionNonterminalParser->SetPost(PostNamespaceDefinition);
                NonterminalParser* linkageSpecificationNonterminalParser = GetNonterminal(ToUtf32("LinkageSpecification"));
                linkageSpecificationNonterminalParser->SetPre(PreLinkageSpecification);
                linkageSpecificationNonterminalParser->SetPost(PostLinkageSpecification);
                NonterminalParser* functionDefinitionNonterminalParser = GetNonterminal(ToUtf32("FunctionDefinition"));
                functionDefinitionNonterminalParser->SetPre(PreFunctionDefinition);
                functionDefinitionNonterminalParser->SetPost(PostFunctionDefinition);
                NonterminalParser* specialMemberFunctionDefinitionNonterminalParser = GetNonterminal(ToUtf32("SpecialMemberFunctionDefinition"));
                specialMemberFunctionDefinitionNonterminalParser->SetPre(PreSpecialMemberFunctionDefinition);
                specialMemberFunctionDefinitionNonterminalParser->SetPost(PostSpecialMemberFunctionDefinition);
                NonterminalParser* templateDeclarationNonterminalParser = GetNonterminal(ToUtf32("TemplateDeclaration"));
                templateDeclarationNonterminalParser->SetPre(PreTemplateDeclaration);
                templateDeclarationNonterminalParser->SetPost(PostTemplateDeclaration);
                NonterminalParser* explicitInstantiationNonterminalParser = GetNonterminal(ToUtf32("ExplicitInstantiation"));
                explicitInstantiationNonterminalParser->SetPre(PreExplicitInstantiation);
                explicitInstantiationNonterminalParser->SetPost(PostExplicitInstantiation);
                NonterminalParser* explicitSpecializationNonterminalParser = GetNonterminal(ToUtf32("ExplicitSpecialization"));
                explicitSpecializationNonterminalParser->SetPre(PreExplicitSpecialization);
                explicitSpecializationNonterminalParser->SetPost(PostExplicitSpecialization);
                NonterminalParser* classDeclarationNonterminalParser = GetNonterminal(ToUtf32("ClassDeclaration"));
                classDeclarationNonterminalParser->SetPre(PreClassDeclaration);
                classDeclarationNonterminalParser->SetPost(PostClassDeclaration);
                NonterminalParser* enumDeclarationNonterminalParser = GetNonterminal(ToUtf32("EnumDeclaration"));
                enumDeclarationNonterminalParser->SetPre(PreEnumDeclaration);
                enumDeclarationNonterminalParser->SetPost(PostEnumDeclaration);
                NonterminalParser* blockDeclarationNonterminalParser = GetNonterminal(ToUtf32("BlockDeclaration"));
                blockDeclarationNonterminalParser->SetPre(PreBlockDeclaration);
                blockDeclarationNonterminalParser->SetPost(PostBlockDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNamespaceDefinition;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLinkageSpecification;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFunctionDefinition;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSpecialMemberFunctionDefinition;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTemplateDeclaration;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExplicitInstantiation;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExplicitSpecialization;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromClassDeclaration;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEnumDeclaration;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBlockDeclaration;
            }
            public void PreNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNamespaceDefinition_value = stack.Pop();
                    context->fromNamespaceDefinition = *cast<ValueObject<NamespaceNode*>*>(fromNamespaceDefinition_value.Get());
                }
            }
            public void PreLinkageSpecification(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLinkageSpecification(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLinkageSpecification_value = stack.Pop();
                    context->fromLinkageSpecification = *cast<ValueObject<LinkageSpecificationNode*>*>(fromLinkageSpecification_value.Get());
                }
            }
            public void PreFunctionDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostFunctionDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionDefinition_value = stack.Pop();
                    context->fromFunctionDefinition = *cast<ValueObject<FunctionNode*>*>(fromFunctionDefinition_value.Get());
                }
            }
            public void PreSpecialMemberFunctionDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostSpecialMemberFunctionDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSpecialMemberFunctionDefinition_value = stack.Pop();
                    context->fromSpecialMemberFunctionDefinition = *cast<ValueObject<SpecialMemberFunctionNode*>*>(fromSpecialMemberFunctionDefinition_value.Get());
                }
            }
            public void PreTemplateDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTemplateDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTemplateDeclaration_value = stack.Pop();
                    context->fromTemplateDeclaration = *cast<ValueObject<TemplateDeclarationNode*>*>(fromTemplateDeclaration_value.Get());
                }
            }
            public void PreExplicitInstantiation(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExplicitInstantiation(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExplicitInstantiation_value = stack.Pop();
                    context->fromExplicitInstantiation = *cast<ValueObject<ExplicitInstantiationNode*>*>(fromExplicitInstantiation_value.Get());
                }
            }
            public void PreExplicitSpecialization(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExplicitSpecialization(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExplicitSpecialization_value = stack.Pop();
                    context->fromExplicitSpecialization = *cast<ValueObject<ExplicitSpecializationNode*>*>(fromExplicitSpecialization_value.Get());
                }
            }
            public void PreClassDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostClassDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromClassDeclaration_value = stack.Pop();
                    context->fromClassDeclaration = *cast<ValueObject<ClassNode*>*>(fromClassDeclaration_value.Get());
                }
            }
            public void PreEnumDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumDeclaration_value = stack.Pop();
                    context->fromEnumDeclaration = *cast<ValueObject<EnumTypeNode*>*>(fromEnumDeclaration_value.Get());
                }
            }
            public void PreBlockDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBlockDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBlockDeclaration_value = stack.Pop();
                    context->fromBlockDeclaration = *cast<ValueObject<Node*>*>(fromBlockDeclaration_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromNamespaceDefinition(), fromLinkageSpecification(), fromFunctionDefinition(), fromSpecialMemberFunctionDefinition(), fromTemplateDeclaration(), fromExplicitInstantiation(), fromExplicitSpecialization(), fromClassDeclaration(), fromEnumDeclaration(), fromBlockDeclaration()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public NamespaceNode* fromNamespaceDefinition;
                public LinkageSpecificationNode* fromLinkageSpecification;
                public FunctionNode* fromFunctionDefinition;
                public SpecialMemberFunctionNode* fromSpecialMemberFunctionDefinition;
                public TemplateDeclarationNode* fromTemplateDeclaration;
                public ExplicitInstantiationNode* fromExplicitInstantiation;
                public ExplicitSpecializationNode* fromExplicitSpecialization;
                public ClassNode* fromClassDeclaration;
                public EnumTypeNode* fromEnumDeclaration;
                public Node* fromBlockDeclaration;
            }
        }

        public class NamespaceDefinitionRule : System.Text.Parsing.RuleParser
        {
            public NamespaceDefinitionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("NamespaceNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<NamespaceNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* namedNamespaceDefinitionNonterminalParser = GetNonterminal(ToUtf32("NamedNamespaceDefinition"));
                namedNamespaceDefinitionNonterminalParser->SetPre(PreNamedNamespaceDefinition);
                namedNamespaceDefinitionNonterminalParser->SetPost(PostNamedNamespaceDefinition);
                NonterminalParser* unnamedNamespaceDefinitionNonterminalParser = GetNonterminal(ToUtf32("UnnamedNamespaceDefinition"));
                unnamedNamespaceDefinitionNonterminalParser->SetPre(PreUnnamedNamespaceDefinition);
                unnamedNamespaceDefinitionNonterminalParser->SetPost(PostUnnamedNamespaceDefinition);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNamedNamespaceDefinition;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUnnamedNamespaceDefinition;
            }
            public void PreNamedNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostNamedNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNamedNamespaceDefinition_value = stack.Pop();
                    context->fromNamedNamespaceDefinition = *cast<ValueObject<NamespaceNode*>*>(fromNamedNamespaceDefinition_value.Get());
                }
            }
            public void PreUnnamedNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostUnnamedNamespaceDefinition(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUnnamedNamespaceDefinition_value = stack.Pop();
                    context->fromUnnamedNamespaceDefinition = *cast<ValueObject<NamespaceNode*>*>(fromUnnamedNamespaceDefinition_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromNamedNamespaceDefinition(), fromUnnamedNamespaceDefinition()
                {
                }
                public ParsingContext* ctx;
                public NamespaceNode* value;
                public NamespaceNode* fromNamedNamespaceDefinition;
                public NamespaceNode* fromUnnamedNamespaceDefinition;
            }
        }

        public class NamedNamespaceDefinitionRule : System.Text.Parsing.RuleParser
        {
            public NamedNamespaceDefinitionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("NamespaceNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<NamespaceNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
                NonterminalParser* declarationsNonterminalParser = GetNonterminal(ToUtf32("Declarations"));
                declarationsNonterminalParser->SetPre(PreDeclarations);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new NamespaceNode(span, context->fromleft);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->id.Reset(new ColonColonNode(span, context->value->id.Release(), context->fromright));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<IdentifierNode*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<IdentifierNode*>*>(fromright_value.Get());
                }
            }
            public void PreDeclarations(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<CompositeNode<Node>*>(context->value)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public NamespaceNode* value;
                public IdentifierNode* fromleft;
                public IdentifierNode* fromright;
            }
        }

        public class UnnamedNamespaceDefinitionRule : System.Text.Parsing.RuleParser
        {
            public UnnamedNamespaceDefinitionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("NamespaceNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<NamespaceNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* declarationsNonterminalParser = GetNonterminal(ToUtf32("Declarations"));
                declarationsNonterminalParser->SetPre(PreDeclarations);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new NamespaceNode(span, null);
            }
            public void PreDeclarations(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<CompositeNode<Node>*>(context->value)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value()
                {
                }
                public ParsingContext* ctx;
                public NamespaceNode* value;
            }
        }

        public class BlockDeclarationRule : System.Text.Parsing.RuleParser
        {
            public BlockDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* simpleDeclarationNonterminalParser = GetNonterminal(ToUtf32("SimpleDeclaration"));
                simpleDeclarationNonterminalParser->SetPre(PreSimpleDeclaration);
                simpleDeclarationNonterminalParser->SetPost(PostSimpleDeclaration);
                NonterminalParser* aliasDeclarationNonterminalParser = GetNonterminal(ToUtf32("AliasDeclaration"));
                aliasDeclarationNonterminalParser->SetPre(PreAliasDeclaration);
                aliasDeclarationNonterminalParser->SetPost(PostAliasDeclaration);
                NonterminalParser* usingDirectiveNonterminalParser = GetNonterminal(ToUtf32("UsingDirective"));
                usingDirectiveNonterminalParser->SetPre(PreUsingDirective);
                usingDirectiveNonterminalParser->SetPost(PostUsingDirective);
                NonterminalParser* usingDeclarationNonterminalParser = GetNonterminal(ToUtf32("UsingDeclaration"));
                usingDeclarationNonterminalParser->SetPre(PreUsingDeclaration);
                usingDeclarationNonterminalParser->SetPost(PostUsingDeclaration);
                NonterminalParser* staticAssertDeclarationNonterminalParser = GetNonterminal(ToUtf32("StaticAssertDeclaration"));
                staticAssertDeclarationNonterminalParser->SetPre(PreStaticAssertDeclaration);
                staticAssertDeclarationNonterminalParser->SetPost(PostStaticAssertDeclaration);
                NonterminalParser* opaqueEnumDeclarationNonterminalParser = GetNonterminal(ToUtf32("OpaqueEnumDeclaration"));
                opaqueEnumDeclarationNonterminalParser->SetPre(PreOpaqueEnumDeclaration);
                opaqueEnumDeclarationNonterminalParser->SetPost(PostOpaqueEnumDeclaration);
                NonterminalParser* typedefDeclarationNonterminalParser = GetNonterminal(ToUtf32("TypedefDeclaration"));
                typedefDeclarationNonterminalParser->SetPre(PreTypedefDeclaration);
                typedefDeclarationNonterminalParser->SetPost(PostTypedefDeclaration);
                NonterminalParser* forwardClassDeclarationNonterminalParser = GetNonterminal(ToUtf32("ForwardClassDeclaration"));
                forwardClassDeclarationNonterminalParser->SetPre(PreForwardClassDeclaration);
                forwardClassDeclarationNonterminalParser->SetPost(PostForwardClassDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSimpleDeclaration;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAliasDeclaration;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUsingDirective;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUsingDeclaration;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromStaticAssertDeclaration;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromOpaqueEnumDeclaration;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTypedefDeclaration;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromForwardClassDeclaration;
            }
            public void PreSimpleDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostSimpleDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSimpleDeclaration_value = stack.Pop();
                    context->fromSimpleDeclaration = *cast<ValueObject<SimpleDeclarationNode*>*>(fromSimpleDeclaration_value.Get());
                }
            }
            public void PreAliasDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAliasDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAliasDeclaration_value = stack.Pop();
                    context->fromAliasDeclaration = *cast<ValueObject<UsingTypeDeclarationNode*>*>(fromAliasDeclaration_value.Get());
                }
            }
            public void PreUsingDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostUsingDirective(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUsingDirective_value = stack.Pop();
                    context->fromUsingDirective = *cast<ValueObject<UsingDirectiveNode*>*>(fromUsingDirective_value.Get());
                }
            }
            public void PreUsingDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostUsingDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUsingDeclaration_value = stack.Pop();
                    context->fromUsingDeclaration = *cast<ValueObject<UsingDeclarationNode*>*>(fromUsingDeclaration_value.Get());
                }
            }
            public void PreStaticAssertDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStaticAssertDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStaticAssertDeclaration_value = stack.Pop();
                    context->fromStaticAssertDeclaration = *cast<ValueObject<StaticAssertDeclarationNode*>*>(fromStaticAssertDeclaration_value.Get());
                }
            }
            public void PreOpaqueEnumDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostOpaqueEnumDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOpaqueEnumDeclaration_value = stack.Pop();
                    context->fromOpaqueEnumDeclaration = *cast<ValueObject<EnumTypeNode*>*>(fromOpaqueEnumDeclaration_value.Get());
                }
            }
            public void PreTypedefDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypedefDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypedefDeclaration_value = stack.Pop();
                    context->fromTypedefDeclaration = *cast<ValueObject<TypedefDeclarationNode*>*>(fromTypedefDeclaration_value.Get());
                }
            }
            public void PreForwardClassDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForwardClassDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForwardClassDeclaration_value = stack.Pop();
                    context->fromForwardClassDeclaration = *cast<ValueObject<ForwardClassDeclarationNode*>*>(fromForwardClassDeclaration_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromSimpleDeclaration(), fromAliasDeclaration(), fromUsingDirective(), fromUsingDeclaration(), fromStaticAssertDeclaration(), fromOpaqueEnumDeclaration(), fromTypedefDeclaration(), fromForwardClassDeclaration()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public SimpleDeclarationNode* fromSimpleDeclaration;
                public UsingTypeDeclarationNode* fromAliasDeclaration;
                public UsingDirectiveNode* fromUsingDirective;
                public UsingDeclarationNode* fromUsingDeclaration;
                public StaticAssertDeclarationNode* fromStaticAssertDeclaration;
                public EnumTypeNode* fromOpaqueEnumDeclaration;
                public TypedefDeclarationNode* fromTypedefDeclaration;
                public ForwardClassDeclarationNode* fromForwardClassDeclaration;
            }
        }

        public class SimpleDeclarationRule : System.Text.Parsing.RuleParser
        {
            public SimpleDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("SimpleDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<SimpleDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* declSpecifiersNonterminalParser = GetNonterminal(ToUtf32("DeclSpecifiers"));
                declSpecifiersNonterminalParser->SetPost(PostDeclSpecifiers);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* initDeclaratorNonterminalParser = GetNonterminal(ToUtf32("InitDeclarator"));
                initDeclaratorNonterminalParser->SetPre(PreInitDeclarator);
                initDeclaratorNonterminalParser->SetPost(PostInitDeclarator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SimpleDeclarationNode(span, context->fromDeclSpecifiers, context->fromTypeExpr, context->fromInitDeclarator);
            }
            public void PostDeclSpecifiers(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclSpecifiers_value = stack.Pop();
                    context->fromDeclSpecifiers = *cast<ValueObject<Specifiers>*>(fromDeclSpecifiers_value.Get());
                }
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreInitDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostInitDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromInitDeclarator_value = stack.Pop();
                    context->fromInitDeclarator = *cast<ValueObject<Node*>*>(fromInitDeclarator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromDeclSpecifiers(), fromTypeExpr(), fromInitDeclarator()
                {
                }
                public ParsingContext* ctx;
                public SimpleDeclarationNode* value;
                public Specifiers fromDeclSpecifiers;
                public Node* fromTypeExpr;
                public Node* fromInitDeclarator;
            }
        }

        public class DeclSpecifiersRule : System.Text.Parsing.RuleParser
        {
            public DeclSpecifiersRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Specifiers"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Specifiers>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* declSpecifierNonterminalParser = GetNonterminal(ToUtf32("DeclSpecifier"));
                declSpecifierNonterminalParser->SetPost(PostDeclSpecifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = cast<Specifiers>(context->value | context->fromDeclSpecifier);
            }
            public void PostDeclSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclSpecifier_value = stack.Pop();
                    context->fromDeclSpecifier = *cast<ValueObject<Specifiers>*>(fromDeclSpecifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromDeclSpecifier()
                {
                }
                public Specifiers value;
                public Specifiers fromDeclSpecifier;
            }
        }

        public class DeclSpecifierRule : System.Text.Parsing.RuleParser
        {
            public DeclSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Specifiers"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Specifiers>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* storageClassSpecifierNonterminalParser = GetNonterminal(ToUtf32("StorageClassSpecifier"));
                storageClassSpecifierNonterminalParser->SetPost(PostStorageClassSpecifier);
                NonterminalParser* functionSpecifierNonterminalParser = GetNonterminal(ToUtf32("FunctionSpecifier"));
                functionSpecifierNonterminalParser->SetPost(PostFunctionSpecifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromStorageClassSpecifier;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFunctionSpecifier;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.friend;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.constexpr_;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.thread_local;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.dllimport;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.dllexport;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.thread_local;
            }
            public void PostStorageClassSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStorageClassSpecifier_value = stack.Pop();
                    context->fromStorageClassSpecifier = *cast<ValueObject<Specifiers>*>(fromStorageClassSpecifier_value.Get());
                }
            }
            public void PostFunctionSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionSpecifier_value = stack.Pop();
                    context->fromFunctionSpecifier = *cast<ValueObject<Specifiers>*>(fromFunctionSpecifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromStorageClassSpecifier(), fromFunctionSpecifier()
                {
                }
                public Specifiers value;
                public Specifiers fromStorageClassSpecifier;
                public Specifiers fromFunctionSpecifier;
            }
        }

        public class StorageClassSpecifierRule : System.Text.Parsing.RuleParser
        {
            public StorageClassSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Specifiers"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Specifiers>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.register;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.static_;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.thread_local;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.extern_;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.mutable;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Specifiers value;
            }
        }

        public class FunctionSpecifierRule : System.Text.Parsing.RuleParser
        {
            public FunctionSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Specifiers"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Specifiers>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.inline_;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.virtual_;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Specifiers.explicit_;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Specifiers value;
            }
        }

        public class AliasDeclarationRule : System.Text.Parsing.RuleParser
        {
            public AliasDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("UsingTypeDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<UsingTypeDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new UsingTypeDeclarationNode(span, context->fromIdentifier, context->fromTypeExpr);
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.Get());
                }
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromIdentifier(), fromTypeExpr()
                {
                }
                public ParsingContext* ctx;
                public UsingTypeDeclarationNode* value;
                public IdentifierNode* fromIdentifier;
                public Node* fromTypeExpr;
            }
        }

        public class UsingDirectiveRule : System.Text.Parsing.RuleParser
        {
            public UsingDirectiveRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("UsingDirectiveNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<UsingDirectiveNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* qualifiedIdNonterminalParser = GetNonterminal(ToUtf32("QualifiedId"));
                qualifiedIdNonterminalParser->SetPre(PreQualifiedId);
                qualifiedIdNonterminalParser->SetPost(PostQualifiedId);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new UsingDirectiveNode(span, context->fromQualifiedId);
            }
            public void PreQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQualifiedId_value = stack.Pop();
                    context->fromQualifiedId = *cast<ValueObject<Node*>*>(fromQualifiedId_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromQualifiedId()
                {
                }
                public ParsingContext* ctx;
                public UsingDirectiveNode* value;
                public Node* fromQualifiedId;
            }
        }

        public class UsingDeclarationRule : System.Text.Parsing.RuleParser
        {
            public UsingDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("UsingDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<UsingDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* qualifiedIdNonterminalParser = GetNonterminal(ToUtf32("QualifiedId"));
                qualifiedIdNonterminalParser->SetPre(PreQualifiedId);
                qualifiedIdNonterminalParser->SetPost(PostQualifiedId);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new UsingDeclarationNode(span, context->fromQualifiedId);
            }
            public void PreQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQualifiedId_value = stack.Pop();
                    context->fromQualifiedId = *cast<ValueObject<Node*>*>(fromQualifiedId_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromQualifiedId()
                {
                }
                public ParsingContext* ctx;
                public UsingDeclarationNode* value;
                public Node* fromQualifiedId;
            }
        }

        public class StaticAssertDeclarationRule : System.Text.Parsing.RuleParser
        {
            public StaticAssertDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StaticAssertDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StaticAssertDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* exprNonterminalParser = GetNonterminal(ToUtf32("expr"));
                exprNonterminalParser->SetPre(Preexpr);
                exprNonterminalParser->SetPost(Postexpr);
                NonterminalParser* messageNonterminalParser = GetNonterminal(ToUtf32("message"));
                messageNonterminalParser->SetPost(Postmessage);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new StaticAssertDeclarationNode(span, context->fromexpr, context->frommessage);
            }
            public void Preexpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postexpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromexpr_value = stack.Pop();
                    context->fromexpr = *cast<ValueObject<Node*>*>(fromexpr_value.Get());
                }
            }
            public void Postmessage(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frommessage_value = stack.Pop();
                    context->frommessage = *cast<ValueObject<StringLiteralNode*>*>(frommessage_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromexpr(), frommessage()
                {
                }
                public ParsingContext* ctx;
                public StaticAssertDeclarationNode* value;
                public Node* fromexpr;
                public StringLiteralNode* frommessage;
            }
        }

        public class TypedefDeclarationRule : System.Text.Parsing.RuleParser
        {
            public TypedefDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("TypedefDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<TypedefDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* declaratorNonterminalParser = GetNonterminal(ToUtf32("Declarator"));
                declaratorNonterminalParser->SetPre(PreDeclarator);
                declaratorNonterminalParser->SetPost(PostDeclarator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TypedefDeclarationNode(span, context->fromTypeExpr, context->fromDeclarator);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclarator_value = stack.Pop();
                    context->fromDeclarator = *cast<ValueObject<Node*>*>(fromDeclarator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromDeclarator()
                {
                }
                public ParsingContext* ctx;
                public TypedefDeclarationNode* value;
                public Node* fromTypeExpr;
                public Node* fromDeclarator;
            }
        }

        public class LinkageSpecificationRule : System.Text.Parsing.RuleParser
        {
            public LinkageSpecificationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("LinkageSpecificationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<LinkageSpecificationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* linkageNonterminalParser = GetNonterminal(ToUtf32("linkage"));
                linkageNonterminalParser->SetPost(Postlinkage);
                NonterminalParser* d1NonterminalParser = GetNonterminal(ToUtf32("d1"));
                d1NonterminalParser->SetPre(Pred1);
                d1NonterminalParser->SetPost(Postd1);
                NonterminalParser* d2NonterminalParser = GetNonterminal(ToUtf32("d2"));
                d2NonterminalParser->SetPre(Pred2);
                d2NonterminalParser->SetPost(Postd2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LinkageSpecificationNode(span, context->fromlinkage);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddNode(context->fromd1);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddNode(context->fromd2);
            }
            public void Postlinkage(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlinkage_value = stack.Pop();
                    context->fromlinkage = *cast<ValueObject<StringLiteralNode*>*>(fromlinkage_value.Get());
                }
            }
            public void Pred1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postd1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromd1_value = stack.Pop();
                    context->fromd1 = *cast<ValueObject<Node*>*>(fromd1_value.Get());
                }
            }
            public void Pred2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postd2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromd2_value = stack.Pop();
                    context->fromd2 = *cast<ValueObject<Node*>*>(fromd2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromlinkage(), fromd1(), fromd2()
                {
                }
                public ParsingContext* ctx;
                public LinkageSpecificationNode* value;
                public StringLiteralNode* fromlinkage;
                public Node* fromd1;
                public Node* fromd2;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.TypeExprGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.IdentifierGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("cppparser.TemplateGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new cppparser.TemplateGrammar(pd);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = pd->GetGrammar(ToUtf32("cppparser.ExpressionGrammar"));
            if (grammar3 == null)
            {
                grammar3 = new cppparser.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = pd->GetGrammar(ToUtf32("cppparser.DeclaratorGrammar"));
            if (grammar4 == null)
            {
                grammar4 = new cppparser.DeclaratorGrammar(pd);
            }
            AddGrammarReference(grammar4);
            Grammar* grammar5 = pd->GetGrammar(ToUtf32("cppparser.LiteralGrammar"));
            if (grammar5 == null)
            {
                grammar5 = new cppparser.LiteralGrammar(pd);
            }
            AddGrammarReference(grammar5);
            Grammar* grammar6 = pd->GetGrammar(ToUtf32("cppparser.ClassGrammar"));
            if (grammar6 == null)
            {
                grammar6 = new cppparser.ClassGrammar(pd);
            }
            AddGrammarReference(grammar6);
            Grammar* grammar7 = pd->GetGrammar(ToUtf32("cppparser.FunctionGrammar"));
            if (grammar7 == null)
            {
                grammar7 = new cppparser.FunctionGrammar(pd);
            }
            AddGrammarReference(grammar7);
            Grammar* grammar8 = pd->GetGrammar(ToUtf32("cppparser.EnumerationGrammar"));
            if (grammar8 == null)
            {
                grammar8 = new cppparser.EnumerationGrammar(pd);
            }
            AddGrammarReference(grammar8);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("QualifiedId"), this, ToUtf32("IdentifierGrammar.QualifiedId")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("FunctionDefinition"), this, ToUtf32("FunctionGrammar.FunctionDefinition")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("SpecialMemberFunctionDefinition"), this, ToUtf32("ClassGrammar.SpecialMemberFunctionDefinition")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ClassDeclaration"), this, ToUtf32("ClassGrammar.ClassDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ForwardClassDeclaration"), this, ToUtf32("ClassGrammar.ForwardClassDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("InitDeclarator"), this, ToUtf32("DeclaratorGrammar.InitDeclarator")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Declarator"), this, ToUtf32("DeclaratorGrammar.Declarator")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TemplateDeclaration"), this, ToUtf32("TemplateGrammar.TemplateDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ExplicitInstantiation"), this, ToUtf32("TemplateGrammar.ExplicitInstantiation")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ExplicitSpecialization"), this, ToUtf32("TemplateGrammar.ExplicitSpecialization")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("EnumDeclaration"), this, ToUtf32("EnumerationGrammar.EnumDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("OpaqueEnumDeclaration"), this, ToUtf32("EnumerationGrammar.OpaqueEnumDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("StringLiteral"), this, ToUtf32("LiteralGrammar.StringLiteral")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ConstantExpression"), this, ToUtf32("ExpressionGrammar.ConstantExpression")));
            AddRule(new DeclarationsRule(ToUtf32("Declarations"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.KleeneStarParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Declaration"), ToUtf32("Declaration"), 1))))));
            AddRule(new DeclarationRule(ToUtf32("Declaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NamespaceDefinition"), ToUtf32("NamespaceDefinition"), 1)),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("LinkageSpecification"), ToUtf32("LinkageSpecification"), 1))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionDefinition"), ToUtf32("FunctionDefinition"), 1))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SpecialMemberFunctionDefinition"), ToUtf32("SpecialMemberFunctionDefinition"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("TemplateDeclaration"), ToUtf32("TemplateDeclaration"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ExplicitInstantiation"), ToUtf32("ExplicitInstantiation"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ExplicitSpecialization"), ToUtf32("ExplicitSpecialization"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ClassDeclaration"), ToUtf32("ClassDeclaration"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("EnumDeclaration"), ToUtf32("EnumDeclaration"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("BlockDeclaration"), ToUtf32("BlockDeclaration"), 1)))));
            AddRule(new NamespaceDefinitionRule(ToUtf32("NamespaceDefinition"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("NamedNamespaceDefinition"), ToUtf32("NamedNamespaceDefinition"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("UnnamedNamespaceDefinition"), ToUtf32("UnnamedNamespaceDefinition"), 1)))));
            AddRule(new NamedNamespaceDefinitionRule(ToUtf32("NamedNamespaceDefinition"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("namespace")),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Identifier"), 0)),
                                        new System.Text.Parsing.KleeneStarParser(
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.StringParser(ToUtf32("::")),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Identifier"), 0)))))))),
                            new System.Text.Parsing.CharParser('{')),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Declarations"), ToUtf32("Declarations"), 2)),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new UnnamedNamespaceDefinitionRule(ToUtf32("UnnamedNamespaceDefinition"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("namespace")),
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.CharParser('{'))),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Declarations"), ToUtf32("Declarations"), 2)),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new BlockDeclarationRule(ToUtf32("BlockDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SimpleDeclaration"), ToUtf32("SimpleDeclaration"), 1)),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("AliasDeclaration"), ToUtf32("AliasDeclaration"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("UsingDirective"), ToUtf32("UsingDirective"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("UsingDeclaration"), ToUtf32("UsingDeclaration"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("StaticAssertDeclaration"), ToUtf32("StaticAssertDeclaration"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("OpaqueEnumDeclaration"), ToUtf32("OpaqueEnumDeclaration"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypedefDeclaration"), ToUtf32("TypedefDeclaration"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("ForwardClassDeclaration"), ToUtf32("ForwardClassDeclaration"), 1)))));
            AddRule(new SimpleDeclarationRule(ToUtf32("SimpleDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("DeclSpecifiers"), ToUtf32("DeclSpecifiers"), 0),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("InitDeclarator"), ToUtf32("InitDeclarator"), 1)),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new DeclSpecifiersRule(ToUtf32("DeclSpecifiers"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.KleeneStarParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DeclSpecifier"), ToUtf32("DeclSpecifier"), 0))))));
            AddRule(new DeclSpecifierRule(ToUtf32("DeclSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("StorageClassSpecifier"), ToUtf32("StorageClassSpecifier"), 0)),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionSpecifier"), ToUtf32("FunctionSpecifier"), 0))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("friend")))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                new System.Text.Parsing.KeywordParser(ToUtf32("constexpr")))),
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("__declspec")),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharParser('('),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("thread")))),
                                            new System.Text.Parsing.CharParser(')')),
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharParser('('),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("dllimport")))),
                                            new System.Text.Parsing.CharParser(')'))),
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('('),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                new System.Text.Parsing.KeywordParser(ToUtf32("dllexport")))),
                                        new System.Text.Parsing.CharParser(')')))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("__thread"))))));
            AddRule(new StorageClassSpecifierRule(ToUtf32("StorageClassSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("register"))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("static")))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.KeywordParser(ToUtf32("thread_local")))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.KeywordParser(ToUtf32("extern")))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("mutable"))))));
            AddRule(new FunctionSpecifierRule(ToUtf32("FunctionSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.KeywordParser(ToUtf32("inline"))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.KeywordParser(ToUtf32("virtual")))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("explicit"))))));
            AddRule(new AliasDeclarationRule(ToUtf32("AliasDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("using")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)),
                                    new System.Text.Parsing.CharParser('=')),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(';')))))));
            AddRule(new UsingDirectiveRule(ToUtf32("UsingDirective"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("using")),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("namespace"))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("QualifiedId"), ToUtf32("QualifiedId"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(';')))))));
            AddRule(new UsingDeclarationRule(ToUtf32("UsingDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("using")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("QualifiedId"), ToUtf32("QualifiedId"), 1)),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new StaticAssertDeclarationRule(ToUtf32("StaticAssertDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("static_assert")),
                                                new System.Text.Parsing.CharParser('(')),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("expr"), ToUtf32("ConstantExpression"), 1)),
                                        new System.Text.Parsing.CharParser(',')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("message"), ToUtf32("StringLiteral"), 0)),
                                new System.Text.Parsing.CharParser(')')),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new TypedefDeclarationRule(ToUtf32("TypedefDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("typedef")),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Declarator"), ToUtf32("Declarator"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(';')))))));
            AddRule(new LinkageSpecificationRule(ToUtf32("LinkageSpecification"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("extern")),
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("linkage"), ToUtf32("StringLiteral"), 0))),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('{'),
                                    new System.Text.Parsing.KleeneStarParser(
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("d1"), ToUtf32("Declaration"), 1))))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser('}'))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("d2"), ToUtf32("Declaration"), 1)))))));
        }
    }
} // cppparser

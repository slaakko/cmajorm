using System;
using System.Collections;
using System.Text.Parsing;
using cppast;

// this source file has been automatically generated from 'StatementGrammar.parser' using cmparsergen version 2.0.0.

namespace cppparser
{
    public class StatementGrammar : System.Text.Parsing.Grammar
    {
        public StatementGrammar() : this(new ParsingDomain())
        {
        }
        public StatementGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("StatementGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public StatementNode* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            StatementNode* result = *cast<ValueObject<StatementNode*>*>(value.Get());
            return result;
        }

        public class StatementRule : System.Text.Parsing.RuleParser
        {
            public StatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                NonterminalParser* labeledStatementNonterminalParser = GetNonterminal(ToUtf32("LabeledStatement"));
                labeledStatementNonterminalParser->SetPre(PreLabeledStatement);
                labeledStatementNonterminalParser->SetPost(PostLabeledStatement);
                NonterminalParser* expressionStatementNonterminalParser = GetNonterminal(ToUtf32("ExpressionStatement"));
                expressionStatementNonterminalParser->SetPre(PreExpressionStatement);
                expressionStatementNonterminalParser->SetPost(PostExpressionStatement);
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal(ToUtf32("CompoundStatement"));
                compoundStatementNonterminalParser->SetPre(PreCompoundStatement);
                compoundStatementNonterminalParser->SetPost(PostCompoundStatement);
                NonterminalParser* selectionStatementNonterminalParser = GetNonterminal(ToUtf32("SelectionStatement"));
                selectionStatementNonterminalParser->SetPre(PreSelectionStatement);
                selectionStatementNonterminalParser->SetPost(PostSelectionStatement);
                NonterminalParser* iterationStatementNonterminalParser = GetNonterminal(ToUtf32("IterationStatement"));
                iterationStatementNonterminalParser->SetPre(PreIterationStatement);
                iterationStatementNonterminalParser->SetPost(PostIterationStatement);
                NonterminalParser* jumpStatementNonterminalParser = GetNonterminal(ToUtf32("JumpStatement"));
                jumpStatementNonterminalParser->SetPre(PreJumpStatement);
                jumpStatementNonterminalParser->SetPost(PostJumpStatement);
                NonterminalParser* declarationStatementNonterminalParser = GetNonterminal(ToUtf32("DeclarationStatement"));
                declarationStatementNonterminalParser->SetPre(PreDeclarationStatement);
                declarationStatementNonterminalParser->SetPost(PostDeclarationStatement);
                NonterminalParser* tryBlockNonterminalParser = GetNonterminal(ToUtf32("TryBlock"));
                tryBlockNonterminalParser->SetPre(PreTryBlock);
                tryBlockNonterminalParser->SetPost(PostTryBlock);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLabeledStatement;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpressionStatement;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromCompoundStatement;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSelectionStatement;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIterationStatement;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromJumpStatement;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDeclarationStatement;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTryBlock;
            }
            public void PreLabeledStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLabeledStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLabeledStatement_value = stack.Pop();
                    context->fromLabeledStatement = *cast<ValueObject<StatementNode*>*>(fromLabeledStatement_value.Get());
                }
            }
            public void PreExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpressionStatement_value = stack.Pop();
                    context->fromExpressionStatement = *cast<ValueObject<StatementNode*>*>(fromExpressionStatement_value.Get());
                }
            }
            public void PreCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context->fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.Get());
                }
            }
            public void PreSelectionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostSelectionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSelectionStatement_value = stack.Pop();
                    context->fromSelectionStatement = *cast<ValueObject<StatementNode*>*>(fromSelectionStatement_value.Get());
                }
            }
            public void PreIterationStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostIterationStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIterationStatement_value = stack.Pop();
                    context->fromIterationStatement = *cast<ValueObject<StatementNode*>*>(fromIterationStatement_value.Get());
                }
            }
            public void PreJumpStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostJumpStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromJumpStatement_value = stack.Pop();
                    context->fromJumpStatement = *cast<ValueObject<StatementNode*>*>(fromJumpStatement_value.Get());
                }
            }
            public void PreDeclarationStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclarationStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclarationStatement_value = stack.Pop();
                    context->fromDeclarationStatement = *cast<ValueObject<StatementNode*>*>(fromDeclarationStatement_value.Get());
                }
            }
            public void PreTryBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTryBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTryBlock_value = stack.Pop();
                    context->fromTryBlock = *cast<ValueObject<TryStatementNode*>*>(fromTryBlock_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromLabeledStatement(), fromExpressionStatement(), fromCompoundStatement(), fromSelectionStatement(), fromIterationStatement(), fromJumpStatement(), fromDeclarationStatement(), fromTryBlock()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public StatementNode* fromLabeledStatement;
                public StatementNode* fromExpressionStatement;
                public CompoundStatementNode* fromCompoundStatement;
                public StatementNode* fromSelectionStatement;
                public StatementNode* fromIterationStatement;
                public StatementNode* fromJumpStatement;
                public StatementNode* fromDeclarationStatement;
                public TryStatementNode* fromTryBlock;
            }
        }

        public class LabeledStatementRule : System.Text.Parsing.RuleParser
        {
            public LabeledStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* labelNonterminalParser = GetNonterminal(ToUtf32("label"));
                labelNonterminalParser->SetPost(Postlabel);
                NonterminalParser* s1NonterminalParser = GetNonterminal(ToUtf32("s1"));
                s1NonterminalParser->SetPre(Pres1);
                s1NonterminalParser->SetPost(Posts1);
                NonterminalParser* constantExpressionNonterminalParser = GetNonterminal(ToUtf32("ConstantExpression"));
                constantExpressionNonterminalParser->SetPre(PreConstantExpression);
                constantExpressionNonterminalParser->SetPost(PostConstantExpression);
                NonterminalParser* s2NonterminalParser = GetNonterminal(ToUtf32("s2"));
                s2NonterminalParser->SetPre(Pres2);
                s2NonterminalParser->SetPost(Posts2);
                NonterminalParser* s3NonterminalParser = GetNonterminal(ToUtf32("s3"));
                s3NonterminalParser->SetPre(Pres3);
                s3NonterminalParser->SetPost(Posts3);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new LabeledStatementNode(span, context->fromlabel, context->froms1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new CaseStatementNode(span, context->fromConstantExpression, context->froms2);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DefaultStatementNode(span, context->froms3);
            }
            public void Postlabel(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlabel_value = stack.Pop();
                    context->fromlabel = *cast<ValueObject<IdentifierNode*>*>(fromlabel_value.Get());
                }
            }
            public void Pres1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms1_value = stack.Pop();
                    context->froms1 = *cast<ValueObject<StatementNode*>*>(froms1_value.Get());
                }
            }
            public void PreConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstantExpression_value = stack.Pop();
                    context->fromConstantExpression = *cast<ValueObject<Node*>*>(fromConstantExpression_value.Get());
                }
            }
            public void Pres2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms2_value = stack.Pop();
                    context->froms2 = *cast<ValueObject<StatementNode*>*>(froms2_value.Get());
                }
            }
            public void Pres3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms3_value = stack.Pop();
                    context->froms3 = *cast<ValueObject<StatementNode*>*>(froms3_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromlabel(), froms1(), fromConstantExpression(), froms2(), froms3()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public IdentifierNode* fromlabel;
                public StatementNode* froms1;
                public Node* fromConstantExpression;
                public StatementNode* froms2;
                public StatementNode* froms3;
            }
        }

        public class ExpressionStatementRule : System.Text.Parsing.RuleParser
        {
            public ExpressionStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ExpressionStatementNode(span, context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
            }
        }

        public class CompoundStatementRule : System.Text.Parsing.RuleParser
        {
            public CompoundStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("CompoundStatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CompoundStatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new CompoundStatementNode(span);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddStatement(context->fromStatement);
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<StatementNode*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public CompoundStatementNode* value;
                public StatementNode* fromStatement;
            }
        }

        public class SelectionStatementRule : System.Text.Parsing.RuleParser
        {
            public SelectionStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* c1NonterminalParser = GetNonterminal(ToUtf32("c1"));
                c1NonterminalParser->SetPre(Prec1);
                c1NonterminalParser->SetPost(Postc1);
                NonterminalParser* thenSNonterminalParser = GetNonterminal(ToUtf32("thenS"));
                thenSNonterminalParser->SetPre(PrethenS);
                thenSNonterminalParser->SetPost(PostthenS);
                NonterminalParser* elseSNonterminalParser = GetNonterminal(ToUtf32("elseS"));
                elseSNonterminalParser->SetPre(PreelseS);
                elseSNonterminalParser->SetPost(PostelseS);
                NonterminalParser* c2NonterminalParser = GetNonterminal(ToUtf32("c2"));
                c2NonterminalParser->SetPre(Prec2);
                c2NonterminalParser->SetPost(Postc2);
                NonterminalParser* swsNonterminalParser = GetNonterminal(ToUtf32("sws"));
                swsNonterminalParser->SetPre(Presws);
                swsNonterminalParser->SetPost(Postsws);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new IfStatementNode(span, context->fromc1, context->fromthenS, context->fromelseS);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SwitchStatementNode(span, context->fromc2, context->fromsws);
            }
            public void Prec1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc1_value = stack.Pop();
                    context->fromc1 = *cast<ValueObject<Node*>*>(fromc1_value.Get());
                }
            }
            public void PrethenS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostthenS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromthenS_value = stack.Pop();
                    context->fromthenS = *cast<ValueObject<StatementNode*>*>(fromthenS_value.Get());
                }
            }
            public void PreelseS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostelseS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromelseS_value = stack.Pop();
                    context->fromelseS = *cast<ValueObject<StatementNode*>*>(fromelseS_value.Get());
                }
            }
            public void Prec2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc2_value = stack.Pop();
                    context->fromc2 = *cast<ValueObject<Node*>*>(fromc2_value.Get());
                }
            }
            public void Presws(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postsws(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsws_value = stack.Pop();
                    context->fromsws = *cast<ValueObject<StatementNode*>*>(fromsws_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromc1(), fromthenS(), fromelseS(), fromc2(), fromsws()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromc1;
                public StatementNode* fromthenS;
                public StatementNode* fromelseS;
                public Node* fromc2;
                public StatementNode* fromsws;
            }
        }

        public class ConditionRule : System.Text.Parsing.RuleParser
        {
            public ConditionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("typeExpr")));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Node>"), ToUtf32("declarator")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* declaratorNonterminalParser = GetNonterminal(ToUtf32("Declarator"));
                declaratorNonterminalParser->SetPre(PreDeclarator);
                declaratorNonterminalParser->SetPost(PostDeclarator);
                NonterminalParser* initializerClauseNonterminalParser = GetNonterminal(ToUtf32("InitializerClause"));
                initializerClauseNonterminalParser->SetPre(PreInitializerClause);
                initializerClauseNonterminalParser->SetPost(PostInitializerClause);
                NonterminalParser* bracedInitializerListNonterminalParser = GetNonterminal(ToUtf32("BracedInitializerList"));
                bracedInitializerListNonterminalParser->SetPre(PreBracedInitializerList);
                bracedInitializerListNonterminalParser->SetPost(PostBracedInitializerList);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->typeExpr.Reset(context->fromTypeExpr);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->declarator.Reset(context->fromDeclarator);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SimpleDeclarationNode(span, Specifiers.none, context->typeExpr.Release(), new InitDeclaratorNode(span, context->declarator.Release(), new AssignmentInitializerNode(span, context->fromInitializerClause)));
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SimpleDeclarationNode(span, Specifiers.none, context->typeExpr.Release(), new InitDeclaratorNode(span, context->declarator.Release(), context->fromBracedInitializerList));
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpression;
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclarator_value = stack.Pop();
                    context->fromDeclarator = *cast<ValueObject<Node*>*>(fromDeclarator_value.Get());
                }
            }
            public void PreInitializerClause(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostInitializerClause(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromInitializerClause_value = stack.Pop();
                    context->fromInitializerClause = *cast<ValueObject<Node*>*>(fromInitializerClause_value.Get());
                }
            }
            public void PreBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBracedInitializerList_value = stack.Pop();
                    context->fromBracedInitializerList = *cast<ValueObject<BracedInitializerListNode*>*>(fromBracedInitializerList_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), typeExpr(), declarator(), fromTypeExpr(), fromDeclarator(), fromInitializerClause(), fromBracedInitializerList(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public UniquePtr<Node> typeExpr;
                public UniquePtr<Node> declarator;
                public Node* fromTypeExpr;
                public Node* fromDeclarator;
                public Node* fromInitializerClause;
                public BracedInitializerListNode* fromBracedInitializerList;
                public Node* fromExpression;
            }
        }

        public class IterationStatementRule : System.Text.Parsing.RuleParser
        {
            public IterationStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* c1NonterminalParser = GetNonterminal(ToUtf32("c1"));
                c1NonterminalParser->SetPre(Prec1);
                c1NonterminalParser->SetPost(Postc1);
                NonterminalParser* s1NonterminalParser = GetNonterminal(ToUtf32("s1"));
                s1NonterminalParser->SetPre(Pres1);
                s1NonterminalParser->SetPost(Posts1);
                NonterminalParser* s2NonterminalParser = GetNonterminal(ToUtf32("s2"));
                s2NonterminalParser->SetPre(Pres2);
                s2NonterminalParser->SetPost(Posts2);
                NonterminalParser* e1NonterminalParser = GetNonterminal(ToUtf32("e1"));
                e1NonterminalParser->SetPre(Pree1);
                e1NonterminalParser->SetPost(Poste1);
                NonterminalParser* forRangeDeclarationNonterminalParser = GetNonterminal(ToUtf32("ForRangeDeclaration"));
                forRangeDeclarationNonterminalParser->SetPre(PreForRangeDeclaration);
                forRangeDeclarationNonterminalParser->SetPost(PostForRangeDeclaration);
                NonterminalParser* forRangeInitializerNonterminalParser = GetNonterminal(ToUtf32("ForRangeInitializer"));
                forRangeInitializerNonterminalParser->SetPre(PreForRangeInitializer);
                forRangeInitializerNonterminalParser->SetPost(PostForRangeInitializer);
                NonterminalParser* s3NonterminalParser = GetNonterminal(ToUtf32("s3"));
                s3NonterminalParser->SetPre(Pres3);
                s3NonterminalParser->SetPost(Posts3);
                NonterminalParser* forInitializationNonterminalParser = GetNonterminal(ToUtf32("ForInitialization"));
                forInitializationNonterminalParser->SetPre(PreForInitialization);
                forInitializationNonterminalParser->SetPost(PostForInitialization);
                NonterminalParser* c2NonterminalParser = GetNonterminal(ToUtf32("c2"));
                c2NonterminalParser->SetPre(Prec2);
                c2NonterminalParser->SetPost(Postc2);
                NonterminalParser* e2NonterminalParser = GetNonterminal(ToUtf32("e2"));
                e2NonterminalParser->SetPre(Pree2);
                e2NonterminalParser->SetPost(Poste2);
                NonterminalParser* s4NonterminalParser = GetNonterminal(ToUtf32("s4"));
                s4NonterminalParser->SetPre(Pres4);
                s4NonterminalParser->SetPost(Posts4);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new WhileStatementNode(span, context->fromc1, context->froms1);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DoStatementNode(span, context->froms2, context->frome1);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new RangeForStatementNode(span, context->fromForRangeDeclaration, context->fromForRangeInitializer, context->froms3);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ForStatementNode(span, context->fromForInitialization, context->fromc2, context->frome2, context->froms4);
            }
            public void Prec1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc1_value = stack.Pop();
                    context->fromc1 = *cast<ValueObject<Node*>*>(fromc1_value.Get());
                }
            }
            public void Pres1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms1_value = stack.Pop();
                    context->froms1 = *cast<ValueObject<StatementNode*>*>(froms1_value.Get());
                }
            }
            public void Pres2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms2_value = stack.Pop();
                    context->froms2 = *cast<ValueObject<StatementNode*>*>(froms2_value.Get());
                }
            }
            public void Pree1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poste1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frome1_value = stack.Pop();
                    context->frome1 = *cast<ValueObject<Node*>*>(frome1_value.Get());
                }
            }
            public void PreForRangeDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForRangeDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForRangeDeclaration_value = stack.Pop();
                    context->fromForRangeDeclaration = *cast<ValueObject<SimpleDeclarationNode*>*>(fromForRangeDeclaration_value.Get());
                }
            }
            public void PreForRangeInitializer(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForRangeInitializer(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForRangeInitializer_value = stack.Pop();
                    context->fromForRangeInitializer = *cast<ValueObject<Node*>*>(fromForRangeInitializer_value.Get());
                }
            }
            public void Pres3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms3_value = stack.Pop();
                    context->froms3 = *cast<ValueObject<StatementNode*>*>(froms3_value.Get());
                }
            }
            public void PreForInitialization(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForInitialization(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForInitialization_value = stack.Pop();
                    context->fromForInitialization = *cast<ValueObject<Node*>*>(fromForInitialization_value.Get());
                }
            }
            public void Prec2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postc2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromc2_value = stack.Pop();
                    context->fromc2 = *cast<ValueObject<Node*>*>(fromc2_value.Get());
                }
            }
            public void Pree2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poste2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frome2_value = stack.Pop();
                    context->frome2 = *cast<ValueObject<Node*>*>(frome2_value.Get());
                }
            }
            public void Pres4(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posts4(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> froms4_value = stack.Pop();
                    context->froms4 = *cast<ValueObject<StatementNode*>*>(froms4_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromc1(), froms1(), froms2(), frome1(), fromForRangeDeclaration(), fromForRangeInitializer(), froms3(), fromForInitialization(), fromc2(), frome2(), froms4()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromc1;
                public StatementNode* froms1;
                public StatementNode* froms2;
                public Node* frome1;
                public SimpleDeclarationNode* fromForRangeDeclaration;
                public Node* fromForRangeInitializer;
                public StatementNode* froms3;
                public Node* fromForInitialization;
                public Node* fromc2;
                public Node* frome2;
                public StatementNode* froms4;
            }
        }

        public class ForInitializationRule : System.Text.Parsing.RuleParser
        {
            public ForInitializationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* expressionStatementNonterminalParser = GetNonterminal(ToUtf32("ExpressionStatement"));
                expressionStatementNonterminalParser->SetPre(PreExpressionStatement);
                expressionStatementNonterminalParser->SetPost(PostExpressionStatement);
                NonterminalParser* simpleDeclarationNonterminalParser = GetNonterminal(ToUtf32("SimpleDeclaration"));
                simpleDeclarationNonterminalParser->SetPre(PreSimpleDeclaration);
                simpleDeclarationNonterminalParser->SetPost(PostSimpleDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpressionStatement;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSimpleDeclaration;
            }
            public void PreExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpressionStatement_value = stack.Pop();
                    context->fromExpressionStatement = *cast<ValueObject<StatementNode*>*>(fromExpressionStatement_value.Get());
                }
            }
            public void PreSimpleDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostSimpleDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSimpleDeclaration_value = stack.Pop();
                    context->fromSimpleDeclaration = *cast<ValueObject<SimpleDeclarationNode*>*>(fromSimpleDeclaration_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpressionStatement(), fromSimpleDeclaration()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public StatementNode* fromExpressionStatement;
                public SimpleDeclarationNode* fromSimpleDeclaration;
            }
        }

        public class ForRangeDeclarationRule : System.Text.Parsing.RuleParser
        {
            public ForRangeDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("SimpleDeclarationNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<SimpleDeclarationNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* declaratorNonterminalParser = GetNonterminal(ToUtf32("Declarator"));
                declaratorNonterminalParser->SetPre(PreDeclarator);
                declaratorNonterminalParser->SetPost(PostDeclarator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SimpleDeclarationNode(span, Specifiers.none, context->fromTypeExpr, context->fromDeclarator);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclarator_value = stack.Pop();
                    context->fromDeclarator = *cast<ValueObject<Node*>*>(fromDeclarator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromDeclarator()
                {
                }
                public ParsingContext* ctx;
                public SimpleDeclarationNode* value;
                public Node* fromTypeExpr;
                public Node* fromDeclarator;
            }
        }

        public class ForRangeInitializerRule : System.Text.Parsing.RuleParser
        {
            public ForRangeInitializerRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* bracedInitializerListNonterminalParser = GetNonterminal(ToUtf32("BracedInitializerList"));
                bracedInitializerListNonterminalParser->SetPre(PreBracedInitializerList);
                bracedInitializerListNonterminalParser->SetPost(PostBracedInitializerList);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpression;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBracedInitializerList;
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.Get());
                }
            }
            public void PreBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBracedInitializerList_value = stack.Pop();
                    context->fromBracedInitializerList = *cast<ValueObject<BracedInitializerListNode*>*>(fromBracedInitializerList_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression(), fromBracedInitializerList()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromExpression;
                public BracedInitializerListNode* fromBracedInitializerList;
            }
        }

        public class JumpStatementRule : System.Text.Parsing.RuleParser
        {
            public JumpStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* bracedInitializerListNonterminalParser = GetNonterminal(ToUtf32("BracedInitializerList"));
                bracedInitializerListNonterminalParser->SetPre(PreBracedInitializerList);
                bracedInitializerListNonterminalParser->SetPost(PostBracedInitializerList);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BreakStatementNode(span);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ContinueStatementNode(span);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ReturnStatementNode(span, context->fromExpression);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ReturnStatementNode(span, context->fromBracedInitializerList);
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new GotoStatementNode(span, context->fromIdentifier);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<Node*>*>(fromExpression_value.Get());
                }
            }
            public void PreBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBracedInitializerList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBracedInitializerList_value = stack.Pop();
                    context->fromBracedInitializerList = *cast<ValueObject<BracedInitializerListNode*>*>(fromBracedInitializerList_value.Get());
                }
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression(), fromBracedInitializerList(), fromIdentifier()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromExpression;
                public BracedInitializerListNode* fromBracedInitializerList;
                public IdentifierNode* fromIdentifier;
            }
        }

        public class DeclarationStatementRule : System.Text.Parsing.RuleParser
        {
            public DeclarationStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("StatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<StatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* blockDeclarationNonterminalParser = GetNonterminal(ToUtf32("BlockDeclaration"));
                blockDeclarationNonterminalParser->SetPre(PreBlockDeclaration);
                blockDeclarationNonterminalParser->SetPost(PostBlockDeclaration);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DeclarationStatementNode(span, context->fromBlockDeclaration);
            }
            public void PreBlockDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBlockDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBlockDeclaration_value = stack.Pop();
                    context->fromBlockDeclaration = *cast<ValueObject<Node*>*>(fromBlockDeclaration_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromBlockDeclaration()
                {
                }
                public ParsingContext* ctx;
                public StatementNode* value;
                public Node* fromBlockDeclaration;
            }
        }

        public class TryBlockRule : System.Text.Parsing.RuleParser
        {
            public TryBlockRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("TryStatementNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<TryStatementNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal(ToUtf32("CompoundStatement"));
                compoundStatementNonterminalParser->SetPre(PreCompoundStatement);
                compoundStatementNonterminalParser->SetPost(PostCompoundStatement);
                NonterminalParser* handlerSequenceNonterminalParser = GetNonterminal(ToUtf32("HandlerSequence"));
                handlerSequenceNonterminalParser->SetPre(PreHandlerSequence);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TryStatementNode(span, context->fromCompoundStatement);
            }
            public void PreCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context->fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.Get());
                }
            }
            public void PreHandlerSequence(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<TryStatementNode*>(context->value)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromCompoundStatement()
                {
                }
                public ParsingContext* ctx;
                public TryStatementNode* value;
                public CompoundStatementNode* fromCompoundStatement;
            }
        }

        public class HandlerSequenceRule : System.Text.Parsing.RuleParser
        {
            public HandlerSequenceRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("TryStatementNode*"), ToUtf32("tryStatement")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> tryStatement_value = stack.Pop();
                context->tryStatement = *cast<ValueObject<TryStatementNode*>*>(tryStatement_value.Get());
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* handlerNonterminalParser = GetNonterminal(ToUtf32("Handler"));
                handlerNonterminalParser->SetPre(PreHandler);
                handlerNonterminalParser->SetPost(PostHandler);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->tryStatement->AddHandler(context->fromHandler);
            }
            public void PreHandler(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostHandler(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromHandler_value = stack.Pop();
                    context->fromHandler = *cast<ValueObject<ExceptionHandlerNode*>*>(fromHandler_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), tryStatement(), fromHandler()
                {
                }
                public ParsingContext* ctx;
                public TryStatementNode* tryStatement;
                public ExceptionHandlerNode* fromHandler;
            }
        }

        public class HandlerRule : System.Text.Parsing.RuleParser
        {
            public HandlerRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ExceptionHandlerNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ExceptionHandlerNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* exceptionDeclarationNonterminalParser = GetNonterminal(ToUtf32("ExceptionDeclaration"));
                exceptionDeclarationNonterminalParser->SetPre(PreExceptionDeclaration);
                exceptionDeclarationNonterminalParser->SetPost(PostExceptionDeclaration);
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal(ToUtf32("CompoundStatement"));
                compoundStatementNonterminalParser->SetPre(PreCompoundStatement);
                compoundStatementNonterminalParser->SetPost(PostCompoundStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ExceptionHandlerNode(span, context->fromExceptionDeclaration, context->fromCompoundStatement);
            }
            public void PreExceptionDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExceptionDeclaration(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExceptionDeclaration_value = stack.Pop();
                    context->fromExceptionDeclaration = *cast<ValueObject<Node*>*>(fromExceptionDeclaration_value.Get());
                }
            }
            public void PreCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context->fromCompoundStatement = *cast<ValueObject<CompoundStatementNode*>*>(fromCompoundStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExceptionDeclaration(), fromCompoundStatement()
                {
                }
                public ParsingContext* ctx;
                public ExceptionHandlerNode* value;
                public Node* fromExceptionDeclaration;
                public CompoundStatementNode* fromCompoundStatement;
            }
        }

        public class ExceptionDeclarationRule : System.Text.Parsing.RuleParser
        {
            public ExceptionDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* declaratorNonterminalParser = GetNonterminal(ToUtf32("Declarator"));
                declaratorNonterminalParser->SetPre(PreDeclarator);
                declaratorNonterminalParser->SetPost(PostDeclarator);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SimpleDeclarationNode(span, Specifiers.none, context->fromTypeExpr, context->fromDeclarator);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new CatchAllNode(span);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PreDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeclarator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeclarator_value = stack.Pop();
                    context->fromDeclarator = *cast<ValueObject<Node*>*>(fromDeclarator_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromDeclarator()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromTypeExpr;
                public Node* fromDeclarator;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.IdentifierGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.ExpressionGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("cppparser.DeclarationGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new cppparser.DeclarationGrammar(pd);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = pd->GetGrammar(ToUtf32("cppparser.TypeExprGrammar"));
            if (grammar3 == null)
            {
                grammar3 = new cppparser.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = pd->GetGrammar(ToUtf32("cppparser.DeclaratorGrammar"));
            if (grammar4 == null)
            {
                grammar4 = new cppparser.DeclaratorGrammar(pd);
            }
            AddGrammarReference(grammar4);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Expression"), this, ToUtf32("ExpressionGrammar.Expression")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ConstantExpression"), this, ToUtf32("ExpressionGrammar.ConstantExpression")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Declarator"), this, ToUtf32("DeclaratorGrammar.Declarator")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("InitializerClause"), this, ToUtf32("DeclaratorGrammar.InitializerClause")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("BracedInitializerList"), this, ToUtf32("DeclaratorGrammar.BracedInitializerList")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("SimpleDeclaration"), this, ToUtf32("DeclarationGrammar.SimpleDeclaration")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("BlockDeclaration"), this, ToUtf32("DeclarationGrammar.BlockDeclaration")));
            AddRule(new StatementRule(ToUtf32("Statement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("LabeledStatement"), ToUtf32("LabeledStatement"), 1)),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ExpressionStatement"), ToUtf32("ExpressionStatement"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("CompoundStatement"), ToUtf32("CompoundStatement"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SelectionStatement"), ToUtf32("SelectionStatement"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("IterationStatement"), ToUtf32("IterationStatement"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("JumpStatement"), ToUtf32("JumpStatement"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DeclarationStatement"), ToUtf32("DeclarationStatement"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("TryBlock"), ToUtf32("TryBlock"), 1)))));
            AddRule(new LabeledStatementRule(ToUtf32("LabeledStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("label"), ToUtf32("Identifier"), 0),
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.DifferenceParser(
                                                new System.Text.Parsing.CharParser(':'),
                                                new System.Text.Parsing.StringParser(ToUtf32("::"))))),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("s1"), ToUtf32("Statement"), 1)))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("case")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ConstantExpression"), ToUtf32("ConstantExpression"), 1))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(':'))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("s2"), ToUtf32("Statement"), 1)))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("default")),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(':'))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("s3"), ToUtf32("Statement"), 1))))))));
            AddRule(new ExpressionStatementRule(ToUtf32("ExpressionStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new CompoundStatementRule(ToUtf32("CompoundStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.CharParser('{')),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new SelectionStatementRule(ToUtf32("SelectionStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("if")),
                                                new System.Text.Parsing.ExpectationParser(
                                                    new System.Text.Parsing.CharParser('('))),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("c1"), ToUtf32("Condition"), 1))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(')'))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("thenS"), ToUtf32("Statement"), 1))),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("else")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("elseS"), ToUtf32("Statement"), 1)))))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("switch")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser('('))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("c2"), ToUtf32("Condition"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(')'))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("sws"), ToUtf32("Statement"), 1))))))));
            AddRule(new ConditionRule(ToUtf32("Condition"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1)),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Declarator"), ToUtf32("Declarator"), 1))),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('='),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("InitializerClause"), ToUtf32("InitializerClause"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("BracedInitializerList"), ToUtf32("BracedInitializerList"), 1))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)))));
            AddRule(new IterationStatementRule(ToUtf32("IterationStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.KeywordParser(ToUtf32("while")),
                                                    new System.Text.Parsing.ExpectationParser(
                                                        new System.Text.Parsing.CharParser('('))),
                                                new System.Text.Parsing.ExpectationParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("c1"), ToUtf32("Condition"), 1))),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser(')'))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("s1"), ToUtf32("Statement"), 1))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.SequenceParser(
                                                            new System.Text.Parsing.KeywordParser(ToUtf32("do")),
                                                            new System.Text.Parsing.ExpectationParser(
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("s2"), ToUtf32("Statement"), 1))),
                                                        new System.Text.Parsing.ExpectationParser(
                                                            new System.Text.Parsing.KeywordParser(ToUtf32("while")))),
                                                    new System.Text.Parsing.ExpectationParser(
                                                        new System.Text.Parsing.CharParser('('))),
                                                new System.Text.Parsing.ExpectationParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("e1"), ToUtf32("Expression"), 1))),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser(')'))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(';')))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("for")),
                                                        new System.Text.Parsing.CharParser('(')),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ForRangeDeclaration"), ToUtf32("ForRangeDeclaration"), 1)),
                                                new System.Text.Parsing.CharParser(':')),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ForRangeInitializer"), ToUtf32("ForRangeInitializer"), 1))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(')'))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("s3"), ToUtf32("Statement"), 1)))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.SequenceParser(
                                                        new System.Text.Parsing.KeywordParser(ToUtf32("for")),
                                                        new System.Text.Parsing.CharParser('(')),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ForInitialization"), ToUtf32("ForInitialization"), 1)),
                                                new System.Text.Parsing.OptionalParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("c2"), ToUtf32("Condition"), 1))),
                                            new System.Text.Parsing.CharParser(';')),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("e2"), ToUtf32("Expression"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(')'))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("s4"), ToUtf32("Statement"), 1))))))));
            AddRule(new ForInitializationRule(ToUtf32("ForInitialization"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("ExpressionStatement"), ToUtf32("ExpressionStatement"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("SimpleDeclaration"), ToUtf32("SimpleDeclaration"), 1)))));
            AddRule(new ForRangeDeclarationRule(ToUtf32("ForRangeDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Declarator"), ToUtf32("Declarator"), 1))))));
            AddRule(new ForRangeInitializerRule(ToUtf32("ForRangeInitializer"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("BracedInitializerList"), ToUtf32("BracedInitializerList"), 1)))));
            AddRule(new JumpStatementRule(ToUtf32("JumpStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("break")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser(';'))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("continue")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser(';')))))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("return")),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(';')))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("return")),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("BracedInitializerList"), ToUtf32("BracedInitializerList"), 1)),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(';')))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("goto")),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser(';'))))))));
            AddRule(new DeclarationStatementRule(ToUtf32("DeclarationStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("BlockDeclaration"), ToUtf32("BlockDeclaration"), 1))));
            AddRule(new TryBlockRule(ToUtf32("TryBlock"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("try")),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CompoundStatement"), ToUtf32("CompoundStatement"), 1))))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("HandlerSequence"), ToUtf32("HandlerSequence"), 2)))));
            AddRule(new HandlerSequenceRule(ToUtf32("HandlerSequence"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.PositiveParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Handler"), ToUtf32("Handler"), 1))))));
            AddRule(new HandlerRule(ToUtf32("Handler"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("catch")),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser('('))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ExceptionDeclaration"), ToUtf32("ExceptionDeclaration"), 1))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.CharParser(')'))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("CompoundStatement"), ToUtf32("CompoundStatement"), 1)))))));
            AddRule(new ExceptionDeclarationRule(ToUtf32("ExceptionDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Declarator"), ToUtf32("Declarator"), 1))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.StringParser(ToUtf32("..."))))));
        }
    }
} // cppparser

using System;
using System.Collections;
using System.Text.Parsing;
using cppast;

// this source file has been automatically generated from 'EnumerationGrammar.parser' using cmparsergen version 2.0.0.

namespace cppparser
{
    public class EnumerationGrammar : System.Text.Parsing.Grammar
    {
        public EnumerationGrammar() : this(new ParsingDomain())
        {
        }
        public EnumerationGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("EnumerationGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("cppparser")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public EnumTypeNode* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            EnumTypeNode* result = *cast<ValueObject<EnumTypeNode*>*>(value.Get());
            return result;
        }

        public class EnumDeclarationRule : System.Text.Parsing.RuleParser
        {
            public EnumDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("EnumTypeNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumTypeNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* enumSpecifierNonterminalParser = GetNonterminal(ToUtf32("EnumSpecifier"));
                enumSpecifierNonterminalParser->SetPre(PreEnumSpecifier);
                enumSpecifierNonterminalParser->SetPost(PostEnumSpecifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEnumSpecifier;
            }
            public void PreEnumSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumSpecifier_value = stack.Pop();
                    context->fromEnumSpecifier = *cast<ValueObject<EnumTypeNode*>*>(fromEnumSpecifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromEnumSpecifier()
                {
                }
                public ParsingContext* ctx;
                public EnumTypeNode* value;
                public EnumTypeNode* fromEnumSpecifier;
            }
        }

        public class OpaqueEnumDeclarationRule : System.Text.Parsing.RuleParser
        {
            public OpaqueEnumDeclarationRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("EnumTypeNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumTypeNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* enumKeyNonterminalParser = GetNonterminal(ToUtf32("EnumKey"));
                enumKeyNonterminalParser->SetPost(PostEnumKey);
                NonterminalParser* enumNameNonterminalParser = GetNonterminal(ToUtf32("EnumName"));
                enumNameNonterminalParser->SetPre(PreEnumName);
                enumNameNonterminalParser->SetPost(PostEnumName);
                NonterminalParser* enumBaseNonterminalParser = GetNonterminal(ToUtf32("EnumBase"));
                enumBaseNonterminalParser->SetPre(PreEnumBase);
                enumBaseNonterminalParser->SetPost(PostEnumBase);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EnumTypeNode(span, context->fromEnumKey, context->fromEnumName, context->fromEnumBase);
            }
            public void PostEnumKey(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumKey_value = stack.Pop();
                    context->fromEnumKey = *cast<ValueObject<EnumKey>*>(fromEnumKey_value.Get());
                }
            }
            public void PreEnumName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumName_value = stack.Pop();
                    context->fromEnumName = *cast<ValueObject<Node*>*>(fromEnumName_value.Get());
                }
            }
            public void PreEnumBase(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumBase(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumBase_value = stack.Pop();
                    context->fromEnumBase = *cast<ValueObject<Node*>*>(fromEnumBase_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromEnumKey(), fromEnumName(), fromEnumBase()
                {
                }
                public ParsingContext* ctx;
                public EnumTypeNode* value;
                public EnumKey fromEnumKey;
                public Node* fromEnumName;
                public Node* fromEnumBase;
            }
        }

        public class EnumSpecifierRule : System.Text.Parsing.RuleParser
        {
            public EnumSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("EnumTypeNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumTypeNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* enumHeadNonterminalParser = GetNonterminal(ToUtf32("EnumHead"));
                enumHeadNonterminalParser->SetPre(PreEnumHead);
                enumHeadNonterminalParser->SetPost(PostEnumHead);
                NonterminalParser* enumeratorsNonterminalParser = GetNonterminal(ToUtf32("Enumerators"));
                enumeratorsNonterminalParser->SetPre(PreEnumerators);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEnumHead;
            }
            public void PreEnumHead(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumHead(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumHead_value = stack.Pop();
                    context->fromEnumHead = *cast<ValueObject<EnumTypeNode*>*>(fromEnumHead_value.Get());
                }
            }
            public void PreEnumerators(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<EnumTypeNode*>(context->value)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromEnumHead()
                {
                }
                public ParsingContext* ctx;
                public EnumTypeNode* value;
                public EnumTypeNode* fromEnumHead;
            }
        }

        public class EnumHeadRule : System.Text.Parsing.RuleParser
        {
            public EnumHeadRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("EnumTypeNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumTypeNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* enumKeyNonterminalParser = GetNonterminal(ToUtf32("EnumKey"));
                enumKeyNonterminalParser->SetPost(PostEnumKey);
                NonterminalParser* enumNameNonterminalParser = GetNonterminal(ToUtf32("EnumName"));
                enumNameNonterminalParser->SetPre(PreEnumName);
                enumNameNonterminalParser->SetPost(PostEnumName);
                NonterminalParser* enumBaseNonterminalParser = GetNonterminal(ToUtf32("EnumBase"));
                enumBaseNonterminalParser->SetPre(PreEnumBase);
                enumBaseNonterminalParser->SetPost(PostEnumBase);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EnumTypeNode(span, context->fromEnumKey, context->fromEnumName, context->fromEnumBase);
            }
            public void PostEnumKey(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumKey_value = stack.Pop();
                    context->fromEnumKey = *cast<ValueObject<EnumKey>*>(fromEnumKey_value.Get());
                }
            }
            public void PreEnumName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumName_value = stack.Pop();
                    context->fromEnumName = *cast<ValueObject<Node*>*>(fromEnumName_value.Get());
                }
            }
            public void PreEnumBase(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEnumBase(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumBase_value = stack.Pop();
                    context->fromEnumBase = *cast<ValueObject<Node*>*>(fromEnumBase_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromEnumKey(), fromEnumName(), fromEnumBase()
                {
                }
                public ParsingContext* ctx;
                public EnumTypeNode* value;
                public EnumKey fromEnumKey;
                public Node* fromEnumName;
                public Node* fromEnumBase;
            }
        }

        public class EnumKeyRule : System.Text.Parsing.RuleParser
        {
            public EnumKeyRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("EnumKey"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumKey>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = EnumKey.enumClass;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = EnumKey.enumStruct;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = EnumKey.enum_;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public EnumKey value;
            }
        }

        public class EnumNameRule : System.Text.Parsing.RuleParser
        {
            public EnumNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* qualifiedIdNonterminalParser = GetNonterminal(ToUtf32("QualifiedId"));
                qualifiedIdNonterminalParser->SetPre(PreQualifiedId);
                qualifiedIdNonterminalParser->SetPost(PostQualifiedId);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromQualifiedId;
            }
            public void PreQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostQualifiedId(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQualifiedId_value = stack.Pop();
                    context->fromQualifiedId = *cast<ValueObject<Node*>*>(fromQualifiedId_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromQualifiedId()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromQualifiedId;
            }
        }

        public class EnumBaseRule : System.Text.Parsing.RuleParser
        {
            public EnumBaseRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Node*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Node*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTypeExpr;
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<Node*>*>(fromTypeExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr()
                {
                }
                public ParsingContext* ctx;
                public Node* value;
                public Node* fromTypeExpr;
            }
        }

        public class EnumeratorsRule : System.Text.Parsing.RuleParser
        {
            public EnumeratorsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("EnumTypeNode*"), ToUtf32("enumType")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> enumType_value = stack.Pop();
                context->enumType = *cast<ValueObject<EnumTypeNode*>*>(enumType_value.Get());
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->enumType->AddNode(context->fromleft);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->enumType->AddNode(context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<EnumeratorNode*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<EnumeratorNode*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), enumType(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public EnumTypeNode* enumType;
                public EnumeratorNode* fromleft;
                public EnumeratorNode* fromright;
            }
        }

        public class EnumeratorDefinitionRule : System.Text.Parsing.RuleParser
        {
            public EnumeratorDefinitionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("EnumeratorNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<EnumeratorNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* enumeratorNonterminalParser = GetNonterminal(ToUtf32("Enumerator"));
                enumeratorNonterminalParser->SetPost(PostEnumerator);
                NonterminalParser* constantExpressionNonterminalParser = GetNonterminal(ToUtf32("ConstantExpression"));
                constantExpressionNonterminalParser->SetPre(PreConstantExpression);
                constantExpressionNonterminalParser->SetPost(PostConstantExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EnumeratorNode(span, context->fromEnumerator, context->fromConstantExpression);
            }
            public void PostEnumerator(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEnumerator_value = stack.Pop();
                    context->fromEnumerator = *cast<ValueObject<IdentifierNode*>*>(fromEnumerator_value.Get());
                }
            }
            public void PreConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConstantExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstantExpression_value = stack.Pop();
                    context->fromConstantExpression = *cast<ValueObject<Node*>*>(fromConstantExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromEnumerator(), fromConstantExpression()
                {
                }
                public ParsingContext* ctx;
                public EnumeratorNode* value;
                public IdentifierNode* fromEnumerator;
                public Node* fromConstantExpression;
            }
        }

        public class EnumeratorRule : System.Text.Parsing.RuleParser
        {
            public EnumeratorRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("IdentifierNode*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<IdentifierNode*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIdentifier;
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<IdentifierNode*>*>(fromIdentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromIdentifier()
                {
                }
                public IdentifierNode* value;
                public IdentifierNode* fromIdentifier;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("cppparser.IdentifierGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new cppparser.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("cppparser.ExpressionGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new cppparser.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("cppparser.TypeExprGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new cppparser.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar2);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("QualifiedId"), this, ToUtf32("IdentifierGrammar.QualifiedId")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ConstantExpression"), this, ToUtf32("ExpressionGrammar.ConstantExpression")));
            AddRule(new EnumDeclarationRule(ToUtf32("EnumDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("EnumSpecifier"), ToUtf32("EnumSpecifier"), 1),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new OpaqueEnumDeclarationRule(ToUtf32("OpaqueEnumDeclaration"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("EnumKey"), ToUtf32("EnumKey"), 0),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("EnumName"), ToUtf32("EnumName"), 1)),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("EnumBase"), ToUtf32("EnumBase"), 1))),
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new EnumSpecifierRule(ToUtf32("EnumSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("EnumHead"), ToUtf32("EnumHead"), 1)),
                            new System.Text.Parsing.CharParser('{')),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Enumerators"), ToUtf32("Enumerators"), 2)),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new EnumHeadRule(ToUtf32("EnumHead"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("EnumKey"), ToUtf32("EnumKey"), 0),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("EnumName"), ToUtf32("EnumName"), 1)),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("EnumBase"), ToUtf32("EnumBase"), 1)))))));
            AddRule(new EnumKeyRule(ToUtf32("EnumKey"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("enum")),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("class"))))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("enum")),
                                    new System.Text.Parsing.KeywordParser(ToUtf32("struct")))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("enum"))))));
            AddRule(new EnumNameRule(ToUtf32("EnumName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("QualifiedId"), ToUtf32("QualifiedId"), 1))));
            AddRule(new EnumBaseRule(ToUtf32("EnumBase"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser(':'),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1))))));
            AddRule(new EnumeratorsRule(ToUtf32("Enumerators"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("EnumeratorDefinition"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(','),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("EnumeratorDefinition"), 1))))))));
            AddRule(new EnumeratorDefinitionRule(ToUtf32("EnumeratorDefinition"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Enumerator"), ToUtf32("Enumerator"), 0),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser('='),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ConstantExpression"), ToUtf32("ConstantExpression"), 1)))))))));
            AddRule(new EnumeratorRule(ToUtf32("Enumerator"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0))));
        }
    }
} // cppparser

using System;
using System.Collections;
using System.Text.Parsing;
using ParsingContext = Code.ParsingContext;

// this source file has been automatically generated from 'Composite.parser' using cmparsergen version 2.0.0.

namespace Syntax
{
    public class CompositeGrammar : System.Text.Parsing.Grammar
    {
        public CompositeGrammar() : this(new ParsingDomain())
        {
        }
        public CompositeGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("CompositeGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("Syntax")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public System.Text.Parsing.Parser* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            System.Text.Parsing.Parser* result = *cast<ValueObject<System.Text.Parsing.Parser*>*>(value.Get());
            return result;
        }

        public class AlternativeRule : System.Text.Parsing.RuleParser
        {
            public AlternativeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.AlternativeParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class SequenceRule : System.Text.Parsing.RuleParser
        {
            public SequenceRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.SequenceParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class DifferenceRule : System.Text.Parsing.RuleParser
        {
            public DifferenceRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.DifferenceParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class ExclusiveOrRule : System.Text.Parsing.RuleParser
        {
            public ExclusiveOrRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.ExclusiveOrParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class IntersectionRule : System.Text.Parsing.RuleParser
        {
            public IntersectionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.IntersectionParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class ListRule : System.Text.Parsing.RuleParser
        {
            public ListRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPre(Preleft);
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPre(Preright);
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.ListParser(context->value, context->fromright);
            }
            public void Preleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromleft_value.Get());
                }
            }
            public void Preright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromleft(), fromright()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromleft;
                public System.Text.Parsing.Parser* fromright;
            }
        }

        public class PostfixRule : System.Text.Parsing.RuleParser
        {
            public PostfixRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("System.Text.Parsing.Parser*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<System.Text.Parsing.Parser*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* primaryNonterminalParser = GetNonterminal(ToUtf32("Primary"));
                primaryNonterminalParser->SetPre(PrePrimary);
                primaryNonterminalParser->SetPost(PostPrimary);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPrimary;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.KleeneStarParser(context->value);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.PositiveParser(context->value);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new System.Text.Parsing.OptionalParser(context->value);
            }
            public void PrePrimary(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostPrimary(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrimary_value = stack.Pop();
                    context->fromPrimary = *cast<ValueObject<System.Text.Parsing.Parser*>*>(fromPrimary_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromPrimary()
                {
                }
                public ParsingContext* ctx;
                public System.Text.Parsing.Parser* value;
                public System.Text.Parsing.Parser* fromPrimary;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("Syntax.PrimaryGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new Syntax.PrimaryGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Primary"), this, ToUtf32("PrimaryGrammar.Primary")));
            AddRule(new AlternativeRule(ToUtf32("Alternative"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Sequence"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('|'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Sequence"), 1)))))))));
            AddRule(new SequenceRule(ToUtf32("Sequence"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Difference"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Difference"), 1)))))));
            AddRule(new DifferenceRule(ToUtf32("Difference"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("ExclusiveOr"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('-'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("ExclusiveOr"), 1)))))))));
            AddRule(new ExclusiveOrRule(ToUtf32("ExclusiveOr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Intersection"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('^'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Intersection"), 1)))))))));
            AddRule(new IntersectionRule(ToUtf32("Intersection"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("List"), 1)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('&'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("List"), 1)))))))));
            AddRule(new ListRule(ToUtf32("List"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Postfix"), 1)),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('%'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Postfix"), 1)))))))));
            AddRule(new PostfixRule(ToUtf32("Postfix"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Primary"), ToUtf32("Primary"), 1)),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.CharParser('*')),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                        new System.Text.Parsing.CharParser('+'))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.CharParser('?'))))))));
        }
    }
} // Syntax

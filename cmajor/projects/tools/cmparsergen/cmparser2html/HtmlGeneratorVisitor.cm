using System;
using System.Collections;
using System.IO;
using System.Text;
using System.Text.Parsing;
using System.Dom;
using System.Security;

public class GrammarInfo
{
    public nothrow GrammarInfo(const ustring& grammarName_, const ustring& grammarId_, const string& grammarFileName_) : 
        grammarName(grammarName_), grammarId(grammarId_), grammarFileName(grammarFileName_)
    {
    }
    public nothrow const ustring& GrammarName() const
    {
        return grammarName;
    }
    public nothrow const ustring& GrammarId() const
    {
        return grammarId;
    }
    public nothrow const string& GrammarFileName() const
    {
        return grammarFileName;
    }
    private ustring grammarName;
    private ustring grammarId;
    private string grammarFileName;
}

public string MakeGrammarId(const Grammar& grammar)
{
    return "grammar_" + ToUtf8(grammar.Name()) + "_" + GetSha1MessageDigest(ToUtf8(grammar.FullName()));
}

public string MakeGrammarFileName(const Grammar& grammar)
{
    return MakeGrammarId(grammar) + ".html";
}

public ustring MakeRuleId(const RuleParser& rule)
{
    return u"rule_" + rule.Name() + u"_" + ToUtf32(GetSha1MessageDigest(ToUtf8(rule.FullName())));
}

public class GrammarMapBuilderVisitor : System.Text.Parsing.Visitor
{
    public nothrow GrammarMapBuilderVisitor(HashMap<ustring, string>& grammarMap_) : grammarMap(grammarMap_)
    {
    }
    public override void BeginVisit(Grammar& grammar)
    {
        if (!grammar.IsExternal())
        {
            grammarMap[ToUtf32(MakeGrammarId(grammar))] = MakeGrammarFileName(grammar);
        }
    }
    private HashMap<ustring, string>& grammarMap;
}

public class HtmlGeneratorVisitor : System.Text.Parsing.Visitor
{
    public nothrow HtmlGeneratorVisitor(const HashMap<ustring, string>& grammarMap_, 
        List<GrammarInfo>& outputGrammars_, const string& docDir_, const string& styleFilePath_) : 
        grammarMap(grammarMap_), outputGrammars(outputGrammars_), docDir(docDir_), styleFilePath(styleFilePath_)
    {
    }
    public override void BeginVisit(Grammar& grammar)
    {
        if (!grammar.IsExternal())
        {
            currentGrammar = &grammar;
            if (Syntax.Flags.Instance().Verbose())
            {
                Console.Out() << ">> " << currentGrammar->FullName() << endl();
            }
        }
        else
        {
            currentGrammar = null;
        }
        if (currentGrammar != null)
        {
            ustring title = currentGrammar->Name() + u" Grammar";
            grammarDoc.Reset(new DomDocument());
            htmlElement.Reset(new DomElement(u"html"));
            UniquePtr<DomElement> headElement(new DomElement(u"head"));
            UniquePtr<DomElement> metaElement(new DomElement(u"meta"));
            metaElement->SetAttribute(u"charset", u"utf-8");
            headElement->AppendChild(UniquePtr<DomNode>(metaElement.Release()));
            UniquePtr<DomElement> titleElement(new DomElement(u"title"));
            titleElement->AppendChild(UniquePtr<DomNode>(new DomText(title)));
            headElement->AppendChild(UniquePtr<DomNode>(titleElement.Release()));
            UniquePtr<DomElement> linkElement(new DomElement(u"link"));
            linkElement->SetAttribute(u"rel", u"stylesheet");
            linkElement->SetAttribute(u"type", u"text/css");
            linkElement->SetAttribute(u"href", ToUtf32(styleFilePath));
            headElement->AppendChild(UniquePtr<DomNode>(linkElement.Release()));
            htmlElement->AppendChild(UniquePtr<DomNode>(headElement.Release()));
            bodyElement.Reset(new DomElement(u"body"));
            UniquePtr<DomElement> headerElement(new DomElement(u"h1"));
            headerElement->AppendChild(UniquePtr<DomNode>(new DomText(title)));
            bodyElement->AppendChild(UniquePtr<DomNode>(headerElement.Release()));
            ruleTableElement.Reset(new DomElement(u"table"));
            ruleTableElement->SetAttribute(u"class", u"grammar");
        }
    }
    public override void EndVisit(Grammar& grammar)
    {
        if (currentGrammar != null)
        {
            if (!grammarDoc.IsNull())
            {
                bodyElement->AppendChild(UniquePtr<DomNode>(ruleTableElement.Release()));
                htmlElement->AppendChild(UniquePtr<DomNode>(bodyElement.Release()));
                grammarDoc->AppendChild(UniquePtr<DomNode>(htmlElement.Release()));
                string grammarFileName = MakeGrammarFileName(grammar);
                string grammarFilePath = Path.Combine(docDir, grammarFileName);
                StreamWriter writer = File.CreateText(grammarFilePath);
                CodeFormatter formatter(writer);
                formatter.SetIndentSize(1);
                grammarDoc->Write(formatter);
                grammarDoc.Reset();
            }
            outputGrammars.Add(GrammarInfo(currentGrammar->FullName(), ToUtf32(MakeGrammarId(*currentGrammar)), MakeGrammarFileName(*currentGrammar)));
            currentGrammar = null;
        }        
    }
    public override void BeginVisit(RuleParser& rule) 
    {
        if (currentGrammar != null)
        {
            currentRule = &rule;
            ustring ruleId = MakeRuleId(rule);
            trElement.Reset(new DomElement(u"tr"));
            trElement->SetAttribute(u"id", ruleId);
            UniquePtr<DomElement> tdNameElement(new DomElement(u"td"));
            tdNameElement->SetAttribute(u"class", u"grammarFirstCol");
            UniquePtr<DomElement> ruleSpanElement(new DomElement(u"span"));
            ruleSpanElement->SetAttribute(u"class", u"rule");
            ruleSpanElement->AppendChild(UniquePtr<DomNode>(new DomText(rule.Name())));
            tdNameElement->AppendChild(UniquePtr<DomNode>(ruleSpanElement.Release()));
            trElement->AppendChild(UniquePtr<DomNode>(tdNameElement.Release()));
            UniquePtr<DomElement> tdArrowElement(new DomElement(u"td"));
            tdArrowElement->SetAttribute(u"class", u"grammarSecondCol");
            tdArrowElement->AppendChild(UniquePtr<DomNode>(new DomEntityReference(u"rarr")));
            trElement->AppendChild(UniquePtr<DomNode>(tdArrowElement.Release()));
            ruleBodyElement.Reset(new DomElement(u"td"));
            ruleBodyElement->SetAttribute(u"class", u"grammarThirdCol");
            ruleBodyElement->SetAttribute(u"xml:space", u"preserve");
        }        
        else
        {
            currentRule = null;
        }
    }
    public override void EndVisit(RuleParser& rule) 
    {
        if (currentRule != null)
        {
            trElement->AppendChild(UniquePtr<DomNode>(ruleBodyElement.Release()));
            ruleTableElement->AppendChild(UniquePtr<DomNode>(trElement.Release()));
            currentRule = null;
        }        
    }
    public override void Visit(RuleLink& ruleLink) 
    {
    }
    public override void Visit(KeywordParser& keywordParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"keyword")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
            UniquePtr<DomElement> kw(new DomElement(u"span"));
            kw->SetAttribute(u"class", u"ruleString");
            ustring k = u"(\"" + StringStr(keywordParser.Keyword()) + u"\")";
            kw->AppendChild(UniquePtr<DomNode>(new DomText(k)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(kw.Release()));
        }
    }
    public override void Visit(KeywordListParser& keywordListParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"keyword_list")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
            UniquePtr<DomElement> preamble(new DomElement(u"span"));
            preamble->SetAttribute(u"class", u"ruleParams");
            ustring t = u"(" + keywordListParser.SelectorRuleName() + u", [";
            preamble->AppendChild(UniquePtr<DomNode>(new DomText(t)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(preamble.Release()));
            UniquePtr<DomElement> kw(new DomElement(u"span"));
            kw->SetAttribute(u"class", u"ruleString");
            bool first = true;
            for (const ustring& keyword : keywordListParser.Keywords())
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    kw->AppendChild(UniquePtr<DomNode>(new DomText(u", ")));
                }
                ustring k = u"\"" + StringStr(keyword) + u"\"";
                kw->AppendChild(UniquePtr<DomNode>(new DomText(k)));
            }
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(kw.Release()));
            UniquePtr<DomElement> postamble(new DomElement(u"span"));
            postamble->SetAttribute(u"class", u"ruleParams");
            postamble->AppendChild(UniquePtr<DomNode>(new DomText(u"])")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(postamble.Release()));
        }
    }
    public override void BeginVisit(OptionalParser& optionalParser) 
    {
    }
    public override void EndVisit(OptionalParser& optionalParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"?")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void BeginVisit(PositiveParser& positiveParser) 
    {
    }
    public override void EndVisit(PositiveParser& positiveParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"+")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void BeginVisit(KleeneStarParser& kleeneStarParser) 
    {
    }
    public override void EndVisit(KleeneStarParser& kleeneStarParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"*")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void BeginVisit(ExpectationParser& expectationParser) 
    {
    }
    public override void EndVisit(ExpectationParser& expectationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"!")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void BeginVisit(TokenParser& tokenParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"token")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
            UniquePtr<DomElement> paren(new DomElement(u"span"));
            paren->SetAttribute(u"class", u"ruleOp");
            paren->AppendChild(UniquePtr<DomNode>(new DomText(u"(")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(paren.Release()));
        }
    }
    public override void EndVisit(TokenParser& tokenParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> paren(new DomElement(u"span"));
            paren->SetAttribute(u"class", u"ruleOp");
            paren->AppendChild(UniquePtr<DomNode>(new DomText(u")")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(paren.Release()));
        }        
    }
    public override void BeginVisit(GroupingParser& groupingParser)
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> paren(new DomElement(u"span"));
            paren->SetAttribute(u"class", u"ruleOp");
            paren->AppendChild(UniquePtr<DomNode>(new DomText(u"(")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(paren.Release()));
        }
    }
    public override void EndVisit(GroupingParser& groupingParser)
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> paren(new DomElement(u"span"));
            paren->SetAttribute(u"class", u"ruleOp");
            paren->AppendChild(UniquePtr<DomNode>(new DomText(u")")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(paren.Release()));
        }        
    }
    public override void BeginVisit(SequenceParser& sequenceParser) 
    {
    }
    public override void Visit(SequenceParser& sequenceParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(SequenceParser& sequenceParser) 
    {
    }
    public override void BeginVisit(AlternativeParser& alternativeParser) 
    {
    }
    public override void Visit(AlternativeParser& alternativeParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" | ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(AlternativeParser& alternativeParser) 
    {
    }
    public override void BeginVisit(DifferenceParser& differenceParser) 
    {
    }
    public override void Visit(DifferenceParser& differenceParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" ")));
            element->AppendChild(UniquePtr<DomNode>(new DomEntityReference(u"minus")));
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(DifferenceParser& differenceParser) 
    {
    }
    public override void BeginVisit(ExclusiveOrParser& exclusiveOrParser) 
    {
    }
    public override void Visit(ExclusiveOrParser& exclusiveOrParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" ^ ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(ExclusiveOrParser& exclusiveOrParser) 
    {
    }
    public override void BeginVisit(IntersectionParser& intersectionParser) 
    {
    }
    public override void Visit(IntersectionParser& intersectionParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" & ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(IntersectionParser& intersectionParser) 
    {
    }
    public override void BeginVisit(ListParser& listParser) 
    {
    }
    public override void Visit(ListParser& listParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleOp");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u" % ")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void EndVisit(ListParser& listParser) 
    {
    }
    public override void Visit(NonterminalParser& nonterminalParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleLink");
            UniquePtr<DomElement> linkElement(new DomElement(u"a"));
            linkElement->SetAttribute(u"class", u"ruleLink");
            RuleParser* rule = nonterminalParser.Rule();
            if (rule == null)
            {
                throw Exception("rule '" + ToUtf8(nonterminalParser.RuleName()) + "' not found");
            }
            Grammar* grammar = rule->GetGrammar();
            if (grammar == currentGrammar)
            {
                linkElement->SetAttribute(u"href", u"#" + MakeRuleId(*rule));
            }
            else
            {
                HashMap<ustring, string>.ConstIterator it = grammarMap.CFind(ToUtf32(MakeGrammarId(*grammar)));
                if (it != grammarMap.CEnd())
                {
                    string grammarDocPath = it->second;
                    linkElement->SetAttribute(u"href", ToUtf32(grammarDocPath) + u"#" + MakeRuleId(*rule));
                }
                else
                {
                    throw Exception("grammar '" + ToUtf8(grammar->Name()) + "' not found");
                }
            }
            linkElement->AppendChild(UniquePtr<DomNode>(new DomText(nonterminalParser.RuleName())));
            element->AppendChild(UniquePtr<DomNode>(linkElement.Release()));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(CharParser& charParser) 
    {
        if (currentRule != null)
        {
            ustring charLit = u"'" + CharStr(charParser.Char()) + u"'";
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleChar");
            element->AppendChild(UniquePtr<DomNode>(new DomText(charLit)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(StringParser& stringParser) 
    {
        if (currentRule != null)
        {
            ustring stringLit = u"\"" + StringStr(stringParser.String()) + u"\"";
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleString");
            element->AppendChild(UniquePtr<DomNode>(new DomText(stringLit)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(CharSetParser& charSetParser) 
    {
        if (currentRule != null)
        {
            ustring inverse;
            if (charSetParser.Inverse())
            {
                inverse = u"^";
            }
            ustring stringLit = u"[" + StringStr(inverse + charSetParser.Set()) + u"]";
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleCharSet");
            element->AppendChild(UniquePtr<DomNode>(new DomText(stringLit)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(EmptyParser& emptyParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"empty")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SpaceParser& spaceParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"space")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(LetterParser& letterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(UpperLetterParser& upperLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"upper_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(LowerLetterParser& lowerLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"lower_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(TitleLetterParser& titleLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"title_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ModifierLetterParser& modifierLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"modifier_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OtherLetterParser& otherLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"other_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(CasedLetterParser& casedLetterParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"cased_letter")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(DigitParser& digitParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"digit")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(HexDigitParser& hexDigitParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"hexdigit")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(MarkParser& markParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"mark")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(NonspacingMarkParser& nonspacingMarkParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"nonspacing_mark")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SpacingMarkParser& spacingMarkParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"spacing_mark")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(EnclosingMarkParser& enclosingMarkParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"enclosing_mark")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(NumberParser& numberParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"number")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(DecimalNumberParser& decimalNumberParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"decimal_number")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(LetterNumberParser& letterNumberParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"letter_number")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OtherNumberParser& otherNumberParer) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"other_number")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(PunctuationParser& punctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ConnectorPunctuationParser& connectorPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"connector_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(DashPunctuationParser& dashPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"dash_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OpenPunctuationParser& openPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"open_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ClosePunctuationParser& closePunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"close_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(InitialPunctuationParser& initialPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"initial_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(FinalPunctuationParser& finalPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"final_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OtherPunctuationParser& otherPunctuationParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"other_puctuation")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SymbolParser& symbolParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"symbol")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(MathSymbolParser& mathSymbolParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"math_symbol")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(CurrencySymbolParser& currencySymbolParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"currency_symbol")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ModifierSymbolParser& modifierSymbolParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"modifier_symbol")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OtherSymbolParser& otherSymbolParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"other_symbol")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SeparatorParser& separatorParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"separator")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SpaceSeparatorParser& spaceSeparatorParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"space_separator")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(LineSeparatorParser& lineSeparatorParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"line_separator")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ParagraphSeparatorParser& paragraphSeparatorParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"paragraph_separator")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(OtherParser& otherParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"other")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(ControlParser& controlParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"control")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(FormatParser& formatParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"format")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(SurrogateParser& surrogateParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"surrogate")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(PrivateUseParser& privateUseParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"private_use")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(UnassignedParser& unassignedParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"unassigned")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(GraphicParser& graphicParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"graphic")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(BaseCharParser& baseCharParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"basechar")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(AlphabeticParser& alphabeticParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"alphabetic")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(IdStartParser& idStartParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"idstart")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(IdContParser& idContParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"idcont")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(AnyCharParser& anyCharParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"anychar")));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
        }
    }
    public override void Visit(RangeParser& rangeParser) 
    {
        if (currentRule != null)
        {
            UniquePtr<DomElement> element(new DomElement(u"span"));
            element->SetAttribute(u"class", u"ruleKeyword");
            element->AppendChild(UniquePtr<DomNode>(new DomText(u"range")));
            UniquePtr<DomElement> params(new DomElement(u"span"));
            params->SetAttribute(u"class", u"ruleParams");
            ustring s = u"(" + ToUtf32(ToString(rangeParser.Start())) + u"," + ToUtf32(ToString(rangeParser.End())) + u")";
            params->AppendChild(UniquePtr<DomNode>(new DomText(s)));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(element.Release()));
            ruleBodyElement->AppendChild(UniquePtr<DomNode>(params.Release()));
        }    
    }
    private Grammar* currentGrammar;
    private RuleParser* currentRule;
    private string docDir;
    private string styleFilePath;
    private UniquePtr<DomDocument> grammarDoc;
    private UniquePtr<DomElement> htmlElement;
    private UniquePtr<DomElement> bodyElement;
    private UniquePtr<DomElement> ruleTableElement;
    private UniquePtr<DomElement> trElement;
    private UniquePtr<DomElement> ruleBodyElement;
    private const HashMap<ustring, string>& grammarMap;
    private List<GrammarInfo>& outputGrammars;
}

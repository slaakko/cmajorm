using System;
using System.Collections;
using System.Text.Parsing;
using System.Text.Parsing.CodeDom;

namespace Code
{
    public class StatementGrammar : System.Text.Parsing.Grammar
    {
        public StatementGrammar() : this(new ParsingDomain())
        {
        }
        public StatementGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("StatementGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("Code")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public Statement* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ParsingContext* ctx)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(ctx)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            Statement* result = *cast<ValueObject<Statement*>*>(value.Get());
            return result;
        }

        public class StatementRule : System.Text.Parsing.RuleParser
        {
            public StatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                NonterminalParser* labeledStatementNonterminalParser = GetNonterminal(ToUtf32("LabeledStatement"));
                labeledStatementNonterminalParser->SetPre(PreLabeledStatement);
                labeledStatementNonterminalParser->SetPost(PostLabeledStatement);
                NonterminalParser* controlStatementNonterminalParser = GetNonterminal(ToUtf32("ControlStatement"));
                controlStatementNonterminalParser->SetPre(PreControlStatement);
                controlStatementNonterminalParser->SetPost(PostControlStatement);
                NonterminalParser* expressionStatementNonterminalParser = GetNonterminal(ToUtf32("ExpressionStatement"));
                expressionStatementNonterminalParser->SetPre(PreExpressionStatement);
                expressionStatementNonterminalParser->SetPost(PostExpressionStatement);
                NonterminalParser* assignmentStatementNonterminalParser = GetNonterminal(ToUtf32("AssignmentStatement"));
                assignmentStatementNonterminalParser->SetPre(PreAssignmentStatement);
                assignmentStatementNonterminalParser->SetPost(PostAssignmentStatement);
                NonterminalParser* constructionStatementNonterminalParser = GetNonterminal(ToUtf32("ConstructionStatement"));
                constructionStatementNonterminalParser->SetPre(PreConstructionStatement);
                constructionStatementNonterminalParser->SetPost(PostConstructionStatement);
                NonterminalParser* deleteStatementNonterminalParser = GetNonterminal(ToUtf32("DeleteStatement"));
                deleteStatementNonterminalParser->SetPre(PreDeleteStatement);
                deleteStatementNonterminalParser->SetPost(PostDeleteStatement);
                NonterminalParser* destroyStatementNonterminalParser = GetNonterminal(ToUtf32("DestroyStatement"));
                destroyStatementNonterminalParser->SetPre(PreDestroyStatement);
                destroyStatementNonterminalParser->SetPost(PostDestroyStatement);
                NonterminalParser* emptyStatementNonterminalParser = GetNonterminal(ToUtf32("EmptyStatement"));
                emptyStatementNonterminalParser->SetPre(PreEmptyStatement);
                emptyStatementNonterminalParser->SetPost(PostEmptyStatement);
                NonterminalParser* throwStatementNonterminalParser = GetNonterminal(ToUtf32("ThrowStatement"));
                throwStatementNonterminalParser->SetPre(PreThrowStatement);
                throwStatementNonterminalParser->SetPost(PostThrowStatement);
                NonterminalParser* tryStatementNonterminalParser = GetNonterminal(ToUtf32("TryStatement"));
                tryStatementNonterminalParser->SetPre(PreTryStatement);
                tryStatementNonterminalParser->SetPost(PostTryStatement);
                NonterminalParser* assertStatementNonterminalParser = GetNonterminal(ToUtf32("AssertStatement"));
                assertStatementNonterminalParser->SetPre(PreAssertStatement);
                assertStatementNonterminalParser->SetPost(PostAssertStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLabeledStatement;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromControlStatement;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpressionStatement;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssignmentStatement;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConstructionStatement;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDeleteStatement;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDestroyStatement;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEmptyStatement;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromThrowStatement;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromTryStatement;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssertStatement;
            }
            public void PreLabeledStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostLabeledStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLabeledStatement_value = stack.Pop();
                    context->fromLabeledStatement = *cast<ValueObject<Statement*>*>(fromLabeledStatement_value.Get());
                }
            }
            public void PreControlStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostControlStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromControlStatement_value = stack.Pop();
                    context->fromControlStatement = *cast<ValueObject<Statement*>*>(fromControlStatement_value.Get());
                }
            }
            public void PreExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpressionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpressionStatement_value = stack.Pop();
                    context->fromExpressionStatement = *cast<ValueObject<Statement*>*>(fromExpressionStatement_value.Get());
                }
            }
            public void PreAssignmentStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatement_value = stack.Pop();
                    context->fromAssignmentStatement = *cast<ValueObject<Statement*>*>(fromAssignmentStatement_value.Get());
                }
            }
            public void PreConstructionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConstructionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstructionStatement_value = stack.Pop();
                    context->fromConstructionStatement = *cast<ValueObject<ConstructionStatement*>*>(fromConstructionStatement_value.Get());
                }
            }
            public void PreDeleteStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDeleteStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDeleteStatement_value = stack.Pop();
                    context->fromDeleteStatement = *cast<ValueObject<Statement*>*>(fromDeleteStatement_value.Get());
                }
            }
            public void PreDestroyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDestroyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDestroyStatement_value = stack.Pop();
                    context->fromDestroyStatement = *cast<ValueObject<Statement*>*>(fromDestroyStatement_value.Get());
                }
            }
            public void PreEmptyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEmptyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEmptyStatement_value = stack.Pop();
                    context->fromEmptyStatement = *cast<ValueObject<Statement*>*>(fromEmptyStatement_value.Get());
                }
            }
            public void PreThrowStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostThrowStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromThrowStatement_value = stack.Pop();
                    context->fromThrowStatement = *cast<ValueObject<Statement*>*>(fromThrowStatement_value.Get());
                }
            }
            public void PreTryStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTryStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTryStatement_value = stack.Pop();
                    context->fromTryStatement = *cast<ValueObject<TryStatement*>*>(fromTryStatement_value.Get());
                }
            }
            public void PreAssertStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssertStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssertStatement_value = stack.Pop();
                    context->fromAssertStatement = *cast<ValueObject<Statement*>*>(fromAssertStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromLabeledStatement(), fromControlStatement(), fromExpressionStatement(), fromAssignmentStatement(), fromConstructionStatement(), fromDeleteStatement(), fromDestroyStatement(), fromEmptyStatement(), fromThrowStatement(), fromTryStatement(), fromAssertStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromLabeledStatement;
                public Statement* fromControlStatement;
                public Statement* fromExpressionStatement;
                public Statement* fromAssignmentStatement;
                public ConstructionStatement* fromConstructionStatement;
                public Statement* fromDeleteStatement;
                public Statement* fromDestroyStatement;
                public Statement* fromEmptyStatement;
                public Statement* fromThrowStatement;
                public TryStatement* fromTryStatement;
                public Statement* fromAssertStatement;
            }
        }

        public class LabelIdRule : System.Text.Parsing.RuleParser
        {
            public LabelIdRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("identifier"));
                identifierNonterminalParser->SetPost(Postidentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromidentifier;
            }
            public void Postidentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromidentifier_value = stack.Pop();
                    context->fromidentifier = *cast<ValueObject<ustring>*>(fromidentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromidentifier()
                {
                }
                public ustring value;
                public ustring fromidentifier;
            }
        }

        public class LabeledStatementRule : System.Text.Parsing.RuleParser
        {
            public LabeledStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* lblNonterminalParser = GetNonterminal(ToUtf32("lbl"));
                lblNonterminalParser->SetPost(Postlbl);
                NonterminalParser* stmtNonterminalParser = GetNonterminal(ToUtf32("stmt"));
                stmtNonterminalParser->SetPre(Prestmt);
                stmtNonterminalParser->SetPost(Poststmt);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->fromstmt->SetLabel(context->fromlbl);
                context->value = context->fromstmt;
            }
            public void Postlbl(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromlbl_value = stack.Pop();
                    context->fromlbl = *cast<ValueObject<ustring>*>(fromlbl_value.Get());
                }
            }
            public void Prestmt(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poststmt(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromstmt_value = stack.Pop();
                    context->fromstmt = *cast<ValueObject<Statement*>*>(fromstmt_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromlbl(), fromstmt()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public ustring fromlbl;
                public Statement* fromstmt;
            }
        }

        public class ControlStatementRule : System.Text.Parsing.RuleParser
        {
            public ControlStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
                ActionParser* a12ActionParser = GetAction(ToUtf32("A12"));
                a12ActionParser->SetAction(A12Action);
                NonterminalParser* compoundStatementNonterminalParser = GetNonterminal(ToUtf32("CompoundStatement"));
                compoundStatementNonterminalParser->SetPre(PreCompoundStatement);
                compoundStatementNonterminalParser->SetPost(PostCompoundStatement);
                NonterminalParser* returnStatementNonterminalParser = GetNonterminal(ToUtf32("ReturnStatement"));
                returnStatementNonterminalParser->SetPre(PreReturnStatement);
                returnStatementNonterminalParser->SetPost(PostReturnStatement);
                NonterminalParser* ifStatementNonterminalParser = GetNonterminal(ToUtf32("IfStatement"));
                ifStatementNonterminalParser->SetPre(PreIfStatement);
                ifStatementNonterminalParser->SetPost(PostIfStatement);
                NonterminalParser* whileStatementNonterminalParser = GetNonterminal(ToUtf32("WhileStatement"));
                whileStatementNonterminalParser->SetPre(PreWhileStatement);
                whileStatementNonterminalParser->SetPost(PostWhileStatement);
                NonterminalParser* doStatementNonterminalParser = GetNonterminal(ToUtf32("DoStatement"));
                doStatementNonterminalParser->SetPre(PreDoStatement);
                doStatementNonterminalParser->SetPost(PostDoStatement);
                NonterminalParser* rangeForStatementNonterminalParser = GetNonterminal(ToUtf32("RangeForStatement"));
                rangeForStatementNonterminalParser->SetPre(PreRangeForStatement);
                rangeForStatementNonterminalParser->SetPost(PostRangeForStatement);
                NonterminalParser* forStatementNonterminalParser = GetNonterminal(ToUtf32("ForStatement"));
                forStatementNonterminalParser->SetPre(PreForStatement);
                forStatementNonterminalParser->SetPost(PostForStatement);
                NonterminalParser* breakStatementNonterminalParser = GetNonterminal(ToUtf32("BreakStatement"));
                breakStatementNonterminalParser->SetPre(PreBreakStatement);
                breakStatementNonterminalParser->SetPost(PostBreakStatement);
                NonterminalParser* continueStatementNonterminalParser = GetNonterminal(ToUtf32("ContinueStatement"));
                continueStatementNonterminalParser->SetPre(PreContinueStatement);
                continueStatementNonterminalParser->SetPost(PostContinueStatement);
                NonterminalParser* gotoStatementNonterminalParser = GetNonterminal(ToUtf32("GotoStatement"));
                gotoStatementNonterminalParser->SetPre(PreGotoStatement);
                gotoStatementNonterminalParser->SetPost(PostGotoStatement);
                NonterminalParser* switchStatementNonterminalParser = GetNonterminal(ToUtf32("SwitchStatement"));
                switchStatementNonterminalParser->SetPre(PreSwitchStatement);
                switchStatementNonterminalParser->SetPost(PostSwitchStatement);
                NonterminalParser* gotoCaseStatementNonterminalParser = GetNonterminal(ToUtf32("GotoCaseStatement"));
                gotoCaseStatementNonterminalParser->SetPre(PreGotoCaseStatement);
                gotoCaseStatementNonterminalParser->SetPost(PostGotoCaseStatement);
                NonterminalParser* gotoDefaultStatementNonterminalParser = GetNonterminal(ToUtf32("GotoDefaultStatement"));
                gotoDefaultStatementNonterminalParser->SetPre(PreGotoDefaultStatement);
                gotoDefaultStatementNonterminalParser->SetPost(PostGotoDefaultStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromCompoundStatement;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromReturnStatement;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromIfStatement;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromWhileStatement;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromDoStatement;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromRangeForStatement;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromForStatement;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromBreakStatement;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromContinueStatement;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromGotoStatement;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromSwitchStatement;
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromGotoCaseStatement;
            }
            public void A12Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromGotoDefaultStatement;
            }
            public void PreCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCompoundStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCompoundStatement_value = stack.Pop();
                    context->fromCompoundStatement = *cast<ValueObject<CompoundStatement*>*>(fromCompoundStatement_value.Get());
                }
            }
            public void PreReturnStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostReturnStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromReturnStatement_value = stack.Pop();
                    context->fromReturnStatement = *cast<ValueObject<Statement*>*>(fromReturnStatement_value.Get());
                }
            }
            public void PreIfStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostIfStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIfStatement_value = stack.Pop();
                    context->fromIfStatement = *cast<ValueObject<Statement*>*>(fromIfStatement_value.Get());
                }
            }
            public void PreWhileStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostWhileStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromWhileStatement_value = stack.Pop();
                    context->fromWhileStatement = *cast<ValueObject<Statement*>*>(fromWhileStatement_value.Get());
                }
            }
            public void PreDoStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDoStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDoStatement_value = stack.Pop();
                    context->fromDoStatement = *cast<ValueObject<Statement*>*>(fromDoStatement_value.Get());
                }
            }
            public void PreRangeForStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostRangeForStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromRangeForStatement_value = stack.Pop();
                    context->fromRangeForStatement = *cast<ValueObject<Statement*>*>(fromRangeForStatement_value.Get());
                }
            }
            public void PreForStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForStatement_value = stack.Pop();
                    context->fromForStatement = *cast<ValueObject<Statement*>*>(fromForStatement_value.Get());
                }
            }
            public void PreBreakStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostBreakStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromBreakStatement_value = stack.Pop();
                    context->fromBreakStatement = *cast<ValueObject<Statement*>*>(fromBreakStatement_value.Get());
                }
            }
            public void PreContinueStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostContinueStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromContinueStatement_value = stack.Pop();
                    context->fromContinueStatement = *cast<ValueObject<Statement*>*>(fromContinueStatement_value.Get());
                }
            }
            public void PreGotoStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostGotoStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromGotoStatement_value = stack.Pop();
                    context->fromGotoStatement = *cast<ValueObject<Statement*>*>(fromGotoStatement_value.Get());
                }
            }
            public void PreSwitchStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostSwitchStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSwitchStatement_value = stack.Pop();
                    context->fromSwitchStatement = *cast<ValueObject<SwitchStatement*>*>(fromSwitchStatement_value.Get());
                }
            }
            public void PreGotoCaseStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostGotoCaseStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromGotoCaseStatement_value = stack.Pop();
                    context->fromGotoCaseStatement = *cast<ValueObject<Statement*>*>(fromGotoCaseStatement_value.Get());
                }
            }
            public void PreGotoDefaultStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostGotoDefaultStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromGotoDefaultStatement_value = stack.Pop();
                    context->fromGotoDefaultStatement = *cast<ValueObject<Statement*>*>(fromGotoDefaultStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromCompoundStatement(), fromReturnStatement(), fromIfStatement(), fromWhileStatement(), fromDoStatement(), fromRangeForStatement(), fromForStatement(), fromBreakStatement(), fromContinueStatement(), fromGotoStatement(), fromSwitchStatement(), fromGotoCaseStatement(), fromGotoDefaultStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public CompoundStatement* fromCompoundStatement;
                public Statement* fromReturnStatement;
                public Statement* fromIfStatement;
                public Statement* fromWhileStatement;
                public Statement* fromDoStatement;
                public Statement* fromRangeForStatement;
                public Statement* fromForStatement;
                public Statement* fromBreakStatement;
                public Statement* fromContinueStatement;
                public Statement* fromGotoStatement;
                public SwitchStatement* fromSwitchStatement;
                public Statement* fromGotoCaseStatement;
                public Statement* fromGotoDefaultStatement;
            }
        }

        public class CompoundStatementRule : System.Text.Parsing.RuleParser
        {
            public CompoundStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("CompoundStatement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CompoundStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* stmtNonterminalParser = GetNonterminal(ToUtf32("stmt"));
                stmtNonterminalParser->SetPre(Prestmt);
                stmtNonterminalParser->SetPost(Poststmt);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new CompoundStatement();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddStatement(context->fromstmt);
            }
            public void Prestmt(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Poststmt(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromstmt_value = stack.Pop();
                    context->fromstmt = *cast<ValueObject<Statement*>*>(fromstmt_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromstmt()
                {
                }
                public ParsingContext* ctx;
                public CompoundStatement* value;
                public Statement* fromstmt;
            }
        }

        public class ReturnStatementRule : System.Text.Parsing.RuleParser
        {
            public ReturnStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ReturnStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public class IfStatementRule : System.Text.Parsing.RuleParser
        {
            public IfStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* thenSNonterminalParser = GetNonterminal(ToUtf32("thenS"));
                thenSNonterminalParser->SetPre(PrethenS);
                thenSNonterminalParser->SetPost(PostthenS);
                NonterminalParser* elseSNonterminalParser = GetNonterminal(ToUtf32("elseS"));
                elseSNonterminalParser->SetPre(PreelseS);
                elseSNonterminalParser->SetPost(PostelseS);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new IfStatement(context->fromExpression, context->fromthenS, context->fromelseS);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PrethenS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostthenS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromthenS_value = stack.Pop();
                    context->fromthenS = *cast<ValueObject<Statement*>*>(fromthenS_value.Get());
                }
            }
            public void PreelseS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostelseS(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromelseS_value = stack.Pop();
                    context->fromelseS = *cast<ValueObject<Statement*>*>(fromelseS_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression(), fromthenS(), fromelseS()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
                public Statement* fromthenS;
                public Statement* fromelseS;
            }
        }

        public class WhileStatementRule : System.Text.Parsing.RuleParser
        {
            public WhileStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new WhileStatement(context->fromExpression, context->fromStatement);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
                public Statement* fromStatement;
            }
        }

        public class DoStatementRule : System.Text.Parsing.RuleParser
        {
            public DoStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DoStatement(context->fromExpression, context->fromStatement);
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromStatement(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromStatement;
                public DomObject* fromExpression;
            }
        }

        public class ForStatementRule : System.Text.Parsing.RuleParser
        {
            public ForStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* forInitStatementNonterminalParser = GetNonterminal(ToUtf32("ForInitStatement"));
                forInitStatementNonterminalParser->SetPre(PreForInitStatement);
                forInitStatementNonterminalParser->SetPost(PostForInitStatement);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* forLoopStatementExprNonterminalParser = GetNonterminal(ToUtf32("ForLoopStatementExpr"));
                forLoopStatementExprNonterminalParser->SetPre(PreForLoopStatementExpr);
                forLoopStatementExprNonterminalParser->SetPost(PostForLoopStatementExpr);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ForStatement(context->fromForInitStatement, context->fromExpression, context->fromForLoopStatementExpr, context->fromStatement);
            }
            public void PreForInitStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForInitStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForInitStatement_value = stack.Pop();
                    context->fromForInitStatement = *cast<ValueObject<Statement*>*>(fromForInitStatement_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreForLoopStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostForLoopStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromForLoopStatementExpr_value = stack.Pop();
                    context->fromForLoopStatementExpr = *cast<ValueObject<Statement*>*>(fromForLoopStatementExpr_value.Get());
                }
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromForInitStatement(), fromExpression(), fromForLoopStatementExpr(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromForInitStatement;
                public DomObject* fromExpression;
                public Statement* fromForLoopStatementExpr;
                public Statement* fromStatement;
            }
        }

        public class ForInitStatementRule : System.Text.Parsing.RuleParser
        {
            public ForInitStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* assignmentStatementNonterminalParser = GetNonterminal(ToUtf32("AssignmentStatement"));
                assignmentStatementNonterminalParser->SetPre(PreAssignmentStatement);
                assignmentStatementNonterminalParser->SetPost(PostAssignmentStatement);
                NonterminalParser* constructionStatementNonterminalParser = GetNonterminal(ToUtf32("ConstructionStatement"));
                constructionStatementNonterminalParser->SetPre(PreConstructionStatement);
                constructionStatementNonterminalParser->SetPost(PostConstructionStatement);
                NonterminalParser* emptyStatementNonterminalParser = GetNonterminal(ToUtf32("EmptyStatement"));
                emptyStatementNonterminalParser->SetPre(PreEmptyStatement);
                emptyStatementNonterminalParser->SetPost(PostEmptyStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssignmentStatement;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromConstructionStatement;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromEmptyStatement;
            }
            public void PreAssignmentStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatement_value = stack.Pop();
                    context->fromAssignmentStatement = *cast<ValueObject<Statement*>*>(fromAssignmentStatement_value.Get());
                }
            }
            public void PreConstructionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostConstructionStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromConstructionStatement_value = stack.Pop();
                    context->fromConstructionStatement = *cast<ValueObject<ConstructionStatement*>*>(fromConstructionStatement_value.Get());
                }
            }
            public void PreEmptyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostEmptyStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromEmptyStatement_value = stack.Pop();
                    context->fromEmptyStatement = *cast<ValueObject<Statement*>*>(fromEmptyStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromAssignmentStatement(), fromConstructionStatement(), fromEmptyStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromAssignmentStatement;
                public ConstructionStatement* fromConstructionStatement;
                public Statement* fromEmptyStatement;
            }
        }

        public class ForLoopStatementExprRule : System.Text.Parsing.RuleParser
        {
            public ForLoopStatementExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* assignmentStatementExprNonterminalParser = GetNonterminal(ToUtf32("AssignmentStatementExpr"));
                assignmentStatementExprNonterminalParser->SetPre(PreAssignmentStatementExpr);
                assignmentStatementExprNonterminalParser->SetPost(PostAssignmentStatementExpr);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssignmentStatementExpr;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ExpressionStatement(context->fromExpression);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EmptyStatement();
            }
            public void PreAssignmentStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatementExpr_value = stack.Pop();
                    context->fromAssignmentStatementExpr = *cast<ValueObject<Statement*>*>(fromAssignmentStatementExpr_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromAssignmentStatementExpr(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromAssignmentStatementExpr;
                public DomObject* fromExpression;
            }
        }

        public class RangeForStatementRule : System.Text.Parsing.RuleParser
        {
            public RangeForStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new RangeForStatement(context->fromTypeExpr, context->fromIdentifier, context->fromExpression, context->fromStatement);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<DomObject*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<Identifier*>*>(fromIdentifier_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromIdentifier(), fromExpression(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromTypeExpr;
                public Identifier* fromIdentifier;
                public DomObject* fromExpression;
                public Statement* fromStatement;
            }
        }

        public class BreakStatementRule : System.Text.Parsing.RuleParser
        {
            public BreakStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new BreakStatement();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
            }
        }

        public class ContinueStatementRule : System.Text.Parsing.RuleParser
        {
            public ContinueStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ContinueStatement();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
            }
        }

        public class GotoStatementRule : System.Text.Parsing.RuleParser
        {
            public GotoStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<Identifier>"), ToUtf32("id")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->id.Reset(context->fromIdentifier);
                context->value = new GotoStatement(context->fromIdentifier->Name());
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<Identifier*>*>(fromIdentifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), id(), fromIdentifier()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public UniquePtr<Identifier> id;
                public Identifier* fromIdentifier;
            }
        }

        public class SwitchStatementRule : System.Text.Parsing.RuleParser
        {
            public SwitchStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("SwitchStatement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<SwitchStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* caseStatementNonterminalParser = GetNonterminal(ToUtf32("CaseStatement"));
                caseStatementNonterminalParser->SetPre(PreCaseStatement);
                caseStatementNonterminalParser->SetPost(PostCaseStatement);
                NonterminalParser* defaultStatementNonterminalParser = GetNonterminal(ToUtf32("DefaultStatement"));
                defaultStatementNonterminalParser->SetPre(PreDefaultStatement);
                defaultStatementNonterminalParser->SetPost(PostDefaultStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new SwitchStatement(context->fromExpression);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddCase(context->fromCaseStatement);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->SetDefault(context->fromDefaultStatement);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreCaseStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCaseStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCaseStatement_value = stack.Pop();
                    context->fromCaseStatement = *cast<ValueObject<CaseStatement*>*>(fromCaseStatement_value.Get());
                }
            }
            public void PreDefaultStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostDefaultStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDefaultStatement_value = stack.Pop();
                    context->fromDefaultStatement = *cast<ValueObject<DefaultStatement*>*>(fromDefaultStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression(), fromCaseStatement(), fromDefaultStatement()
                {
                }
                public ParsingContext* ctx;
                public SwitchStatement* value;
                public DomObject* fromExpression;
                public CaseStatement* fromCaseStatement;
                public DefaultStatement* fromDefaultStatement;
            }
        }

        public class CaseStatementRule : System.Text.Parsing.RuleParser
        {
            public CaseStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("CaseStatement*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<CaseStatement>"), ToUtf32("caseS")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<CaseStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->caseS.Release();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->caseS.Reset(new CaseStatement());
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->caseS->AddCaseExpr(context->fromExpression);
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->caseS->AddStatement(context->fromStatement);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), caseS(), fromExpression(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public CaseStatement* value;
                public UniquePtr<CaseStatement> caseS;
                public DomObject* fromExpression;
                public Statement* fromStatement;
            }
        }

        public class DefaultStatementRule : System.Text.Parsing.RuleParser
        {
            public DefaultStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("DefaultStatement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DefaultStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* statementNonterminalParser = GetNonterminal(ToUtf32("Statement"));
                statementNonterminalParser->SetPre(PreStatement);
                statementNonterminalParser->SetPost(PostStatement);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DefaultStatement();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddStatement(context->fromStatement);
            }
            public void PreStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostStatement(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromStatement_value = stack.Pop();
                    context->fromStatement = *cast<ValueObject<Statement*>*>(fromStatement_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromStatement()
                {
                }
                public ParsingContext* ctx;
                public DefaultStatement* value;
                public Statement* fromStatement;
            }
        }

        public class GotoCaseStatementRule : System.Text.Parsing.RuleParser
        {
            public GotoCaseStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new GotoCaseStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public class GotoDefaultStatementRule : System.Text.Parsing.RuleParser
        {
            public GotoDefaultStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new GotoDefaultStatement();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
            }
        }

        public class AssignmentStatementExprRule : System.Text.Parsing.RuleParser
        {
            public AssignmentStatementExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<DomObject>"), ToUtf32("targetExpr")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                a2ActionParser->SetFailure(A2ActionFail);
                NonterminalParser* targetNonterminalParser = GetNonterminal(ToUtf32("target"));
                targetNonterminalParser->SetPre(Pretarget);
                targetNonterminalParser->SetPost(Posttarget);
                NonterminalParser* sourceNonterminalParser = GetNonterminal(ToUtf32("source"));
                sourceNonterminalParser->SetPre(Presource);
                sourceNonterminalParser->SetPost(Postsource);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AssignmentStatement(context->targetExpr.Release(), context->fromsource);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PushParsingLvalue(true);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PopParsingLvalue();
                context->targetExpr.Reset(context->fromtarget);
            }
            public void A2ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PopParsingLvalue();
            }
            public void Pretarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Posttarget(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtarget_value = stack.Pop();
                    context->fromtarget = *cast<ValueObject<DomObject*>*>(fromtarget_value.Get());
                }
            }
            public void Presource(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void Postsource(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsource_value = stack.Pop();
                    context->fromsource = *cast<ValueObject<DomObject*>*>(fromsource_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), targetExpr(), fromtarget(), fromsource()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public UniquePtr<DomObject> targetExpr;
                public DomObject* fromtarget;
                public DomObject* fromsource;
            }
        }

        public class AssignmentStatementRule : System.Text.Parsing.RuleParser
        {
            public AssignmentStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* assignmentStatementExprNonterminalParser = GetNonterminal(ToUtf32("AssignmentStatementExpr"));
                assignmentStatementExprNonterminalParser->SetPre(PreAssignmentStatementExpr);
                assignmentStatementExprNonterminalParser->SetPost(PostAssignmentStatementExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAssignmentStatementExpr;
            }
            public void PreAssignmentStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostAssignmentStatementExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAssignmentStatementExpr_value = stack.Pop();
                    context->fromAssignmentStatementExpr = *cast<ValueObject<Statement*>*>(fromAssignmentStatementExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromAssignmentStatementExpr()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public Statement* fromAssignmentStatementExpr;
            }
        }

        public class ConstructionStatementRule : System.Text.Parsing.RuleParser
        {
            public ConstructionStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("ConstructionStatement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ConstructionStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
                NonterminalParser* argumentListNonterminalParser = GetNonterminal(ToUtf32("ArgumentList"));
                argumentListNonterminalParser->SetPre(PreArgumentList);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ConstructionStatement(context->fromTypeExpr, context->fromIdentifier);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddArgument(context->fromExpression);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->SetParens();
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<DomObject*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<Identifier*>*>(fromIdentifier_value.Get());
                }
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public void PreArgumentList(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
                stack.Push(UniquePtr<Object>(new ValueObject<DomObject*>(context->value)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromIdentifier(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public ConstructionStatement* value;
                public DomObject* fromTypeExpr;
                public Identifier* fromIdentifier;
                public DomObject* fromExpression;
            }
        }

        public class DeleteStatementRule : System.Text.Parsing.RuleParser
        {
            public DeleteStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DeleteStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public class DestroyStatementRule : System.Text.Parsing.RuleParser
        {
            public DestroyStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new DestroyStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public class ExpressionStatementRule : System.Text.Parsing.RuleParser
        {
            public ExpressionStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<DomObject>"), ToUtf32("expr")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                a0ActionParser->SetFailure(A0ActionFail);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PopParsingExpressionStatement();
                context->value = new ExpressionStatement(context->expr.Release());
            }
            public void A0ActionFail(ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PopParsingExpressionStatement();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->ctx->PushParsingExpressionStatement(true);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->expr.Reset(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), expr(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public UniquePtr<DomObject> expr;
                public DomObject* fromExpression;
            }
        }

        public class EmptyStatementRule : System.Text.Parsing.RuleParser
        {
            public EmptyStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new EmptyStatement();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
            }
        }

        public class ThrowStatementRule : System.Text.Parsing.RuleParser
        {
            public ThrowStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new ThrowStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public class TryStatementRule : System.Text.Parsing.RuleParser
        {
            public TryStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("TryStatement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<TryStatement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* tryBlockNonterminalParser = GetNonterminal(ToUtf32("tryBlock"));
                tryBlockNonterminalParser->SetPre(PretryBlock);
                tryBlockNonterminalParser->SetPost(PosttryBlock);
                NonterminalParser* catchNonterminalParser = GetNonterminal(ToUtf32("Catch"));
                catchNonterminalParser->SetPre(PreCatch);
                catchNonterminalParser->SetPost(PostCatch);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new TryStatement(context->fromtryBlock);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddCatch(context->fromCatch);
            }
            public void PretryBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PosttryBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtryBlock_value = stack.Pop();
                    context->fromtryBlock = *cast<ValueObject<CompoundStatement*>*>(fromtryBlock_value.Get());
                }
            }
            public void PreCatch(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostCatch(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCatch_value = stack.Pop();
                    context->fromCatch = *cast<ValueObject<Catch*>*>(fromCatch_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromtryBlock(), fromCatch()
                {
                }
                public ParsingContext* ctx;
                public TryStatement* value;
                public CompoundStatement* fromtryBlock;
                public Catch* fromCatch;
            }
        }

        public class CatchRule : System.Text.Parsing.RuleParser
        {
            public CatchRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Catch*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Catch*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* typeExprNonterminalParser = GetNonterminal(ToUtf32("TypeExpr"));
                typeExprNonterminalParser->SetPre(PreTypeExpr);
                typeExprNonterminalParser->SetPost(PostTypeExpr);
                NonterminalParser* identifierNonterminalParser = GetNonterminal(ToUtf32("Identifier"));
                identifierNonterminalParser->SetPost(PostIdentifier);
                NonterminalParser* catchBlockNonterminalParser = GetNonterminal(ToUtf32("catchBlock"));
                catchBlockNonterminalParser->SetPre(PrecatchBlock);
                catchBlockNonterminalParser->SetPost(PostcatchBlock);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new Catch(context->fromTypeExpr, context->fromIdentifier, context->fromcatchBlock);
            }
            public void PreTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostTypeExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromTypeExpr_value = stack.Pop();
                    context->fromTypeExpr = *cast<ValueObject<DomObject*>*>(fromTypeExpr_value.Get());
                }
            }
            public void PostIdentifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromIdentifier_value = stack.Pop();
                    context->fromIdentifier = *cast<ValueObject<Identifier*>*>(fromIdentifier_value.Get());
                }
            }
            public void PrecatchBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostcatchBlock(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromcatchBlock_value = stack.Pop();
                    context->fromcatchBlock = *cast<ValueObject<CompoundStatement*>*>(fromcatchBlock_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromTypeExpr(), fromIdentifier(), fromcatchBlock()
                {
                }
                public ParsingContext* ctx;
                public Catch* value;
                public DomObject* fromTypeExpr;
                public Identifier* fromIdentifier;
                public CompoundStatement* fromcatchBlock;
            }
        }

        public class AssertStatementRule : System.Text.Parsing.RuleParser
        {
            public AssertStatementRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ParsingContext*"), ToUtf32("ctx")));
                SetValueTypeName(ToUtf32("Statement*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> ctx_value = stack.Pop();
                context->ctx = *cast<ValueObject<ParsingContext*>*>(ctx_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Statement*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* expressionNonterminalParser = GetNonterminal(ToUtf32("Expression"));
                expressionNonterminalParser->SetPre(PreExpression);
                expressionNonterminalParser->SetPost(PostExpression);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new AssertStatement(context->fromExpression);
            }
            public void PreExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ParsingContext*>(context->ctx)));
            }
            public void PostExpression(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpression_value = stack.Pop();
                    context->fromExpression = *cast<ValueObject<DomObject*>*>(fromExpression_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : ctx(), value(), fromExpression()
                {
                }
                public ParsingContext* ctx;
                public Statement* value;
                public DomObject* fromExpression;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("Code.KeywordGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new Code.KeywordGrammar(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("Code.IdentifierGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new Code.IdentifierGrammar(pd);
            }
            AddGrammarReference(grammar1);
            Grammar* grammar2 = pd->GetGrammar(ToUtf32("Code.TypeExprGrammar"));
            if (grammar2 == null)
            {
                grammar2 = new Code.TypeExprGrammar(pd);
            }
            AddGrammarReference(grammar2);
            Grammar* grammar3 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar3 == null)
            {
                grammar3 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar3);
            Grammar* grammar4 = pd->GetGrammar(ToUtf32("Code.ExpressionGrammar"));
            if (grammar4 == null)
            {
                grammar4 = new Code.ExpressionGrammar(pd);
            }
            AddGrammarReference(grammar4);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("identifier"), this, ToUtf32("System.Text.Parsing.stdlib.identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Keyword"), this, ToUtf32("KeywordGrammar.Keyword")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Expression"), this, ToUtf32("ExpressionGrammar.Expression")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("ArgumentList"), this, ToUtf32("ExpressionGrammar.ArgumentList")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("TypeExpr"), this, ToUtf32("TypeExprGrammar.TypeExpr")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("Identifier"), this, ToUtf32("IdentifierGrammar.Identifier")));
            AddRule(new StatementRule(ToUtf32("Statement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("LabeledStatement"), ToUtf32("LabeledStatement"), 1)),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("ControlStatement"), ToUtf32("ControlStatement"), 1))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ExpressionStatement"), ToUtf32("ExpressionStatement"), 1))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentStatement"), ToUtf32("AssignmentStatement"), 1))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ConstructionStatement"), ToUtf32("ConstructionStatement"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("DeleteStatement"), ToUtf32("DeleteStatement"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("DestroyStatement"), ToUtf32("DestroyStatement"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("EmptyStatement"), ToUtf32("EmptyStatement"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("ThrowStatement"), ToUtf32("ThrowStatement"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TryStatement"), ToUtf32("TryStatement"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AssertStatement"), ToUtf32("AssertStatement"), 1)))));
            AddRule(new LabelIdRule(ToUtf32("LabelId"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.DifferenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("identifier"), ToUtf32("identifier"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Keyword"), ToUtf32("Keyword"), 0))))));
            AddRule(new LabeledStatementRule(ToUtf32("LabeledStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("lbl"), ToUtf32("LabelId"), 0),
                        new System.Text.Parsing.CharParser(':')),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("stmt"), ToUtf32("Statement"), 1)))));
            AddRule(new ControlStatementRule(ToUtf32("ControlStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.AlternativeParser(
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CompoundStatement"), ToUtf32("CompoundStatement"), 1)),
                                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ReturnStatement"), ToUtf32("ReturnStatement"), 1))),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                                new System.Text.Parsing.NonterminalParser(ToUtf32("IfStatement"), ToUtf32("IfStatement"), 1))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                            new System.Text.Parsing.NonterminalParser(ToUtf32("WhileStatement"), ToUtf32("WhileStatement"), 1))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                        new System.Text.Parsing.NonterminalParser(ToUtf32("DoStatement"), ToUtf32("DoStatement"), 1))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("RangeForStatement"), ToUtf32("RangeForStatement"), 1))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ForStatement"), ToUtf32("ForStatement"), 1))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("BreakStatement"), ToUtf32("BreakStatement"), 1))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ContinueStatement"), ToUtf32("ContinueStatement"), 1))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("GotoStatement"), ToUtf32("GotoStatement"), 1))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SwitchStatement"), ToUtf32("SwitchStatement"), 1))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("GotoCaseStatement"), ToUtf32("GotoCaseStatement"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A12"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("GotoDefaultStatement"), ToUtf32("GotoDefaultStatement"), 1)))));
            AddRule(new CompoundStatementRule(ToUtf32("CompoundStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.CharParser('{')),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("stmt"), ToUtf32("Statement"), 1)))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new ReturnStatementRule(ToUtf32("ReturnStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("return")),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new IfStatementRule(ToUtf32("IfStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("if")),
                                        new System.Text.Parsing.CharParser('(')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)),
                                new System.Text.Parsing.CharParser(')')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("thenS"), ToUtf32("Statement"), 1)),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("else")),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("elseS"), ToUtf32("Statement"), 1)))))));
            AddRule(new WhileStatementRule(ToUtf32("WhileStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.KeywordParser(ToUtf32("while")),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser('('))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')'))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))))));
            AddRule(new DoStatementRule(ToUtf32("DoStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("do")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("while")))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser('('))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')'))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new ForStatementRule(ToUtf32("ForStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("for")),
                                                new System.Text.Parsing.CharParser('(')),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ForInitStatement"), ToUtf32("ForInitStatement"), 1))),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(';'))),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("ForLoopStatementExpr"), ToUtf32("ForLoopStatementExpr"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')'))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))))));
            AddRule(new ForInitStatementRule(ToUtf32("ForInitStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentStatement"), ToUtf32("AssignmentStatement"), 1)),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("ConstructionStatement"), ToUtf32("ConstructionStatement"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("EmptyStatement"), ToUtf32("EmptyStatement"), 1)))));
            AddRule(new ForLoopStatementExprRule(ToUtf32("ForLoopStatementExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentStatementExpr"), ToUtf32("AssignmentStatementExpr"), 1)),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.EmptyParser()))));
            AddRule(new RangeForStatementRule(ToUtf32("RangeForStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.KeywordParser(ToUtf32("for")),
                                                new System.Text.Parsing.CharParser('(')),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1)),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)),
                                    new System.Text.Parsing.CharParser(':')),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')'))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))))));
            AddRule(new BreakStatementRule(ToUtf32("BreakStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("break")),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new ContinueStatementRule(ToUtf32("ContinueStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("continue")),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new GotoStatementRule(ToUtf32("GotoStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("goto")),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new SwitchStatementRule(ToUtf32("SwitchStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("switch")),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.CharParser('('))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(')')))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser('{'))),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CaseStatement"), ToUtf32("CaseStatement"), 1)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("DefaultStatement"), ToUtf32("DefaultStatement"), 1))))),
                    new System.Text.Parsing.ExpectationParser(
                        new System.Text.Parsing.CharParser('}')))));
            AddRule(new CaseStatementRule(ToUtf32("CaseStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.EmptyParser()),
                            new System.Text.Parsing.PositiveParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("case")),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.CharParser(':'))))),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1)))))));
            AddRule(new DefaultStatementRule(ToUtf32("DefaultStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("default")),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(':')))),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Statement"), ToUtf32("Statement"), 1))))));
            AddRule(new GotoCaseStatementRule(ToUtf32("GotoCaseStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("goto")),
                                new System.Text.Parsing.KeywordParser(ToUtf32("case"))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new GotoDefaultStatementRule(ToUtf32("GotoDefaultStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("goto")),
                            new System.Text.Parsing.KeywordParser(ToUtf32("default"))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new AssignmentStatementExprRule(ToUtf32("AssignmentStatementExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.EmptyParser()),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("target"), ToUtf32("Expression"), 1))),
                            new System.Text.Parsing.CharParser('=')),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("source"), ToUtf32("Expression"), 1)))));
            AddRule(new AssignmentStatementRule(ToUtf32("AssignmentStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AssignmentStatementExpr"), ToUtf32("AssignmentStatementExpr"), 1),
                        new System.Text.Parsing.CharParser(';')))));
            AddRule(new ConstructionStatementRule(ToUtf32("ConstructionStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1),
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.ExpectationParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0)))),
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('='),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1)))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('('),
                                            new System.Text.Parsing.ExpectationParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("ArgumentList"), ToUtf32("ArgumentList"), 2))),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser(')'))))),
                            new System.Text.Parsing.EmptyParser())),
                    new System.Text.Parsing.CharParser(';'))));
            AddRule(new DeleteStatementRule(ToUtf32("DeleteStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("delete")),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new DestroyStatementRule(ToUtf32("DestroyStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("destroy")),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new ExpressionStatementRule(ToUtf32("ExpressionStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.EmptyParser()),
                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.CharParser(';')))));
            AddRule(new EmptyStatementRule(ToUtf32("EmptyStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.CharParser(';'))));
            AddRule(new ThrowStatementRule(ToUtf32("ThrowStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.KeywordParser(ToUtf32("throw")),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
            AddRule(new TryStatementRule(ToUtf32("TryStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.KeywordParser(ToUtf32("try")),
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("tryBlock"), ToUtf32("CompoundStatement"), 1))),
                    new System.Text.Parsing.PositiveParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Catch"), ToUtf32("Catch"), 1))))));
            AddRule(new CatchRule(ToUtf32("Catch"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.KeywordParser(ToUtf32("catch")),
                                        new System.Text.Parsing.ExpectationParser(
                                            new System.Text.Parsing.CharParser('('))),
                                    new System.Text.Parsing.ExpectationParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("TypeExpr"), ToUtf32("TypeExpr"), 1))),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Identifier"), ToUtf32("Identifier"), 0))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.CharParser(')'))),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("catchBlock"), ToUtf32("CompoundStatement"), 1)))));
            AddRule(new AssertStatementRule(ToUtf32("AssertStatement"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('#'),
                                new System.Text.Parsing.KeywordParser(ToUtf32("assert"))),
                            new System.Text.Parsing.ExpectationParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Expression"), ToUtf32("Expression"), 1))),
                        new System.Text.Parsing.ExpectationParser(
                            new System.Text.Parsing.CharParser(';'))))));
        }
    }
} // Code

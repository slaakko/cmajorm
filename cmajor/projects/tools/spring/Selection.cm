// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.IO;
using System.Collections;
using System.Text;

namespace spring
{
    public abstract class Selection
    {
        public nothrow Selection(Diagram& diagram_) : diagram(diagram_)
        {
        }
        public default virtual ~Selection();
        public abstract nothrow bool IsEmpty() const;
        public abstract nothrow int Count() const;
        public abstract nothrow bool Contains(const System.Windows.PointF& location) const;
        public abstract nothrow int GetContainerElementCount() const;
        public abstract nothrow List<int> GetContainerElementIndeces() const;
        public abstract nothrow void Clear();
        public abstract nothrow void Delete();
        public abstract nothrow ustring Copy();
        public abstract nothrow int GetFirstIndex() const;
        public abstract nothrow void Add(int index);
        public abstract nothrow void Remove(int index);
        public abstract nothrow void AddActions(System.Windows.ContextMenu* contextMenu);
        public nothrow inline Diagram& GetDiagram() const
        {
            return diagram;
        }
        private Diagram& diagram;
    }

    public class EmptySelection : Selection
    {
        public nothrow EmptySelection(Diagram& diagram) : base(diagram)
        {
        }
        public override nothrow bool IsEmpty() const
        {
            return true;
        }
        public override nothrow int Count() const
        {
            return 0;
        }
        public override nothrow bool Contains(const System.Windows.PointF& location) const
        {
            return false;
        }
        public override nothrow int GetContainerElementCount() const
        {
            return 0;
        }
        public override nothrow List<int> GetContainerElementIndeces() const
        {
            return List<int>();
        }
        public override nothrow void Clear()
        {
        }
        public override nothrow void Delete()
        {
        }
        public override nothrow ustring Copy()
        {
            return ustring();
        }
        public override nothrow int GetFirstIndex() const
        {
            return -1;
        }
        public override nothrow void Add(int elementIndex)
        {
        }
        public override nothrow void Remove(int elementIndex)
        {
        }
        public override nothrow void AddActions(System.Windows.ContextMenu* contextMenu)
        {
        }
    }

    public class ElementSelection : Selection
    {
        public nothrow ElementSelection(Diagram& diagram) : base(diagram)
        {
        }
        public nothrow ElementSelection(Diagram& diagram, int index) : base(diagram)
        {
            indeces.Add(index);
            diagram.GetElementByIndex(index)->Select();
            diagram.EnableCopy();
            diagram.EnableCut();
        }
        public nothrow ElementSelection(Diagram& diagram, List<int>&& indeces_) : base(diagram), indeces(indeces_)
        {
        }
        public override nothrow bool IsEmpty() const
        {
            return indeces.IsEmpty();
        }
        public override nothrow int Count() const
        {
            return cast<int>(indeces.Count());
        }
        public override nothrow bool Contains(const System.Windows.PointF& location) const
        {
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                int index = indeces[i];
                DiagramElement* element = GetDiagram().GetElementByIndex(index);
                if (element->Contains(location))
                {
                    return true;
                }
            }
            return false;
        }
        public override nothrow int GetContainerElementCount() const
        {
            int count = 0;
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                int index = indeces[i];
                DiagramElement* element = GetDiagram().GetElementByIndex(index);
                if (element is ContainerElement*)
                {
                    ++count;
                }
            }
            return count;
        }
        public override nothrow List<int> GetContainerElementIndeces() const
        {
            List<int> containerElementIndeces;
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                int index = indeces[i];
                DiagramElement* element = GetDiagram().GetElementByIndex(index);
                if (element is ContainerElement*)
                {
                    containerElementIndeces.Add(index);
                }
            }
            return containerElementIndeces;
        }
        public override nothrow void Clear()
        {
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                int index = indeces[i];
                GetDiagram().GetElementByIndex(index)->ResetSelected();
            }
            indeces.Clear();
        }
        public override nothrow void Delete()
        {
            List<RelationshipElement*> relationships;
            SortByIndex();
            int n = cast<int>(indeces.Count());
            for (int i = n - 1; i >= 0; --i)
            {
                int index = indeces[i];
                UniquePtr<DiagramElement> element = GetDiagram().RemoveElementByIndex(index);
                if (element.Get() is ContainerElement*)
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element.Get());
                    for (RelationshipElement* relationship : containerElement->Relationships())
                    {
                        relationships.Add(relationship);
                    }
                }
            }
            indeces.Clear();
            List<int> relationshipIndeces;
            for (RelationshipElement* relationship : relationships)
            {
                int index = GetDiagram().GetIndexOfElement(relationship);
                if (index != -1)
                {
                    relationshipIndeces.Add(index);
                }
            }
            Sort(relationshipIndeces);
            int m = cast<int>(relationshipIndeces.Count());
            for (int i = m - 1; i >= 0; --i)
            {
                int index = relationshipIndeces[i];
                UniquePtr<DiagramElement> element = GetDiagram().RemoveElementByIndex(index);
            }
        }
        public List<UniquePtr<DiagramElement>> Clone() const
        {
            List<UniquePtr<DiagramElement>> clonedElements;
            List<ContainerElement*> containerElements;
            List<RelationshipElement*> relationshipElements;
            System.Windows.RectF boundingRect;
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                int index = indeces[i];
                DiagramElement* element = GetDiagram().GetElementByIndex(index);
                if (element is ContainerElement*)
                {
                    if (boundingRect.IsEmpty())
                    {
                        boundingRect = element->BoundingRect();
                    }
                    else
                    {
                        boundingRect = System.Windows.RectF.Union(boundingRect, element->BoundingRect());
                    }
                    containerElements.Add(cast<ContainerElement*>(element));
                }
            }
            for (ContainerElement* containerElement : containerElements)
            {
                for (RelationshipElement* relationship : containerElement->Relationships())
                {
                    bool sourceInClosure = false;
                    if (relationship->source.element != null)
                    {
                        ContainerElement* sourceContainerElement = relationship->source.element->GetContainerElement();
                        if (Find(containerElements.CBegin(), containerElements.CEnd(), sourceContainerElement) != containerElements.CEnd())
                        {
                            sourceInClosure = true;
                        }
                    }
                    bool targetInClosure = false;
                    if (relationship->target.element != null)
                    {
                        ContainerElement* targetContainerElement = relationship->target.element->GetContainerElement();
                        if (Find(containerElements.CBegin(), containerElements.CEnd(), targetContainerElement) != containerElements.CEnd())
                        {
                            targetInClosure = true;
                        }
                    }
                    if (sourceInClosure && targetInClosure)
                    {
                        if (boundingRect.IsEmpty())
                        {
                            boundingRect = relationship->BoundingRect();
                        }
                        else
                        {
                            boundingRect = System.Windows.RectF.Union(boundingRect, relationship->BoundingRect());
                        }
                        relationshipElements.Add(relationship);
                    }
                }
            }
            for (ContainerElement* containerElement : containerElements)
            {
                clonedElements.Add(UniquePtr<DiagramElement>(containerElement->Clone()));
            }
            for (RelationshipElement* relationshipElement : relationshipElements)
            {
                clonedElements.Add(UniquePtr<DiagramElement>(relationshipElement->Clone()));
            }
            for (UniquePtr<DiagramElement>& clonedElement : clonedElements)
            {
                CompoundLocation location = clonedElement->GetCompoundLocation();
                location.Offset(-boundingRect.location.x, -boundingRect.location.y);
                clonedElement->SetCompoundLocation(location);
            }
            return clonedElements;
        }
        public override nothrow ustring Copy()
        {
            List<UniquePtr<DiagramElement>> clonedElements = Clone();
            System.Dom.Document elementDoc;
            elementDoc.AppendChild(UniquePtr<System.Dom.Node>(new System.Dom.Element(u"spring.diagram.elements")));
            for (const UniquePtr<DiagramElement>& clonedElement : clonedElements)
            {
                UniquePtr<System.Dom.Element> domElement = clonedElement->CreateDomElement();
                clonedElement->Write(domElement.Get());
                elementDoc.DocumentElement()->AppendChild(UniquePtr<System.Dom.Node>(domElement.Release()));
            }
            StringWriter writer;
            CodeFormatter formatter(writer);
            elementDoc.Write(formatter);
            return ToUtf32(writer.GetString());
        }
        public override nothrow int GetFirstIndex() const
        {
            return indeces.Front();
        }
        public override nothrow void Add(int index)
        {
            int n = cast<int>(indeces.Count());
            for (int i = 0; i < n; ++i)
            {
                if (indeces[i] == index) return;
            }
            indeces.Add(index);
            GetDiagram().GetElementByIndex(index)->Select();
            if (!indeces.IsEmpty())
            {
                GetDiagram().EnableCopy();
                GetDiagram().EnableCut();
            }
        }
        public override nothrow void Remove(int index)
        {
            indeces.Remove(index);
            GetDiagram().GetElementByIndex(index)->ResetSelected();
            if (indeces.IsEmpty())
            {
                GetDiagram().DisableCopy();
                GetDiagram().DisableCut();
            }
        }
        public override nothrow void AddActions(System.Windows.ContextMenu* contextMenu)
        {
            int containerElementCount = GetContainerElementCount();
            if (containerElementCount > 1)
            {
                System.Windows.MenuItem* alignTopMenuItem = new System.Windows.MenuItem("Align top");
                contextMenu->AddMenuItemAction(alignTopMenuItem, new AlignTopAction(GetDiagram()));
                System.Windows.MenuItem* alignBottomMenuItem = new System.Windows.MenuItem("Align bottom");
                contextMenu->AddMenuItemAction(alignBottomMenuItem, new AlignBottomAction(GetDiagram()));
                System.Windows.MenuItem* alignVerticalCenterMenuItem = new System.Windows.MenuItem("Align vertical center");
                contextMenu->AddMenuItemAction(alignVerticalCenterMenuItem, new AlignVerticalCenterAction(GetDiagram()));
                System.Windows.MenuItem* alignLeftSideMenuItem = new System.Windows.MenuItem("Align left side");
                contextMenu->AddMenuItemAction(alignLeftSideMenuItem, new AlignLeftSideAction(GetDiagram()));
                System.Windows.MenuItem* alignRightSideMenuItem = new System.Windows.MenuItem("Align right side");
                contextMenu->AddMenuItemAction(alignRightSideMenuItem, new AlignRightSideAction(GetDiagram()));
                System.Windows.MenuItem* alignHorizontalCenterMenuItem = new System.Windows.MenuItem("Align horizontal center");
                contextMenu->AddMenuItemAction(alignHorizontalCenterMenuItem, new AlignHorizontalCenterAction(GetDiagram()));
                if (containerElementCount > 2)
                {
                    System.Windows.MenuItem* spaceEvenlyVerticallyMenuItem = new System.Windows.MenuItem("Space evenly vertically");
                    contextMenu->AddMenuItemAction(spaceEvenlyVerticallyMenuItem, new SpaceEvenlyVerticallyAction(GetDiagram()));
                    System.Windows.MenuItem* spaceEvenlyHorizontallyMenuItem = new System.Windows.MenuItem("Space evenly horizontally");
                    contextMenu->AddMenuItemAction(spaceEvenlyHorizontallyMenuItem, new SpaceEvenlyHorizontallyAction(GetDiagram()));
                }
            }
            System.Windows.MenuItem* deleteMenuItem = new System.Windows.MenuItem("Delete");
            contextMenu->AddMenuItemAction(deleteMenuItem, new DeleteSelectionAction(GetDiagram()));
        }
        public nothrow void SortByIndex()
        {
            Sort(indeces);
        }
        public nothrow void SortHorizontally()
        {
            Sort(indeces, HorizontallyLess(&GetDiagram()));
        }
        public nothrow void SortVertically()
        {
            Sort(indeces, VerticallyLess(&GetDiagram()));
        }
        public nothrow void AlignTop()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float top = firstElement->Location().y;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    element->SetLocation(System.Windows.PointF(element->Location().x, top));
                }
            }
        }
        public nothrow void AlignBottom()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float bottom = firstElement->Location().y + firstElement->GetSize().h;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float elementBottom = element->Location().y + element->GetSize().h;
                    float dy = elementBottom - bottom;
                    float top = element->Location().y - dy;
                    element->SetLocation(System.Windows.PointF(element->Location().x, top));
                }
            }
        }
        public nothrow void AlignVerticalCenter()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float center = firstElement->Location().y + firstElement->GetSize().h / 2.0f;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float elementCenter = element->Location().y + element->GetSize().h / 2;
                    float dy = elementCenter - center;
                    float top = element->Location().y - dy;
                    element->SetLocation(System.Windows.PointF(element->Location().x, top));
                }
            }
        }
        public nothrow void AlignLeftSide()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float leftSide = firstElement->Location().x;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    element->SetLocation(System.Windows.PointF(leftSide, element->Location().y));
                }
            }
        }
        public nothrow void AlignRightSide()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float rightSide = firstElement->Location().x + firstElement->GetSize().w;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float elementRightSide = element->Location().x + element->GetSize().w;
                    float dx = elementRightSide - rightSide;
                    float leftSide = element->Location().x - dx;
                    element->SetLocation(System.Windows.PointF(leftSide, element->Location().y));
                }
            }
        }
        public nothrow void AlignHorizontalCenter()
        {
            if (!indeces.IsEmpty())
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                float center = firstElement->Location().x + firstElement->GetSize().w / 2.0f;
                int n = cast<int>(indeces.Count());
                for (int i = 1; i < n; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float elementCenter = element->Location().x + element->GetSize().w / 2.0f;
                    float dx = elementCenter - center;
                    float leftSide = element->Location().x - dx;
                    element->SetLocation(System.Windows.PointF(leftSide, element->Location().y));
                }
            }
        }
        public nothrow void SpaceEvenlyVertically()
        {
            if (indeces.Count() > 2)
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                DiagramElement* lastElement = GetDiagram().GetElementByIndex(indeces.Back());
                float firstElementBottom = firstElement->Location().y + firstElement->GetSize().h;
                float lastElementTop = lastElement->Location().y;
                int n = cast<int>(indeces.Count());
                float space = lastElementTop - firstElementBottom;
                for (int i = 1; i < n - 1; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    space = space - element->GetSize().h;
                }
                space = space / (n - 1);
                float prevElementBottom = firstElementBottom;
                for (int i = 1; i < n - 1; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float top = prevElementBottom + space;
                    element->SetLocation(System.Windows.PointF(element->Location().x, top));
                    prevElementBottom = top + element->GetSize().h;
                }
            }
        }
        public nothrow void SpaceEvenlyHorizontally()
        {
            if (indeces.Count() > 2)
            {
                DiagramElement* firstElement = GetDiagram().GetElementByIndex(indeces.Front());
                DiagramElement* lastElement = GetDiagram().GetElementByIndex(indeces.Back());
                float firstElementRightSide = firstElement->Location().x + firstElement->GetSize().w;
                float lastElementLeftSide = lastElement->Location().x;
                int n = cast<int>(indeces.Count());
                float space = lastElementLeftSide - firstElementRightSide;
                for (int i = 1; i < n - 1; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    space = space - element->GetSize().w;
                }
                space = space / (n - 1);
                float prevElementRightSide = firstElementRightSide;
                for (int i = 1; i < n - 1; ++i)
                {
                    DiagramElement* element = GetDiagram().GetElementByIndex(indeces[i]);
                    float left = prevElementRightSide + space;
                    element->SetLocation(System.Windows.PointF(left, element->Location().y));
                    prevElementRightSide = left + element->GetSize().w;
                }
            }
        }
        private List<int> indeces;
    }
}


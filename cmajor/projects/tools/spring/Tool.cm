// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows;

namespace spring
{
    public static class Tools
    {
        static nothrow Tools() : currentTool(&selectTool)
        {
        }
        public static nothrow void SetDiagram(Diagram* diagram_)
        {
            diagram = diagram_;
        }
        public static nothrow Diagram* GetDiagram()
        {
            return diagram;
        }
        public static nothrow inline Tool* Current()
        {
            return currentTool;
        }
        public static nothrow void SetCurrent(Tool* tool)
        {
            if (tool != currentTool)
            {
                currentTool = tool;
                currentTool->GetToolButton()->SetState(ToolButton.State.pressed);
                currentTool->Initialize(*diagram);
            }
        }
        internal static nothrow void SetCurrentInternal(Tool* tool)
        {
            currentTool = tool;
        }
        public static nothrow Tool* GetSelectTool()
        {
            return &selectTool;
        }
        public static nothrow Tool* GetClassTool()
        {
            return &classTool;
        }
        public static nothrow Tool* GetObjectTool()
        {
            return &objectTool;
        }
        public static nothrow Tool* GetInheritanceTool()
        {
            return &inheritanceTool;
        }
        public static nothrow Tool* GetAggregationTool()
        {
            return &aggregationTool;
        }
        public static nothrow Tool* GetCreateInstanceTool()
        {
            return &createInstanceTool;
        }
        public static nothrow Tool* GetNoteTool()
        {
            return &noteTool;
        }
        public static nothrow Tool* GetReferenceTool()
        {
            return &referenceTool;
        }
        private static SelectTool selectTool;
        private static ClassTool classTool;
        private static ObjectTool objectTool;
        private static InheritanceTool inheritanceTool;
        private static AggregationTool aggregationTool;
        private static CreateInstanceTool createInstanceTool;
        private static NoteTool noteTool;
        private static ReferenceTool referenceTool;
        private static Tool* currentTool;
        private static Diagram* diagram;
    }

    public class MouseArgs
    {
        public nothrow MouseArgs()
        {
        }
        public nothrow MouseArgs(Diagram* diagram_, const PointF& location_, int elementIndex_, DiagramElement* element_, bool shift_, bool control_, bool left_, bool right_) :
            time(Now()), diagram(diagram_), location(location_), elementIndex(elementIndex_), element(element_), shift(shift_), control(control_), left(left_), right(right_)
        {
        }
        public TimePoint time;
        public Diagram* diagram;
        public PointF location;
        public int elementIndex;
        public DiagramElement* element;
        public bool shift;
        public bool control;
        public bool left;
        public bool right;
    }

    public abstract class Tool
    {
        public default virtual ~Tool();
        public nothrow void SetToolButton(ToolButton* toolButton_)
        {
            toolButton = toolButton_;
            toolButton->ClickEvent().AddHandler(ToolButtonClicked);
        }
        public nothrow inline ToolButton* GetToolButton() const
        {
            return toolButton;
        }
        public nothrow void SetCursor(Cursor* cursor_)
        {
            cursor = cursor_;
        }
        public nothrow inline Cursor* GetCursor() const
        {
            return cursor;
        }
        public nothrow virtual bool CanMove() const
        {
            return false;
        }
        public nothrow virtual bool IsSimpleClickTool() const
        {
            return false;
        }
        public virtual void Initialize(Diagram& diagram)
        {
        }
        public virtual void BeforeLeftClick(MouseArgs& args)
        {
        }
        public virtual void AfterLeftClick(MouseArgs& args)
        {
        }
        public virtual void BeforeRightClick(MouseArgs& args)
        {
        }
        public virtual void AfterRightClick(MouseArgs& args)
        {
        }
        public virtual void MouseClick(MouseArgs& args)
        {
            if (args.left)
            {
                BeforeLeftClick(args);
                if (args.shift)
                {
                    MouseShiftLeftClick(args);
                }
                else if (args.control)
                {
                    MouseControlLeftClick(args);
                }
                else
                {
                    MouseNormalLeftClick(args);
                }
                AfterLeftClick(args);
            }
            else if (args.right)
            {
                BeforeRightClick(args);
                if (args.shift)
                {
                    MouseShiftRightClick(args);
                }
                else if (args.control)
                {
                    MouseControlRightClick(args);
                }
                else
                {
                    MouseNormalRightClick(args);
                }
                AfterRightClick(args);
            }
        }
        public virtual void MouseShiftLeftClick(MouseArgs& args)
        {
        }
        public virtual void MouseControlLeftClick(MouseArgs& args)
        {
        }
        public virtual void MouseNormalLeftClick(MouseArgs& args)
        {
        }
        public virtual void MouseShiftRightClick(MouseArgs& args)
        {
        }
        public virtual void MouseControlRightClick(MouseArgs& args)
        {
        }
        public virtual void MouseNormalRightClick(MouseArgs& args)
        {
        }
        public virtual void MouseDoubleClick(MouseArgs& args)
        {
        }
        public virtual void CreateMoveOperation(MouseArgs& args)
        {
        }
        public virtual void ContinueMoveOperation(MouseArgs& args)
        {
        }
        public virtual void CancelMoveOperation(MouseArgs& args)
        {
        }
        public virtual void CommitMoveOperation(MouseArgs& args)
        {
        }
        private nothrow void ToolButtonClicked()
        {
            Tools.SetCurrentInternal(this);
        }
        private ToolButton* toolButton;
        private Cursor* cursor;
    }

    public class SelectTool : Tool
    {
        public override void Initialize(Diagram& diagram)
        {
            diagram.ResetSelection();
        }
        public nothrow override bool CanMove() const
        {
            return true;
        }
        public override void BeforeLeftClick(MouseArgs& args)
        {
            args.diagram->DisposeContextMenu();
        }
        public override void MouseNormalLeftClick(MouseArgs& args)
        {
            if (args.element != null)
            {
                if (args.diagram->GetSelection()->Count() == 1 && args.diagram->GetSelection()->Contains(args.location))
                {
                    args.diagram->ResetSelection();
                }
                else
                {
                    args.diagram->SetSelection(new ElementSelection(*args.diagram, args.elementIndex));
                }
            }
            else
            {
                args.diagram->ResetSelection();
            }
        }
        public override void MouseControlLeftClick(MouseArgs& args)
        {
            if (args.element != null)
            {
                if (args.element->IsSelected())
                {
                    args.diagram->GetSelection()->Remove(args.elementIndex);
                }
                else
                {
                    args.diagram->GetSelection()->Add(args.elementIndex);
                }
            }
        }
        public override void MouseNormalRightClick(MouseArgs& args)
        {
            UniquePtr<ContextMenu> contextMenu(new ContextMenu());
            if (args.diagram->GetSelection()->Count() <= 1)
            {
                if (args.diagram->GetSelection()->Count() == 1)
                {
                    args.elementIndex = args.diagram->GetSelection()->GetFirstIndex();
                    if (args.elementIndex != -1)
                    {
                        args.element = args.diagram->GetElementByIndex(args.elementIndex);
                    }
                    else
                    {
                        args.element = null;
                    }
                }
                if (args.element != null)
                {
                    if (args.element->Contains(args.location))
                    {
                        args.element->AddActions(*args.diagram, args.elementIndex, contextMenu.Get());
                    }
                    else
                    {
                        args.diagram->DisposeContextMenu();
                    }
                }
                else
                {
                    args.diagram->DisposeContextMenu();
                }
            }
            else
            {
                if (args.diagram->GetSelection()->Contains(args.location))
                {
                    args.diagram->GetSelection()->AddActions(contextMenu.Get());
                }
                else
                {
                    args.diagram->DisposeContextMenu();
                }
            }
            if (contextMenu->HasMenuItems())
            {
                Point loc = args.diagram->GetCanvas()->ToControlLocation(args.location);
                Point screenLoc = args.diagram->GetCanvas()->ClientToScreen(loc);
                Window* window = args.diagram->GetCanvas()->GetWindow();
                window->ShowContextMenu(contextMenu.Release(), screenLoc);
            }
            else
            {
                args.diagram->DisposeContextMenu();
            }
        }
        public override void MouseDoubleClick(MouseArgs& args)
        {
            args.diagram->GetSelection()->Clear();
            if (args.element != null)
            {
                if (args.element is ClassElement*)
                {
                    ClassElementPropertiesAction action(*args.diagram, args.elementIndex);
                    action.Execute();
                }
                else if (args.element is ObjectElement*)
                {
                    ObjectElementPropertiesAction action(*args.diagram, args.elementIndex);
                    action.Execute();
                }
            }
        }
        public override void CreateMoveOperation(MouseArgs& args)
        {
            UniquePtr<MoveContainerElementsOperation> moveOperation(new MoveContainerElementsOperation(args.diagram, args.location));
            if (args.diagram->GetSelection()->Count() <= 1)
            {
                if (args.diagram->GetSelection()->Count() == 1)
                {
                    args.elementIndex = args.diagram->GetSelection()->GetFirstIndex();
                    if (args.elementIndex != -1)
                    {
                        args.element = args.diagram->GetElementByIndex(args.elementIndex);
                    }
                    else
                    {
                        args.element = null;
                    }
                }
                if (args.element != null)
                {
                    if (args.element is ContainerElement*)
                    {
                        if (args.element->Contains(args.location))
                        {
                            moveOperation->AddContainerElementIndex(args.elementIndex);
                        }
                    }
                }
            }
            else
            {
                if (args.diagram->GetSelection()->GetContainerElementCount() > 0)
                {
                    if (args.diagram->GetSelection()->Contains(args.location))
                    {
                        moveOperation->SetContainerElementIndeces(args.diagram->GetSelection()->GetContainerElementIndeces());
                    }
                }
            }
            moveOperation->FetchOriginalLocations();
            if (!moveOperation->IsEmpty())
            {
                args.diagram->SetOperation(moveOperation.Release());
            }
        }
        public override void ContinueMoveOperation(MouseArgs& args)
        {
            args.diagram->AdvanceOperation(args.location);
        }
        public override void CancelMoveOperation(MouseArgs& args)
        {
            args.diagram->CancelOperation();
        }
        public override void CommitMoveOperation(MouseArgs& args)
        {
            args.diagram->CommitOperation(args.location);
        }
    }

    public abstract class SimpleClickTool : Tool
    {
        public nothrow override bool IsSimpleClickTool() const
        {
            return true;
        }
    }

    public class ClassTool : SimpleClickTool
    {
        public override void Initialize(Diagram& diagram)
        {
            diagram.ResetSelection();
        }
        public override void MouseNormalLeftClick(MouseArgs& args)
        {
            args.diagram->ResetSelection();
            UniquePtr<ClassElement> classElement(new ClassElement("Class", false));
            classElement->SetLocation(args.location);
            args.diagram->AddElement(classElement.Release());
            args.diagram->SetChanged();
            args.diagram->Invalidate();
            Tools.SetCurrent(Tools.GetSelectTool());
        }
    }

    public class ObjectTool : SimpleClickTool
    {
        public override void Initialize(Diagram& diagram)
        {
            diagram.ResetSelection();
        }
        public override void MouseNormalLeftClick(MouseArgs& args)
        {
            args.diagram->ResetSelection();
            UniquePtr<ObjectElement> objectElement(new ObjectElement("anObject"));
            objectElement->SetLocation(args.location);
            args.diagram->AddElement(objectElement.Release());
            args.diagram->SetChanged();
            args.diagram->Invalidate();
            Tools.SetCurrent(Tools.GetSelectTool());
        }
    }

    public abstract class RelationshipTool : SimpleClickTool
    {
        public override void Initialize(Diagram& diagram)
        {
            diagram.ResetSelection();
        }
        public nothrow virtual bool Accept(DiagramElement* element)
        {
            return false;
        }
        public abstract nothrow RelationshipElement.Kind GetRelationshipKind() const;
        public override void MouseNormalLeftClick(MouseArgs& args)
        {
            args.diagram->ResetSelection();
            DiagramElement* element = args.element;
            if (element == null) return;
            if (!Accept(element)) return;
            List<Endpoint> endpoints = args.element->GetEndpoints();
            List<Endpoint*> endpointPtrs;
            for (const Endpoint& endpoint : endpoints)
            {
                endpointPtrs.Add(&endpoint);
            }
            Sort(endpointPtrs.Begin(), endpointPtrs.End(), EndpointNearer(args.location));
            Endpoint* nearestEndpoint = endpointPtrs.Front();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                logView->WriteLine(nearestEndpoint->ToString());
            }
            Operation* currentOperation = args.diagram->GetOperation();
            if (currentOperation is EmptyOperation*)
            {
                RelationshipElement.Kind relationshipKind = GetRelationshipKind();
                UniquePtr<RelationshipElement> relationshipElement(new RelationshipElement(relationshipKind));
                relationshipElement->source = *nearestEndpoint;
                UniquePtr<AddRelationshipOperation> operation(new AddRelationshipOperation(args.diagram, relationshipElement.Release()));
                args.diagram->SetOperation(operation.Release());
            }
            else if (currentOperation is AddRelationshipOperation*)
            {
                AddRelationshipOperation* operation = cast<AddRelationshipOperation*>(currentOperation);
                RelationshipElement& relationshipElement = operation->GetRelationshipElement();
                if (relationshipElement.source.element == element)
                {
                    relationshipElement.source = *nearestEndpoint;
                }
                else if (relationshipElement.target.element == null)
                {
                    relationshipElement.target = *nearestEndpoint;
                    args.diagram->CommitOperation(args.location);
                    Tools.SetCurrent(Tools.GetSelectTool());
                }
                else
                {
                    #assert(false);
                }
            }
        }
        public override void MouseControlLeftClick(MouseArgs& args)
        {
            DiagramElement* element = args.element;
            if (element == null) return;
            if (!Accept(element)) return;
        }
    }

    public abstract class ClassRelationShipTool : RelationshipTool
    {
        public nothrow override bool Accept(DiagramElement* element)
        {
            if (element is ClassElement*)
            {
                return true;
            }
            return base->Accept(element);
        }
    }

    public class InheritanceTool : ClassRelationShipTool
    {
        public override nothrow RelationshipElement.Kind GetRelationshipKind() const
        {
            return RelationshipElement.Kind.inheritance;
        }
    }

    public class AggregationTool : ClassRelationShipTool
    {
        public override nothrow RelationshipElement.Kind GetRelationshipKind() const
        {
            return RelationshipElement.Kind.aggregation;
        }
    }

    public class CreateInstanceTool : ClassRelationShipTool
    {
        public override nothrow RelationshipElement.Kind GetRelationshipKind() const
        {
            return RelationshipElement.Kind.createInstance;
        }
    }

    public class NoteTool : ClassRelationShipTool
    {
        public override nothrow RelationshipElement.Kind GetRelationshipKind() const
        {
            return RelationshipElement.Kind.note;
        }
    }

    public class ReferenceTool : RelationshipTool
    {
        public nothrow override bool Accept(DiagramElement* element)
        {
            if (element is ContainerElement*)
            {
                return true;
            }
            return base->Accept(element);
        }
        public override nothrow RelationshipElement.Kind GetRelationshipKind() const
        {
            return RelationshipElement.Kind.reference;
        }
    }

}

// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Windows;
using System.XPath;
using System.Text;

namespace spring
{
    public class Contains<T>
    {
        public typedef T ElementType;

        public nothrow Contains(const PointF& location_) : location(location_)
        {
        }
        public nothrow inline bool operator()(T* element) const
        {
            return element->Contains(location);
        }
        private PointF location;
    }

    public class HorizontallyLess : Rel<int>
    {
        public nothrow HorizontallyLess() : diagram(null)
        {
        }
        public nothrow HorizontallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().x < right->Location().x)
            {
                return true;
            }
            if (left->Location().x > right->Location().x)
            {
                return false;
            }
            return left->Location().y < right->Location().y;
        }
        private Diagram* diagram;
    }

    public class VerticallyLess : Rel<int>
    {
        public nothrow VerticallyLess () : diagram(null)
        {
        }
        public nothrow VerticallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().y < right->Location().y)
            {
                return true;
            }
            if (left->Location().y > right->Location().y)
            {
                return false;
            }
            return left->Location().x < right->Location().x;
        }
        private Diagram* diagram;
    }

    public abstract class DiagramElementCreator
    {
        public abstract DiagramElement* Create() const;
    }

    public class ConcreteDiagramElementCreator<DiagramElementT> : DiagramElementCreator
    {
        public override DiagramElement* Create() const
        {
            return new DiagramElementT();
        }
    }

    public class DiagramElementFactory
    {
        static DiagramElementFactory() : instance(new DiagramElementFactory())
        {
        }
        public static DiagramElementFactory& Instance()
        {
            return *instance;
        }
        public DiagramElement* Create(const string& domElementName)
        {
            Map<string, DiagramElementCreator*>.ConstIterator it = registry.CFind(domElementName);
            if (it != registry.CEnd())
            {
                DiagramElementCreator* creator = it->second;
                return creator->Create();
            }
            else
            {
                throw Exception("element '" + domElementName + "' not registered to diagram element factory");
            }
        }
        private DiagramElementFactory()
        {
            UniquePtr<DiagramElementCreator> classCreator(new ConcreteDiagramElementCreator<ClassElement>());
            registry["class"] = classCreator.Get();
            creators.Add(Rvalue(classCreator));
            UniquePtr<DiagramElementCreator> objectCreator(new ConcreteDiagramElementCreator<ObjectElement>());
            registry["object"] = objectCreator.Get();
            creators.Add(Rvalue(objectCreator));
            UniquePtr<DiagramElementCreator> relationshipCreator(new ConcreteDiagramElementCreator<RelationshipElement>());
            registry["relationship"] = relationshipCreator.Get();
            creators.Add(Rvalue(relationshipCreator));
        }
        private void Instantiate()
        {
            ConcreteDiagramElementCreator<ClassElement>().Create();
            ConcreteDiagramElementCreator<ObjectElement>().Create();
            ConcreteDiagramElementCreator<RelationshipElement>().Create();
        }
        private static UniquePtr<DiagramElementFactory> instance;
        private List<UniquePtr<DiagramElementCreator>> creators;
        private Map<string, DiagramElementCreator*> registry;
    }

    public class Diagram 
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, invalidated = 1 << 1, modified = 1 << 2
        }
        public Diagram() : flags(Flags.none), layout(), elements(), selection(new EmptySelection(*this)), operation(new EmptyOperation())
        {
            Tools.SetDiagram(this);
            SetChanged();
            Invalidate();
            ResetModified();
        }
        suppress Diagram(const Diagram&);
        suppress void operator=(const Diagram&);
        suppress Diagram(Diagram&&);
        suppress void operator=(Diagram&&);
        public nothrow void SetCanvas(Canvas* canvas_)
        {
            canvas = canvas_;
        }
        public nothrow Canvas* GetCanvas() const
        {
            return canvas;
        }
        public void Save(const string& filePath)
        {
            StreamWriter writer = File.CreateText(filePath);
            CodeFormatter formatter(writer);
            formatter.SetIndentSize(1);
            System.Dom.Document diagramDocument;
            diagramDocument.AppendChild(UniquePtr<System.Dom.Node>(new System.Dom.Element(u"diagram")));
            for (UniquePtr<DiagramElement>& element : elements)
            {
                UniquePtr<System.Dom.Element> domElement = element->CreateDomElement();
                element->Write(domElement.Get());
                diagramDocument.DocumentElement()->AppendChild(UniquePtr<System.Dom.Node>(domElement.Release()));
            }
            diagramDocument.Write(formatter);
        }
        public void Load(const string& filePath)
        {
            List<DiagramElement*> relationshipElements;
            UniquePtr<System.Dom.Document> diagramDocument = System.Dom.ReadDocument(filePath);
            UniquePtr<XPathObject> result = Evaluate(u"/diagram/*", diagramDocument.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->SetDiagram(this);
                            diagramElement->Read(element);
                            if (diagramElement.Get() is RelationshipElement*)
                            {
                                relationshipElements.Add(diagramElement.Get());
                            }
                            AddElement(diagramElement.Release());
                        }
                    }
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Resolve();
            }
        }
        public void Draw(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                if (layout.IsNull())
                {
                    layout.Reset(new Layout(graphics));
                }
                for (const UniquePtr<DiagramElement>& element : elements)
                {
                    element->Measure(graphics, *layout);
                }
            }
            if (Invalidated())
            {
                ResetInvalidated();
            }
            List<DiagramElement*> relationshipElements;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    element->Draw(graphics, *layout);
                }
                else if (element.Get() is RelationshipElement*)
                {
                    relationshipElements.Add(element.Get());
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Draw(graphics, *layout);
            }
        }
        public nothrow const Layout& GetLayout() const
        {
            return *layout;
        }
        public nothrow Layout& GetLayout()
        {
            return *layout;
        }
        public nothrow void SetLayout(Layout* layout_)
        {
            layout.Reset(layout_);
        }
        public nothrow void DeleteSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            if (!selection->IsEmpty())
            {
                selection->Delete();
            }
        }
        public nothrow inline DiagramElement* GetElementByIndex(int index) const
        {
            return elements.Get(index);
        }
        public nothrow inline void SetElementByIndex(DiagramElement* element, int index)
        {
            if (element != null)
            {
                element->SetDiagram(this);
            }
            elements.Set(index, element);
        }
        public nothrow inline int GetIndexOfElement(DiagramElement* element)
        {
            int n = elements.Count();
            for (int i = 0; i < n; ++i)
            {
                if (elements.Get(i) == element)
                {
                    return i;
                }
            }
            return -1;
        }
        public nothrow void AddElement(DiagramElement* element)
        {
            element->SetDiagram(this);
            elements.Add(element);
            SetChanged();
            Invalidate();
        }
        public nothrow UniquePtr<DiagramElement> RemoveElementByIndex(int index)
        {
            UniquePtr<DiagramElement> element = elements.Remove(index);
            SetChanged();
            Invalidate();
            return element;
        }
        public nothrow int GetIndexOfElementAt(const PointF& location) const
        {
            Contains<DiagramElement> pred(location);
            return IndexOf(elements, pred);
        }
        public nothrow Selection* GetSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            return selection.Get();
        }
        public nothrow void SetSelection(Selection* selection_)
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            selection->Clear();
            selection.Reset(selection_);
            if (selection.IsNull())
            {
                int x = 0;
            }
            if (!selection->IsEmpty())
            {
                EnableCopy();
                EnableCut();
            }
            else
            {
                DisableCopy();
                DisableCut();
            }
        }
        public nothrow void ResetSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            selection->Clear();
            DisposeContextMenu();
            selection.Reset(new EmptySelection(*this));
            DisableCopy();
            DisableCut();
        }
        public nothrow void EnableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCopy();
            }
        }
        public nothrow void EnableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCut();
            }
        }
        public nothrow void DisableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCopy();
            }
        }
        public nothrow void DisableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCut();
            }
        }
        public void Paste(const ustring& clipboardData)
        {
            UniquePtr<System.Dom.Document> diagramElementDoc = System.Dom.ParseDocument(clipboardData, "clipboard");
            UniquePtr<XPathObject> result = Evaluate(u"/spring.diagram.elements/*", diagramElementDoc.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    UniquePtr<ElementSelection> elementSelection(new ElementSelection(*this));
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->Read(element);
                            int index = elements.Count();
                            AddElement(diagramElement.Release());
                            elementSelection->Add(index);
                        }
                    }
                    SetSelection(elementSelection.Release());
                }
            }
        }
        public nothrow inline Operation* GetOperation() const
        {
            return operation.Get();
        }
        public nothrow void SetOperation(Operation* operation_)
        {
            operation.Reset(operation_);
        }
        public void AdvanceOperation(const PointF& location)
        {
            operation->AdvanceTo(location);
            SetChanged();
            Invalidate();
        }
        public void CancelOperation()
        {
            operation->Cancel();
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public void CommitOperation(const PointF& location)
        {
            operation->Commit(location);
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public nothrow void ResetOperation()
        {
            operation.Reset(new EmptyOperation());
        }
        public void DisposeContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->RemoveContextMenu();
        }
        public void HideContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->HideContextMenu();
        }
        private nothrow inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        public nothrow inline void SetChanged()
        {
            if (!Changed())
            {
                flags = cast<Flags>(flags | Flags.changed);
                SetModified();
            }
        }
        private nothrow inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public nothrow inline bool Modified() const
        {
            return (flags & Flags.modified) != Flags.none;
        }
        public nothrow void SetModified()
        {
            flags = cast<Flags>(flags | Flags.modified);
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                if (modifiedStatusBarItem != null)
                {
                    modifiedStatusBarItem->SetText("*");
                }
            }
        }
        public nothrow void ResetModified()
        {
            if (Modified())
            {
                flags = cast<Flags>(flags & ~Flags.modified);
                Canvas* canvas = GetCanvas();
                if (canvas != null)
                {
                    StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                    if (modifiedStatusBarItem != null)
                    {
                        modifiedStatusBarItem->SetText(" ");
                    }
                }
            }
        }
        public nothrow inline bool Invalidated() const
        {
            return (flags & Flags.invalidated) != Flags.none;
        }
        public nothrow void Invalidate()
        {
            if (!Invalidated())
            {
                flags = cast<Flags>(flags | Flags.invalidated);
                if (canvas != null)
                {
                    canvas->Invalidate();
                }
            }
        }
        public nothrow inline void ResetInvalidated()
        {
            flags = cast<Flags>(flags & ~Flags.invalidated);
        }
        private Flags flags;
        private Canvas* canvas;
        private UniquePtr<Layout> layout;
        private IndexList<DiagramElement> elements;
        private UniquePtr<Selection> selection;
        private UniquePtr<Operation> operation;
    }

    public abstract class DiagramElement
    {
        private enum Flags : sbyte
        {
            none = 0, selected = 1 << 0
        }
        public nothrow DiagramElement() : name()
        {
        }
        public nothrow DiagramElement(const string& name_) : name(name_)
        {
        }
        suppress DiagramElement(const DiagramElement&);
        suppress void operator=(const DiagramElement&);
        suppress DiagramElement(DiagramElement&&);
        suppress void operator=(DiagramElement&&);
        public virtual void Draw(Graphics& graphics, Layout& layout)
        {
            if (IsSelected())
            {
                DrawSelected(graphics, layout);
            }
        }
        public abstract System.Dom.Element* CreateDomElement() const;
        public abstract DiagramElement* Clone() const;
        public abstract void Measure(Graphics& graphics, Layout& layout);
        public virtual nothrow void Resolve()
        {
        }
        public virtual nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            return Endpoint();
        }
        public virtual nothrow List<Endpoint> GetEndpoints() const
        {
            return List<Endpoint>();
        }
        public virtual nothrow void AddRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void RemoveRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            MenuItem* deleteMenuItem = new MenuItem("Delete");
            contextMenu->AddMenuItemAction(deleteMenuItem, new DeleteDiagramElementAction(diagram, elementIndex));
        }
        private void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const ColorElement& selectedColorElement = layout.GetSelectedColorElement();
            Brush& selectedBrush = selectedColorElement.GetBrush(layout);
            graphics.FillRectangleChecked(selectedBrush, boundingRect);
        }
        public nothrow inline const string& Name() const
        {
            return name;
        }
        public nothrow void SetName(const string& name_)
        {
            name = name_;
        }
        public nothrow inline const PointF& Location() const
        {
            return boundingRect.location;
        }
        public nothrow inline void SetLocation(const PointF& location)
        {
            boundingRect.location = location;
        }
        public nothrow inline const SizeF& GetSize() const
        {
            return boundingRect.size;
        }
        public nothrow inline void SetSize(const SizeF& size)
        {
            boundingRect.size = size;
        }
        public nothrow const RectF& BoundingRect() const
        {
            return boundingRect;
        }
        public virtual nothrow bool Contains(const PointF& location)
        {
            return boundingRect.Contains(location);
        }
        public virtual void Read(System.Dom.Element* parentElement)
        {
            name = ToUtf8(parentElement->GetAttribute(u"name"));
            UniquePtr<XPathObject> result = Evaluate(u"boundingRect", parentElement);
            if (!result.IsNull())
            {
                if (result->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* boundingRectElement = cast<System.Dom.Element*>(node);
                            string x = ToUtf8(boundingRectElement->GetAttribute(u"x"));
                            string y = ToUtf8(boundingRectElement->GetAttribute(u"y"));
                            string w = ToUtf8(boundingRectElement->GetAttribute(u"w"));
                            string h = ToUtf8(boundingRectElement->GetAttribute(u"h"));
                            boundingRect = RectF(PointF(ParseFloat(x), ParseFloat(y)), SizeF(ParseFloat(w), ParseFloat(h)));
                        }
                    }
                }
            }
        }
        public virtual void Write(System.Dom.Element* parentElement)
        {
            parentElement->SetAttribute(u"name", ToUtf32(name));
            UniquePtr<System.Dom.Element> boundingRectElement(new System.Dom.Element(u"boundingRect"));
            boundingRectElement->SetAttribute(u"x", ToUtf32(System.ToString(boundingRect.location.x)));
            boundingRectElement->SetAttribute(u"y", ToUtf32(System.ToString(boundingRect.location.y)));
            boundingRectElement->SetAttribute(u"w", ToUtf32(System.ToString(boundingRect.size.w)));
            boundingRectElement->SetAttribute(u"h", ToUtf32(System.ToString(boundingRect.size.h)));
            parentElement->AppendChild(UniquePtr<System.Dom.Node>(boundingRectElement.Release()));
        }
        public virtual void SetFrom(DiagramElement* that)
        {
            name = that->name;
            boundingRect = that->boundingRect;
        }
        public nothrow inline bool IsSelected() const
        {
            return (flags & Flags.selected) != Flags.none;
        }
        public nothrow void Select()
        {
            if (!IsSelected())
            {
                flags = cast<Flags>(flags | Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void ResetSelected()
        {
            if (IsSelected())
            {
                flags = cast<Flags>(flags & ~Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void SetDiagram(Diagram* diagram_)
        {
            diagram = diagram_;
        }
        public nothrow inline Diagram* GetDiagram() const
        {
            return diagram;
        }
        private Flags flags;
        private string name;
        private RectF boundingRect;
        private Diagram* diagram;
    }

    public enum SnapPoint : sbyte
    {
        none, top, bottom, left, right, center
    }

    public nothrow string ToString(SnapPoint snapPoint)
    {
        switch (snapPoint)
        {
            case SnapPoint.none: return "none";
            case SnapPoint.top: return "top";
            case SnapPoint.bottom: return "bottom";
            case SnapPoint.left: return "left";
            case SnapPoint.right: return "right";
            case SnapPoint.center: return "center";
        }
        return string();
    }

    public nothrow SnapPoint ParseSnapPoint(const string& str)
    {
        if (str == "none")
        {
            return SnapPoint.none;
        }
        else if (str == "top")
        {
            return SnapPoint.top;
        }
        else if (str == "bottom")
        {
            return SnapPoint.bottom;
        }
        else if (str == "left")
        {
            return SnapPoint.left;
        }
        else if (str == "right")
        {
            return SnapPoint.right;
        }
        else if (str == "center")
        {
            return SnapPoint.center;
        }
        return SnapPoint.none;
    }

    public class Snap
    {
        public nothrow constexpr Snap() : primaryPoint(SnapPoint.none), secondaryPoint(SnapPoint.none)
        {
        }
        public nothrow constexpr Snap(SnapPoint primaryPoint_, SnapPoint secondaryPoint_) : primaryPoint(primaryPoint_), secondaryPoint(secondaryPoint_)
        {
        }
        public explicit constexpr nothrow Snap(int x) : primaryPoint(cast<SnapPoint>(cast<sbyte>((x >> 8) & 0xff))), secondaryPoint(cast<SnapPoint>(cast<sbyte>(x & 0xff)))
        {
        }
        public static nothrow constexpr inline int TopLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int TopCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int TopRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int LeftTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int LeftCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int LeftBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public static nothrow constexpr inline int BottomLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int BottomCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int BottomRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int RightTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int RightCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int RightBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public nothrow string ToString() const
        {
            return spring.ToString(primaryPoint) + "." + spring.ToString(secondaryPoint);
        }
        public nothrow constexpr inline int ToInt() const
        {
            return cast<int>(cast<sbyte>(primaryPoint)) << 8 | cast<int>(cast<sbyte>(secondaryPoint));
        }
        public nothrow PointF Calculate(const PointF& point, float w, int index, int count)
        {
            int s = ToInt();
            switch (s)
            {
                case TopLeft():
                case BottomLeft():
                {
                    return PointF(point.x + index * w * 2.0f, point.y);
                }
                case TopRight():
                case BottomRight():
                {
                    return PointF(point.x - index * w * 2.0f, point.y);
                }
                case LeftTop():
                case RightTop():
                {
                    return PointF(point.x, point.y + w * 2.0f);
                }
                case LeftBottom():
                case RightBottom():
                {
                    return PointF(point.x, point.y - w * 2.0f);
                }
                case LeftCenter():
                case RightCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x, point.y - (count / 2) * w * 2.0f + index * w * 2.0f + w);
                    }
                    else
                    {
                        return PointF(point.x, point.y - (count / 2) * w * 2.0f + index * w * 2.0f);
                    }
                }
                case TopCenter():
                case BottomCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x - (count / 2) * w * 2.0f + index * w * 2.0f + w, point.y);
                    }
                    else
                    {
                        return PointF(point.x - (count / 2) * w * 2.0f + index * w * 2.0f, point.y);
                    }
                }
            }
            return PointF();
        }
        public SnapPoint primaryPoint;
        public SnapPoint secondaryPoint;
    }

    public nothrow Snap ParseSnap(const string& str)
    {
        List<string> components = str.Split(".");
        if (components.Count() == 2)
        {
            Snap snap(ParseSnapPoint(components[0]), ParseSnapPoint(components[1]));
            return snap;
        }
        return Snap();
    }

    public nothrow constexpr inline bool operator==(const Snap& left, const Snap& right)
    {
        return left.primaryPoint == right.primaryPoint && left.secondaryPoint == right.secondaryPoint;
    }

    public nothrow constexpr inline bool operator<(const Snap& left, const Snap& right)
    {
        if (left.primaryPoint < right.primaryPoint) return true;
        if (left.primaryPoint > right.primaryPoint) return false;
        return left.secondaryPoint < right.secondaryPoint;
    }

    public enum Cardinality : sbyte
    {
        zero, one, many
    }

    public nothrow Cardinality ParseCardinality(const string& s)
    {
        if (s == "zero")
        {
            return Cardinality.zero;
        }
        else if (s == "one")
        {
            return Cardinality.one;
        }
        else if (s == "many")
        {
            return Cardinality.many;
        }
        return Cardinality.zero;
    }

    public nothrow string ToString(Cardinality cardinality)
    {
        switch (cardinality)
        {
            case Cardinality.zero: return "zero";
            case Cardinality.one: return "one";
            case Cardinality.many: return "many";
        }
        return string();
    }

    public class EndpointNearer : Rel<Endpoint*>
    {
        public nothrow EndpointNearer(const PointF& location_) : location(location_)
        {
        }
        public nothrow bool operator()(Endpoint* left, Endpoint* right) const
        {
            return System.Windows.Distance(left->point, location) < System.Windows.Distance(right->point, location);
        }
        private PointF location;
    }

    public class Endpoint
    {
        public nothrow Endpoint() : element(null), snap(), point(0, 0), name()
        {
        }
        public nothrow Endpoint(DiagramElement* element_, const Snap& snap_, const PointF& point_) : element(element_), snap(snap_), point(point_), name()
        {
        }
        public nothrow string ToString() const
        {
            if (element != null)
            {
                return "endpoint." + element->Name() + "." + snap.ToString() + "." + point.ToString() + "." + name;
            }
            return "endpoint.null";
        }
        public void Write(System.Dom.Element* parentElement)
        {
            if (element != null)
            {
                Diagram* diagram = element->GetDiagram();
                if (element != null)
                {
                    int index = diagram->GetIndexOfElement(element);
                    parentElement->SetAttribute(u"index", ToUtf32(ToString(index)));
                }
                else
                {
                    parentElement->SetAttribute(u"index", u"-1");
                }
                parentElement->SetAttribute(u"snap", ToUtf32(snap.ToString()));
                parentElement->SetAttribute(u"x", ToUtf32(ToString(point.x)));
                parentElement->SetAttribute(u"y", ToUtf32(ToString(point.y)));
                parentElement->SetAttribute(u"name", ToUtf32(name));
            }
        }
        public void Read(System.Dom.Element* parentElement)
        {
            index = ParseInt(ToUtf8(parentElement->GetAttribute(u"index")));
            snap = ParseSnap(ToUtf8(parentElement->GetAttribute(u"snap")));
            point.x = ParseFloat(ToUtf8(parentElement->GetAttribute(u"x")));
            point.y = ParseFloat(ToUtf8(parentElement->GetAttribute(u"y")));
            name = ToUtf8(parentElement->GetAttribute(u"name"));
        }
        public void Resolve(Diagram* diagram)
        {
            if (index != -1)
            {
                element = diagram->GetElementByIndex(index);
            }
        }
        public DiagramElement* element;
        public Snap snap;
        public PointF point;
        public string name;
        private int index;
    }

    public class RelationshipElement : DiagramElement
    {
        public enum Kind
        {
            none, inheritance, aggregation, createInstance, note, reference
        }
        public nothrow RelationshipElement() : base(), kind(Kind.none), source(), target(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        public nothrow RelationshipElement(Kind kind_) : base(), kind(kind_), source(), target(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        public nothrow RelationshipElement(Kind kind_, const string& name, const Endpoint& source_, const Endpoint& target_) :
            base(name), kind(kind_), source(source_), target(target_), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        suppress RelationshipElement(const RelationshipElement&);
        suppress void operator=(const RelationshipElement&);
        suppress RelationshipElement(RelationshipElement&&);
        suppress void operator=(RelationshipElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"relationship");
        }
        public override DiagramElement* Clone() const
        {
            RelationshipElement* clone = new RelationshipElement();
            clone->SetFrom(this);
            return clone;
        }
        public nothrow Kind ParseRelationshipKind(const string& str)
        {
            if (str == "none")
            {
                return Kind.none;
            }
            else if (str == "inheritance")
            {
                return Kind.inheritance;
            }
            else if (str == "aggregation")
            {
                return Kind.aggregation;
            }
            else if (str == "createInstance")
            {
                return Kind.createInstance;
            }
            else if (str == "note")
            {
                return Kind.note;
            }
            else if (str == "reference")
            {
                return Kind.reference;
            }
            return Kind.none;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            kind = ParseRelationshipKind(ToUtf8(element->GetAttribute(u"kind")));
            UniquePtr<XPathObject> sourceResult = Evaluate(u"source", element);
            if (!sourceResult.IsNull())
            {
                if (sourceResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(sourceResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            source.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> targetResult = Evaluate(u"target", element);
            if (!targetResult.IsNull())
            {
                if (targetResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(targetResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            target.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> intermediatePointsResult = Evaluate(u"intermediatePoint", element);
            if (!intermediatePointsResult.IsNull())
            {
                if (intermediatePointsResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(intermediatePointsResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            PointF intermediatePoint;
                            intermediatePoint.x = ParseFloat(ToUtf8(element->GetAttribute(u"x")));
                            intermediatePoint.y = ParseFloat(ToUtf8(element->GetAttribute(u"y")));
                            intermediatePoints.Add(intermediatePoint);
                        }
                    }
                }
            }
            cardinality = ParseCardinality(ToUtf8(element->GetAttribute(u"cardinality")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            switch (kind)
            {
                case Kind.none: element->SetAttribute(u"kind", u"none"); break;
                case Kind.inheritance: element->SetAttribute(u"kind", u"inheritance"); break;
                case Kind.aggregation: element->SetAttribute(u"kind", u"aggregation"); break;
                case Kind.createInstance: element->SetAttribute(u"kind", u"createInstance"); break;
                case Kind.note: element->SetAttribute(u"kind", u"note"); break;
                case Kind.reference: element->SetAttribute(u"kind", u"reference"); break;
            }
            System.Dom.Element* sourceElement = new System.Dom.Element(u"source");
            source.Write(sourceElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(sourceElement));
            System.Dom.Element* targetElement = new System.Dom.Element(u"target");
            target.Write(targetElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(targetElement));
            int n = cast<int>(intermediatePoints.Count());
            for (int i = 0; i < n; ++i)
            {
                System.Dom.Element* intermediatePointElement = new System.Dom.Element(u"intermediatePoint");
                intermediatePointElement->SetAttribute(u"x", ToUtf32(ToString(intermediatePoints[i].x)));
                intermediatePointElement->SetAttribute(u"y", ToUtf32(ToString(intermediatePoints[i].y)));
            }
            element->SetAttribute(u"cardinality", ToUtf32(ToString(cardinality)));
        }
        public nothrow override void Resolve()
        {
            source.Resolve(GetDiagram());
            if (source.element != null)
            {
                source.element->AddRelationship(this);
            }
            target.Resolve(GetDiagram());
            if (target.element != null)
            {
                target.element->AddRelationship(this);
            }
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            // todo
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            switch (kind)
            {
                case Kind.inheritance:
                {
                    DrawInheritance(graphics, layout);
                    break;
                }
            }
        }
        public nothrow void Calculate(const Snap& snap, DiagramElement* element, float w, int index, int count)
        {
            Endpoint endpoint = element->GetEndpoint(snap);
            if (source.element == element)
            {
                source.point = snap.Calculate(endpoint.point, w, index, count);
            }
            else if (target.element == element)
            {
                target.point = snap.Calculate(endpoint.point, w, index, count);
            }
        }
        private void DrawInheritance(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
            float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
            PointF lastPoint;
            if (intermediatePoints.IsEmpty())
            {
                lastPoint = source.point;
            }
            else
            {
                lastPoint = intermediatePoints.Back();
            }
            Line line(lastPoint, target.point);
            Vector v = line.ToVector();
            float len = v.Length();
            float startLen = Max(0.0f, len - inheritanceArrowHeight);
            Vector u = UnitVector(v) * startLen;
            Line startLine(source.point, u);
            graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
            Line arrowLine(startLine.end, target.point);
            Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
            Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
            Line arrowRightLine(arrowRightRotatedLine.start, arv);
            graphics.DrawLineChecked(linePen, arrowRightLine.end, target.point);
            Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
            Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
            Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
            graphics.DrawLineChecked(linePen, arrowLeftLine.end, target.point);
            graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            kind = cast<RelationshipElement*>(that)->kind;
            source = cast<RelationshipElement*>(that)->source;
            target = cast<RelationshipElement*>(that)->target;
            intermediatePoints = cast<RelationshipElement*>(that)->intermediatePoints;
            cardinality = cast<RelationshipElement*>(that)->cardinality;
        }
        public nothrow void AddToContainers()
        {
            if (source.element != null && target.element != null)
            {
                source.element->AddRelationship(this);
                target.element->AddRelationship(this);
            }
        }
        public Kind kind;
        public Endpoint source;
        public Endpoint target;
        public List<PointF> intermediatePoints;
        public Cardinality cardinality;
    }

    public class FieldElement : DiagramElement
    {
        public nothrow FieldElement() : base()
        {
        }
        public nothrow FieldElement(const string& name) : base(name)
        {
        }
        suppress FieldElement(const FieldElement&);
        suppress void operator=(const FieldElement&);
        suppress FieldElement(FieldElement&&);
        suppress void operator=(FieldElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"field");
        }
        public override DiagramElement* Clone() const
        {
            FieldElement* clone = new FieldElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
    }

    public class OperationElement : DiagramElement
    {
        public nothrow OperationElement() : base(), isAbstract(false)
        {
        }
        public nothrow OperationElement(const string& name) : base(name), isAbstract(false)
        {
        }
        public nothrow OperationElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
        }
        suppress OperationElement(const OperationElement&);
        suppress void operator=(const OperationElement&);
        suppress OperationElement(OperationElement&&);
        suppress void operator=(OperationElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"operation");
        }
        public override DiagramElement* Clone() const
        {
            OperationElement* clone = new OperationElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            isAbstract = ParseBool(ToUtf8(element->GetAttribute(u"abstract")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            element->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                DrawAbstractOperation(graphics, layout);
            }
            else
            {
                DrawConcreteOperation(graphics, layout);
            }
        }
        private void DrawAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), textColorElement.GetBrush(layout));
        }
        private void DrawConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                MeasureAbstractOperation(graphics, layout);
            }
            else
            {
                MeasureConcreteOperation(graphics, layout);
            }
        }
        private void MeasureAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        private void MeasureConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<OperationElement*>(that)->isAbstract;
        }
        private bool isAbstract;
    }

    public abstract class ContainerElement : DiagramElement
    {
        public nothrow ContainerElement() : base()
        {
        }
        public nothrow ContainerElement(const string& name) : base(name)
        {
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            MeasureRelationships(Snap(Snap.TopLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftBottom()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightBottom()), w, graphics, layout);
        }
        private void MeasureRelationships(const Snap& snap, float w, Graphics& graphics, Layout& layout)
        {
            List<RelationshipElement*> pickedRelationships = PickRelationships(snap);
            int n = cast<int>(pickedRelationships.Count());
            for (int i = 0; i < n; ++i)
            {
                RelationshipElement* relationship = pickedRelationships[i];
                relationship->Calculate(snap, this, w, i, n);
            }
        }
        public nothrow inline const List<RelationshipElement*>& Relationships() const
        {
            return relationships;
        }
        public nothrow List<RelationshipElement*>& Relationships()
        {
            return relationships;
        }
        public nothrow override void AddRelationship(RelationshipElement* relationship)
        {
            relationships.Add(relationship);
        }
        public nothrow override void RemoveRelationship(RelationshipElement* relationship)
        {
            relationships.Remove(relationship);
        }
        private nothrow List<RelationshipElement*> PickRelationships(const Snap& snap) const
        {
            List<RelationshipElement*> pickedRelationships;
            for (RelationshipElement* relationship : relationships)
            {
                if (relationship->source.element == this)
                {
                    if (relationship->source.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
                else if (relationship->target.element == this)
                {
                    if (relationship->target.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
            }
            return pickedRelationships;
        }
        private List<RelationshipElement*> relationships;
    }

    public class ClassElement : ContainerElement
    {
        public nothrow ClassElement() : base()
        {
        }
        public nothrow ClassElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
        }
        suppress ClassElement(const ClassElement&);
        suppress void operator=(const ClassElement&);
        suppress ClassElement(ClassElement&&);
        suppress void operator=(ClassElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow inline void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public nothrow void ResetAbstractOperations()
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->SetAbstract(false);
            }
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            switch (snap.ToInt())
            {
                case Snap.TopLeft():
                {
                    return Endpoint(this, Snap(Snap.TopLeft()), PointF(loc.x + w, loc.y));
                }
                case Snap.TopCenter():
                {
                    return Endpoint(this, Snap(Snap.TopCenter()), PointF(loc.x + size.w / 2, loc.y));
                }
                case Snap.TopRight():
                {
                    return Endpoint (this, Snap(Snap.TopRight()), PointF(loc.x + size.w - w, loc.y));
                }
                case Snap.RightTop():
                {
                    return Endpoint(this, Snap(Snap.RightTop()), PointF(loc.x + size.w, loc.y + w));
                }
                case Snap.RightCenter():
                {
                    return Endpoint(this, Snap(Snap.RightCenter()), PointF(loc.x + size.w, loc.y + size.h / 2));
                }
                case Snap.RightBottom():
                {
                    return Endpoint(this, Snap(Snap.RightBottom()), PointF(loc.x + size.w, loc.y + size.h - w));
                }
                case Snap.BottomRight():
                {
                    return Endpoint(this, Snap(Snap.BottomRight()), PointF(loc.x + size.w - w, loc.y + size.h));
                }
                case Snap.BottomCenter():
                {
                    return Endpoint(this, Snap(Snap.BottomCenter()), PointF(loc.x + size.w / 2, loc.y + size.h));
                }
                case Snap.BottomLeft():
                {
                    return Endpoint(this, Snap(Snap.BottomLeft()), PointF(loc.x + w, loc.y + size.h));
                }
                case Snap.LeftBottom():
                {
                    return Endpoint(this, Snap(Snap.LeftBottom()), PointF(loc.x, loc.y + size.h - w));
                }
                case Snap.LeftCenter():
                {
                    return Endpoint(this, Snap(Snap.LeftCenter()), PointF(loc.x, loc.y + size.h / 2));
                }
                case Snap.LeftTop():
                {
                    return Endpoint(this, Snap(Snap.LeftTop()), PointF(loc.x, loc.y + w));
                }
            }
            return Endpoint();
        }
        public override nothrow List<Endpoint> GetEndpoints() const
        {
            List<Endpoint> endpoints;
            endpoints.Add(GetEndpoint(Snap(Snap.TopLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightTop())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftTop()))); 
            return endpoints;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"class");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ClassElement> clone = new ClassElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawOperations(graphics, layout);
            DrawFields(graphics, layout);
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ClassElementPropertiesAction(diagram, elementIndex));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            base->Measure(graphics, layout);
            if (!isAbstract)
            {
                MeasureConcreteClass(graphics, layout);
            }
            else
            {
                MeasureAbstractClass(graphics, layout);
            }
        }
        private void MeasureConcreteClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            MeasureOperations(graphics, layout);
            MeasureFields(graphics, layout);
            SetSize();
        }
        private void MeasureAbstractClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            MeasureOperations(graphics, layout);
            MeasureFields(graphics, layout);
            SetSize();
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                size.w = Max(size.w, operationRect.size.w);
                h = h + operationRect.size.h;
            }
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        private void MeasureOperations(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            PointF location = Location();
            operationRect = RectF();
            operationRect.location.x = location.x;
            operationRect.location.y = location.y + captionRect.size.h;
            operationRect.size.w = captionRect.size.w;
            operationRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = operationRect.location.x + paddingElement.left;
            origin.y = operationRect.location.y + paddingElement.top;
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Measure(graphics, layout);
                SizeF operationSize = operation->GetSize();
                float w = operationSize.w + paddingElement.Horizontal();
                float h = operationSize.h;
                operation->SetLocation(origin);
                operationRect.size.w = Max(operationRect.size.w, w);
                origin.y = origin.y + h;
                operationRect.size.h = operationRect.size.h + h;
            }
            operationRect.size.h = operationRect.size.h + paddingElement.bottom;
        }
        private void MeasureFields(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = operationRect.location.y + operationRect.size.h;
            fieldRect.size.w = operationRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassFrame(graphics, layout);
            }
            else
            {
                DrawAbstractClassFrame(graphics, layout);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassCaption(graphics, layout);
            }
            else
            {
                DrawAbstractClassCaption(graphics, layout);
            }
        }
        private void DrawConcreteClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawAbstractClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawConcreteClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawAbstractClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawOperations(Graphics& graphics, Layout& layout)
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Draw(graphics, layout);
            }
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            isAbstract = ParseBool(ToUtf8(parentElement->GetAttribute(u"abstract")));
            UniquePtr<XPathObject> operationResult = Evaluate(u"operation", parentElement);
            if (!operationResult.IsNull())
            {
                if (operationResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(operationResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<OperationElement> operation(new OperationElement());
                            operation->Read(element);
                            operations.Add(operation.Release());
                        }
                    }
                }
            }
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            parentElement->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
            for (const UniquePtr<OperationElement>& operation : operations)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"operation");
                operation->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<ClassElement*>(that)->isAbstract;
            operations.Clear();
            for (UniquePtr<OperationElement>& operation : cast<ClassElement*>(that)->operations)
            {
                operations.Add(cast<OperationElement*>(operation->Clone()));
            }
            fields.Clear();
            for (UniquePtr<FieldElement>& field : cast<ClassElement*>(that)->fields)
            {
                fields.Add(cast<FieldElement*>(field->Clone()));
            }
        }
        public nothrow IndexList<OperationElement>& Operations() 
        {
            return operations;
        }
        public void SetOperations(IndexList<OperationElement>&& operations_)
        {
            operations = operations_;
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
        }
        private IndexList<OperationElement> operations;
        private IndexList<FieldElement> fields;
        private bool isAbstract;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF operationRect;
        private RectF fieldRect;
    }

    public class ObjectElement : ContainerElement
    {
        public nothrow ObjectElement() : base()
        {
        }
        public nothrow ObjectElement(const string& name) : base(name)
        {
        }
        suppress ObjectElement(const ObjectElement&);
        suppress void operator=(const ObjectElement&);
        suppress ObjectElement(ObjectElement&&);
        suppress void operator=(ObjectElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"object");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ObjectElement> clone = new ObjectElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ObjectElementPropertiesAction(diagram, elementIndex));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawFields(graphics, layout);
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const Pen& framePen = layoutElement.FramePen();
            float roundingRadius = layoutElement.FrameRoundingRadius();
            PointF loc = Location();
            SizeF size = GetSize();
            PointF topStart(loc.x + roundingRadius - 1.0f - DefaultFrameWidth(graphics), loc.y);
            PointF topEnd(loc.x + size.w - roundingRadius + 1.0f + DefaultFrameWidth(graphics), loc.y);
            graphics.DrawLineChecked(framePen, topStart, topEnd);
            RectF topLeftRoundingRect(PointF(loc.x, loc.y), SizeF(roundingRadius, roundingRadius));
            float topLeftRoundingStartAngle = 180.0f;
            float topLeftRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, topLeftRoundingRect, topLeftRoundingStartAngle, topLeftRoudingSweepAngle);
            PointF rightStart(loc.x + size.w, loc.y + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics));
            PointF rightEnd(loc.x + size.w, loc.y + size.h - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, rightStart, rightEnd);
            RectF topRightRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y), SizeF(roundingRadius, roundingRadius));
            float topRightRoundingStartAngle = 0.0f;
            float topRightRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, topRightRoundingRect, topRightRoundingStartAngle, topRightRoudingSweepAngle);
            RectF rightBottomRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float rightBottomRoundingStartAngle = 0.0f;
            float rightBottomRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, rightBottomRoundingRect, rightBottomRoundingStartAngle, rightBottomRoudingSweepAngle);
            PointF bottomStart(loc.x + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            PointF bottomEnd(loc.x + size.w - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            graphics.DrawLineChecked(framePen, bottomStart, bottomEnd);
            RectF leftBottomRoundingRect(PointF(loc.x, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float leftBottomRoundingStartAngle = 180.0f;
            float leftBottomRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, leftBottomRoundingRect, leftBottomRoundingStartAngle, leftBottomRoudingSweepAngle);
            PointF leftStart(loc.x, loc.y + roundingRadius - 1.0f - DefaultFrameWidth(graphics));
            PointF leftEnd(loc.x, loc.y + size.h - roundingRadius + 1.0f + DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, leftStart, leftEnd);
            if (!fields.IsEmpty())
            {
                float captionY = paddingElement.Vertical() + captionTextHeight;
                PointF location = Location();
                PointF captionLineStart(location.x, location.y + captionY);
                PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            MeasureFields(graphics, layout);
            SetSize();
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        private void MeasureFields(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = captionRect.location.y + captionRect.size.h;
            fieldRect.size.w = captionRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            fields.Clear();
            for (UniquePtr<FieldElement>& field : cast<ObjectElement*>(that)->fields)
            {
                fields.Add(cast<FieldElement*>(field->Clone()));
            }
        }
        private IndexList<FieldElement> fields;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF fieldRect;
    }
}

// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Windows;
using System.XPath;
using System.Text;

namespace spring
{
    public class Contains<T>
    {
        public typedef T ElementType;

        public nothrow Contains(const PointF& location_) : location(location_)
        {
        }
        public nothrow inline bool operator()(T* element) const
        {
            return element->Contains(location);
        }
        private PointF location;
    }

    public class HorizontallyLess : Rel<int>
    {
        public nothrow HorizontallyLess() : diagram(null)
        {
        }
        public nothrow HorizontallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().x < right->Location().x)
            {
                return true;
            }
            if (left->Location().x > right->Location().x)
            {
                return false;
            }
            return left->Location().y < right->Location().y;
        }
        private Diagram* diagram;
    }

    public class VerticallyLess : Rel<int>
    {
        public nothrow VerticallyLess () : diagram(null)
        {
        }
        public nothrow VerticallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().y < right->Location().y)
            {
                return true;
            }
            if (left->Location().y > right->Location().y)
            {
                return false;
            }
            return left->Location().x < right->Location().x;
        }
        private Diagram* diagram;
    }

    public abstract class DiagramElementCreator
    {
        public abstract DiagramElement* Create() const;
    }

    public class ConcreteDiagramElementCreator<DiagramElementT> : DiagramElementCreator
    {
        public override DiagramElement* Create() const
        {
            return new DiagramElementT();
        }
    }

    public class DiagramElementFactory
    {
        static DiagramElementFactory() : instance(new DiagramElementFactory())
        {
        }
        public static DiagramElementFactory& Instance()
        {
            return *instance;
        }
        public DiagramElement* Create(const string& domElementName)
        {
            Map<string, DiagramElementCreator*>.ConstIterator it = registry.CFind(domElementName);
            if (it != registry.CEnd())
            {
                DiagramElementCreator* creator = it->second;
                return creator->Create();
            }
            else
            {
                throw Exception("element '" + domElementName + "' not registered to diagram element factory");
            }
        }
        private DiagramElementFactory()
        {
            UniquePtr<DiagramElementCreator> classCreator(new ConcreteDiagramElementCreator<ClassElement>());
            registry["class"] = classCreator.Get();
            creators.Add(Rvalue(classCreator));
            UniquePtr<DiagramElementCreator> objectCreator(new ConcreteDiagramElementCreator<ObjectElement>());
            registry["object"] = objectCreator.Get();
            creators.Add(Rvalue(objectCreator));
            UniquePtr<DiagramElementCreator> noteCreator(new ConcreteDiagramElementCreator<NoteElement>());
            registry["note"] = noteCreator.Get();
            creators.Add(Rvalue(noteCreator));
            UniquePtr<DiagramElementCreator> relationshipCreator(new ConcreteDiagramElementCreator<RelationshipElement>());
            registry["relationship"] = relationshipCreator.Get();
            creators.Add(Rvalue(relationshipCreator));
        }
        private void Instantiate()
        {
            ConcreteDiagramElementCreator<ClassElement>().Create();
            ConcreteDiagramElementCreator<ObjectElement>().Create();
            ConcreteDiagramElementCreator<NoteElement>().Create();
            ConcreteDiagramElementCreator<RelationshipElement>().Create();
        }
        private static UniquePtr<DiagramElementFactory> instance;
        private List<UniquePtr<DiagramElementCreator>> creators;
        private Map<string, DiagramElementCreator*> registry;
    }

    public nothrow int MainDirection(DiagramElement* source, DiagramElement* target)
    {
        PointF sourceCenter = source->Center();
        PointF targetCenter = target->Center();
        Line line(sourceCenter, targetCenter);
        Vector v = line.ToVector();
        return MainDirection(v);
    }

    public class Diagram
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, invalidated = 1 << 1, modified = 1 << 2
        }
        public Diagram() : flags(Flags.none), layout(null), layoutPtr(), elements(), selection(new EmptySelection(*this)), operation(new EmptyOperation())
        {
            Tools.SetDiagram(this);
            SetChanged();
            Invalidate();
            ResetModified();
        }
        public Diagram(const Layout& layout_) : flags(Flags.none), layout(&layout_), layoutPtr(), elements(), selection(new EmptySelection(*this)), operation(new EmptyOperation())
        {
            SetChanged();
            ResetModified();
        }
        suppress Diagram(const Diagram&);
        suppress void operator=(const Diagram&);
        suppress Diagram(Diagram&&);
        suppress void operator=(Diagram&&);
        public nothrow void SetCanvas(Canvas* canvas_)
        {
            canvas = canvas_;
        }
        public nothrow Canvas* GetCanvas() const
        {
            return canvas;
        }
        public void SetMenuItems(MenuItem* undoMenuItem, MenuItem* redoMenuItem)
        {
            commandList.SetMenuItems(undoMenuItem, redoMenuItem);
        }
        public void Save(const string& filePath)
        {
            StreamWriter writer = File.CreateText(filePath);
            CodeFormatter formatter(writer);
            formatter.SetIndentSize(1);
            System.Dom.Document diagramDocument;
            diagramDocument.AppendChild(UniquePtr<System.Dom.Node>(new System.Dom.Element(u"diagram")));
            HashMap<ContainerElement*, int> containerElementIndexMap;
            List<ContainerElement*> containerElements;
            List<RelationshipElement*> relationshipElements;
            for (UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    containerElements.Add(cast<ContainerElement*>(element.Get()));
                }
                else if (element.Get() is RelationshipElement*)
                {
                    relationshipElements.Add(cast<RelationshipElement*>(element.Get()));
                }
            }
            int nc = cast<int>(containerElements.Count());
            for (int i = 0; i < nc; ++i)
            {
                ContainerElement* containerElement = containerElements[i];
                containerElementIndexMap[containerElement] = i;
                UniquePtr<System.Dom.Element> domElement = containerElement->CreateDomElement();
                containerElement->Write(domElement.Get());
                diagramDocument.DocumentElement()->AppendChild(UniquePtr<System.Dom.Node>(domElement.Release()));
            }
            int nr = cast<int>(relationshipElements.Count());
            for (int i = 0; i < nr; ++i)
            {
                RelationshipElement* relationshipElement = relationshipElements[i];
                relationshipElement->SetContainerElementIndeces(containerElementIndexMap);
                UniquePtr<System.Dom.Element> domElement = relationshipElement->CreateDomElement();
                relationshipElement->Write(domElement.Get());
                diagramDocument.DocumentElement()->AppendChild(UniquePtr<System.Dom.Node>(domElement.Release()));
            }
            diagramDocument.Write(formatter);
        }
        public void Load(const string& filePath)
        {
            List<DiagramElement*> relationshipElements;
            UniquePtr<System.Dom.Document> diagramDocument = System.Dom.ReadDocument(filePath);
            UniquePtr<XPathObject> result = Evaluate(u"/diagram/*", diagramDocument.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->SetDiagram(this);
                            diagramElement->Read(element);
                            if (diagramElement.Get() is RelationshipElement*)
                            {
                                relationshipElements.Add(diagramElement.Get());
                            }
                            AddElement(diagramElement.Release());
                        }
                    }
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Resolve();
            }
        }
        public void SaveImage(const string& fileName, const PaddingElement& margins, ImageFormat imageFormat)
        {
            List<DiagramElement*> diagramElements;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                diagramElements.Add(element.Get());
            }
            Graphics graphics = Graphics.FromWindowHandle(GetCanvas()->Handle());
            spring.SaveImage(fileName, margins, canvas, diagramElements, graphics, GetLayout(), imageFormat);
        }
        public nothrow RectF CalculateBoundingRect() const
        {
            List<DiagramElement*> diagramElements;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                diagramElements.Add(element.Get());
            }
            return CalculateBoundingRect(diagramElements);
        }
        public nothrow void Offset(float dx, float dy)
        {
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                element->Offset(dx, dy);
            }
        }
        public void Draw(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                if (layout == null)
                {
                    layoutPtr.Reset(new Layout(graphics));
                    layout = layoutPtr.Get();
                }
                for (const UniquePtr<DiagramElement>& element : elements)
                {
                    element->Measure(graphics, *layout);
                }
            }
            if (Invalidated())
            {
                ResetInvalidated();
            }
            List<DiagramElement*> relationshipElements;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    element->Draw(graphics, *layout);
                }
                else if (element.Get() is RelationshipElement*)
                {
                    relationshipElements.Add(element.Get());
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Draw(graphics, *layout);
            }
            operation->Draw(graphics, *layout);
            selection->Draw(graphics);
        }
        public nothrow const Layout& GetLayout() const
        {
            return *layout;
        }
        public nothrow Layout& GetLayout()
        {
            return *layout;
        }
        public nothrow void ResetLayout(Layout* layout_)
        {
            layoutPtr.Reset(layout_);
            layout = layoutPtr.Get();
        }
        public nothrow void DeleteSelection()
        {
            if (!selection->IsEmpty())
            {
                selection->Delete();
                ResetSelection();
            }
        }
        public nothrow void Undo()
        {
            commandList.Undo();
            SetChanged();
            Invalidate();
        }
        public nothrow void Redo()
        {
            commandList.Redo();
            SetChanged();
            Invalidate();
        }
        public nothrow inline DiagramElement* GetElementByIndex(int index) const
        {
            return elements.Get(index);
        }
        public nothrow inline void SetElementByIndex(DiagramElement* element, int index)
        {
            if (element != null)
            {
                element->SetDiagram(this);
            }
            elements.Set(index, element);
        }
        public nothrow int GetIndexOfElement(DiagramElement* element)
        {
            int n = elements.Count();
            for (int i = 0; i < n; ++i)
            {
                if (elements.Get(i) == element)
                {
                    return i;
                }
            }
            return -1;
        }
        public inline nothrow int NextIndex() const
        {
            return elements.Count();
        }
        public nothrow void AddElement(DiagramElement* element)
        {
            element->SetDiagram(this);
            elements.Add(element);
            SetChanged();
            Invalidate();
        }
        public nothrow UniquePtr<DiagramElement> RemoveElementByIndex(int index)
        {
            UniquePtr<DiagramElement> element = elements.Remove(index);
            SetChanged();
            Invalidate();
            return element;
        }
        public nothrow void InsertElement(DiagramElement* element, int index)
        {
            element->SetDiagram(this);
            elements.Insert(index, element);
        }
        public nothrow DiagramElement* ReleaseElementByIndex(int index)
        {
            return elements.Release(index);
        }
        public nothrow int GetIndexOfElementAt(const PointF& location) const
        {
            Contains<DiagramElement> pred(location);
            return IndexOf(elements, pred);
        }
        public nothrow bool HasIntersectingContrainerElements(const RectF& rect) const
        {
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element.Get());
                    if (containerElement->IntersectsWith(rect))
                    {
                        return true;
                    }
                }
            }
            return false;
        }
        public nothrow int GetNumberOfIntersectingContainerElements(const RectF& rect) const
        {
            int count = 0;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element.Get());
                    if (containerElement->IntersectsWith(rect))
                    {
                        ++count;
                    }
                }
            }
            return count;
        }
        public nothrow List<int> GetIntersectingContainerElementIndeces(const RectF& rect) const
        {
            List<int> indeces;
            int n = elements.Count();
            for (int i = 0; i < n; ++i)
            {
                DiagramElement* element = GetElementByIndex(i);
                if (element is ContainerElement*)
                {
                    ContainerElement* containerElement = cast<ContainerElement*>(element);
                    if (containerElement->IntersectsWith(rect))
                    {
                        indeces.Add(i);
                    }
                }
            }
            return indeces;
        }
        public nothrow spring.Selection* GetSelection()
        {
            return selection.Get();
        }
        public nothrow void SetSelection(spring.Selection* selection_)
        {
            selection->Clear();
            selection.Reset(selection_);
            if (!selection->IsEmpty())
            {
                EnableCopy();
                EnableCut();
            }
            else
            {
                DisableCopy();
                DisableCut();
            }
        }
        public nothrow void ResetSelection()
        {
            selection->Clear();
            DisposeContextMenu();
            selection.Reset(new EmptySelection(*this));
            DisableCopy();
            DisableCut();
            SetChanged();
            Invalidate();
        }
        public nothrow void EnableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCopy();
            }
        }
        public nothrow void EnableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCut();
            }
        }
        public nothrow void DisableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCopy();
            }
        }
        public nothrow void DisableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCut();
            }
        }
        public void Paste(const ustring& clipboardData)
        {
            UniquePtr<AddElementsCommand> addElementsCommand(new AddElementsCommand(*this));
            UniquePtr<System.Dom.Document> diagramElementDoc = System.Dom.ParseDocument(clipboardData, "clipboard");
            UniquePtr<XPathObject> result = Evaluate(u"/spring.diagram.elements/*", diagramElementDoc.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    UniquePtr<ElementSelection> elementSelection(new ElementSelection(*this));
                    List<RelationshipElement*> relationshipElements;
                    HashMap<int, int> indexMap;
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->Read(element);
                            int index = elements.Count();
                            if (diagramElement.Get() is RelationshipElement*)
                            {
                                relationshipElements.Add(cast<RelationshipElement*>(diagramElement.Get()));
                            }
                            AddElement(diagramElement.Release());
                            indexMap[i] = index;
                            elementSelection->Add(index);
                            addElementsCommand->AddIndex(index);
                        }
                    }
                    for (RelationshipElement* relationship : relationshipElements)
                    {
                        relationship->MapIndeces(indexMap);
                        relationship->Resolve();
                    }
                    SetSelection(elementSelection.Release());
                    commandList.AddCommand(addElementsCommand.Release());
                }
            }
        }
        public nothrow inline Operation* GetOperation() const
        {
            return operation.Get();
        }
        public nothrow void SetOperation(Operation* operation_)
        {
            operation.Reset(operation_);
        }
        public void AdvanceOperation(MouseArgs& args)
        {
            if (!(operation.Get() is EmptyOperation*))
            {
                operation->AdvanceTo(args);
                SetChanged();
                Invalidate();
            }
        }
        public void CancelOperation()
        {
            operation->Cancel();
            ResetOperation();
            Tools.SetCurrent(Tools.GetSelectTool());
            SetChanged();
            Invalidate();
        }
        public void CommitOperation(MouseArgs& args)
        {
            operation->Commit(args);
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public nothrow void ResetOperation()
        {
            operation.Reset(new EmptyOperation());
        }
        public void DisposeContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->RemoveContextMenu();
        }
        public void HideContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->HideContextMenu();
        }
        private nothrow inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        public nothrow inline void SetChanged()
        {
            if (!Changed())
            {
                flags = cast<Flags>(flags | Flags.changed);
                SetModified();
            }
        }
        private nothrow inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public nothrow inline bool Modified() const
        {
            return (flags & Flags.modified) != Flags.none;
        }
        public nothrow void SetModified()
        {
            flags = cast<Flags>(flags | Flags.modified);
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                if (modifiedStatusBarItem != null)
                {
                    modifiedStatusBarItem->SetText("*");
                }
            }
        }
        public nothrow void ResetModified()
        {
            if (Modified())
            {
                flags = cast<Flags>(flags & ~Flags.modified);
                Canvas* canvas = GetCanvas();
                if (canvas != null)
                {
                    StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                    if (modifiedStatusBarItem != null)
                    {
                        modifiedStatusBarItem->SetText(" ");
                    }
                }
            }
        }
        public nothrow inline bool Invalidated() const
        {
            return (flags & Flags.invalidated) != Flags.none;
        }
        public nothrow void Invalidate()
        {
            if (!Invalidated())
            {
                flags = cast<Flags>(flags | Flags.invalidated);
                if (canvas != null)
                {
                    canvas->Invalidate();
                }
            }
        }
        public nothrow inline void ResetInvalidated()
        {
            flags = cast<Flags>(flags & ~Flags.invalidated);
        }
        public nothrow inline CommandList& GetCommandList()
        {
            return commandList;
        }
        private Flags flags;
        private Canvas* canvas;
        private Layout* layout;
        private UniquePtr<Layout> layoutPtr;
        private IndexList<DiagramElement> elements;
        private UniquePtr<spring.Selection> selection;
        private UniquePtr<Operation> operation;
        private CommandList commandList;
    }

    public abstract class DiagramElement
    {
        private enum Flags : sbyte
        {
            none = 0, selected = 1 << 0
        }
        public nothrow DiagramElement() : name()
        {
        }
        public nothrow DiagramElement(const string& name_) : name(name_)
        {
        }
        suppress DiagramElement(const DiagramElement&);
        suppress void operator=(const DiagramElement&);
        suppress DiagramElement(DiagramElement&&);
        suppress void operator=(DiagramElement&&);
        public virtual nothrow void Offset(float dx, float dy)
        {
            boundingRect.location.Offset(dx, dy);
        }
        public virtual nothrow bool IntersectsWith(const RectF& rect) const
        {
            return boundingRect.IntersectsWith(rect);
        }
        public virtual void Draw(Graphics& graphics, Layout& layout)
        {
            if (IsSelected())
            {
                DrawSelected(graphics, layout);
            }
        }
        public abstract System.Dom.Element* CreateDomElement() const;
        public abstract DiagramElement* Clone() const;
        public abstract void Measure(Graphics& graphics, Layout& layout);
        public virtual nothrow ContainerElement* GetContainerElement() const
        {
            return null;
        }
        public virtual nothrow void Resolve()
        {
        }
        public virtual nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            return Endpoint();
        }
        public virtual nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            return List<Endpoint>();
        }
        public virtual nothrow void AddRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void RemoveRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            MenuItem* deleteMenuItem = new MenuItem("Delete");
            contextMenu->AddMenuItemAction(deleteMenuItem, new DeleteDiagramElementAction(diagram, elementIndex));
        }
        public virtual void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const ColorElement& selectedColorElement = layout.GetSelectedColorElement();
            const Brush* selectedBrush = selectedColorElement.GetBrush(layout);
            graphics.FillRectangleChecked(*selectedBrush, boundingRect);
        }
        public nothrow inline const string& Name() const
        {
            return name;
        }
        public nothrow void SetName(const string& name_)
        {
            name = name_;
        }
        public nothrow inline const PointF& Location() const
        {
            return boundingRect.location;
        }
        public nothrow inline void SetLocation(const PointF& location)
        {
            boundingRect.location = location;
        }
        public virtual nothrow void SetCompoundLocation(const CompoundLocation& compoundLocation)
        {
            boundingRect.location = compoundLocation.Location();
        }
        public virtual nothrow CompoundLocation GetCompoundLocation() const
        {
            return CompoundLocation(Location());
        }
        public nothrow inline const SizeF& GetSize() const
        {
            return boundingRect.size;
        }
        public nothrow inline void SetSize(const SizeF& size)
        {
            boundingRect.size = size;
        }
        public nothrow virtual RectF BoundingRect() const
        {
            return boundingRect;
        }
        public nothrow PointF Center() const
        {
            return PointF(boundingRect.location.x + boundingRect.size.w / 2, boundingRect.location.y + boundingRect.size.h / 2);
        }
        public virtual nothrow bool Contains(const PointF& location)
        {
            return boundingRect.Contains(location);
        }
        public virtual void Read(System.Dom.Element* parentElement)
        {
            name = ToUtf8(parentElement->GetAttribute(u"name"));
            UniquePtr<XPathObject> result = Evaluate(u"boundingRect", parentElement);
            if (!result.IsNull())
            {
                if (result->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* boundingRectElement = cast<System.Dom.Element*>(node);
                            string x = ToUtf8(boundingRectElement->GetAttribute(u"x"));
                            string y = ToUtf8(boundingRectElement->GetAttribute(u"y"));
                            string w = ToUtf8(boundingRectElement->GetAttribute(u"w"));
                            string h = ToUtf8(boundingRectElement->GetAttribute(u"h"));
                            boundingRect = RectF(PointF(ParseFloat(x), ParseFloat(y)), SizeF(ParseFloat(w), ParseFloat(h)));
                        }
                    }
                }
            }
        }
        public virtual void Write(System.Dom.Element* parentElement)
        {
            parentElement->SetAttribute(u"name", ToUtf32(name));
            UniquePtr<System.Dom.Element> boundingRectElement(new System.Dom.Element(u"boundingRect"));
            boundingRectElement->SetAttribute(u"x", ToUtf32(System.ToString(boundingRect.location.x)));
            boundingRectElement->SetAttribute(u"y", ToUtf32(System.ToString(boundingRect.location.y)));
            boundingRectElement->SetAttribute(u"w", ToUtf32(System.ToString(boundingRect.size.w)));
            boundingRectElement->SetAttribute(u"h", ToUtf32(System.ToString(boundingRect.size.h)));
            parentElement->AppendChild(UniquePtr<System.Dom.Node>(boundingRectElement.Release()));
        }
        public virtual void SetFrom(DiagramElement* that)
        {
            name = that->name;
            boundingRect = that->boundingRect;
        }
        public nothrow inline bool IsSelected() const
        {
            return (flags & Flags.selected) != Flags.none;
        }
        public nothrow void Select()
        {
            if (!IsSelected())
            {
                flags = cast<Flags>(flags | Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void ResetSelected()
        {
            if (IsSelected())
            {
                flags = cast<Flags>(flags & ~Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void SetDiagram(Diagram* diagram_)
        {
            diagram = diagram_;
        }
        public nothrow inline Diagram* GetDiagram() const
        {
            return diagram;
        }
        private Flags flags;
        private string name;
        private RectF boundingRect;
        private Diagram* diagram;
    }

    public enum SnapPoint : sbyte
    {
        none, top, bottom, left, right, center, operation, field
    }

    public nothrow string ToString(SnapPoint snapPoint)
    {
        switch (snapPoint)
        {
            case SnapPoint.none: return "none";
            case SnapPoint.top: return "top";
            case SnapPoint.bottom: return "bottom";
            case SnapPoint.left: return "left";
            case SnapPoint.right: return "right";
            case SnapPoint.center: return "center";
            case SnapPoint.operation: return "operation";
            case SnapPoint.field: return "field";
        }
        return string();
    }

    public nothrow SnapPoint ParseSnapPoint(const string& str)
    {
        if (str == "none")
        {
            return SnapPoint.none;
        }
        else if (str == "top")
        {
            return SnapPoint.top;
        }
        else if (str == "bottom")
        {
            return SnapPoint.bottom;
        }
        else if (str == "left")
        {
            return SnapPoint.left;
        }
        else if (str == "right")
        {
            return SnapPoint.right;
        }
        else if (str == "center")
        {
            return SnapPoint.center;
        }
        else if (str == "operation")
        {
            return SnapPoint.operation;
        }
        else if (str == "field")
        {
            return SnapPoint.field;
        }
        return SnapPoint.none;
    }

    public class Snap
    {
        public nothrow constexpr Snap() : primaryPoint(SnapPoint.none), secondaryPoint(SnapPoint.none)
        {
        }
        public nothrow constexpr Snap(SnapPoint primaryPoint_, SnapPoint secondaryPoint_) : primaryPoint(primaryPoint_), secondaryPoint(secondaryPoint_)
        {
        }
        public explicit constexpr nothrow Snap(int x) : primaryPoint(cast<SnapPoint>(cast<sbyte>((x >> 8) & 0xff))), secondaryPoint(cast<SnapPoint>(cast<sbyte>(x & 0xff)))
        {
        }
        public static nothrow constexpr inline int TopLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int TopCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int TopRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int LeftTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int LeftCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int LeftBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public static nothrow constexpr inline int BottomLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int BottomCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int BottomRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int RightTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int RightCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int RightBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public static nothrow constexpr inline int Operation(sbyte index)
        {
            return cast<int>(cast<sbyte>(SnapPoint.operation)) << 8 | cast<int>(index);
        }
        public static nothrow constexpr inline int Field(sbyte index)
        {
            return cast<int>(cast<sbyte>(SnapPoint.field)) << 8 | cast<int>(index);
        }
        public nothrow string ToString() const
        {
            if (primaryPoint == SnapPoint.operation || primaryPoint == SnapPoint.field)
            {
                return spring.ToString(primaryPoint) + "." + System.ToString(cast<sbyte>(secondaryPoint));
            }
            return spring.ToString(primaryPoint) + "." + spring.ToString(secondaryPoint);
        }
        public nothrow constexpr inline int ToInt() const
        {
            return cast<int>(cast<sbyte>(primaryPoint)) << 8 | cast<int>(cast<sbyte>(secondaryPoint));
        }
        public nothrow PointF Calculate(const PointF& point, float w, int index, int count)
        {
            int s = ToInt();
            switch (s)
            {
                case TopLeft():
                case BottomLeft():
                {
                    return PointF(point.x + index * w, point.y);
                }
                case TopRight():
                case BottomRight():
                {
                    return PointF(point.x - index * w, point.y);
                }
                case LeftTop():
                case RightTop():
                {
                    return PointF(point.x, point.y + index * w);
                }
                case LeftBottom():
                case RightBottom():
                {
                    return PointF(point.x, point.y - index * w);
                }
                case LeftCenter():
                case RightCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x, point.y - (count / 2) * w + index * w + w / 2);
                    }
                    else
                    {
                        return PointF(point.x, point.y - (count / 2) * w + index * w);
                    }
                }
                case TopCenter():
                case BottomCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x - (count / 2) * w + index * w + w / 2, point.y);
                    }
                    else
                    {
                        return PointF(point.x - (count / 2) * w + index * w, point.y);
                    }
                }
            }
            return PointF();
        }
        public SnapPoint primaryPoint;
        public SnapPoint secondaryPoint;
    }

    public nothrow Snap ParseSnap(const string& str)
    {
        List<string> components = str.Split(".");
        if (components.Count() == 2)
        {
            SnapPoint primary = ParseSnapPoint(components[0]);
            if (primary == SnapPoint.operation || primary == SnapPoint.field)
            {
                Snap snap(primary, cast<SnapPoint>(ParseSByte(components[1])));
                return snap;
            }
            else
            {
                Snap snap(primary, ParseSnapPoint(components[1]));
                return snap;
            }
        }
        return Snap();
    }

    public nothrow constexpr inline bool operator==(const Snap& left, const Snap& right)
    {
        return left.primaryPoint == right.primaryPoint && left.secondaryPoint == right.secondaryPoint;
    }

    public nothrow constexpr inline bool operator<(const Snap& left, const Snap& right)
    {
        if (left.primaryPoint < right.primaryPoint) return true;
        if (left.primaryPoint > right.primaryPoint) return false;
        return left.secondaryPoint < right.secondaryPoint;
    }

    public enum Cardinality : sbyte
    {
        zero, one, many
    }

    public nothrow Cardinality ParseCardinality(const string& s)
    {
        if (s == "zero")
        {
            return Cardinality.zero;
        }
        else if (s == "one")
        {
            return Cardinality.one;
        }
        else if (s == "many")
        {
            return Cardinality.many;
        }
        return Cardinality.zero;
    }

    public nothrow string ToString(Cardinality cardinality)
    {
        switch (cardinality)
        {
            case Cardinality.zero: return "zero";
            case Cardinality.one: return "one";
            case Cardinality.many: return "many";
        }
        return string();
    }

    public class EndpointNearer : Rel<Endpoint*>
    {
        public nothrow EndpointNearer(const PointF& location_) : location(location_)
        {
        }
        public nothrow bool operator()(Endpoint* left, Endpoint* right) const
        {
            return System.Windows.Distance(left->point, location) < System.Windows.Distance(right->point, location);
        }
        private PointF location;
    }

    public enum EndpointType
    {
        source, target
    }

    public class Endpoint
    {
        public nothrow Endpoint() : element(null), snap(), point(0, 0), text()
        {
        }
        public nothrow Endpoint(DiagramElement* element_, const Snap& snap_, const PointF& point_) : element(element_), snap(snap_), point(point_), text()
        {
        }
        public nothrow string ToString() const
        {
            if (element != null)
            {
                return "endpoint." + element->Name() + "." + snap.ToString() + "." + point.ToString() + "." + text;
            }
            return "endpoint.null";
        }
        public void Write(System.Dom.Element* parentElement)
        {
            if (index != -1)
            {
                parentElement->SetAttribute(u"index", ToUtf32(ToString(index)));
            }
            parentElement->SetAttribute(u"snap", ToUtf32(snap.ToString()));
            parentElement->SetAttribute(u"x", ToUtf32(ToString(point.x)));
            parentElement->SetAttribute(u"y", ToUtf32(ToString(point.y)));
            parentElement->SetAttribute(u"text", ToUtf32(text));
        }
        public void Read(System.Dom.Element* parentElement)
        {
            ustring indexStr = parentElement->GetAttribute(u"index");
            if (indexStr.IsEmpty())
            {
                index = -1;
            }
            else
            {
                index = ParseInt(ToUtf8(indexStr));
            }
            snap = ParseSnap(ToUtf8(parentElement->GetAttribute(u"snap")));
            point.x = ParseFloat(ToUtf8(parentElement->GetAttribute(u"x")));
            point.y = ParseFloat(ToUtf8(parentElement->GetAttribute(u"y")));
            text = ToUtf8(parentElement->GetAttribute(u"text"));
        }
        public void Resolve(Diagram* diagram)
        {
            if (index != -1)
            {
                element = diagram->GetElementByIndex(index);
                if (snap.primaryPoint == SnapPoint.field)
                {
                    if (element is ContainerElement*)
                    {
                        ContainerElement* containerElement = cast<ContainerElement*>(element);
                        element = containerElement->GetField(cast<sbyte>(snap.secondaryPoint));
                    }
                    else
                    {
                        throw Exception("container element expected");
                    }
                }
                else if (snap.primaryPoint == SnapPoint.operation)
                {
                    if (element is ContainerElement*)
                    {
                        ContainerElement* containerElement = cast<ContainerElement*>(element);
                        element = containerElement->GetOperation(cast<sbyte>(snap.secondaryPoint));
                    }
                    else
                    {
                        throw Exception("container element expected");
                    }
                }
            }
            else
            {
                element = null;
            }
        }
        public void SetIndex(const HashMap<ContainerElement*, int>& containerElementIndexMap)
        {
            if (element != null)
            {
                ContainerElement* containerElement = element->GetContainerElement();
                HashMap<ContainerElement*, int>.ConstIterator it = containerElementIndexMap.CFind(containerElement);
                if (it != containerElementIndexMap.CEnd())
                {
                    index = it->second;
                }
                else
                {
                    throw Exception("index for container element '" + containerElement->Name() + "' not found");
                }
            }
            else
            {
                index = -1;
            }
        }
        public void MapIndex(const HashMap<int, int>& indexMap)
        {
            if (index != -1)
            {
                HashMap<int, int>.ConstIterator it = indexMap.CFind(index);
                if (it != indexMap.CEnd())
                {
                    index = it->second;
                }
                else
                {
                    throw Exception("index not found from index map");
                }
            }
        }
        public DiagramElement* element;
        public Snap snap;
        public PointF point;
        public string text;
        private int index;
    }

    public class DecreasingOrderBySecond : Rel<Pair<int, int>>
    {
        public inline nothrow bool operator()(const Pair<int, int>& left, const Pair<int, int>& right) const
        {
            return left.second > right.second;
        }
    }

    public class RelationshipElement : DiagramElement
    {
        public enum Kind
        {
            none, inheritance, aggregation, reference, createInstance, attachNote
        }
        public nothrow RelationshipElement() : base(), kind(Kind.none), source(), target(), sourceEndpoints(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        public nothrow RelationshipElement(Kind kind_) : base(), kind(kind_), source(), target(), sourceEndpoints(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        suppress RelationshipElement(const RelationshipElement&);
        suppress void operator=(const RelationshipElement&);
        suppress RelationshipElement(RelationshipElement&&);
        suppress void operator=(RelationshipElement&&);
        public nothrow override RectF BoundingRect() const
        {
            RectF boundingRect;
            PointF minPoint(99999999999.9f, 99999999999.9f);
            PointF maxPoint(-1, -1);
            if (source.element != null)
            {
                minPoint.x = Min(source.point.x, minPoint.x);
                minPoint.y = Min(source.point.y, minPoint.y);
            }
            for (const Endpoint& sourceEndpoint : sourceEndpoints)
            {
                minPoint.x = Min(sourceEndpoint.point.x, minPoint.x);
                minPoint.y = Min(sourceEndpoint.point.y, minPoint.y);
                maxPoint.x = Max(sourceEndpoint.point.x, maxPoint.x);
                maxPoint.y = Max(sourceEndpoint.point.y, maxPoint.y);
            }
            minPoint.x = Min(target.point.x, minPoint.x);
            minPoint.y = Min(target.point.y, minPoint.y);
            maxPoint.x = Max(source.point.x, maxPoint.x);
            maxPoint.y = Max(source.point.y, maxPoint.y);
            maxPoint.x = Max(target.point.x, maxPoint.x);
            maxPoint.y = Max(target.point.y, maxPoint.y);
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                minPoint.x = Min(intermediatePoint.x, minPoint.x);
                minPoint.y = Min(intermediatePoint.y, minPoint.y);
                maxPoint.x = Max(intermediatePoint.x, maxPoint.x);
                maxPoint.y = Max(intermediatePoint.y, maxPoint.y);
            }
            boundingRect.location.x = minPoint.x;
            boundingRect.location.y = minPoint.y;
            boundingRect.size.w = maxPoint.x - minPoint.x;
            boundingRect.size.h = maxPoint.y - minPoint.y;
            return boundingRect;
        }
        public override nothrow void Offset(float dx, float dy)
        {
            source.point.Offset(dx, dy);
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                sourceEndpoint.point.Offset(dx, dy);
            }
            for (PointF& intermediatePoint : intermediatePoints)
            {
                intermediatePoint.Offset(dx, dy);
            }
            target.point.Offset(dx, dy);
        }
        public override nothrow bool IntersectsWith(const RectF& rect) const
        {
            if (rect.Contains(source.point)) return true;
            for (const Endpoint& sourceEndpoint : sourceEndpoints)
            {
                if (rect.Contains(sourceEndpoint.point)) return true;
            }
            if (rect.Contains(target.point)) return true;
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                if (rect.Contains(intermediatePoint)) return true;
            }
            return BoundingRect().IntersectsWith(rect);
        }
        public override nothrow void SetCompoundLocation(const CompoundLocation& compoundLocation)
        {
            SetLocation(compoundLocation.Location());
            intermediatePoints = compoundLocation.Points();
            if (kind == Kind.reference && cardinality == Cardinality.zero)
            {
                target.point = compoundLocation.TargetPoint();
            }
        }
        public override nothrow CompoundLocation GetCompoundLocation() const
        {
            CompoundLocation compoundLocation(Location(), intermediatePoints);
            if (kind == Kind.reference && cardinality == Cardinality.zero)
            {
                compoundLocation.SetTargetPoint(target.point);
            }
            return compoundLocation;
        }
        public nothrow int MainDirection() const
        {
            if (sourceEndpoints.IsEmpty())
            {
                if (source.element != null && target.element != null)
                {
                    return MainDirection(source.element, target.element);
                }
            }
            else if (target.element != null)
            {
                LogView* log = Application.GetLogView();
                Map<int, int> directionMap;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        Line line(target.element->Center(), sourceEndpoint.element->Center());
                        Vector v = line.ToVector();
                        if (v.x > 0) ++directionMap[180];
                        if (v.y > 0) ++directionMap[270];
                        if (v.x < 0) ++directionMap[0];
                        if (v.y < 0) ++directionMap[90];
                    }
                }
                List<Pair<int, int>> directionList;
                for (const Pair<int, int>& p : directionMap)
                {
                    directionList.Add(p);
                }
                Sort(directionList.Begin(), directionList.End(), DecreasingOrderBySecond());
                Pair<int, int> max = directionList.Front();
                if (log != null)
                {
                    log->WriteLine("MainDirection: " + ToString(max.first) + ", " + ToString(max.second));
                }
                return max.first;
            }
            return 0;
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* straightenMenuItem = new MenuItem("Straighten");
            contextMenu->AddMenuItemAction(straightenMenuItem, new StraightenRelationshipElementAction(diagram, elementIndex));
            if (kind == Kind.inheritance && !sourceEndpoints.IsEmpty())
            {
                MenuItem* splitMenuItem = new MenuItem("Split");
                contextMenu->AddMenuItemAction(splitMenuItem, new SplitRelationshipElementAction(diagram, elementIndex));
            }
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new RelationshipElementPropertiesAction(diagram, elementIndex));
        }
        public nothrow void Straighten()
        {
            if (!intermediatePoints.IsEmpty())
            {
                PointF prev = source.point;
                for (PointF& next : intermediatePoints)
                {
                    Line line(prev, next);
                    Vector v(line.ToVector());
                    switch (MainDirection(v))
                    {
                        case 0:
                        case 180:
                        {
                            next.y = prev.y;
                            break;
                        }
                        case 90:
                        case 270:
                        {
                            next.x = prev.x;
                            break;
                        }
                    }
                    prev = next;
                }
                if (!intermediatePoints.IsEmpty())
                {
                    PointF& last = intermediatePoints.Back();
                    Line line(last, target.point);
                    Vector v(line.ToVector());
                    switch (MainDirection(v))
                    {
                        case 0:
                        case 180:
                        {
                            last.y = target.point.y;
                            break;
                        }
                        case 90:
                        case 270:
                        {
                            last.x = target.point.x;
                            break;
                        }
                    }
                }
            }
            else
            {
                if (kind == Kind.inheritance && !sourceEndpoints.IsEmpty())
                {
                    if (target.element != null && sourceEndpoints.Count() >= 2)
                    {
                        int direction = MainDirection();
                        switch (direction)
                        {
                            case 90:
                            case 270:
                            {
                                float minX = 9999999.9f;
                                float maxX = -1.0f;
                                for (const Endpoint& endpoint : sourceEndpoints)
                                {
                                    if (endpoint.point.x < minX) minX = endpoint.point.x;
                                    if (endpoint.point.x > maxX) maxX = endpoint.point.x;
                                }
                                float targetX = minX + (maxX - minX) / 2;
                                float dx = targetX - target.element->Center().x;
                                target.element->Offset(dx, 0.0f);
                                break;
                            }
                            case 0:
                            case 180:
                            {
                                float minY = 9999999.9f;
                                float maxY = -1.0f;
                                for (const Endpoint& endpoint : sourceEndpoints)
                                {
                                    if (endpoint.point.y < minY) minY = endpoint.point.y;
                                    if (endpoint.point.y > maxY) maxY = endpoint.point.y;
                                }
                                float targetY = minY + (maxY - minY) / 2;
                                float dy = targetY - target.element->Center().y;
                                target.element->Offset(0.0f, dy);
                                break;
                            }
                        }
                    }
                }
                else
                {
                    Line line(source.point, target.point);
                    Vector v(line.ToVector());
                    switch (MainDirection(v))
                    {
                        case 0:
                        case 180:
                        {
                            if (target.element != null)
                            {
                                float dy = source.point.y - target.point.y;
                                target.element->Offset(0.0f, dy);
                            }
                            else
                            {
                                target.point.y = source.point.y;
                            }
                            break;
                        }
                        case 90:
                        case 270:
                        {
                            if (target.element != null)
                            {
                                float dx = source.point.x - target.point.x;
                                target.element->Offset(dx, 0.0f);
                            }
                            else
                            {
                                target.point.x = source.point.x;
                            }
                            break;
                        }
                    }
                }
            }
        }
        public override nothrow bool Contains(const PointF& location)
        {
            Diagram* diagram = GetDiagram();
            const Layout& layout = diagram->GetLayout();
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            float selectedLineWidth = relationshipLayoutElement.SelectedLineWidth();
            if (kind == Kind.inheritance && !sourceEndpoints.IsEmpty())
            {
                return ContainsCombinedInheritance(location, selectedLineWidth, layout);
            }
            else
            {
                PointF from = source.point;
                for (PointF to : intermediatePoints)
                {
                    if (Contains(from, to, location, selectedLineWidth))
                    {
                        return true;
                    }
                    from = to;
                }
                PointF to = target.point;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    PointF from = sourceEndpoint.point;
                    if (Contains(from, to, location, selectedLineWidth))
                    {
                        return true;
                    }
                }
                if (Contains(from, to, location, selectedLineWidth))
                {
                    return true;
                }
            }
            return false;
        }
        public nothrow bool Contains(const PointF& from, const PointF& to, const PointF& loc, float selectedLineWidth)
        {
            Line line(from, to);
            Line lineToLoc(from, loc);
            Vector a(line.ToVector());
            Vector b(lineToLoc.ToVector());
            float f = ProjectionFactor(b, a);
            if (f >= 0 && f <= a.Length())
            {
                Vector c = Projection(b, a);
                Vector d = b - c;
                if (d.Length() <= selectedLineWidth / 2)
                {
                    return true;
                }
            }
            return false;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"relationship");
        }
        public override DiagramElement* Clone() const
        {
            RelationshipElement* clone = new RelationshipElement();
            clone->SetFrom(this);
            return clone;
        }
        public nothrow Kind ParseRelationshipKind(const string& str)
        {
            if (str == "none")
            {
                return Kind.none;
            }
            else if (str == "inheritance")
            {
                return Kind.inheritance;
            }
            else if (str == "aggregation")
            {
                return Kind.aggregation;
            }
            else if (str == "reference")
            {
                return Kind.reference;
            }
            else if (str == "createInstance")
            {
                return Kind.createInstance;
            }
            else if (str == "attachNote")
            {
                return Kind.attachNote;
            }
            return Kind.none;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            kind = ParseRelationshipKind(ToUtf8(element->GetAttribute(u"kind")));
            UniquePtr<XPathObject> sourceResult = Evaluate(u"source", element);
            if (!sourceResult.IsNull())
            {
                if (sourceResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(sourceResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            source.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> sourceEndpointsResult = Evaluate(u"sourceEndpoint", element);
            if (!sourceEndpointsResult.IsNull())
            {
                if (sourceEndpointsResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(sourceEndpointsResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            Endpoint source;
                            source.Read(element);
                            sourceEndpoints.Add(source);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> targetResult = Evaluate(u"target", element);
            if (!targetResult.IsNull())
            {
                if (targetResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(targetResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            target.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> intermediatePointsResult = Evaluate(u"intermediatePoint", element);
            if (!intermediatePointsResult.IsNull())
            {
                if (intermediatePointsResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(intermediatePointsResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            PointF intermediatePoint;
                            intermediatePoint.x = ParseFloat(ToUtf8(element->GetAttribute(u"x")));
                            intermediatePoint.y = ParseFloat(ToUtf8(element->GetAttribute(u"y")));
                            intermediatePoints.Add(intermediatePoint);
                        }
                    }
                }
            }
            cardinality = ParseCardinality(ToUtf8(element->GetAttribute(u"cardinality")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            switch (kind)
            {
                case Kind.none: element->SetAttribute(u"kind", u"none"); break;
                case Kind.inheritance: element->SetAttribute(u"kind", u"inheritance"); break;
                case Kind.aggregation: element->SetAttribute(u"kind", u"aggregation"); break;
                case Kind.reference: element->SetAttribute(u"kind", u"reference"); break;
                case Kind.createInstance: element->SetAttribute(u"kind", u"createInstance"); break;
                case Kind.attachNote: element->SetAttribute(u"kind", u"attachNote"); break;
            }
            System.Dom.Element* sourceElement = new System.Dom.Element(u"source");
            source.Write(sourceElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(sourceElement));
            if (!sourceEndpoints.IsEmpty())
            {
                for (const Endpoint& source : sourceEndpoints)
                {
                    System.Dom.Element* sourceEndpointElement = new System.Dom.Element(u"sourceEndpoint");
                    source.Write(sourceEndpointElement);
                    element->AppendChild(UniquePtr<System.Dom.Node>(sourceEndpointElement));
                }
            }
            System.Dom.Element* targetElement = new System.Dom.Element(u"target");
            target.Write(targetElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(targetElement));
            int n = cast<int>(intermediatePoints.Count());
            for (int i = 0; i < n; ++i)
            {
                System.Dom.Element* intermediatePointElement = new System.Dom.Element(u"intermediatePoint");
                intermediatePointElement->SetAttribute(u"x", ToUtf32(ToString(intermediatePoints[i].x)));
                intermediatePointElement->SetAttribute(u"y", ToUtf32(ToString(intermediatePoints[i].y)));
                element->AppendChild(UniquePtr<System.Dom.Node>(intermediatePointElement));
            }
            element->SetAttribute(u"cardinality", ToUtf32(ToString(cardinality)));
        }
        public nothrow override void Resolve()
        {
            source.Resolve(GetDiagram());
            if (source.element != null)
            {
                source.element->AddRelationship(this);
            }
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                sourceEndpoint.Resolve(GetDiagram());
                if (sourceEndpoint.element != null)
                {
                    sourceEndpoint.element->AddRelationship(this);
                }
            }
            target.Resolve(GetDiagram());
            if (target.element != null)
            {
                target.element->AddRelationship(this);
            }
        }
        public nothrow void SetContainerElementIndeces(const HashMap<ContainerElement*, int>& containerElementIndexMap)
        {
            source.SetIndex(containerElementIndexMap);
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                sourceEndpoint.SetIndex(containerElementIndexMap);
            }
            target.SetIndex(containerElementIndexMap);
        }
        public void MapIndeces(const HashMap<int, int>& indexMap)
        {
            source.MapIndex(indexMap);
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                sourceEndpoint.MapIndex(indexMap);
            }
            target.MapIndex(indexMap);
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            StringFormat stringFormat;
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Font& font = relationshipLayoutElement.GetFontElement().GetFont();
            if (!source.text.IsEmpty())
            {
                RectF r = graphics.MeasureStringChecked(source.text, font, PointF(), stringFormat);
                sourceTextSize = r.size;
            }
            else
            {
                sourceTextSize = SizeF();
            }
            if (!target.text.IsEmpty())
            {
                RectF r = graphics.MeasureStringChecked(target.text, font, PointF(), stringFormat);
                targetTextSize = r.size;
            }
            else
            {
                targetTextSize = SizeF();
            }
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            switch (kind)
            {
                case Kind.inheritance:
                {
                    DrawInheritance(graphics, layout);
                    break;
                }
                case Kind.aggregation:
                {
                    DrawAggregation(graphics, layout);
                    break;
                }
                case Kind.reference:
                {
                    DrawReference(graphics, layout);
                    break;
                }
                case Kind.createInstance:
                {
                    DrawCreateInstance(graphics, layout);
                    break;
                }
                case Kind.attachNote:
                {
                    DrawAttachNote(graphics, layout);
                    break;
                }
            }
        }
        protected override void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& selectedLinePen = relationshipLayoutElement.SelectedLinePen();
            if (kind == Kind.inheritance && !sourceEndpoints.IsEmpty())
            {
                DrawCombinedInheritanceSelected(graphics, layout, selectedLinePen);
            }
            else
            {
                PointF prev = source.point;
                for (PointF next : intermediatePoints)
                {
                    graphics.DrawLineChecked(selectedLinePen, prev, next);
                    prev = next;
                }
                graphics.DrawLineChecked(selectedLinePen, prev, target.point);
            }
        }
        public nothrow void Calculate(const Snap& snap, DiagramElement* element, float w, int index, int count)
        {
            Endpoint endpoint = element->GetEndpoint(snap);
            if (source.element == element && source.snap == snap)
            {
                source.point = snap.Calculate(endpoint.point, w, index, count);
            }
            if (target.element == element && target.snap == snap)
            {
                target.point = snap.Calculate(endpoint.point, w, index, count);
            }
        }
        public nothrow PointF LastPoint() const
        {
            if (intermediatePoints.IsEmpty())
            {
                return source.point;
            }
            else
            {
                return intermediatePoints.Back();
            }
        }
        public nothrow void SetLastPoint(const PointF& lastPoint)
        {
            if (intermediatePoints.IsEmpty())
            {
                source.point = lastPoint;
            }
            else
            {
                intermediatePoints.Back() = lastPoint;
            }
        }
        private void DrawInheritance(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
            float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
            if (!sourceEndpoints.IsEmpty())
            {
                DrawCombinedInheritance(graphics, layout);
            }
            else
            {
                PointF lastPoint;
                if (intermediatePoints.IsEmpty())
                {
                    lastPoint = source.point;
                }
                else
                {
                    PointF prevPoint = source.point;
                    for (const PointF& intermediatePoint : intermediatePoints)
                    {
                        graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                        prevPoint = intermediatePoint;
                    }
                    lastPoint = intermediatePoints.Back();
                }
                Line line(lastPoint, target.point);
                Vector v = line.ToVector();
                float len = v.Length();
                float startLen = Max(0.0f, len - inheritanceArrowHeight);
                Vector u = UnitVector(v) * startLen;
                Line startLine(lastPoint, u);
                graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
                Line arrowLine(startLine.end, target.point);
                Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
                Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                Line arrowRightLine(arrowRightRotatedLine.start, arv);
                graphics.DrawLineChecked(linePen, arrowRightLine.end, target.point);
                Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
                Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
                graphics.DrawLineChecked(linePen, arrowLeftLine.end, target.point);
                graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
            }
        }
        private void DrawCombinedInheritance(Graphics& graphics, Layout& layout)
        {
            int mainDirection = MainDirection();
            switch (mainDirection)
            {
                case 0:
                {
                    DrawCombinedInheritance0(graphics, layout);
                    break;
                }
                case 90:
                {
                    DrawCombinedInheritance90(graphics, layout);
                    break;
                }
                case 180:
                {
                    DrawCombinedInheritance180(graphics, layout);
                    break;
                }
                case 270:
                {
                    DrawCombinedInheritance270(graphics, layout);
                    break;
                }
            }
        }
        private void DrawCombinedInheritance0(Graphics& graphics, Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.LeftCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    const Pen& linePen = relationshipLayoutElement.LinePen();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* rightElement = horizontalOrder.Back();
                    Endpoint rightEndpoint = rightElement->GetEndpoint(Snap(Snap.RightCenter()));
                    PointF rightPoint = rightEndpoint.point;
                    float dx = (targetPoint.x - inheritanceArrowHeight) - rightPoint.x;
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x - inheritanceArrowHeight - w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.RightCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        graphics.DrawLineChecked(linePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(linePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
                    Line arrowLine(startLine.end, targetPoint);
                    Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
                    Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowRightLine(arrowRightRotatedLine.start, arv);
                    graphics.DrawLineChecked(linePen, arrowRightLine.end, targetPoint);
                    Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
                    Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, targetPoint);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
                }
            }
        }
        private void DrawCombinedInheritance90(Graphics& graphics, Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.TopCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    const Pen& linePen = relationshipLayoutElement.LinePen();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* bottomElement = verticalOrder.Back();
                    Endpoint bottomEndpoint = bottomElement->GetEndpoint(Snap(Snap.BottomCenter()));
                    PointF bottomPoint = bottomEndpoint.point;
                    float dy = (targetPoint.y - inheritanceArrowHeight) - bottomPoint.y;
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y - inheritanceArrowHeight - h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.BottomCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        graphics.DrawLineChecked(linePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(linePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
                    Line arrowLine(startLine.end, targetPoint);
                    Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
                    Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowRightLine(arrowRightRotatedLine.start, arv);
                    graphics.DrawLineChecked(linePen, arrowRightLine.end, targetPoint);
                    Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
                    Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, targetPoint);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
                }
            }
        }
        private void DrawCombinedInheritance180(Graphics& graphics, Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.RightCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    const Pen& linePen = relationshipLayoutElement.LinePen();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* leftElement = horizontalOrder.Front();
                    Endpoint leftEndpoint = leftElement->GetEndpoint(Snap(Snap.LeftCenter()));
                    PointF leftPoint = leftEndpoint.point;
                    float dx = leftPoint.x - (targetPoint.x + inheritanceArrowHeight);
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x + inheritanceArrowHeight + w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.LeftCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        graphics.DrawLineChecked(linePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(linePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
                    Line arrowLine(startLine.end, targetPoint);
                    Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
                    Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowRightLine(arrowRightRotatedLine.start, arv);
                    graphics.DrawLineChecked(linePen, arrowRightLine.end, targetPoint);
                    Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
                    Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, targetPoint);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
                }
            }
        }
        private void DrawCombinedInheritance270(Graphics& graphics, Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.BottomCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    const Pen& linePen = relationshipLayoutElement.LinePen();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* topElement = verticalOrder.Front();
                    Endpoint topEndpoint = topElement->GetEndpoint(Snap(Snap.TopCenter()));
                    PointF topPoint = topEndpoint.point;
                    float dy = topPoint.y - (targetPoint.y + inheritanceArrowHeight);
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y + inheritanceArrowHeight + h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.TopCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        graphics.DrawLineChecked(linePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(linePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
                    Line arrowLine(startLine.end, targetPoint);
                    Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
                    Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowRightLine(arrowRightRotatedLine.start, arv);
                    graphics.DrawLineChecked(linePen, arrowRightLine.end, targetPoint);
                    Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
                    Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
                    Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, targetPoint);
                    graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
                }
            }
        }
        private void DrawCombinedInheritanceSelected(Graphics& graphics, Layout& layout, const Pen& selectedLinePen)
        {
            int mainDirection = MainDirection();
            switch (mainDirection)
            {
                case 0:
                {
                    DrawCombinedInheritance0Selected(graphics, layout, selectedLinePen);
                    break;
                }
                case 90:
                {
                    DrawCombinedInheritance90Selected(graphics, layout, selectedLinePen);
                    break;
                }
                case 180:
                {
                    DrawCombinedInheritance180Selected(graphics, layout, selectedLinePen);
                    break;
                }
                case 270:
                {
                    DrawCombinedInheritance270Selected(graphics, layout, selectedLinePen);
                    break;
                }
            }
        }
        private void DrawCombinedInheritance0Selected(Graphics& graphics, Layout& layout, const Pen& selectedLinePen)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.LeftCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* rightElement = horizontalOrder.Back();
                    Endpoint rightEndpoint = rightElement->GetEndpoint(Snap(Snap.RightCenter()));
                    PointF rightPoint = rightEndpoint.point;
                    float dx = (targetPoint.x - inheritanceArrowHeight) - rightPoint.x;
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x - inheritanceArrowHeight - w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.RightCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        graphics.DrawLineChecked(selectedLinePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(selectedLinePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(selectedLinePen, startLine.start, startLine.end);
                }
            }
        }
        private void DrawCombinedInheritance90Selected(Graphics& graphics, Layout& layout, const Pen& selectedLinePen)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.TopCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* bottomElement = verticalOrder.Back();
                    Endpoint bottomEndpoint = bottomElement->GetEndpoint(Snap(Snap.BottomCenter()));
                    PointF bottomPoint = bottomEndpoint.point;
                    float dy = (targetPoint.y - inheritanceArrowHeight) - bottomPoint.y;
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y - inheritanceArrowHeight - h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.BottomCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        graphics.DrawLineChecked(selectedLinePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(selectedLinePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(selectedLinePen, startLine.start, startLine.end);
                }
            }
        }
        private void DrawCombinedInheritance180Selected(Graphics& graphics, Layout& layout, const Pen& selectedLinePen)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.RightCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* leftElement = horizontalOrder.Front();
                    Endpoint leftEndpoint = leftElement->GetEndpoint(Snap(Snap.LeftCenter()));
                    PointF leftPoint = leftEndpoint.point;
                    float dx = leftPoint.x - (targetPoint.x + inheritanceArrowHeight);
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x + inheritanceArrowHeight + w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.LeftCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        graphics.DrawLineChecked(selectedLinePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(selectedLinePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(selectedLinePen, startLine.start, startLine.end);
                }
            }
        }
        private void DrawCombinedInheritance270Selected(Graphics& graphics, Layout& layout, const Pen& selectedLinePen)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.BottomCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* topElement = verticalOrder.Front();
                    Endpoint topEndpoint = topElement->GetEndpoint(Snap(Snap.TopCenter()));
                    PointF topPoint = topEndpoint.point;
                    float dy = topPoint.y - (targetPoint.y + inheritanceArrowHeight);
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y + inheritanceArrowHeight + h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.TopCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        graphics.DrawLineChecked(selectedLinePen, sourcePoint, vpoint);
                        graphics.DrawLineChecked(selectedLinePen, vpoint, crossPoint);
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    graphics.DrawLineChecked(selectedLinePen, startLine.start, startLine.end);
                }
            }
        }
        private bool ContainsCombinedInheritance(const PointF& location, float selectedLineWidth, const Layout& layout)
        {
            int mainDirection = MainDirection();
            switch (mainDirection)
            {
                case 0:
                {
                    return ContainsCombinedInheritance0(location, selectedLineWidth, layout);
                }
                case 90:
                {
                    return ContainsCombinedInheritance90(location, selectedLineWidth, layout);
                }
                case 180:
                {
                    return ContainsCombinedInheritance180(location, selectedLineWidth, layout);
                }
                case 270:
                {
                    return ContainsCombinedInheritance270(location, selectedLineWidth, layout);
                }
            }
            return false;
        }
        private bool ContainsCombinedInheritance0(const PointF& location, float selectedLineWidth, const Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.LeftCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* rightElement = horizontalOrder.Back();
                    Endpoint rightEndpoint = rightElement->GetEndpoint(Snap(Snap.RightCenter()));
                    PointF rightPoint = rightEndpoint.point;
                    float dx = (targetPoint.x - inheritanceArrowHeight) - rightPoint.x;
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x - inheritanceArrowHeight - w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.RightCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        if (Contains(sourcePoint, vpoint, location, selectedLineWidth)) return true;
                        if (Contains(vpoint, crossPoint, location, selectedLineWidth)) return true;
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    if (Contains(startLine.start, startLine.end, location, selectedLineWidth)) return true;
                }
            }
            return false;
        }
        private bool ContainsCombinedInheritance90(const PointF& location, float selectedLineWidth, const Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.TopCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* bottomElement = verticalOrder.Back();
                    Endpoint bottomEndpoint = bottomElement->GetEndpoint(Snap(Snap.BottomCenter()));
                    PointF bottomPoint = bottomEndpoint.point;
                    float dy = (targetPoint.y - inheritanceArrowHeight) - bottomPoint.y;
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y - inheritanceArrowHeight - h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.BottomCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        if (Contains(sourcePoint, vpoint, location, selectedLineWidth)) return true;
                        if (Contains(vpoint, crossPoint, location, selectedLineWidth)) return true;
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    if (Contains(startLine.start, startLine.end, location, selectedLineWidth)) return true;
                }
            }
            return false;
        }
        private bool ContainsCombinedInheritance180(const PointF& location, float selectedLineWidth, const Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.RightCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* leftElement = horizontalOrder.Front();
                    Endpoint leftEndpoint = leftElement->GetEndpoint(Snap(Snap.LeftCenter()));
                    PointF leftPoint = leftEndpoint.point;
                    float dx = leftPoint.x - (targetPoint.x + inheritanceArrowHeight);
                    float w = dx / 2;
                    PointF crossPoint(targetPoint.x + inheritanceArrowHeight + w, targetPoint.y);
                    for (ClassElement* sourceElement : verticalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.LeftCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(crossPoint.x, sourcePoint.y);
                        if (Contains(sourcePoint, vpoint, location, selectedLineWidth)) return true;
                        if (Contains(vpoint, crossPoint, location, selectedLineWidth)) return true;
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    if (Contains(startLine.start, startLine.end, location, selectedLineWidth)) return true;
                }
            }
            return false;
        }
        private bool ContainsCombinedInheritance270(const PointF& location, float selectedLineWidth, const Layout& layout)
        {
            ClassElement* targetClassElement = null;
            if (target.element != null)
            {
                if (target.element is ClassElement*)
                {
                    targetClassElement = cast<ClassElement*>(target.element);
                }
            }
            if (targetClassElement != null)
            {
                const Endpoint& targetEndpoint = targetClassElement->GetEndpoint(Snap(Snap.BottomCenter()));
                PointF targetPoint = targetEndpoint.point;
                target.point = targetPoint;
                List<int> indeces;
                for (const Endpoint& sourceEndpoint : sourceEndpoints)
                {
                    if (sourceEndpoint.element != null)
                    {
                        if (sourceEndpoint.element is ClassElement*)
                        {
                            int index = GetDiagram()->GetIndexOfElement(sourceEndpoint.element);
                            if (index != -1)
                            {
                                indeces.Add(index);
                            }
                        }
                    }
                }
                if (indeces.Count() > 1)
                {
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
                    float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
                    List<int> horizontalIndexOrder = indeces;
                    Sort(horizontalIndexOrder.Begin(), horizontalIndexOrder.End(), HorizontallyLess(GetDiagram()));
                    List<ClassElement*> horizontalOrder;
                    for (int index : horizontalIndexOrder)
                    {
                        horizontalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    List<int> verticalIndexOrder = indeces;
                    Sort(verticalIndexOrder.Begin(), verticalIndexOrder.End(), VerticallyLess(GetDiagram()));
                    List<ClassElement*> verticalOrder;
                    for (int index : verticalIndexOrder)
                    {
                        verticalOrder.Add(cast<ClassElement*>(GetDiagram()->GetElementByIndex(index)));
                    }
                    ClassElement* topElement = verticalOrder.Front();
                    Endpoint topEndpoint = topElement->GetEndpoint(Snap(Snap.TopCenter()));
                    PointF topPoint = topEndpoint.point;
                    float dy = topPoint.y - (targetPoint.y + inheritanceArrowHeight);
                    float h = dy / 2;
                    PointF crossPoint(targetPoint.x, targetPoint.y + inheritanceArrowHeight + h);
                    for (ClassElement* sourceElement : horizontalOrder)
                    {
                        Endpoint sourceEndpoint = sourceElement->GetEndpoint(Snap(Snap.TopCenter()));
                        PointF sourcePoint = sourceEndpoint.point;
                        PointF vpoint(sourcePoint.x, crossPoint.y);
                        if (Contains(sourcePoint, vpoint, location, selectedLineWidth)) return true;
                        if (Contains(vpoint, crossPoint, location, selectedLineWidth)) return true;
                    }
                    Line line(crossPoint, targetPoint);
                    Vector v = line.ToVector();
                    float len = v.Length();
                    float startLen = Max(0.0f, len - inheritanceArrowHeight);
                    Vector u = UnitVector(v) * startLen;
                    Line startLine(crossPoint, u);
                    if (Contains(startLine.start, startLine.end, location, selectedLineWidth)) return true;
                }
            }
            return false;
        }
        private void DrawAggregation(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const PaddingElement& padding = layout.GetClassPaddingElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float aggregateSymbolWidth = relationshipLayoutElement.AggregateSymbolWidth();
            float aggregateSymbolHeight = relationshipLayoutElement.AggregateSymbolHeight();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            PointF start = source.point;
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line aggregateLine(start, end);
            if (!source.text.IsEmpty())
            {
                float leadinglWidth = aggregateSymbolWidth;
                Line textLine = GetSourceTextLine(aggregateLine, leadinglWidth, padding.left);
                DrawSourceText(graphics, font, textBrush, textLine, leadinglWidth);
            }
            Vector v(aggregateLine.ToVector());
            Vector u(UnitVector(v) * aggregateSymbolWidth);
            Line aggregateSymbolLine(start, u);
            Vector h(u * 0.5f);
            Line halfAggregateSymbolLine(start, h);
            Vector l(UnitVector(System.Windows.Rotate(halfAggregateSymbolLine, 90.0f).ToVector()) * (aggregateSymbolHeight / 2));
            Vector r(UnitVector(System.Windows.Rotate(halfAggregateSymbolLine, -90.0f).ToVector()) * (aggregateSymbolHeight / 2));
            Line leftAggregateSymbolLine(halfAggregateSymbolLine.end, l);
            Line rightAggregateSymbolLine(halfAggregateSymbolLine.end, r);
            graphics.DrawLineChecked(linePen, aggregateSymbolLine.start, leftAggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, leftAggregateSymbolLine.end, aggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, aggregateSymbolLine.start, rightAggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, rightAggregateSymbolLine.end, aggregateSymbolLine.end);
            PointF prevPoint = aggregateSymbolLine.end;
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                prevPoint = intermediatePoint;
            }
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, circleLine.end, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, arrowEndLine.start, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
        }
        private void DrawReference(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const PaddingElement& padding = layout.GetClassPaddingElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            float nullReferenceSymbolWidth = relationshipLayoutElement.NullReferenceSymbolWidth();
            float nullReferenceSymbolHeight = relationshipLayoutElement.NullReferenceSymbolHeight();
            PointF start = source.point;
            PointF first = start;
            if (source.element is FieldElement*)
            {
                float relationshipSymbolRadius = relationshipLayoutElement.RelationshipSymbolRadius();
                Vector left(-1, 0);
                Vector ul(UnitVector(left) * relationshipSymbolRadius);
                Line l(start, ul);
                Vector up(0, -1);
                Vector uu(UnitVector(up) * relationshipSymbolRadius);
                Line u(l.end, uu);
                RectF r(u.end, SizeF(2.0f * relationshipSymbolRadius, 2.0f * relationshipSymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, r);
                PointF next;
                if (intermediatePoints.IsEmpty())
                {
                    next = target.point;
                }
                else
                {
                    next = intermediatePoints.Front();
                }
                Line line(start, next);
                Vector v = line.ToVector();
                Vector n = UnitVector(v) * relationshipSymbolRadius;
                Line f(start, n);
                first = f.end;
            }
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line referenceLine(first, end);
            if (!source.text.IsEmpty())
            {
                float leadingWidth = padding.left;
                Line textLine = GetSourceTextLine(referenceLine, leadingWidth, leadingWidth);
                DrawSourceText(graphics, font, textBrush, textLine, leadingWidth);
            }
            Vector v(referenceLine.ToVector());
            PointF prevPoint = referenceLine.start;
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                prevPoint = intermediatePoint;
            }
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, arrowEndLine.start, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, arrowEndLine.start, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.zero)
            {
                Line line(arrowLine.end, target.point);
                Vector v = line.ToVector();
                Vector up = UnitVector(v) * (line.Length() - 2 * nullReferenceSymbolHeight);
                Line prevLine(line.start, up);
                Vector uf = UnitVector(v) * (line.Length() - nullReferenceSymbolHeight);
                Line lastLine(line.start, uf);
                graphics.DrawLineChecked(linePen, prevLine.start, prevLine.end);
                Line prev = Line(prevLine.end, UnitVector(v) * (nullReferenceSymbolWidth / 2));
                Line prevl = System.Windows.Rotate(prev, 90.0f);
                Line prevr = System.Windows.Rotate(prev, -90.0f);
                Line final = Line(lastLine.end, UnitVector(v) * (nullReferenceSymbolWidth / 2));
                Line finall = System.Windows.Rotate(final, 90.0f);
                Line finalr = System.Windows.Rotate(final, -90.0f);
                graphics.DrawLineChecked(linePen, prevl.end, prevr.end);
                graphics.DrawLineChecked(linePen, finall.end, finalr.end);
            }
        }
        private void DrawCreateInstance(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const PaddingElement& padding = layout.GetClassPaddingElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Pen& dashPen = relationshipLayoutElement.DashLinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            PointF start = source.point;
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line instanceLine(start, end);
            if (!source.text.IsEmpty())
            {
                float leadingWidth = padding.left;
                Line textLine = GetSourceTextLine(instanceLine, leadingWidth, leadingWidth);
                DrawSourceText(graphics, font, textBrush, textLine, leadingWidth);
            }
            Vector v(instanceLine.ToVector());
            PointF prevPoint = instanceLine.start;
            if (!intermediatePoints.IsEmpty())
            {
                prevPoint = intermediatePoints.Back();
            }
            PointF finalPoint;
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                finalPoint = arrowEndLine.start;
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                finalPoint = arrowEndLine.start;
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                finalPoint = arrowEndLine.start;
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            List<PointF> points;
            points.Add(source.point);
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                points.Add(intermediatePoint);
            }
            points.Add(finalPoint);
            graphics.DrawLinesChecked(dashPen, cast<int>(points.Count()), points.CBegin().Ptr());
        }
        private void DrawAttachNote(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Pen& dotPen = relationshipLayoutElement.DotLinePen();
            float radius = relationshipLayoutElement.RelationshipSymbolRadius();
            PointF start = source.point;
            Vector left(-1, 0);
            Vector ul(UnitVector(left) * radius);
            Line l(start, ul);
            Vector up(0, -1);
            Vector uu(UnitVector(up) * radius);
            Line u(l.end, uu);
            RectF r(u.end, SizeF(2.0f * radius, 2.0f * radius));
            graphics.DrawEllipseChecked(linePen, r);
            PointF next;
            if (intermediatePoints.IsEmpty())
            {
                next = target.point;
            }
            else
            {
                next = intermediatePoints.Front();
            }
            Line line(start, next);
            Vector v = line.ToVector();
            Vector n = UnitVector(v) * radius;
            Line f(start, n);
            PointF first = f.end;
            List<PointF> points;
            points.Add(first);
            if (intermediatePoints.IsEmpty())
            {
                points.Add(next);
            }
            else
            {
                for (const PointF& intermediatePoint : intermediatePoints)
                {
                    points.Add(intermediatePoint);
                }
                points.Add(target.point);
            }
            graphics.DrawLinesChecked(dotPen, cast<int>(points.Count()), points.CBegin().Ptr());
        }
        private Line GetSourceTextLine(const Line& firstLine, float& leadingWidth, float padding)
        {
            Line textLine = firstLine;
            if (IsHorizontalLine(firstLine.start, firstLine.end, textLine))
            {
                if (textLine != firstLine)
                {
                    leadingWidth = padding;
                }
                return textLine;
            }
            if (!intermediatePoints.IsEmpty())
            {
                PointF prev = firstLine.end;
                for (int i = 1; i < intermediatePoints.Count(); ++i)
                {
                    PointF next = intermediatePoints[i];
                    if (IsHorizontalLine(prev, next, textLine))
                    {
                        leadingWidth = padding;
                        return textLine;
                    }
                    prev = next;
                }
                if (IsHorizontalLine(prev, target.point, textLine))
                {
                    leadingWidth = padding;
                    return textLine;
                }
            }
            return textLine;
        }
        private bool IsHorizontalLine(const PointF& prev, const PointF& next, Line& textLine)
        {
            Line line(prev, next);
            Vector v = line.ToVector();
            int direction = MainDirection(v);
            if (direction == 0)
            {
                textLine = line;
                return true;
            }
            else if (direction == 180)
            {
                textLine = Line(next, prev);
                return true;
            }
            return false;
        }
        private void DrawSourceText(Graphics& graphics, const Font& font, const Brush& textBrush, const Line& line, float leadingWidth)
        {
            try
            {
                GraphicsState state = graphics.SaveChecked();
                graphics.TranslateTransformChecked(0, -sourceTextSize.h, MatrixOrder.append);
                float dx = line.end.x - line.start.x;
                float dy = line.end.y - line.start.y;
                if (Abs(dy) >= Epsilon() * 2 && Abs(dx) >= Epsilon() * 2)
                {
                    float length = cast<float>(Sqrt(dx * dx, dy * dy));
                    dx = dx / length;
                    dy = dy / length;
                    float angle = cast<float>(180.0 * Atan2(dy, dx) / PI());
                    graphics.RotateTransformChecked(angle, MatrixOrder.append);
                }
                graphics.TranslateTransformChecked(line.start.x + leadingWidth, line.start.y, MatrixOrder.append);
                graphics.DrawStringChecked(source.text, font, PointF(0, 0), textBrush);
                graphics.RestoreChecked(state);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void DrawTargetText(Graphics& graphics, const Font& font, const Brush& textBrush, const Line& line, float symbolWidth)
        {
            try
            {
                GraphicsState state = graphics.SaveChecked();
                graphics.TranslateTransformChecked(0, -targetTextSize.h, MatrixOrder.append);
                float dx = line.end.x - line.start.x;
                float dy = line.end.y - line.start.y;
                if (Abs(dy) >= Epsilon() * 2 && Abs(dx) >= Epsilon() * 2)
                {
                    float length = cast<float>(Sqrt(dx * dx, dy * dy));
                    dx = dx / length;
                    dy = dy / length;
                    float angle = cast<float>(180.0 * Atan2(dy, dx) / PI());
                    graphics.RotateTransformChecked(angle, MatrixOrder.append);
                }
                graphics.TranslateTransformChecked(line.end.x - symbolWidth - targetTextSize.w, line.start.y, MatrixOrder.append);
                graphics.DrawStringChecked(target.text, font, PointF(0, 0), textBrush);
                graphics.RestoreChecked(state);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            kind = cast<RelationshipElement*>(that)->kind;
            source = cast<RelationshipElement*>(that)->source;
            for (const Endpoint& sourceEndpoint : cast<RelationshipElement*>(that)->sourceEndpoints)
            {
                sourceEndpoints.Add(sourceEndpoint);
            }
            target = cast<RelationshipElement*>(that)->target;
            intermediatePoints = cast<RelationshipElement*>(that)->intermediatePoints;
            cardinality = cast<RelationshipElement*>(that)->cardinality;
        }
        public nothrow void MapContainerElements(HashMap<DiagramElement*, DiagramElement*>& cloneMap)
        {
            if (source.element != null)
            {
                HashMap<DiagramElement*, DiagramElement*>.ConstIterator it = cloneMap.CFind(source.element);
                if (it != cloneMap.CEnd())
                {
                    source.element = it->second;
                }
            }
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                if (sourceEndpoint.element != null)
                {
                    HashMap<DiagramElement*, DiagramElement*>.ConstIterator it = cloneMap.CFind(sourceEndpoint.element);
                    if (it != cloneMap.CEnd())
                    {
                        sourceEndpoint.element = it->second;
                    }
                }
            }
            if (target.element != null)
            {
                HashMap<DiagramElement*, DiagramElement*>.ConstIterator it = cloneMap.CFind(target.element);
                if (it != cloneMap.CEnd())
                {
                    target.element = it->second;
                }
            }
        }
        public nothrow void AddToElements()
        {
            if (source.element != null && target.element != null)
            {
                source.element->AddRelationship(this);
                target.element->AddRelationship(this);
            }
            for (const Endpoint& sourceEndpoint : sourceEndpoints)
            {
                if (sourceEndpoint.element != null && target.element != null)
                {
                    sourceEndpoint.element->AddRelationship(this);
                    target.element->AddRelationship(this);
                }
            }
        }
        public nothrow void RemoveFromElements()
        {
            if (source.element != null)
            {
                source.element->RemoveRelationship(this);
            }
            for (const Endpoint& sourceEndpoint : sourceEndpoints)
            {
                if (sourceEndpoint.element != null)
                {
                    sourceEndpoint.element->RemoveRelationship(this);
                }
            }
            if (target.element != null)
            {
                target.element->RemoveRelationship(this);
            }
        }
        public nothrow void RemoveContainer(ContainerElement* element)
        {
            if (source.element == element)
            {
                source.element = null;
            }
            for (Endpoint& sourceEndpoint : sourceEndpoints)
            {
                if (sourceEndpoint.element == element)
                {
                    sourceEndpoint.element = null;
                }
            }
            if (target.element == element)
            {
                target.element = null;
            }
        }
        public Kind kind;
        public Cardinality cardinality;
        public Endpoint source;
        public Endpoint target;
        public List<Endpoint> sourceEndpoints;
        public List<PointF> intermediatePoints;
        private SizeF sourceTextSize;
        private SizeF targetTextSize;
    }

    public class FieldElement : DiagramElement
    {
        public nothrow FieldElement() : base(), relationship(null)
        {
        }
        public nothrow FieldElement(const string& name) : base(name), relationship(null)
        {
        }
        suppress FieldElement(const FieldElement&);
        suppress void operator=(const FieldElement&);
        suppress FieldElement(FieldElement&&);
        suppress void operator=(FieldElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"field");
        }
        public nothrow void SetContainerElement(ContainerElement* containerElement_)
        {
            containerElement = containerElement_;
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return containerElement;
        }
        public override nothrow void AddRelationship(RelationshipElement* relationship_)
        {
            relationship = relationship_;
        }
        public override nothrow void RemoveRelationship(RelationshipElement* relationship_)
        {
            if (relationship == relationship_)
            {
                relationship = null;
            }
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            Endpoint endpoint(this, snap, GetRelationshipPoint());
            return endpoint;
        }
        public void SetRelationshipPoint()
        {
            if (relationship != null)
            {
                relationship->source.element = this;
                for (Endpoint& sourceEndpoint : relationship->sourceEndpoints)
                {
                    sourceEndpoint.element = this;
                    sourceEndpoint.point = GetRelationshipPoint();
                }
                relationship->source.point = GetRelationshipPoint();
            }
        }
        public PointF GetRelationshipPoint() const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            float symbolLeft = 0.0f;
            if (containerElement != null)
            {
                size.w = containerElement->GetMaxChildElementWidth();
                Diagram* diagram = containerElement->GetDiagram();
                if (diagram != null)
                {
                    const Layout& layout = diagram->GetLayout();
                    const PaddingElement& padding = layout.GetRelationshipSymbolPaddingElement();
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float relationshipSymbolRadius = relationshipLayoutElement.RelationshipSymbolRadius();
                    size.w = size.w - GetRelationshipSymbolFieldWidth(layout);
                    symbolLeft = padding.left + relationshipSymbolRadius;
                }
            }
            PointF point(loc.x + size.w + symbolLeft, loc.y + size.h / 2);
            return point;
        }
        public override DiagramElement* Clone() const
        {
            FieldElement* clone = new FieldElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            containerElement = cast<FieldElement*>(that)->containerElement;
        }
        public nothrow inline RelationshipElement* Relationship() const
        {
            return relationship;
        }
        private ContainerElement* containerElement;
        private RelationshipElement* relationship;
    }

    public class OperationElement : DiagramElement
    {
        public nothrow OperationElement() : base(), isAbstract(false), relationship(null), containerElement(null)
        {
        }
        public nothrow OperationElement(const string& name) : base(name), isAbstract(false), relationship(null), containerElement(null)
        {
        }
        public nothrow OperationElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_), relationship(null), containerElement(null)
        {
        }
        suppress OperationElement(const OperationElement&);
        suppress void operator=(const OperationElement&);
        suppress OperationElement(OperationElement&&);
        suppress void operator=(OperationElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public nothrow void SetContainerElement(ContainerElement* containerElement_)
        {
            containerElement = containerElement_;
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return containerElement;
        }
        public override nothrow void AddRelationship(RelationshipElement* relationship_)
        {
            relationship = relationship_;
        }
        public override nothrow void RemoveRelationship(RelationshipElement* relationship_)
        {
            if (relationship == relationship_)
            {
                relationship = null;
            }
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            Endpoint endpoint(this, snap, GetRelationshipPoint());
            return endpoint;
        }
        public void SetRelationshipPoint()
        {
            if (relationship != null)
            {
                relationship->source.element = this;
                relationship->source.point = GetRelationshipPoint();
                for (Endpoint& sourceEndpoint : relationship->sourceEndpoints)
                {
                    sourceEndpoint.element = this;
                    sourceEndpoint.point = GetRelationshipPoint();
                }
            }
        }
        public PointF GetRelationshipPoint() const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            float symbolLeft = 0.0f;
            if (containerElement != null)
            {
                size.w = containerElement->GetMaxChildElementWidth();
                Diagram* diagram = containerElement->GetDiagram();
                if (diagram != null)
                {
                    const Layout& layout = diagram->GetLayout();
                    const PaddingElement& padding = layout.GetRelationshipSymbolPaddingElement();
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float relationshipSymbolRadius = relationshipLayoutElement.RelationshipSymbolRadius();
                    size.w = size.w - GetRelationshipSymbolFieldWidth(layout);
                    symbolLeft = padding.left + relationshipSymbolRadius;
                }
            }
            PointF point(loc.x + size.w + symbolLeft, loc.y + size.h / 2);
            return point;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"operation");
        }
        public override DiagramElement* Clone() const
        {
            OperationElement* clone = new OperationElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            isAbstract = ParseBool(ToUtf8(element->GetAttribute(u"abstract")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            element->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                DrawAbstractOperation(graphics, layout);
            }
            else
            {
                DrawConcreteOperation(graphics, layout);
            }
        }
        private void DrawAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        private void DrawConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                MeasureAbstractOperation(graphics, layout);
            }
            else
            {
                MeasureConcreteOperation(graphics, layout);
            }
        }
        private void MeasureAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        private void MeasureConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<OperationElement*>(that)->isAbstract;
            containerElement = cast<OperationElement*>(that)->containerElement;
        }
        public nothrow inline RelationshipElement* Relationship() const
        {
            return relationship;
        }
        private bool isAbstract;
        private ContainerElement* containerElement;
        private RelationshipElement* relationship;
    }

    public abstract class ContainerElement : DiagramElement
    {
        public nothrow ContainerElement() : base()
        {
        }
        public nothrow ContainerElement(const string& name) : base(name)
        {
        }
        public ~ContainerElement()
        {
            for (RelationshipElement* relationship : relationships)
            {
                relationship->RemoveContainer(this);
            }
        }
        public abstract void MapChildObjects(ContainerElement* from, HashMap<DiagramElement*, DiagramElement*>& cloneMap);
        public abstract nothrow List<RelationshipElement*> GetAllRelationships() const;
        public virtual FieldElement* GetField(int index) const
        {
            throw Exception("container element '" + Name() + "' has no fields");
        }
        public virtual OperationElement* GetOperation(int index) const
        {
            throw Exception("container element '" + Name() + "' has no operations");
        }
        public virtual int GetIndexOfFieldElement(FieldElement* fieldElement) const
        {
            throw Exception("container element '" + Name() + "' has no fields");
        }
        public virtual int GetIndexOfOperationElement(OperationElement* operationElement) const
        {
            throw Exception("container element '" + Name() + "' has no operations");
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return this;
        }
        public virtual nothrow float GetMaxChildElementWidth() const
        {
            return 0.0f;
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            switch (snap.ToInt())
            {
                case Snap.TopLeft():
                {
                    return Endpoint(this, Snap(Snap.TopLeft()), PointF(loc.x + w, loc.y));
                }
                case Snap.TopCenter():
                {
                    return Endpoint(this, Snap(Snap.TopCenter()), PointF(loc.x + size.w / 2, loc.y));
                }
                case Snap.TopRight():
                {
                    return Endpoint (this, Snap(Snap.TopRight()), PointF(loc.x + size.w - w, loc.y));
                }
                case Snap.RightTop():
                {
                    return Endpoint(this, Snap(Snap.RightTop()), PointF(loc.x + size.w, loc.y + w));
                }
                case Snap.RightCenter():
                {
                    return Endpoint(this, Snap(Snap.RightCenter()), PointF(loc.x + size.w, loc.y + size.h / 2));
                }
                case Snap.RightBottom():
                {
                    return Endpoint(this, Snap(Snap.RightBottom()), PointF(loc.x + size.w, loc.y + size.h - w));
                }
                case Snap.BottomRight():
                {
                    return Endpoint(this, Snap(Snap.BottomRight()), PointF(loc.x + size.w - w, loc.y + size.h));
                }
                case Snap.BottomCenter():
                {
                    return Endpoint(this, Snap(Snap.BottomCenter()), PointF(loc.x + size.w / 2, loc.y + size.h));
                }
                case Snap.BottomLeft():
                {
                    return Endpoint(this, Snap(Snap.BottomLeft()), PointF(loc.x + w, loc.y + size.h));
                }
                case Snap.LeftBottom():
                {
                    return Endpoint(this, Snap(Snap.LeftBottom()), PointF(loc.x, loc.y + size.h - w));
                }
                case Snap.LeftCenter():
                {
                    return Endpoint(this, Snap(Snap.LeftCenter()), PointF(loc.x, loc.y + size.h / 2));
                }
                case Snap.LeftTop():
                {
                    return Endpoint(this, Snap(Snap.LeftTop()), PointF(loc.x, loc.y + w));
                }
            }
            return Endpoint();
        }
        public override nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            List<Endpoint> endpoints;
            endpoints.Add(GetEndpoint(Snap(Snap.TopLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightTop())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftTop())));
            return endpoints;
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            MeasureRelationships(Snap(Snap.TopLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftBottom()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightBottom()), w, graphics, layout);
        }
        private void MeasureRelationships(const Snap& snap, float w, Graphics& graphics, Layout& layout)
        {
            List<RelationshipElement*> pickedRelationships = PickRelationships(snap);
            int n = cast<int>(pickedRelationships.Count());
            for (int i = 0; i < n; ++i)
            {
                RelationshipElement* relationship = pickedRelationships[i];
                relationship->Calculate(snap, this, w, i, n);
            }
        }
        public nothrow inline const List<RelationshipElement*>& Relationships() const
        {
            return relationships;
        }
        public nothrow override void AddRelationship(RelationshipElement* relationship)
        {
            if (Find(relationships.CBegin(), relationships.CEnd(), relationship) == relationships.CEnd())
            {
                relationships.Add(relationship);
            }
        }
        public nothrow override void RemoveRelationship(RelationshipElement* relationship)
        {
            relationships.Remove(relationship);
        }
        private nothrow List<RelationshipElement*> PickRelationships(const Snap& snap) const
        {
            List<RelationshipElement*> pickedRelationships;
            for (RelationshipElement* relationship : relationships)
            {
                if (relationship->source.element == this)
                {
                    if (relationship->source.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
                for (Endpoint& sourceEndpoint : relationship->sourceEndpoints)
                {
                    if (sourceEndpoint.element == this)
                    {
                        if (sourceEndpoint.snap == snap)
                        {
                            if (Find(pickedRelationships.CBegin(), pickedRelationships.CEnd(), relationship) == pickedRelationships.CEnd())
                            {
                                pickedRelationships.Add(relationship);
                            }
                        }
                    }
                }
                if (relationship->target.element == this)
                {
                    if (relationship->target.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
            }
            return pickedRelationships;
        }
        private List<RelationshipElement*> relationships;
    }

    public class ClassElement : ContainerElement
    {
        public nothrow ClassElement() : base()
        {
        }
        public nothrow ClassElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
        }
        suppress ClassElement(const ClassElement&);
        suppress void operator=(const ClassElement&);
        suppress ClassElement(ClassElement&&);
        suppress void operator=(ClassElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow inline void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public nothrow void ResetAbstractOperations()
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->SetAbstract(false);
            }
        }
        public override void MapChildObjects(ContainerElement* from, HashMap<DiagramElement*, DiagramElement*>& cloneMap)
        {
            ClassElement* fromClass = cast<ClassElement*>(from);
            int no = fromClass->operations.Count();
            for (int i = 0; i < no; ++i)
            {
                cloneMap[fromClass->operations.Get(i)] = operations.Get(i);
            }
            int nf = fromClass->fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                cloneMap[fromClass->fields.Get(i)] = fields.Get(i);
            }
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"class");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ClassElement> clone = new ClassElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override nothrow List<RelationshipElement*> GetAllRelationships() const
        {
            List<RelationshipElement*> relationships = Relationships();
            int no = operations.Count();
            for (int i = 0; i < no; ++i)
            {
                OperationElement* operation = operations.Get(i);
                RelationshipElement* relationship = operation->Relationship();
                if (relationship != null)
                {
                    relationships.Add(relationship);
                }
            }
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                RelationshipElement* relationship = field->Relationship();
                if (relationship != null)
                {
                    relationships.Add(relationship);
                }
            }
            return relationships;
        }
        public override nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            if (endpointType == EndpointType.source && (tool is AttachNoteTool*))
            {
                List<Endpoint> endpoints;
                int no = operations.Count();
                for (int i = 0; i < no; ++i)
                {
                    OperationElement* operation = operations.Get(i);
                    endpoints.Add(operation->GetEndpoint(Snap(Snap.Operation(cast<sbyte>(i)))));
                }
                int nf = fields.Count();
                for (int i = 0; i < nf; ++i)
                {
                    FieldElement* field = fields.Get(i);
                    endpoints.Add(field->GetEndpoint(Snap(Snap.Field(cast<sbyte>(i)))));
                }
                return endpoints;
            }
            return base->GetEndpoints(endpointType, tool);
        }
        public override FieldElement* GetField(int index) const
        {
            return fields.Get(index);
        }
        public override int GetIndexOfFieldElement(FieldElement* fieldElement) const
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                if (fields.Get(i) == fieldElement) return i;
            }
            throw Exception("field '" + fieldElement->Name() + "' not found from class '" + Name() + "'");
        }
        public override OperationElement* GetOperation(int index)
        {
            return operations.Get(index);
        }
        public override int GetIndexOfOperationElement(OperationElement* operationElement) const
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                if (operations.Get(i) == operationElement) return i;
            }
            throw Exception("operation '" + operationElement->Name() + "' not found from class '" + Name() + "'");
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawOperations(graphics, layout);
            DrawFields(graphics, layout);
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ClassElementPropertiesAction(diagram, elementIndex));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                MeasureConcreteClass(graphics, layout);
            }
            else
            {
                MeasureAbstractClass(graphics, layout);
            }
            base->Measure(graphics, layout);
            SetSize();
        }
        private void MeasureConcreteClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureOperations(graphics, layout, hasRelationship);
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                float w = GetRelationshipSymbolFieldWidth(layout);
                captionRect.size.w = captionRect.size.w + w;
                operationRect.size.w = operationRect.size.w + w;
                fieldRect.size.w = fieldRect.size.w + w;
                SetRelationshipPoints();
            }
        }
        private void MeasureAbstractClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureOperations(graphics, layout, hasRelationship);
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                float w = GetRelationshipSymbolFieldWidth(layout);
                captionRect.size.w = captionRect.size.w + w;
                operationRect.size.w = operationRect.size.w + w;
                fieldRect.size.w = fieldRect.size.w + w;
                SetRelationshipPoints();
            }
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                size.w = Max(size.w, operationRect.size.w);
                h = h + operationRect.size.h;
            }
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        private void SetRelationshipPoints()
        {
            int no = operations.Count();
            for (int i = 0; i < no; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->SetRelationshipPoint();
            }
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->SetRelationshipPoint();
            }
        }
        private void MeasureOperations(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            PointF location = Location();
            operationRect = RectF();
            operationRect.location.x = location.x;
            operationRect.location.y = location.y + captionRect.size.h;
            operationRect.size.w = captionRect.size.w;
            operationRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = operationRect.location.x + paddingElement.left;
            origin.y = operationRect.location.y + paddingElement.top;
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Measure(graphics, layout);
                SizeF operationSize = operation->GetSize();
                float w = operationSize.w + paddingElement.Horizontal();
                float h = operationSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (operation->Relationship() != null)
                {
                    hasRelationship = true;
                }
                operation->SetLocation(origin);
                operationRect.size.w = Max(operationRect.size.w, w);
                origin.y = origin.y + h;
                operationRect.size.h = operationRect.size.h + h;
            }
            operationRect.size.h = operationRect.size.h + paddingElement.bottom;
        }
        private void MeasureFields(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = operationRect.location.y + operationRect.size.h;
            fieldRect.size.w = operationRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (field->Relationship() != null)
                {
                    hasRelationship = true;
                }
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassFrame(graphics, layout);
            }
            else
            {
                DrawAbstractClassFrame(graphics, layout);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassCaption(graphics, layout);
            }
            else
            {
                DrawAbstractClassCaption(graphics, layout);
            }
        }
        private void DrawConcreteClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawAbstractClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawConcreteClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawAbstractClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawOperations(Graphics& graphics, Layout& layout)
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Draw(graphics, layout);
            }
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            isAbstract = ParseBool(ToUtf8(parentElement->GetAttribute(u"abstract")));
            UniquePtr<XPathObject> operationResult = Evaluate(u"operation", parentElement);
            if (!operationResult.IsNull())
            {
                if (operationResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(operationResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<OperationElement> operation(new OperationElement());
                            operation->SetContainerElement(this);
                            operation->Read(element);
                            operations.Add(operation.Release());
                        }
                    }
                }
            }
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->SetContainerElement(this);
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            parentElement->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
            for (const UniquePtr<OperationElement>& operation : operations)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"operation");
                operation->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<ClassElement*>(that)->isAbstract;
            for (UniquePtr<OperationElement>& operation : cast<ClassElement*>(that)->operations)
            {
                OperationElement* clonedOperation = cast<OperationElement*>(operation->Clone());
                clonedOperation->SetContainerElement(this);
                operations.Add(clonedOperation);
            }
            for (UniquePtr<FieldElement>& field : cast<ClassElement*>(that)->fields)
            {
                FieldElement* clonedField = cast<FieldElement*>(field->Clone());
                clonedField->SetContainerElement(this);
                fields.Add(clonedField);
            }
        }
        public nothrow IndexList<OperationElement>& Operations()
        {
            return operations;
        }
        public void SetOperations(IndexList<OperationElement>&& operations_)
        {
            operations = operations_;
            for (UniquePtr<OperationElement>& operation : operations)
            {
                operation->SetContainerElement(this);
            }
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
            for (UniquePtr<FieldElement>& field : fields)
            {
                field->SetContainerElement(this);
            }
        }
        public nothrow override float GetMaxChildElementWidth() const
        {
            return maxChildElementWidth;
        }
        private IndexList<OperationElement> operations;
        private IndexList<FieldElement> fields;
        private bool isAbstract;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF operationRect;
        private RectF fieldRect;
        private float maxChildElementWidth;
    }

    public class ObjectElement : ContainerElement
    {
        public nothrow ObjectElement() : base()
        {
        }
        public nothrow ObjectElement(const string& name) : base(name)
        {
        }
        suppress ObjectElement(const ObjectElement&);
        suppress void operator=(const ObjectElement&);
        suppress ObjectElement(ObjectElement&&);
        suppress void operator=(ObjectElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"object");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ObjectElement> clone = new ObjectElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public nothrow override List<RelationshipElement*> GetAllRelationships() const
        {
            List<RelationshipElement*> relationships = Relationships();
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                RelationshipElement* relationship = field->Relationship();
                if (relationship != null)
                {
                    relationships.Add(relationship);
                }
            }
            return relationships;
        }
        public override void MapChildObjects(ContainerElement* from, HashMap<DiagramElement*, DiagramElement*>& cloneMap)
        {
            ObjectElement* fromObject = cast<ObjectElement*>(from);
            int nf = fromObject->fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                cloneMap[fromObject->fields.Get(i)] = fields.Get(i);
            }
        }
        public override FieldElement* GetField(int index) const
        {
            return fields.Get(index);
        }
        public override int GetIndexOfFieldElement(FieldElement* fieldElement) const
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                if (fields.Get(i) == fieldElement) return i;
            }
            throw Exception("field '" + fieldElement->Name() + "' not found from class '" + Name() + "'");
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ObjectElementPropertiesAction(diagram, elementIndex));
        }
        public override nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            if (endpointType == EndpointType.source && (tool is ReferenceTool*))
            {
                List<Endpoint> endpoints;
                int nf = fields.Count();
                for (int i = 0; i < nf; ++i)
                {
                    FieldElement* field = fields.Get(i);
                    endpoints.Add(field->GetEndpoint(Snap(Snap.Field(cast<sbyte>(i)))));
                }
                return endpoints;
            }
            return base->GetEndpoints(endpointType, tool);
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawFields(graphics, layout);
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const Pen& framePen = layoutElement.FramePen();
            float roundingRadius = layoutElement.FrameRoundingRadius();
            PointF loc = Location();
            SizeF size = GetSize();
            PointF topStart(loc.x + roundingRadius - 1.0f - DefaultFrameWidth(graphics), loc.y);
            PointF topEnd(loc.x + size.w - roundingRadius + 1.0f + DefaultFrameWidth(graphics), loc.y);
            graphics.DrawLineChecked(framePen, topStart, topEnd);
            RectF topLeftRoundingRect(PointF(loc.x, loc.y), SizeF(roundingRadius, roundingRadius));
            float topLeftRoundingStartAngle = 180.0f;
            float topLeftRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, topLeftRoundingRect, topLeftRoundingStartAngle, topLeftRoudingSweepAngle);
            PointF rightStart(loc.x + size.w, loc.y + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics));
            PointF rightEnd(loc.x + size.w, loc.y + size.h - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, rightStart, rightEnd);
            RectF topRightRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y), SizeF(roundingRadius, roundingRadius));
            float topRightRoundingStartAngle = 0.0f;
            float topRightRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, topRightRoundingRect, topRightRoundingStartAngle, topRightRoudingSweepAngle);
            RectF rightBottomRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float rightBottomRoundingStartAngle = 0.0f;
            float rightBottomRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, rightBottomRoundingRect, rightBottomRoundingStartAngle, rightBottomRoudingSweepAngle);
            PointF bottomStart(loc.x + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            PointF bottomEnd(loc.x + size.w - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            graphics.DrawLineChecked(framePen, bottomStart, bottomEnd);
            RectF leftBottomRoundingRect(PointF(loc.x, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float leftBottomRoundingStartAngle = 180.0f;
            float leftBottomRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, leftBottomRoundingRect, leftBottomRoundingStartAngle, leftBottomRoudingSweepAngle);
            PointF leftStart(loc.x, loc.y + roundingRadius - 1.0f - DefaultFrameWidth(graphics));
            PointF leftEnd(loc.x, loc.y + size.h - roundingRadius + 1.0f + DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, leftStart, leftEnd);
            if (!fields.IsEmpty())
            {
                float captionY = paddingElement.Vertical() + captionTextHeight;
                PointF location = Location();
                PointF captionLineStart(location.x, location.y + captionY);
                PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                float w = GetRelationshipSymbolFieldWidth(layout);
                captionRect.size.w = captionRect.size.w + w;
                fieldRect.size.w = fieldRect.size.w + w;
                SetRelationshipPoints();
            }
            base->Measure(graphics, layout);
            SetSize();
        }
        private void SetRelationshipPoints()
        {
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->SetRelationshipPoint();
            }
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        private void MeasureFields(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = captionRect.location.y + captionRect.size.h;
            fieldRect.size.w = captionRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (field->Relationship() != null)
                {
                    hasRelationship = true;
                }
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->SetContainerElement(this);
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
            for (UniquePtr<FieldElement>& field : fields)
            {
                field->SetContainerElement(this);
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            for (UniquePtr<FieldElement>& field : cast<ObjectElement*>(that)->fields)
            {
                FieldElement* clonedField = cast<FieldElement*>(field->Clone());
                clonedField->SetContainerElement(this);
                fields.Add(clonedField);
            }
        }
        public nothrow override float GetMaxChildElementWidth() const
        {
            return maxChildElementWidth;
        }
        private IndexList<FieldElement> fields;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF fieldRect;
        private float maxChildElementWidth;
    }

    public class NoteElement : ContainerElement
    {
        public nothrow NoteElement() : base("note")
        {
        }
        suppress NoteElement(const NoteElement&);
        suppress void operator=(const NoteElement&);
        suppress NoteElement(NoteElement&&);
        suppress void operator=(NoteElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"note");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<NoteElement> clone = new NoteElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override void MapChildObjects(ContainerElement* from, HashMap<DiagramElement*, DiagramElement*>& cloneMap)
        {
        }
        public nothrow override List<RelationshipElement*> GetAllRelationships() const
        {
            return Relationships();
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new NoteElementPropertiesAction(diagram, elementIndex));
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            UniquePtr<XPathObject> lineResult = Evaluate(u"line", parentElement);
            if (!lineResult.IsNull())
            {
                if (lineResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(lineResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            lines.Add(ToUtf8(element->GetAttribute(u"value")));
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                System.Dom.Element* lineElement = new System.Dom.Element(u"line");
                lineElement->SetAttribute(u"value", ToUtf32(lines[i]));
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(lineElement));
            }
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetNotePaddingElement();
            const NoteLayoutElement& layoutElement = layout.GetNoteLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            StringFormat stringFormat;
            SizeF size = SizeF();
            Size cornerBitmapSize(11, 11);
            SizeF cornerBitmapSizeF(ScreenMetrics.Get().HorizontalPixelsToMM(cornerBitmapSize.w), ScreenMetrics.Get().VerticalPixelsToMM(cornerBitmapSize.h));
            size.h = paddingElement.Vertical();
            lineSize = SizeF();
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const string& line = lines[i];
                RectF lineRect = graphics.MeasureStringChecked(line, font, PointF(0, 0), stringFormat);
                lineSize.h = Max(lineSize.h, lineRect.size.h);
                size.w = Max(size.w, paddingElement.Horizontal() + lineRect.size.w + cornerBitmapSizeF.w);
                size.h = size.h + lineSize.h;
            }
            SetSize(size);
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            const PaddingElement& paddingElement = layout.GetNotePaddingElement();
            const NoteLayoutElement& layoutElement = layout.GetNoteLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            const Brush* brush = textColorElement.GetBrush(layout);
            const Pen& framePen = layoutElement.FramePen();
            PointF location = Location();
            SizeF size = GetSize();
            Size cornerBitmapSize(11, 11);
            SizeF cornerBitmapSizeF(ScreenMetrics.Get().HorizontalPixelsToMM(cornerBitmapSize.w), ScreenMetrics.Get().VerticalPixelsToMM(cornerBitmapSize.h));
            PointF cornerBitmapLocF(location.x + size.w - cornerBitmapSizeF.w, location.y);
            Point cornerBitmapLoc(GetDiagram()->GetCanvas()->ToControlLocation(cornerBitmapLocF));
            Bitmap* noteCornerBitmap = GetDiagram()->GetCanvas()->GetNoteCornerBitmap();
            graphics.DrawLineChecked(framePen, location, PointF(location.x + size.w - cornerBitmapSizeF.w, location.y));
            graphics.DrawLineChecked(framePen, PointF(location.x + size.w, location.y + cornerBitmapSizeF.h), PointF(location.x + size.w, location.y + size.h));
            graphics.DrawLineChecked(framePen, location, PointF(location.x, location.y + size.h));
            graphics.DrawLineChecked(framePen, PointF(location.x, location.y + size.h), PointF(location.x + size.w, location.y + size.h));
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const string& line = lines[i];
                graphics.DrawStringChecked(line, font, origin, *brush);
                origin.y = origin.y + lineSize.h;
            }
            RectF r(cornerBitmapLocF, cornerBitmapSizeF);
            ImageAttributes imageAttributes;
            System.Windows.Color transparentColor(0u, 128u, 128u);
            imageAttributes.SetColorKey(transparentColor, transparentColor, ColorAdjustType.default_);
            RectF s(PointF(0, 0), cornerBitmapSizeF);
            SmoothingMode prevSmoothingMode = graphics.GetSmoothingModeChecked();
            graphics.SetSmoothingModeChecked(SmoothingMode.none);
            graphics.DrawImageChecked(*noteCornerBitmap, r, s, Unit.millimeter, imageAttributes);
            graphics.SetSmoothingModeChecked(prevSmoothingMode);
            base->Measure(graphics, layout);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            for (const string& line : cast<NoteElement*>(that)->lines)
            {
                lines.Add(line);
            }
            lineSize = cast<NoteElement*>(that)->lineSize;
        }
        public nothrow inline const List<string>& Lines() const
        {
            return lines;
        }
        public nothrow void SetLines(const List<string>& lines_)
        {
            lines = lines_;
        }
        private List<string> lines;
        private SizeF lineSize;
    }

    public RectF CalculateBoundingRect(const List<DiagramElement*>& diagramElements)
    {
        RectF boundingRect;
        for (DiagramElement* diagramElement : diagramElements)
        {
            if (boundingRect.IsEmpty())
            {
                boundingRect = diagramElement->BoundingRect();
            }
            else
            {
                boundingRect = RectF.Union(boundingRect, diagramElement->BoundingRect());
            }
        }
        return boundingRect;
    }

    UniquePtr<RelationshipElement> CombineInheritanceRelationships(const List<RelationshipElement*>& inheritanceRelationships, List<RelationshipElement*>& sourceRelationships)
    {
        UniquePtr<RelationshipElement> combinedRelationship;
        Map<DiagramElement*, int> targetMap;
        for (RelationshipElement* relationship : inheritanceRelationships)
        {
            if (relationship->target.element != null)
            {
                ++targetMap[relationship->target.element];
            }
        }
        int maxCount = -1;
        DiagramElement* maxTargetElement;
        for (const Pair<DiagramElement*, int>& p : targetMap)
        {
            if (p.second > maxCount)
            {
                maxCount = p.second;
                maxTargetElement = p.first;
            }
        }
        if (maxTargetElement is ClassElement*)
        {
            Endpoint targetEndpoint;
            List<Endpoint> sourceEndpoints;
            ClassElement* targetClassElement = cast<ClassElement*>(maxTargetElement);
            for (RelationshipElement* relationship : inheritanceRelationships)
            {
                if (relationship->target.element != null)
                {
                    if (relationship->target.element == targetClassElement)
                    {
                        if (targetEndpoint.element == null)
                        {
                            targetEndpoint = relationship->target;
                        }
                        if (relationship->source.element != null)
                        {
                            if (relationship->source.element is ClassElement*)
                            {
                                sourceEndpoints.Add(relationship->source);
                                sourceRelationships.Add(relationship);
                            }
                        }
                    }
                }
            }
            if (sourceRelationships.Count() > 1)
            {
                combinedRelationship.Reset(new RelationshipElement());
                combinedRelationship->kind = RelationshipElement.Kind.inheritance;
                combinedRelationship->cardinality = Cardinality.one;
                combinedRelationship->sourceEndpoints = sourceEndpoints;
                combinedRelationship->target = targetEndpoint;
            }
        }
        return combinedRelationship;
    }

    List<UniquePtr<RelationshipElement>> SplitCombinedInheritanceRelationship(RelationshipElement* combinedInheritanceRelationship)
    {
        List<UniquePtr<RelationshipElement>> relationships;
        Endpoint target = combinedInheritanceRelationship->target;
        for (const Endpoint& source : combinedInheritanceRelationship->sourceEndpoints)
        {
            UniquePtr<RelationshipElement> relationship(new RelationshipElement(RelationshipElement.Kind.inheritance));
            relationship->source = source;
            relationship->target = target;
            relationships.Add(Rvalue(relationship));
        }
        combinedInheritanceRelationship->RemoveFromElements();
        for (const UniquePtr<RelationshipElement>& relationship : relationships)
        {
            relationship->AddToElements();
        }
        return relationships;
    }

    public void SaveImage(const string& fileName, const PaddingElement& margins, Canvas* canvas, const List<DiagramElement*>& diagramElements, Graphics& graphics, Layout& layout, ImageFormat imageFormat)
    {
        Diagram diagram(layout);
        diagram.SetCanvas(canvas);
        HashMap<DiagramElement*, DiagramElement*> cloneMap;
        List<ContainerElement*> clones;
        List<RelationshipElement*> relationships;
        for (DiagramElement* diagramElement : diagramElements)
        {
            DiagramElement* clone = diagramElement->Clone();
            if (clone is ContainerElement*)
            {
                ContainerElement* containerElement = cast<ContainerElement*>(clone);
                cloneMap[diagramElement] = clone;
                containerElement->MapChildObjects(cast<ContainerElement*>(diagramElement), cloneMap);
                clones.Add(containerElement);
            }
            else if (clone is RelationshipElement*)
            {
                relationships.Add(cast<RelationshipElement*>(clone));
            }
            diagram.AddElement(clone);
        }
        for (RelationshipElement* relationship : relationships)
        {
            relationship->MapContainerElements(cloneMap);
            relationship->AddToElements();
        }
        RectF boundingRect = diagram.CalculateBoundingRect();
        diagram.Offset(-boundingRect.location.x + margins.left, -boundingRect.location.y + margins.top);
        boundingRect.size.w = boundingRect.size.w + margins.Horizontal();
        boundingRect.size.h = boundingRect.size.h + margins.Vertical();
        int width = ScreenMetrics.Get().MMToHorizontalPixels(boundingRect.size.w);
        int height = ScreenMetrics.Get().MMToVerticalPixels(boundingRect.size.h);
        Bitmap bitmap(width, height, graphics);
        Graphics bitmapGraphics = Graphics.FromImage(bitmap);
        bitmapGraphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
        bitmapGraphics.SetSmoothingModeChecked(SmoothingMode.highQuality);
        bitmapGraphics.SetPageUnitChecked(Unit.millimeter);
        bitmapGraphics.ClearChecked(System.Windows.Color.White());
        diagram.Draw(bitmapGraphics);
        bitmap.SaveChecked(fileName.Chars(), GetEncoderClsIdChecked(GetImageFormat(imageFormat)));
    }
}

// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows;
using System.XPath;

namespace spring
{
    public class Contains<T>
    {
        public typedef T ElementType;

        public nothrow Contains(const PointF& location_) : location(location_)
        {
        }
        public nothrow inline bool operator()(T* element) const
        {
            return element->Contains(location);
        }
        private PointF location;
    }

    public class HorizontallyLess : Rel<int>
    {
        public nothrow HorizontallyLess() : diagram(null)
        {
        }
        public nothrow HorizontallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().x < right->Location().x)
            {
                return true;
            }
            if (left->Location().x > right->Location().x)
            {
                return false;
            }
            return left->Location().y < right->Location().y;
        }
        private Diagram* diagram;
    }

    public class VerticallyLess : Rel<int>
    {
        public nothrow VerticallyLess () : diagram(null)
        {
        }
        public nothrow VerticallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().y < right->Location().y)
            {
                return true;
            }
            if (left->Location().y > right->Location().y)
            {
                return false;
            }
            return left->Location().x < right->Location().x;
        }
        private Diagram* diagram;
    }

    public class Diagram 
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, invalidated = 1 << 1
        }
        public Diagram() : flags(Flags.none), layout(), elements(), selection(new EmptySelection(*this)), operation(new EmptyOperation())
        {
            Tools.SetDiagram(this);
            SetChanged();
            Invalidate();
            UniquePtr<ClassElement> concreteClassElement(new ClassElement("ConcreteClass", false));
            concreteClassElement->SetLocation(PointF(5.0f, 5.0f));
            concreteClassElement->Operations().Add(new OperationElement("ConcreteOperation()"));
            concreteClassElement->Operations().Add(new OperationElement("AnotherConcreteOperation()"));
            concreteClassElement->Operations().Add(new OperationElement("ThirdConcreteOperation()"));
            AddElement(concreteClassElement.Release());
            UniquePtr<ClassElement> abstractClassElement(new ClassElement("AbstractClass", true));
            abstractClassElement->SetLocation(PointF(80.0f, 5.0f));
            AddElement(abstractClassElement.Release());
        }
        suppress Diagram(const Diagram&);
        suppress void operator=(const Diagram&);
        suppress Diagram(Diagram&&);
        suppress void operator=(Diagram&&);
        public nothrow void SetCanvas(Canvas* canvas_)
        {
            canvas = canvas_;
        }
        public nothrow Canvas* GetCanvas() const
        {
            return canvas;
        }
        public void Draw(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                if (layout.IsNull())
                {
                    layout.Reset(new Layout(graphics));
                }
                for (const UniquePtr<DiagramElement>& element : elements)
                {
                    element->Measure(graphics, *layout);
                }
            }
            if (Invalidated())
            {
                ResetInvalidated();
            }
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                element->Draw(graphics, *layout);
            }
        }
        public nothrow const Layout& GetLayout() const
        {
            return *layout;
        }
        public nothrow Layout& GetLayout()
        {
            return *layout;
        }
        public nothrow void SetLayout(Layout* layout_)
        {
            layout.Reset(layout_);
        }
        public nothrow void DeleteSelection()
        {
            if (!selection->IsEmpty())
            {
                selection->Delete();
            }
        }
        public nothrow inline DiagramElement* GetElementByIndex(int index) const
        {
            return elements.Get(index);
        }
        public nothrow inline void SetElementByIndex(DiagramElement* element, int index)
        {
            if (element != null)
            {
                element->SetDiagram(this);
            }
            elements.Set(index, element);
        }
        public nothrow void AddElement(DiagramElement* element)
        {
            element->SetDiagram(this);
            elements.Add(element);
            SetChanged();
            Invalidate();
        }
        public nothrow UniquePtr<DiagramElement> RemoveElementByIndex(int index)
        {
            UniquePtr<DiagramElement> element = elements.Remove(index);
            SetChanged();
            Invalidate();
            return element;
        }
        public nothrow int GetIndexOfElementAt(const PointF& location) const
        {
            Contains<DiagramElement> pred(location);
            return IndexOf(elements, pred);
        }
        public nothrow Selection& GetSelection()
        {
            return *selection;
        }
        public nothrow void SetSelection(Selection* selection_)
        {
            selection->Clear();
            selection.Reset(selection_);
        }
        public nothrow void ResetSelection()
        {
            selection->Clear();
            DisposeContextMenu();
            selection.Reset(new EmptySelection(*this));
        }
        public nothrow inline Operation* GetOperation() const
        {
            return operation.Get();
        }
        public nothrow void SetOperation(Operation* operation_)
        {
            operation.Reset(operation_);
        }
        public void AdvanceOperation(const PointF& location)
        {
            operation->AdvanceTo(location);
            SetChanged();
            Invalidate();
        }
        public void CancelOperation()
        {
            operation->Cancel();
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public void CommitOperation(const PointF& location)
        {
            operation->Commit(location);
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public nothrow void ResetOperation()
        {
            operation.Reset(new EmptyOperation());
        }
        public void DisposeContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->RemoveContextMenu();
        }
        public void HideContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->HideContextMenu();
        }
        private nothrow inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        public nothrow inline void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed);
        }
        private nothrow inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public nothrow inline bool Invalidated() const
        {
            return (flags & Flags.invalidated) != Flags.none;
        }
        public nothrow void Invalidate()
        {
            if (!Invalidated())
            {
                flags = cast<Flags>(flags | Flags.invalidated);
                if (canvas != null)
                {
                    canvas->Invalidate();
                }
            }
        }
        public nothrow inline void ResetInvalidated()
        {
            flags = cast<Flags>(flags & ~Flags.invalidated);
        }
        private Flags flags;
        private Canvas* canvas;
        private UniquePtr<Layout> layout;
        private IndexList<DiagramElement> elements;
        private UniquePtr<Selection> selection;
        private UniquePtr<Operation> operation;
    }

    public abstract class DiagramElement
    {
        private enum Flags : sbyte
        {
            none = 0, selected = 1 << 0
        }
        public nothrow DiagramElement() : name()
        {
        }
        public nothrow DiagramElement(const string& name_) : name(name_)
        {
        }
        suppress DiagramElement(const DiagramElement&);
        suppress void operator=(const DiagramElement&);
        suppress DiagramElement(DiagramElement&&);
        suppress void operator=(DiagramElement&&);
        public virtual void Draw(Graphics& graphics, Layout& layout)
        {
            if (IsSelected())
            {
                DrawSelected(graphics, layout);
            }
        }
        public abstract DiagramElement* Clone() const;
        public abstract void Measure(Graphics& graphics, Layout& layout);
        public virtual nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            MenuItem* deleteMenuItem = new MenuItem("Delete");
            contextMenu->AddMenuItemAction(deleteMenuItem, new DeleteDiagramElementAction(diagram, elementIndex));
        }
        private void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const ColorElement& selectedColorElement = layout.GetSelectedColorElement();
            Brush& selectedBrush = selectedColorElement.GetBrush(layout);
            graphics.FillRectangleChecked(selectedBrush, boundingRect);
        }
        public nothrow inline const string& Name() const
        {
            return name;
        }
        public nothrow void SetName(const string& name_)
        {
            name = name_;
        }
        public nothrow inline const PointF& Location() const
        {
            return boundingRect.location;
        }
        public nothrow inline void SetLocation(const PointF& location)
        {
            boundingRect.location = location;
        }
        public nothrow inline const SizeF& GetSize() const
        {
            return boundingRect.size;
        }
        public nothrow inline void SetSize(const SizeF& size)
        {
            boundingRect.size = size;
        }
        public nothrow const RectF& BoundingRect() const
        {
            return boundingRect;
        }
        public virtual nothrow bool Contains(const PointF& location)
        {
            return boundingRect.Contains(location);
        }
        public virtual void Read(System.Dom.Element* parentElement)
        {
            name = ToUtf8(parentElement->GetAttribute(u"name"));
            UniquePtr<XPathObject> result = Evaluate(u"boundingRect", parentElement);
            if (!result.IsNull())
            {
                if (result->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* boundingRectElement = cast<System.Dom.Element*>(node);
                            string x = ToUtf8(boundingRectElement->GetAttribute(u"x"));
                            string y = ToUtf8(boundingRectElement->GetAttribute(u"y"));
                            string w = ToUtf8(boundingRectElement->GetAttribute(u"w"));
                            string h = ToUtf8(boundingRectElement->GetAttribute(u"h"));
                            boundingRect = RectF(PointF(ParseFloat(x), ParseFloat(y)), SizeF(ParseFloat(w), ParseFloat(h)));
                        }
                    }
                }
            }
        }
        public virtual void Write(System.Dom.Element* parentElement)
        {
            parentElement->SetAttribute(u"name", ToUtf32(name));
            UniquePtr<System.Dom.Element> boundingRectElement(new System.Dom.Element(u"boundingRect"));
            boundingRectElement->SetAttribute(u"x", ToUtf32(System.ToString(boundingRect.location.x)));
            boundingRectElement->SetAttribute(u"y", ToUtf32(System.ToString(boundingRect.location.y)));
            boundingRectElement->SetAttribute(u"w", ToUtf32(System.ToString(boundingRect.size.w)));
            boundingRectElement->SetAttribute(u"h", ToUtf32(System.ToString(boundingRect.size.h)));
            parentElement->AppendChild(UniquePtr<System.Dom.Node>(boundingRectElement.Release()));
        }
        public virtual void SetFrom(DiagramElement* that)
        {
            name = that->name;
            boundingRect = that->boundingRect;
        }
        public nothrow inline bool IsSelected() const
        {
            return (flags & Flags.selected) != Flags.none;
        }
        public nothrow void Select()
        {
            if (!IsSelected())
            {
                flags = cast<Flags>(flags | Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void ResetSelected()
        {
            if (IsSelected())
            {
                flags = cast<Flags>(flags & ~Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void SetDiagram(Diagram* diagram_)
        {
            diagram = diagram_;
        }
        public nothrow inline Diagram* GetDiagram() const
        {
            return diagram;
        }
        private Flags flags;
        private string name;
        private RectF boundingRect;
        private Diagram* diagram;
    }

    public class FieldElement : DiagramElement
    {
        public nothrow FieldElement() : base()
        {
        }
        public nothrow FieldElement(const string& name) : base(name)
        {
        }
        suppress FieldElement(const FieldElement&);
        suppress void operator=(const FieldElement&);
        suppress FieldElement(FieldElement&&);
        suppress void operator=(FieldElement&&);
        public override DiagramElement* Clone() const
        {
            FieldElement* clone = new FieldElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {

        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {

        }
    }

    public class OperationElement : DiagramElement
    {
        public nothrow OperationElement() : base(), isAbstract(false)
        {
        }
        public nothrow OperationElement(const string& name) : base(name), isAbstract(false)
        {
        }
        public nothrow OperationElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
        }
        suppress OperationElement(const OperationElement&);
        suppress void operator=(const OperationElement&);
        suppress OperationElement(OperationElement&&);
        suppress void operator=(OperationElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public override DiagramElement* Clone() const
        {
            OperationElement* clone = new OperationElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            isAbstract = ParseBool(ToUtf8(element->GetAttribute(u"abstract")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            element->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                DrawAbstractOperation(graphics, layout);
            }
            else
            {
                DrawConcreteOperation(graphics, layout);
            }
        }
        private void DrawAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), textColorElement.GetBrush(layout));
        }
        private void DrawConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                MeasureAbstractOperation(graphics, layout);
            }
            else
            {
                MeasureConcreteOperation(graphics, layout);
            }
        }
        private void MeasureAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        private void MeasureConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<OperationElement*>(that)->isAbstract;
        }
        private bool isAbstract;
    }

    public abstract class ContainerElement : DiagramElement
    {
        public nothrow ContainerElement() : base()
        {
        }
        public nothrow ContainerElement(const string& name) : base(name)
        {
        }
    }

    public class ClassElement : ContainerElement
    {
        public nothrow ClassElement() : base()
        {
        }
        public nothrow ClassElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
            SetSize(SizeF(cast<float>(DefaultMinClassHeight() + DefaultMinClassHeight() / GoldenRatio()), DefaultMinClassHeight()));
        }
        suppress ClassElement(const ClassElement&);
        suppress void operator=(const ClassElement&);
        suppress ClassElement(ClassElement&&);
        suppress void operator=(ClassElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow inline void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ClassElement> clone = new ClassElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawOperations(graphics, layout);
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ClassElementPropertiesAction(diagram, elementIndex));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                MeasureConcreteClass(graphics, layout);
            }
            else
            {
                MeasureAbstractClass(graphics, layout);
            }
        }
        private void MeasureConcreteClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            MeasureOperations(graphics, layout);
            MeasureFields(graphics, layout);
            SetSize();
        }
        private void MeasureAbstractClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            MeasureOperations(graphics, layout);
            MeasureFields(graphics, layout);
            SetSize();
        }
        private void SetSize()
        {
            SizeF size = GetSize();
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!operations.IsEmpty())
            {
                size.w = Max(size.w, operationRect.size.w);
                h = h + operationRect.size.h;
            }
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        private void MeasureOperations(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            PointF location = Location();
            operationRect = RectF();
            operationRect.location.x = location.x;
            operationRect.location.y = location.y + captionRect.size.h;
            operationRect.size.w = captionRect.size.w;
            operationRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = operationRect.location.x + paddingElement.left;
            origin.y = operationRect.location.y + paddingElement.top;
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Measure(graphics, layout);
                SizeF operationSize = operation->GetSize();
                float w = operationSize.w + paddingElement.Horizontal();
                float h = operationSize.h;
                operation->SetLocation(origin);
                operationRect.size.w = Max(operationRect.size.w, w);
                origin.y = origin.y + h;
                operationRect.size.h = operationRect.size.h + h;
            }
            operationRect.size.h = operationRect.size.h + paddingElement.bottom;
        }
        private void MeasureFields(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = operationRect.location.y + operationRect.size.h;
            fieldRect.size.w = operationRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassFrame(graphics, layout);
            }
            else
            {
                DrawAbstractClassFrame(graphics, layout);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassCaption(graphics, layout);
            }
            else
            {
                DrawAbstractClassCaption(graphics, layout);
            }
        }
        private void DrawConcreteClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float y = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF start(location.x, location.y + y);
            PointF end(location.x + GetSize().w, location.y + y);
            const Pen& framePen = layoutElement.FramePen();
            graphics.DrawLineChecked(framePen, start, end);
        }
        private void DrawAbstractClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float y = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF start(location.x, location.y + y);
            PointF end(location.x + GetSize().w, location.y + y);
            const Pen& framePen = layoutElement.FramePen();
            graphics.DrawLineChecked(framePen, start, end);
        }
        private void DrawConcreteClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawAbstractClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawOperations(Graphics& graphics, Layout& layout)
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Draw(graphics, layout);
            }
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            isAbstract = ParseBool(ToUtf8(parentElement->GetAttribute(u"abstract")));
            UniquePtr<XPathObject> operationResult = Evaluate(u"operation", parentElement);
            if (!operationResult.IsNull())
            {
                if (operationResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(operationResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<OperationElement> operation(new OperationElement());
                            operation->Read(element);
                            operations.Add(operation.Release());
                        }
                    }
                }
            }
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            parentElement->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
            for (const UniquePtr<OperationElement>& operation : operations)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"operation");
                operation->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<ClassElement*>(that)->isAbstract;
            operations.Clear();
            for (UniquePtr<OperationElement>& operation : cast<ClassElement*>(that)->operations)
            {
                operations.Add(cast<OperationElement*>(operation->Clone()));
            }
            fields.Clear();
            for (UniquePtr<FieldElement>& field : cast<ClassElement*>(that)->fields)
            {
                fields.Add(cast<FieldElement*>(field->Clone()));
            }
        }
        public nothrow IndexList<OperationElement>& Operations() 
        {
            return operations;
        }
        public void SetOperations(IndexList<OperationElement>&& operations_)
        {
            operations = operations_;
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
        }
        private IndexList<OperationElement> operations;
        private IndexList<FieldElement> fields;
        private bool isAbstract;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF operationRect;
        private RectF fieldRect;
    }
}

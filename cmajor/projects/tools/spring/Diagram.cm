// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Windows;
using System.XPath;
using System.Text;

namespace spring
{
    public class Contains<T>
    {
        public typedef T ElementType;

        public nothrow Contains(const PointF& location_) : location(location_)
        {
        }
        public nothrow inline bool operator()(T* element) const
        {
            return element->Contains(location);
        }
        private PointF location;
    }

    public class HorizontallyLess : Rel<int>
    {
        public nothrow HorizontallyLess() : diagram(null)
        {
        }
        public nothrow HorizontallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().x < right->Location().x)
            {
                return true;
            }
            if (left->Location().x > right->Location().x)
            {
                return false;
            }
            return left->Location().y < right->Location().y;
        }
        private Diagram* diagram;
    }

    public class VerticallyLess : Rel<int>
    {
        public nothrow VerticallyLess () : diagram(null)
        {
        }
        public nothrow VerticallyLess(Diagram* diagram_) : diagram(diagram_)
        {
        }
        public nothrow bool operator()(int leftIndex, int rightIndex) const
        {
            DiagramElement* left = diagram->GetElementByIndex(leftIndex);
            DiagramElement* right = diagram->GetElementByIndex(rightIndex);
            if (left->Location().y < right->Location().y)
            {
                return true;
            }
            if (left->Location().y > right->Location().y)
            {
                return false;
            }
            return left->Location().x < right->Location().x;
        }
        private Diagram* diagram;
    }

    public abstract class DiagramElementCreator
    {
        public abstract DiagramElement* Create() const;
    }

    public class ConcreteDiagramElementCreator<DiagramElementT> : DiagramElementCreator
    {
        public override DiagramElement* Create() const
        {
            return new DiagramElementT();
        }
    }

    public class DiagramElementFactory
    {
        static DiagramElementFactory() : instance(new DiagramElementFactory())
        {
        }
        public static DiagramElementFactory& Instance()
        {
            return *instance;
        }
        public DiagramElement* Create(const string& domElementName)
        {
            Map<string, DiagramElementCreator*>.ConstIterator it = registry.CFind(domElementName);
            if (it != registry.CEnd())
            {
                DiagramElementCreator* creator = it->second;
                return creator->Create();
            }
            else
            {
                throw Exception("element '" + domElementName + "' not registered to diagram element factory");
            }
        }
        private DiagramElementFactory()
        {
            UniquePtr<DiagramElementCreator> classCreator(new ConcreteDiagramElementCreator<ClassElement>());
            registry["class"] = classCreator.Get();
            creators.Add(Rvalue(classCreator));
            UniquePtr<DiagramElementCreator> objectCreator(new ConcreteDiagramElementCreator<ObjectElement>());
            registry["object"] = objectCreator.Get();
            creators.Add(Rvalue(objectCreator));
            UniquePtr<DiagramElementCreator> noteCreator(new ConcreteDiagramElementCreator<NoteElement>());
            registry["note"] = noteCreator.Get();
            creators.Add(Rvalue(noteCreator));
            UniquePtr<DiagramElementCreator> relationshipCreator(new ConcreteDiagramElementCreator<RelationshipElement>());
            registry["relationship"] = relationshipCreator.Get();
            creators.Add(Rvalue(relationshipCreator));
        }
        private void Instantiate()
        {
            ConcreteDiagramElementCreator<ClassElement>().Create();
            ConcreteDiagramElementCreator<ObjectElement>().Create();
            ConcreteDiagramElementCreator<NoteElement>().Create();
            ConcreteDiagramElementCreator<RelationshipElement>().Create();
        }
        private static UniquePtr<DiagramElementFactory> instance;
        private List<UniquePtr<DiagramElementCreator>> creators;
        private Map<string, DiagramElementCreator*> registry;
    }

    public class Diagram 
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, invalidated = 1 << 1, modified = 1 << 2
        }
        public Diagram() : flags(Flags.none), layout(), elements(), selection(new EmptySelection(*this)), operation(new EmptyOperation())
        {
            Tools.SetDiagram(this);
            SetChanged();
            Invalidate();
            ResetModified();
        }
        suppress Diagram(const Diagram&);
        suppress void operator=(const Diagram&);
        suppress Diagram(Diagram&&);
        suppress void operator=(Diagram&&);
        public nothrow void SetCanvas(Canvas* canvas_)
        {
            canvas = canvas_;
        }
        public nothrow Canvas* GetCanvas() const
        {
            return canvas;
        }
        public void SetMenuItems(MenuItem* undoMenuItem, MenuItem* redoMenuItem)
        {
            commandList.SetMenuItems(undoMenuItem, redoMenuItem);
        }
        public void Save(const string& filePath)
        {
            StreamWriter writer = File.CreateText(filePath);
            CodeFormatter formatter(writer);
            formatter.SetIndentSize(1);
            System.Dom.Document diagramDocument;
            diagramDocument.AppendChild(UniquePtr<System.Dom.Node>(new System.Dom.Element(u"diagram")));
            for (UniquePtr<DiagramElement>& element : elements)
            {
                UniquePtr<System.Dom.Element> domElement = element->CreateDomElement();
                element->Write(domElement.Get());
                diagramDocument.DocumentElement()->AppendChild(UniquePtr<System.Dom.Node>(domElement.Release()));
            }
            diagramDocument.Write(formatter);
        }
        public void Load(const string& filePath)
        {
            List<DiagramElement*> relationshipElements;
            UniquePtr<System.Dom.Document> diagramDocument = System.Dom.ReadDocument(filePath);
            UniquePtr<XPathObject> result = Evaluate(u"/diagram/*", diagramDocument.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->SetDiagram(this);
                            diagramElement->Read(element);
                            if (diagramElement.Get() is RelationshipElement*)
                            {
                                relationshipElements.Add(diagramElement.Get());
                            }
                            AddElement(diagramElement.Release());
                        }
                    }
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Resolve();
            }
        }
        public void Draw(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                if (layout.IsNull())
                {
                    layout.Reset(new Layout(graphics));
                }
                for (const UniquePtr<DiagramElement>& element : elements)
                {
                    element->Measure(graphics, *layout);
                }
            }
            if (Invalidated())
            {
                ResetInvalidated();
            }
            List<DiagramElement*> relationshipElements;
            for (const UniquePtr<DiagramElement>& element : elements)
            {
                if (element.Get() is ContainerElement*)
                {
                    element->Draw(graphics, *layout);
                }
                else if (element.Get() is RelationshipElement*)
                {
                    relationshipElements.Add(element.Get());
                }
            }
            for (DiagramElement* relationshipElement : relationshipElements)
            {
                relationshipElement->Draw(graphics, *layout);
            }
            operation->Draw(graphics, *layout);
        }
        public nothrow const Layout& GetLayout() const
        {
            return *layout;
        }
        public nothrow Layout& GetLayout()
        {
            return *layout;
        }
        public nothrow void SetLayout(Layout* layout_)
        {
            layout.Reset(layout_);
        }
        public nothrow void DeleteSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            if (!selection->IsEmpty())
            {
                selection->Delete();
            }
        }
        public nothrow void Undo()
        {
            commandList.Undo();
            SetChanged();
            Invalidate();
        }
        public nothrow void Redo()
        {
            commandList.Redo();
            SetChanged();
            Invalidate();
        }
        public nothrow inline DiagramElement* GetElementByIndex(int index) const
        {
            return elements.Get(index);
        }
        public nothrow inline void SetElementByIndex(DiagramElement* element, int index)
        {
            if (element != null)
            {
                element->SetDiagram(this);
            }
            elements.Set(index, element);
        }
        public nothrow int GetIndexOfElement(DiagramElement* element)
        {
            int n = elements.Count();
            for (int i = 0; i < n; ++i)
            {
                if (elements.Get(i) == element)
                {
                    return i;
                }
            }
            return -1;
        }
        public nothrow void AddElement(DiagramElement* element)
        {
            element->SetDiagram(this);
            elements.Add(element);
            SetChanged();
            Invalidate();
        }
        public nothrow UniquePtr<DiagramElement> RemoveElementByIndex(int index)
        {
            UniquePtr<DiagramElement> element = elements.Remove(index);
            SetChanged();
            Invalidate();
            return element;
        }
        public nothrow int GetIndexOfElementAt(const PointF& location) const
        {
            Contains<DiagramElement> pred(location);
            return IndexOf(elements, pred);
        }
        public nothrow Selection* GetSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            return selection.Get();
        }
        public nothrow void SetSelection(Selection* selection_)
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            selection->Clear();
            selection.Reset(selection_);
            if (selection.IsNull())
            {
                int x = 0;
            }
            if (!selection->IsEmpty())
            {
                EnableCopy();
                EnableCut();
            }
            else
            {
                DisableCopy();
                DisableCut();
            }
        }
        public nothrow void ResetSelection()
        {
            if (selection.IsNull())
            {
                int x = 0;
            }
            selection->Clear();
            DisposeContextMenu();
            selection.Reset(new EmptySelection(*this));
            DisableCopy();
            DisableCut();
        }
        public nothrow void EnableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCopy();
            }
        }
        public nothrow void EnableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->EnableCut();
            }
        }
        public nothrow void DisableCopy()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCopy();
            }
        }
        public nothrow void DisableCut()
        {
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                canvas->DisableCut();
            }
        }
        public void Paste(const ustring& clipboardData)
        {
            UniquePtr<System.Dom.Document> diagramElementDoc = System.Dom.ParseDocument(clipboardData, "clipboard");
            UniquePtr<XPathObject> result = Evaluate(u"/spring.diagram.elements/*", diagramElementDoc.Get());
            if (!result.IsNull())
            {
                if (result.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    UniquePtr<ElementSelection> elementSelection(new ElementSelection(*this));
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            string domElementName = ToUtf8(element->Name());
                            UniquePtr<DiagramElement> diagramElement(DiagramElementFactory.Instance().Create(domElementName));
                            diagramElement->Read(element);
                            int index = elements.Count();
                            AddElement(diagramElement.Release());
                            elementSelection->Add(index);
                        }
                    }
                    SetSelection(elementSelection.Release());
                }
            }
        }
        public nothrow inline Operation* GetOperation() const
        {
            return operation.Get();
        }
        public nothrow void SetOperation(Operation* operation_)
        {
            operation.Reset(operation_);
        }
        public void AdvanceOperation(const PointF& location)
        {
            if (!(operation.Get() is EmptyOperation*))
            {
                operation->AdvanceTo(location);
                SetChanged();
                Invalidate();
            }
        }
        public void CancelOperation()
        {
            operation->Cancel();
            ResetOperation();
            Tools.SetCurrent(Tools.GetSelectTool());
            SetChanged();
            Invalidate();
        }
        public void CommitOperation(const PointF& location)
        {
            operation->Commit(location);
            ResetOperation();
            SetChanged();
            Invalidate();
        }
        public nothrow void ResetOperation()
        {
            operation.Reset(new EmptyOperation());
        }
        public void DisposeContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->RemoveContextMenu();
        }
        public void HideContextMenu()
        {
            Window* window = canvas->GetWindow();
            window->HideContextMenu();
        }
        private nothrow inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        public nothrow inline void SetChanged()
        {
            if (!Changed())
            {
                flags = cast<Flags>(flags | Flags.changed);
                SetModified();
            }
        }
        private nothrow inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public nothrow inline bool Modified() const
        {
            return (flags & Flags.modified) != Flags.none;
        }
        public nothrow void SetModified()
        {
            flags = cast<Flags>(flags | Flags.modified);
            Canvas* canvas = GetCanvas();
            if (canvas != null)
            {
                StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                if (modifiedStatusBarItem != null)
                {
                    modifiedStatusBarItem->SetText("*");
                }
            }
        }
        public nothrow void ResetModified()
        {
            if (Modified())
            {
                flags = cast<Flags>(flags & ~Flags.modified);
                Canvas* canvas = GetCanvas();
                if (canvas != null)
                {
                    StatusBarItem* modifiedStatusBarItem = canvas->GetModifiedStatusBarItem();
                    if (modifiedStatusBarItem != null)
                    {
                        modifiedStatusBarItem->SetText(" ");
                    }
                }
            }
        }
        public nothrow inline bool Invalidated() const
        {
            return (flags & Flags.invalidated) != Flags.none;
        }
        public nothrow void Invalidate()
        {
            if (!Invalidated())
            {
                flags = cast<Flags>(flags | Flags.invalidated);
                if (canvas != null)
                {
                    canvas->Invalidate();
                }
            }
        }
        public nothrow inline void ResetInvalidated()
        {
            flags = cast<Flags>(flags & ~Flags.invalidated);
        }
        private Flags flags;
        private Canvas* canvas;
        private UniquePtr<Layout> layout;
        private IndexList<DiagramElement> elements;
        private UniquePtr<Selection> selection;
        private UniquePtr<Operation> operation;
        private CommandList commandList;
    }

    public abstract class DiagramElement
    {
        private enum Flags : sbyte
        {
            none = 0, selected = 1 << 0
        }
        public nothrow DiagramElement() : name()
        {
        }
        public nothrow DiagramElement(const string& name_) : name(name_)
        {
        }
        suppress DiagramElement(const DiagramElement&);
        suppress void operator=(const DiagramElement&);
        suppress DiagramElement(DiagramElement&&);
        suppress void operator=(DiagramElement&&);
        public virtual void Draw(Graphics& graphics, Layout& layout)
        {
            if (IsSelected())
            {
                DrawSelected(graphics, layout);
            }
        }
        public abstract System.Dom.Element* CreateDomElement() const;
        public abstract DiagramElement* Clone() const;
        public abstract void Measure(Graphics& graphics, Layout& layout);
        public virtual nothrow ContainerElement* GetContainerElement() const
        {
            return null;
        }
        public virtual nothrow void Resolve()
        {
        }
        public virtual nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            return Endpoint();
        }
        public virtual nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            return List<Endpoint>();
        }
        public virtual nothrow void AddRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void RemoveRelationship(RelationshipElement* relationship)
        {
        }
        public virtual nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            MenuItem* deleteMenuItem = new MenuItem("Delete");
            contextMenu->AddMenuItemAction(deleteMenuItem, new DeleteDiagramElementAction(diagram, elementIndex));
        }
        public virtual void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const ColorElement& selectedColorElement = layout.GetSelectedColorElement();
            const Brush* selectedBrush = selectedColorElement.GetBrush(layout);
            graphics.FillRectangleChecked(*selectedBrush, boundingRect);
        }
        public nothrow inline const string& Name() const
        {
            return name;
        }
        public nothrow void SetName(const string& name_)
        {
            name = name_;
        }
        public nothrow inline const PointF& Location() const
        {
            return boundingRect.location;
        }
        public nothrow inline void SetLocation(const PointF& location)
        {
            boundingRect.location = location;
        }
        public nothrow inline const SizeF& GetSize() const
        {
            return boundingRect.size;
        }
        public nothrow inline void SetSize(const SizeF& size)
        {
            boundingRect.size = size;
        }
        public nothrow const RectF& BoundingRect() const
        {
            return boundingRect;
        }
        public virtual nothrow bool Contains(const PointF& location)
        {
            return boundingRect.Contains(location);
        }
        public virtual void Read(System.Dom.Element* parentElement)
        {
            name = ToUtf8(parentElement->GetAttribute(u"name"));
            UniquePtr<XPathObject> result = Evaluate(u"boundingRect", parentElement);
            if (!result.IsNull())
            {
                if (result->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(result.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* boundingRectElement = cast<System.Dom.Element*>(node);
                            string x = ToUtf8(boundingRectElement->GetAttribute(u"x"));
                            string y = ToUtf8(boundingRectElement->GetAttribute(u"y"));
                            string w = ToUtf8(boundingRectElement->GetAttribute(u"w"));
                            string h = ToUtf8(boundingRectElement->GetAttribute(u"h"));
                            boundingRect = RectF(PointF(ParseFloat(x), ParseFloat(y)), SizeF(ParseFloat(w), ParseFloat(h)));
                        }
                    }
                }
            }
        }
        public virtual void Write(System.Dom.Element* parentElement)
        {
            parentElement->SetAttribute(u"name", ToUtf32(name));
            UniquePtr<System.Dom.Element> boundingRectElement(new System.Dom.Element(u"boundingRect"));
            boundingRectElement->SetAttribute(u"x", ToUtf32(System.ToString(boundingRect.location.x)));
            boundingRectElement->SetAttribute(u"y", ToUtf32(System.ToString(boundingRect.location.y)));
            boundingRectElement->SetAttribute(u"w", ToUtf32(System.ToString(boundingRect.size.w)));
            boundingRectElement->SetAttribute(u"h", ToUtf32(System.ToString(boundingRect.size.h)));
            parentElement->AppendChild(UniquePtr<System.Dom.Node>(boundingRectElement.Release()));
        }
        public virtual void SetFrom(DiagramElement* that)
        {
            name = that->name;
            boundingRect = that->boundingRect;
        }
        public nothrow inline bool IsSelected() const
        {
            return (flags & Flags.selected) != Flags.none;
        }
        public nothrow void Select()
        {
            if (!IsSelected())
            {
                flags = cast<Flags>(flags | Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void ResetSelected()
        {
            if (IsSelected())
            {
                flags = cast<Flags>(flags & ~Flags.selected);
                diagram->Invalidate();
            }
        }
        public nothrow void SetDiagram(Diagram* diagram_)
        {
            diagram = diagram_;
        }
        public nothrow inline Diagram* GetDiagram() const
        {
            return diagram;
        }
        private Flags flags;
        private string name;
        private RectF boundingRect;
        private Diagram* diagram;
    }

    public enum SnapPoint : sbyte
    {
        none, top, bottom, left, right, center, operation, field
    }

    public nothrow string ToString(SnapPoint snapPoint)
    {
        switch (snapPoint)
        {
            case SnapPoint.none: return "none";
            case SnapPoint.top: return "top";
            case SnapPoint.bottom: return "bottom";
            case SnapPoint.left: return "left";
            case SnapPoint.right: return "right";
            case SnapPoint.center: return "center";
            case SnapPoint.operation: return "operation";
            case SnapPoint.field: return "field";
        }
        return string();
    }

    public nothrow SnapPoint ParseSnapPoint(const string& str)
    {
        if (str == "none")
        {
            return SnapPoint.none;
        }
        else if (str == "top")
        {
            return SnapPoint.top;
        }
        else if (str == "bottom")
        {
            return SnapPoint.bottom;
        }
        else if (str == "left")
        {
            return SnapPoint.left;
        }
        else if (str == "right")
        {
            return SnapPoint.right;
        }
        else if (str == "center")
        {
            return SnapPoint.center;
        }
        else if (str == "operation")
        {
            return SnapPoint.operation;
        }
        else if (str == "field")
        {
            return SnapPoint.field;
        }
        return SnapPoint.none;
    }

    public class Snap
    {
        public nothrow constexpr Snap() : primaryPoint(SnapPoint.none), secondaryPoint(SnapPoint.none)
        {
        }
        public nothrow constexpr Snap(SnapPoint primaryPoint_, SnapPoint secondaryPoint_) : primaryPoint(primaryPoint_), secondaryPoint(secondaryPoint_)
        {
        }
        public explicit constexpr nothrow Snap(int x) : primaryPoint(cast<SnapPoint>(cast<sbyte>((x >> 8) & 0xff))), secondaryPoint(cast<SnapPoint>(cast<sbyte>(x & 0xff)))
        {
        }
        public static nothrow constexpr inline int TopLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int TopCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int TopRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.top)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int LeftTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int LeftCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int LeftBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.left)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public static nothrow constexpr inline int BottomLeft()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.left));
        }
        public static nothrow constexpr inline int BottomCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int BottomRight()
        {
            return cast<int>(cast<sbyte>(SnapPoint.bottom)) << 8 | cast<int>(cast<sbyte>(SnapPoint.right));
        }
        public static nothrow constexpr inline int RightTop()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.top));
        }
        public static nothrow constexpr inline int RightCenter()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.center));
        }
        public static nothrow constexpr inline int RightBottom()
        {
            return cast<int>(cast<sbyte>(SnapPoint.right)) << 8 | cast<int>(cast<sbyte>(SnapPoint.bottom));
        }
        public static nothrow constexpr inline int Operation(sbyte index)
        {
            return cast<int>(cast<sbyte>(SnapPoint.operation)) << 8 | cast<int>(index);
        }
        public static nothrow constexpr inline int Field(sbyte index)
        {
            return cast<int>(cast<sbyte>(SnapPoint.field)) << 8 | cast<int>(index);
        }
        public nothrow string ToString() const
        {
            if (primaryPoint == SnapPoint.operation || primaryPoint == SnapPoint.field)
            {
                return spring.ToString(primaryPoint) + "." + System.ToString(cast<sbyte>(secondaryPoint));
            }
            return spring.ToString(primaryPoint) + "." + spring.ToString(secondaryPoint);
        }
        public nothrow constexpr inline int ToInt() const
        {
            return cast<int>(cast<sbyte>(primaryPoint)) << 8 | cast<int>(cast<sbyte>(secondaryPoint));
        }
        public nothrow PointF Calculate(const PointF& point, float w, int index, int count)
        {
            int s = ToInt();
            switch (s)
            {
                case TopLeft():
                case BottomLeft():
                {
                    return PointF(point.x + index * w, point.y);
                }
                case TopRight():
                case BottomRight():
                {
                    return PointF(point.x - index * w, point.y);
                }
                case LeftTop():
                case RightTop():
                {
                    return PointF(point.x, point.y + index * w);
                }
                case LeftBottom():
                case RightBottom():
                {
                    return PointF(point.x, point.y - index * w);
                }
                case LeftCenter():
                case RightCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x, point.y - (count / 2) * w + index * w + w / 2);
                    }
                    else
                    {
                        return PointF(point.x, point.y - (count / 2) * w + index * w);
                    }
                }
                case TopCenter():
                case BottomCenter():
                {
                    if ((count & 1) == 0)
                    {
                        return PointF(point.x - (count / 2) * w + index * w + w / 2, point.y);
                    }
                    else
                    {
                        return PointF(point.x - (count / 2) * w + index * w, point.y);
                    }
                }
            }
            return PointF();
        }
        public SnapPoint primaryPoint;
        public SnapPoint secondaryPoint;
    }

    public nothrow Snap ParseSnap(const string& str)
    {
        List<string> components = str.Split(".");
        if (components.Count() == 2)
        {
            SnapPoint primary = ParseSnapPoint(components[0]);
            if (primary == SnapPoint.operation || primary == SnapPoint.field)
            {
                Snap snap(primary, cast<SnapPoint>(ParseSByte(components[1])));
                return snap;
            }
            else
            {
                Snap snap(primary, ParseSnapPoint(components[1]));
                return snap;
            }
        }
        return Snap();
    }

    public nothrow constexpr inline bool operator==(const Snap& left, const Snap& right)
    {
        return left.primaryPoint == right.primaryPoint && left.secondaryPoint == right.secondaryPoint;
    }

    public nothrow constexpr inline bool operator<(const Snap& left, const Snap& right)
    {
        if (left.primaryPoint < right.primaryPoint) return true;
        if (left.primaryPoint > right.primaryPoint) return false;
        return left.secondaryPoint < right.secondaryPoint;
    }

    public enum Cardinality : sbyte
    {
        zero, one, many
    }

    public nothrow Cardinality ParseCardinality(const string& s)
    {
        if (s == "zero")
        {
            return Cardinality.zero;
        }
        else if (s == "one")
        {
            return Cardinality.one;
        }
        else if (s == "many")
        {
            return Cardinality.many;
        }
        return Cardinality.zero;
    }

    public nothrow string ToString(Cardinality cardinality)
    {
        switch (cardinality)
        {
            case Cardinality.zero: return "zero";
            case Cardinality.one: return "one";
            case Cardinality.many: return "many";
        }
        return string();
    }

    public class EndpointNearer : Rel<Endpoint*>
    {
        public nothrow EndpointNearer(const PointF& location_) : location(location_)
        {
        }
        public nothrow bool operator()(Endpoint* left, Endpoint* right) const
        {
            return System.Windows.Distance(left->point, location) < System.Windows.Distance(right->point, location);
        }
        private PointF location;
    }

    public enum EndpointType
    {
        source, target
    }

    public class Endpoint
    {
        public nothrow Endpoint() : element(null), snap(), point(0, 0), text()
        {
        }
        public nothrow Endpoint(DiagramElement* element_, const Snap& snap_, const PointF& point_) : element(element_), snap(snap_), point(point_), text()
        {
        }
        public nothrow string ToString() const
        {
            if (element != null)
            {
                return "endpoint." + element->Name() + "." + snap.ToString() + "." + point.ToString() + "." + text;
            }
            return "endpoint.null";
        }
        public void Write(System.Dom.Element* parentElement)
        {
            if (element != null)
            {
                Diagram* diagram = element->GetDiagram();
                if (element != null)
                {
                    int index = diagram->GetIndexOfElement(element);
                    parentElement->SetAttribute(u"index", ToUtf32(ToString(index)));
                }
                else
                {
                    parentElement->SetAttribute(u"index", u"-1");
                }
                parentElement->SetAttribute(u"snap", ToUtf32(snap.ToString()));
                parentElement->SetAttribute(u"x", ToUtf32(ToString(point.x)));
                parentElement->SetAttribute(u"y", ToUtf32(ToString(point.y)));
                parentElement->SetAttribute(u"text", ToUtf32(text));
            }
        }
        public void Read(System.Dom.Element* parentElement)
        {
            index = ParseInt(ToUtf8(parentElement->GetAttribute(u"index")));
            snap = ParseSnap(ToUtf8(parentElement->GetAttribute(u"snap")));
            point.x = ParseFloat(ToUtf8(parentElement->GetAttribute(u"x")));
            point.y = ParseFloat(ToUtf8(parentElement->GetAttribute(u"y")));
            text = ToUtf8(parentElement->GetAttribute(u"text"));
        }
        public void Resolve(Diagram* diagram)
        {
            if (index != -1)
            {
                element = diagram->GetElementByIndex(index);
            }
        }
        public DiagramElement* element;
        public Snap snap;
        public PointF point;
        public string text;
        private int index;
    }

    public class RelationshipElement : DiagramElement
    {
        public enum Kind
        {
            none, inheritance, aggregation, reference, createInstance, attachNote
        }
        public nothrow RelationshipElement() : base(), kind(Kind.none), source(), target(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        public nothrow RelationshipElement(Kind kind_) : base(), kind(kind_), source(), target(), intermediatePoints(), cardinality(Cardinality.one)
        {
        }
        suppress RelationshipElement(const RelationshipElement&);
        suppress void operator=(const RelationshipElement&);
        suppress RelationshipElement(RelationshipElement&&);
        suppress void operator=(RelationshipElement&&);
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new RelationshipElementPropertiesAction(diagram, elementIndex));
        }
        public override nothrow bool Contains(const PointF& location)
        {
            Diagram* diagram = GetDiagram();
            const Layout& layout = diagram->GetLayout();
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            float selectedLineWidth = relationshipLayoutElement.SelectedLineWidth();
            PointF from = source.point;
            for (PointF to : intermediatePoints)
            {
                if (Contains(from, to, location, selectedLineWidth))
                {
                    return true;
                }
                from = to;
            }
            PointF to = target.point;
            if (Contains(from, to, location, selectedLineWidth))
            {
                return true;
            }
            return false;
        }
        public nothrow bool Contains(const PointF& from, const PointF& to, const PointF& loc, float selectedLineWidth)
        {
            Line line(from, to);
            Line lineToLoc(from, loc);
            Vector a(line.ToVector());
            Vector b(lineToLoc.ToVector());
            float f = ProjectionFactor(b, a);
            if (f >= 0 && f <= a.Length())
            {
                Vector c = Projection(b, a);
                Vector d = b - c;
                if (d.Length() <= selectedLineWidth / 2)
                {
                    return true;
                }
            }
            return false;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"relationship");
        }
        public override DiagramElement* Clone() const
        {
            RelationshipElement* clone = new RelationshipElement();
            clone->SetFrom(this);
            return clone;
        }
        public nothrow Kind ParseRelationshipKind(const string& str)
        {
            if (str == "none")
            {
                return Kind.none;
            }
            else if (str == "inheritance")
            {
                return Kind.inheritance;
            }
            else if (str == "aggregation")
            {
                return Kind.aggregation;
            }
            else if (str == "reference")
            {
                return Kind.reference;
            }
            else if (str == "createInstance")
            {
                return Kind.createInstance;
            }
            else if (str == "attachNote")
            {
                return Kind.attachNote;
            }
            return Kind.none;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            kind = ParseRelationshipKind(ToUtf8(element->GetAttribute(u"kind")));
            UniquePtr<XPathObject> sourceResult = Evaluate(u"source", element);
            if (!sourceResult.IsNull())
            {
                if (sourceResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(sourceResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            source.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> targetResult = Evaluate(u"target", element);
            if (!targetResult.IsNull())
            {
                if (targetResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(targetResult.Get());
                    int n = nodeSet->Length();
                    if (n == 1)
                    {
                        System.Dom.Node* node = (*nodeSet)[0];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            target.Read(element);
                        }
                    }
                }
            }
            UniquePtr<XPathObject> intermediatePointsResult = Evaluate(u"intermediatePoint", element);
            if (!intermediatePointsResult.IsNull())
            {
                if (intermediatePointsResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(intermediatePointsResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            PointF intermediatePoint;
                            intermediatePoint.x = ParseFloat(ToUtf8(element->GetAttribute(u"x")));
                            intermediatePoint.y = ParseFloat(ToUtf8(element->GetAttribute(u"y")));
                            intermediatePoints.Add(intermediatePoint);
                        }
                    }
                }
            }
            cardinality = ParseCardinality(ToUtf8(element->GetAttribute(u"cardinality")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            switch (kind)
            {
                case Kind.none: element->SetAttribute(u"kind", u"none"); break;
                case Kind.inheritance: element->SetAttribute(u"kind", u"inheritance"); break;
                case Kind.aggregation: element->SetAttribute(u"kind", u"aggregation"); break;
                case Kind.reference: element->SetAttribute(u"kind", u"reference"); break;
                case Kind.createInstance: element->SetAttribute(u"kind", u"createInstance"); break;
                case Kind.attachNote: element->SetAttribute(u"kind", u"attachNote"); break;
            }
            System.Dom.Element* sourceElement = new System.Dom.Element(u"source");
            source.Write(sourceElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(sourceElement));
            System.Dom.Element* targetElement = new System.Dom.Element(u"target");
            target.Write(targetElement);
            element->AppendChild(UniquePtr<System.Dom.Node>(targetElement));
            int n = cast<int>(intermediatePoints.Count());
            for (int i = 0; i < n; ++i)
            {
                System.Dom.Element* intermediatePointElement = new System.Dom.Element(u"intermediatePoint");
                intermediatePointElement->SetAttribute(u"x", ToUtf32(ToString(intermediatePoints[i].x)));
                intermediatePointElement->SetAttribute(u"y", ToUtf32(ToString(intermediatePoints[i].y)));
            }
            element->SetAttribute(u"cardinality", ToUtf32(ToString(cardinality)));
        }
        public nothrow override void Resolve()
        {
            source.Resolve(GetDiagram());
            if (source.element != null)
            {
                source.element->AddRelationship(this);
            }
            target.Resolve(GetDiagram());
            if (target.element != null)
            {
                target.element->AddRelationship(this);
            }
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            StringFormat stringFormat;
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Font& font = relationshipLayoutElement.GetFontElement().GetFont();
            if (!source.text.IsEmpty())
            {
                RectF r = graphics.MeasureStringChecked(source.text, font, PointF(), stringFormat);
                sourceTextSize = r.size;
            }
            else
            {
                sourceTextSize = SizeF();
            }
            if (!Name().IsEmpty())
            {
                RectF r = graphics.MeasureStringChecked(Name(), font, PointF(), stringFormat);
                centerTextSize = r.size;
            }
            else
            {
                centerTextSize = SizeF();
            }
            if (!target.text.IsEmpty())
            {
                RectF r = graphics.MeasureStringChecked(target.text, font, PointF(), stringFormat);
                targetTextSize = r.size;
            }
            else
            {
                targetTextSize = SizeF();
            }
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            switch (kind)
            {
                case Kind.inheritance:
                {
                    DrawInheritance(graphics, layout);
                    break;
                }
                case Kind.aggregation:
                {
                    DrawAggregation(graphics, layout);
                    break;
                }
                case Kind.reference:
                {
                    DrawReference(graphics, layout);
                    break;
                }
                case Kind.createInstance:
                {
                    DrawCreateInstance(graphics, layout);
                    break;
                }
                case Kind.attachNote:
                {
                    DrawAttachNote(graphics, layout);
                    break;
                }
            }
        }
        protected override void DrawSelected(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& selectedLinePen = relationshipLayoutElement.SelectedLinePen();
            PointF prev = source.point;
            for (PointF next : intermediatePoints)
            {
                graphics.DrawLineChecked(selectedLinePen, prev, next);
                prev = next;
            }
            graphics.DrawLineChecked(selectedLinePen, prev, target.point);
        }
        public nothrow void Calculate(const Snap& snap, DiagramElement* element, float w, int index, int count)
        {
            Endpoint endpoint = element->GetEndpoint(snap);
            if (source.element == element)
            {
                source.point = snap.Calculate(endpoint.point, w, index, count);
            }
            else if (target.element == element)
            {
                target.point = snap.Calculate(endpoint.point, w, index, count);
            }
        }
        private void DrawInheritance(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            float inheritanceArrowWidth = relationshipLayoutElement.InheritanceArrowWidth();
            float inheritanceArrowHeight = cast<float>(Sqrt(3) / 2 * inheritanceArrowWidth);
            PointF lastPoint;
            if (intermediatePoints.IsEmpty())
            {
                lastPoint = source.point;
            }
            else
            {
                PointF prevPoint = source.point;
                for (const PointF& intermediatePoint : intermediatePoints)
                {
                    graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                    prevPoint = intermediatePoint;
                }
                lastPoint = intermediatePoints.Back();
            }
            Line line(lastPoint, target.point);
            Vector v = line.ToVector();
            float len = v.Length();
            float startLen = Max(0.0f, len - inheritanceArrowHeight);
            Vector u = UnitVector(v) * startLen;
            Line startLine(source.point, u);
            graphics.DrawLineChecked(linePen, startLine.start, startLine.end);
            Line arrowLine(startLine.end, target.point);
            Line arrowRightRotatedLine = System.Windows.Rotate(arrowLine, 90.0f);
            Vector arv = UnitVector(arrowRightRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
            Line arrowRightLine(arrowRightRotatedLine.start, arv);
            graphics.DrawLineChecked(linePen, arrowRightLine.end, target.point);
            Line arrowLeftRotatedLine = System.Windows.Rotate(arrowLine, -90.0f);
            Vector alv = UnitVector(arrowLeftRotatedLine.ToVector()) * (inheritanceArrowWidth / 2);
            Line arrowLeftLine(arrowLeftRotatedLine.start, alv);
            graphics.DrawLineChecked(linePen, arrowLeftLine.end, target.point);
            graphics.DrawLineChecked(linePen, arrowLeftLine.end, arrowRightLine.end);
        }
        private void DrawAggregation(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float aggregateSymbolWidth = relationshipLayoutElement.AggregateSymbolWidth();
            float aggregateSymbolHeight = relationshipLayoutElement.AggregateSymbolHeight();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            PointF start = source.point;
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line aggregateLine(start, end);
            if (!source.text.IsEmpty())
            {
                DrawSourceText(graphics, font, textBrush, aggregateLine, aggregateSymbolWidth);
            }
            Vector v(aggregateLine.ToVector());
            Vector u(UnitVector(v) * aggregateSymbolWidth);
            Line aggregateSymbolLine(start, u);
            Vector h(u * 0.5f);
            Line halfAggregateSymbolLine(start, h);
            Vector l(UnitVector(System.Windows.Rotate(halfAggregateSymbolLine, 90.0f).ToVector()) * (aggregateSymbolHeight / 2));
            Vector r(UnitVector(System.Windows.Rotate(halfAggregateSymbolLine, -90.0f).ToVector()) * (aggregateSymbolHeight / 2));
            Line leftAggregateSymbolLine(halfAggregateSymbolLine.end, l);
            Line rightAggregateSymbolLine(halfAggregateSymbolLine.end, r);
            graphics.DrawLineChecked(linePen, aggregateSymbolLine.start, leftAggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, leftAggregateSymbolLine.end, aggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, aggregateSymbolLine.start, rightAggregateSymbolLine.end);
            graphics.DrawLineChecked(linePen, rightAggregateSymbolLine.end, aggregateSymbolLine.end);
            PointF prevPoint = aggregateSymbolLine.end;
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                prevPoint = intermediatePoint;
            }
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, circleLine.end, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, arrowEndLine.start, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
        }
        private void DrawReference(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const PaddingElement& padding = layout.GetClassPaddingElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            PointF start = source.point;
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line referenceLine(start, end);
            if (!source.text.IsEmpty())
            {
                DrawSourceText(graphics, font, textBrush, referenceLine, padding.left);
            }
            Vector v(referenceLine.ToVector());
            PointF prevPoint = referenceLine.start;
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                graphics.DrawLineChecked(linePen, prevPoint, intermediatePoint);
                prevPoint = intermediatePoint;
            }
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, circleLine.end, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                graphics.DrawLineChecked(linePen, arrowEndLine.start, arrowLine.end);
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
        }
        private void DrawCreateInstance(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const PaddingElement& padding = layout.GetClassPaddingElement();
            const FontElement& fontElement = relationshipLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const Brush& textBrush = relationshipLayoutElement.TextBrush();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Pen& dashPen = relationshipLayoutElement.DashLinePen();
            const Brush& arrowBrush = relationshipLayoutElement.ArrowBrush();
            float lineArrowWidth = relationshipLayoutElement.LineArrowWidth();
            float lineArrowHeight = relationshipLayoutElement.LineArrowHeight();
            float cardinalitySymbolRadius = relationshipLayoutElement.CardinalitySymbolRadius();
            PointF start = source.point;
            PointF end;
            if (intermediatePoints.IsEmpty())
            {
                end = target.point;
            }
            else
            {
                end = intermediatePoints.Front();
            }
            Line instanceLine(start, end);
            if (!source.text.IsEmpty())
            {
                DrawSourceText(graphics, font, textBrush, instanceLine, padding.left);
            }
            Vector v(instanceLine.ToVector());
            PointF prevPoint = instanceLine.start;
            if (!intermediatePoints.IsEmpty())
            {
                prevPoint = intermediatePoints.Back();
            }
            PointF finalPoint;
            Line arrowLine(target.point, prevPoint);
            Vector av(arrowLine.ToVector());
            if (cardinality == Cardinality.many)
            {
                Line line = arrowLine;
                Vector v = line.ToVector();
                Vector u(UnitVector(v) * cardinalitySymbolRadius);
                Line toCircleCenter(line.start, u);
                PointF circleCenter(toCircleCenter.end);
                Vector n1(0, -1);
                Vector u1(UnitVector(n1) * cardinalitySymbolRadius);
                Line l1(circleCenter, u1);
                Vector n2(-1, 0);
                Vector u2(UnitVector(n2) * cardinalitySymbolRadius);
                Line l2(l1.end, u2);
                PointF topLeftCorner(l2.end);
                RectF rect(topLeftCorner, SizeF(2.0f * cardinalitySymbolRadius, 2.0f * cardinalitySymbolRadius));
                graphics.FillEllipseChecked(arrowBrush, rect);
                Line circleLine(target.point, UnitVector(av) * 2.0f * cardinalitySymbolRadius);
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(circleLine.end, uv);
                Line arrowEndLine(arrowStartLine.end, circleLine.end);
                finalPoint = arrowEndLine.start;
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(circleLine.end);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                finalPoint = arrowEndLine.start;
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            else if (cardinality == Cardinality.one)
            {
                Vector uv(UnitVector(av) * cast<float>(Sqrt(3) / 2 * lineArrowWidth));
                Line arrowStartLine(target.point, uv);
                Line arrowEndLine(arrowStartLine.end, target.point);
                Vector la(UnitVector(System.Windows.Rotate(arrowEndLine, 90.0f).ToVector()) * (lineArrowHeight / 2));
                Vector ra(UnitVector(System.Windows.Rotate(arrowEndLine, -90.0f).ToVector()) * (lineArrowHeight / 2));
                Line leftArrowLine(arrowEndLine.start, la);
                Line rightArrowLine(arrowEndLine.start, ra);
                List<PointF> points;
                points.Add(target.point);
                points.Add(leftArrowLine.end);
                points.Add(rightArrowLine.end);
                graphics.FillPolygonChecked(arrowBrush, cast<int>(points.Count()), points.CBegin().Ptr());
                finalPoint = arrowEndLine.start;
                if (!target.text.IsEmpty())
                {
                    DrawTargetText(graphics, font, textBrush, arrowEndLine, lineArrowWidth);
                }
            }
            List<PointF> points;
            points.Add(source.point);
            for (const PointF& intermediatePoint : intermediatePoints)
            {
                points.Add(intermediatePoint);
            }
            points.Add(finalPoint);
            graphics.DrawLinesChecked(dashPen, cast<int>(points.Count()), points.CBegin().Ptr());
        }
        private void DrawAttachNote(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
            const Pen& linePen = relationshipLayoutElement.LinePen();
            const Pen& dotPen = relationshipLayoutElement.DotLinePen();
            float radius = relationshipLayoutElement.RelationshipSymbolRadius();
            PointF start = source.point;
            Vector left(-1, 0);
            Vector ul(UnitVector(left) * radius);
            Line l(start, ul);
            Vector up(0, -1);
            Vector uu(UnitVector(up) * radius);
            Line u(l.end, uu);
            RectF r(u.end, SizeF(2.0f * radius, 2.0f * radius));
            graphics.DrawEllipseChecked(linePen, r);
            PointF next;
            if (intermediatePoints.IsEmpty())
            {
                next = target.point;
            }
            else
            {
                next = intermediatePoints.Front();
            }
            Line line(start, next);
            Vector v = line.ToVector();
            Vector n = UnitVector(v) * radius;
            Line f(start, n);
            PointF first = f.end;
            List<PointF> points;
            points.Add(first);
            if (intermediatePoints.IsEmpty())
            {
                points.Add(next);
            }
            else
            {
                for (const PointF& intermediatePoint : intermediatePoints)
                {
                    points.Add(intermediatePoint);
                }
                points.Add(target.point);
            }
            graphics.DrawLinesChecked(dotPen, cast<int>(points.Count()), points.CBegin().Ptr());
        }
        private void DrawSourceText(Graphics& graphics, const Font& font, const Brush& textBrush, const Line& line, float symbolWidth)
        {
            try
            {
                GraphicsState state = graphics.SaveChecked();
                graphics.TranslateTransformChecked(0, -sourceTextSize.h, MatrixOrder.append);
                float dx = line.end.x - line.start.x;
                float dy = line.end.y - line.start.y;
                if (Abs(dy) >= Epsilon() * 2 && Abs(dx) >= Epsilon() * 2)
                {
                    float length = cast<float>(Sqrt(dx * dx, dy * dy));
                    dx = dx / length;
                    dy = dy / length;
                    float angle = cast<float>(180.0 * Atan2(dy, dx) / PI());
                    graphics.RotateTransformChecked(angle, MatrixOrder.append);
                }
                graphics.TranslateTransformChecked(line.start.x + symbolWidth, line.start.y, MatrixOrder.append);
                graphics.DrawStringChecked(source.text, font, PointF(0, 0), textBrush);
                graphics.RestoreChecked(state);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void DrawTargetText(Graphics& graphics, const Font& font, const Brush& textBrush, const Line& line, float symbolWidth)
        {
            try
            {
                GraphicsState state = graphics.SaveChecked();
                graphics.TranslateTransformChecked(0, -targetTextSize.h, MatrixOrder.append);
                float dx = line.end.x - line.start.x;
                float dy = line.end.y - line.start.y;
                if (Abs(dy) >= Epsilon() * 2 && Abs(dx) >= Epsilon() * 2)
                {
                    float length = cast<float>(Sqrt(dx * dx, dy * dy));
                    dx = dx / length;
                    dy = dy / length;
                    float angle = cast<float>(180.0 * Atan2(dy, dx) / PI());
                    graphics.RotateTransformChecked(angle, MatrixOrder.append);
                }
                graphics.TranslateTransformChecked(line.end.x - symbolWidth - targetTextSize.w, line.start.y, MatrixOrder.append);
                graphics.DrawStringChecked(target.text, font, PointF(0, 0), textBrush);
                graphics.RestoreChecked(state);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            kind = cast<RelationshipElement*>(that)->kind;
            source = cast<RelationshipElement*>(that)->source;
            target = cast<RelationshipElement*>(that)->target;
            intermediatePoints = cast<RelationshipElement*>(that)->intermediatePoints;
            cardinality = cast<RelationshipElement*>(that)->cardinality;
        }
        public nothrow void AddToElements()
        {
            if (source.element != null && target.element != null)
            {
                source.element->AddRelationship(this);
                target.element->AddRelationship(this);
            }
        }
        public nothrow void RemoveFromElements()
        {
            if (source.element != null)
            {
                source.element->RemoveRelationship(this);
            }
            if (target.element != null)
            {
                target.element->RemoveRelationship(this);
            }
        }
        public nothrow void RemoveContainer(ContainerElement* element)
        {
            if (source.element == element)
            {
                source.element = null;
            }
            if (target.element == element)
            {
                target.element = null;
            }
        }
        public Kind kind;
        public Cardinality cardinality;
        public Endpoint source;
        public Endpoint target;
        public List<PointF> intermediatePoints;
        private SizeF sourceTextSize;
        private SizeF centerTextSize;
        private SizeF targetTextSize;
    }

    public class FieldElement : DiagramElement
    {
        public nothrow FieldElement() : base(), relationship(null)
        {
        }
        public nothrow FieldElement(const string& name) : base(name), relationship(null)
        {
        }
        suppress FieldElement(const FieldElement&);
        suppress void operator=(const FieldElement&);
        suppress FieldElement(FieldElement&&);
        suppress void operator=(FieldElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"field");
        }
        public nothrow void SetContainerElement(ContainerElement* containerElement_)
        {
            containerElement = containerElement_;
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return containerElement;
        }
        public override nothrow void AddRelationship(RelationshipElement* relationship_)
        {
            relationship = relationship_;
        }
        public override nothrow void RemoveRelationship(RelationshipElement* relationship_)
        {
            if (relationship == relationship_)
            {
                relationship = null;
            }
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            Endpoint endpoint(this, snap, GetRelationshipPoint());
            return endpoint;
        }
        public void SetRelationshipPoint()
        {
            if (relationship != null)
            {
                relationship->source.element = this;
                relationship->source.point = GetRelationshipPoint();
            }
        }
        public PointF GetRelationshipPoint() const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            float symbolLeft = 0.0f;
            if (containerElement != null)
            {
                size.w = containerElement->GetMaxChildElementWidth();
                Diagram* diagram = containerElement->GetDiagram();
                if (diagram != null)
                {
                    const Layout& layout = diagram->GetLayout();
                    const PaddingElement& padding = layout.GetRelationshipSymbolPaddingElement();
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float relationshipSymbolRadius = relationshipLayoutElement.RelationshipSymbolRadius();
                    size.w = size.w - GetRelationshipSymbolFieldWidth(layout);
                    symbolLeft = padding.left + relationshipSymbolRadius;
                }
            }
            PointF point(loc.x + size.w + symbolLeft, loc.y + size.h / 2);
            return point;
        }
        public override DiagramElement* Clone() const
        {
            FieldElement* clone = new FieldElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const FieldLayoutElement& layoutElement = layout.GetFieldLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            containerElement = cast<FieldElement*>(that)->containerElement;
            relationship = cast<FieldElement*>(that)->relationship;
        }
        public nothrow inline RelationshipElement* Relationship() const
        {
            return relationship;
        }
        private ContainerElement* containerElement;
        private RelationshipElement* relationship;
    }

    public class OperationElement : DiagramElement
    {
        public nothrow OperationElement() : base(), isAbstract(false), relationship(null), containerElement(null)
        {
        }
        public nothrow OperationElement(const string& name) : base(name), isAbstract(false), relationship(null), containerElement(null)
        {
        }
        public nothrow OperationElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_), relationship(null), containerElement(null)
        {
        }
        suppress OperationElement(const OperationElement&);
        suppress void operator=(const OperationElement&);
        suppress OperationElement(OperationElement&&);
        suppress void operator=(OperationElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public nothrow void SetContainerElement(ContainerElement* containerElement_)
        {
            containerElement = containerElement_;
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return containerElement;
        }
        public override nothrow void AddRelationship(RelationshipElement* relationship_)
        {
            relationship = relationship_;
        }
        public override nothrow void RemoveRelationship(RelationshipElement* relationship_)
        {
            if (relationship == relationship_)
            {
                relationship = null;
            }
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            Endpoint endpoint(this, snap, GetRelationshipPoint());
            return endpoint;
        }
        public void SetRelationshipPoint()
        {
            if (relationship != null)
            {
                relationship->source.element = this;
                relationship->source.point = GetRelationshipPoint();
            }
        }
        public PointF GetRelationshipPoint() const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            float symbolLeft = 0.0f;
            if (containerElement != null)
            {
                size.w = containerElement->GetMaxChildElementWidth();
                Diagram* diagram = containerElement->GetDiagram();
                if (diagram != null)
                {
                    const Layout& layout = diagram->GetLayout();
                    const PaddingElement& padding = layout.GetRelationshipSymbolPaddingElement();
                    const RelationshipLayoutElement& relationshipLayoutElement = layout.GetRelationshipLayoutElement();
                    float relationshipSymbolRadius = relationshipLayoutElement.RelationshipSymbolRadius();
                    size.w = size.w - GetRelationshipSymbolFieldWidth(layout);
                    symbolLeft = padding.left + relationshipSymbolRadius;
                }
            }
            PointF point(loc.x + size.w + symbolLeft, loc.y + size.h / 2);
            return point;
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"operation");
        }
        public override DiagramElement* Clone() const
        {
            OperationElement* clone = new OperationElement();
            clone->SetFrom(this);
            return clone;
        }
        public override void Read(System.Dom.Element* element)
        {
            base->Read(element);
            isAbstract = ParseBool(ToUtf8(element->GetAttribute(u"abstract")));
        }
        public override void Write(System.Dom.Element* element)
        {
            base->Write(element);
            element->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                DrawAbstractOperation(graphics, layout);
            }
            else
            {
                DrawConcreteOperation(graphics, layout);
            }
        }
        private void DrawAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        private void DrawConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            graphics.DrawStringChecked(Name(), fontElement.GetFont(), Location(), *textColorElement.GetBrush(layout));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (isAbstract)
            {
                MeasureAbstractOperation(graphics, layout);
            }
            else
            {
                MeasureConcreteOperation(graphics, layout);
            }
        }
        private void MeasureAbstractOperation(Graphics& graphics, Layout& layout)
        {
            const AbstractOperationLayoutElement& layoutElement = layout.GetAbstractOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        private void MeasureConcreteOperation(Graphics& graphics, Layout& layout)
        {
            const ConcreteOperationLayoutElement& layoutElement = layout.GetConcreteOperationLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            RectF r = graphics.MeasureStringChecked(Name(), fontElement.GetFont(), PointF(0, 0), layout.GetStringFormat());
            SetSize(r.size);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<OperationElement*>(that)->isAbstract;
            containerElement = cast<OperationElement*>(that)->containerElement;
            relationship = cast<OperationElement*>(that)->relationship;
        }
        public nothrow inline RelationshipElement* Relationship() const
        {
            return relationship;
        }
        private bool isAbstract;
        private ContainerElement* containerElement;
        private RelationshipElement* relationship;
    }

    public abstract class ContainerElement : DiagramElement
    {
        public nothrow ContainerElement() : base()
        {
        }
        public nothrow ContainerElement(const string& name) : base(name)
        {
        }
        public ~ContainerElement()
        {
            for (RelationshipElement* relationship : relationships)
            {
                relationship->RemoveContainer(this);
            }
        }
        public nothrow void SetRelationshipsFrom(ContainerElement* oldElement)
        {
            for (RelationshipElement* relationship : oldElement->relationships)
            {
                if (relationship->source.element == oldElement)
                {
                    AddRelationship(relationship);
                    relationship->source.element = this;
                }
                if (relationship->target.element == oldElement)
                {
                    AddRelationship(relationship);
                    relationship->target.element = this;
                }
            }
        }
        public override nothrow ContainerElement* GetContainerElement() const
        {
            return this;
        }
        public virtual nothrow float GetMaxChildElementWidth() const
        {
            return 0.0f;
        }
        public override nothrow Endpoint GetEndpoint(const Snap& snap) const
        {
            PointF loc = Location();
            SizeF size = GetSize();
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            switch (snap.ToInt())
            {
                case Snap.TopLeft():
                {
                    return Endpoint(this, Snap(Snap.TopLeft()), PointF(loc.x + w, loc.y));
                }
                case Snap.TopCenter():
                {
                    return Endpoint(this, Snap(Snap.TopCenter()), PointF(loc.x + size.w / 2, loc.y));
                }
                case Snap.TopRight():
                {
                    return Endpoint (this, Snap(Snap.TopRight()), PointF(loc.x + size.w - w, loc.y));
                }
                case Snap.RightTop():
                {
                    return Endpoint(this, Snap(Snap.RightTop()), PointF(loc.x + size.w, loc.y + w));
                }
                case Snap.RightCenter():
                {
                    return Endpoint(this, Snap(Snap.RightCenter()), PointF(loc.x + size.w, loc.y + size.h / 2));
                }
                case Snap.RightBottom():
                {
                    return Endpoint(this, Snap(Snap.RightBottom()), PointF(loc.x + size.w, loc.y + size.h - w));
                }
                case Snap.BottomRight():
                {
                    return Endpoint(this, Snap(Snap.BottomRight()), PointF(loc.x + size.w - w, loc.y + size.h));
                }
                case Snap.BottomCenter():
                {
                    return Endpoint(this, Snap(Snap.BottomCenter()), PointF(loc.x + size.w / 2, loc.y + size.h));
                }
                case Snap.BottomLeft():
                {
                    return Endpoint(this, Snap(Snap.BottomLeft()), PointF(loc.x + w, loc.y + size.h));
                }
                case Snap.LeftBottom():
                {
                    return Endpoint(this, Snap(Snap.LeftBottom()), PointF(loc.x, loc.y + size.h - w));
                }
                case Snap.LeftCenter():
                {
                    return Endpoint(this, Snap(Snap.LeftCenter()), PointF(loc.x, loc.y + size.h / 2));
                }
                case Snap.LeftTop():
                {
                    return Endpoint(this, Snap(Snap.LeftTop()), PointF(loc.x, loc.y + w));
                }
            }
            return Endpoint();
        }
        public override nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            List<Endpoint> endpoints;
            endpoints.Add(GetEndpoint(Snap(Snap.TopLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.TopRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightTop())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.RightBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomRight())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.BottomLeft())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftBottom())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftCenter())));
            endpoints.Add(GetEndpoint(Snap(Snap.LeftTop()))); 
            return endpoints;
        }
        public nothrow List<RelationshipElement*> GetSelfRelationships() const
        {
            List<RelationshipElement*> selfRelationships;
            for (RelationshipElement* relationship : relationships)
            {
                if (relationship->source.element == this && relationship->target.element == this)
                {
                    selfRelationships.Add(relationship);
                }
            }
            return selfRelationships;
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const RelationshipLayoutElement& layoutElement = GetDiagram()->GetLayout().GetRelationshipLayoutElement();
            float w = layoutElement.LineArrowWidth();
            MeasureRelationships(Snap(Snap.TopLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.TopRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomLeft()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.BottomRight()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.LeftBottom()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightTop()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightCenter()), w, graphics, layout);
            MeasureRelationships(Snap(Snap.RightBottom()), w, graphics, layout);
        }
        private void MeasureRelationships(const Snap& snap, float w, Graphics& graphics, Layout& layout)
        {
            List<RelationshipElement*> pickedRelationships = PickRelationships(snap);
            int n = cast<int>(pickedRelationships.Count());
            for (int i = 0; i < n; ++i)
            {
                RelationshipElement* relationship = pickedRelationships[i];
                relationship->Calculate(snap, this, w, i, n);
            }
        }
        public nothrow inline const List<RelationshipElement*>& Relationships() const
        {
            return relationships;
        }
        public nothrow List<RelationshipElement*>& Relationships()
        {
            return relationships;
        }
        public nothrow override void AddRelationship(RelationshipElement* relationship)
        {
            if (Find(relationships.CBegin(), relationships.CEnd(), relationship) == relationships.CEnd())
            {
                relationships.Add(relationship);
            }
        }
        public nothrow override void RemoveRelationship(RelationshipElement* relationship)
        {
            relationships.Remove(relationship);
        }
        private nothrow List<RelationshipElement*> PickRelationships(const Snap& snap) const
        {
            List<RelationshipElement*> pickedRelationships;
            for (RelationshipElement* relationship : relationships)
            {
                if (relationship->source.element == this)
                {
                    if (relationship->source.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
                else if (relationship->target.element == this)
                {
                    if (relationship->target.snap == snap)
                    {
                        pickedRelationships.Add(relationship);
                    }
                }
            }
            return pickedRelationships;
        }
        private List<RelationshipElement*> relationships;
    }

    public class ClassElement : ContainerElement
    {
        public nothrow ClassElement() : base()
        {
        }
        public nothrow ClassElement(const string& name, bool isAbstract_) : base(name), isAbstract(isAbstract_)
        {
        }
        suppress ClassElement(const ClassElement&);
        suppress void operator=(const ClassElement&);
        suppress ClassElement(ClassElement&&);
        suppress void operator=(ClassElement&&);
        public nothrow inline bool IsAbstract() const
        {
            return isAbstract;
        }
        public nothrow inline void SetAbstract(bool isAbstract_)
        {
            isAbstract = isAbstract_;
        }
        public nothrow void ResetAbstractOperations()
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->SetAbstract(false);
            }
        }
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"class");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ClassElement> clone = new ClassElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override nothrow List<Endpoint> GetEndpoints(EndpointType endpointType, Tool* tool) const
        {
            if (endpointType == EndpointType.source && (tool is AttachNoteTool*))
            {
                List<Endpoint> endpoints;
                int no = operations.Count();
                for (int i = 0; i < no; ++i)
                {
                    OperationElement* operation = operations.Get(i);
                    endpoints.Add(operation->GetEndpoint(Snap(Snap.Operation(cast<sbyte>(i)))));
                }
                int nf = fields.Count();
                for (int i = 0; i < nf; ++i)
                {
                    FieldElement* field = fields.Get(i);
                    endpoints.Add(field->GetEndpoint(Snap(Snap.Field(cast<sbyte>(i)))));
                }
                return endpoints;
            }
            return base->GetEndpoints(endpointType, tool);
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawOperations(graphics, layout);
            DrawFields(graphics, layout);
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ClassElementPropertiesAction(diagram, elementIndex));
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                MeasureConcreteClass(graphics, layout);
            }
            else
            {
                MeasureAbstractClass(graphics, layout);
            }
            base->Measure(graphics, layout);
        }
        private void MeasureConcreteClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureOperations(graphics, layout, hasRelationship);
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                float w = GetRelationshipSymbolFieldWidth(layout);
                operationRect.size.w = operationRect.size.w + w;
                fieldRect.size.w = fieldRect.size.w + w;
                SetRelationshipPoints();
            }
            SetSize();
        }
        private void MeasureAbstractClass(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureOperations(graphics, layout, hasRelationship);
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                float w = GetRelationshipSymbolFieldWidth(layout);
                operationRect.size.w = operationRect.size.w + w;
                fieldRect.size.w = fieldRect.size.w + w;
                SetRelationshipPoints();
            }
            SetSize();
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                size.w = Max(size.w, operationRect.size.w);
                h = h + operationRect.size.h;
            }
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        private void SetRelationshipPoints()
        {
            int no = operations.Count();
            for (int i = 0; i < no; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->SetRelationshipPoint();
            }
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->SetRelationshipPoint();
            }
        }
        private void MeasureOperations(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            PointF location = Location();
            operationRect = RectF();
            operationRect.location.x = location.x;
            operationRect.location.y = location.y + captionRect.size.h;
            operationRect.size.w = captionRect.size.w;
            operationRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = operationRect.location.x + paddingElement.left;
            origin.y = operationRect.location.y + paddingElement.top;
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Measure(graphics, layout);
                SizeF operationSize = operation->GetSize();
                float w = operationSize.w + paddingElement.Horizontal();
                float h = operationSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (operation->Relationship() != null)
                {
                    hasRelationship = true;
                }
                operation->SetLocation(origin);
                operationRect.size.w = Max(operationRect.size.w, w);
                origin.y = origin.y + h;
                operationRect.size.h = operationRect.size.h + h;
            }
            operationRect.size.h = operationRect.size.h + paddingElement.bottom;
        }
        private void MeasureFields(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = operationRect.location.y + operationRect.size.h;
            fieldRect.size.w = operationRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (field->Relationship() != null)
                {
                    hasRelationship = true;
                }
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassFrame(graphics, layout);
            }
            else
            {
                DrawAbstractClassFrame(graphics, layout);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            if (!isAbstract)
            {
                DrawConcreteClassCaption(graphics, layout);
            }
            else
            {
                DrawAbstractClassCaption(graphics, layout);
            }
        }
        private void DrawConcreteClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawAbstractClassFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            graphics.DrawRectangleChecked(layoutElement.FramePen(), BoundingRect());
            float captionY = paddingElement.Vertical() + captionTextHeight;
            PointF location = Location();
            PointF captionLineStart(location.x, location.y + captionY);
            PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
            const Pen& framePen = layoutElement.FramePen();
            if (!operations.IsEmpty() || !fields.IsEmpty())
            {
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
            if (!fields.IsEmpty())
            {
                PointF fieldLineStart(location.x, fieldRect.location.y);
                PointF fieldLineEnd(location.x + GetSize().w, fieldRect.location.y);
                graphics.DrawLineChecked(framePen, fieldLineStart, fieldLineEnd);
            }
        }
        private void DrawConcreteClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ConcreteClassLayoutElement& layoutElement = layout.GetConcreteClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawAbstractClassCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const AbstractClassLayoutElement& layoutElement = layout.GetAbstractClassLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        private void DrawOperations(Graphics& graphics, Layout& layout)
        {
            int n = operations.Count();
            for (int i = 0; i < n; ++i)
            {
                OperationElement* operation = operations.Get(i);
                operation->Draw(graphics, layout);
            }
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            isAbstract = ParseBool(ToUtf8(parentElement->GetAttribute(u"abstract")));
            UniquePtr<XPathObject> operationResult = Evaluate(u"operation", parentElement);
            if (!operationResult.IsNull())
            {
                if (operationResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(operationResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<OperationElement> operation(new OperationElement());
                            operation->SetContainerElement(this);
                            operation->Read(element);
                            operations.Add(operation.Release());
                        }
                    }
                }
            }
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->SetContainerElement(this);
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            parentElement->SetAttribute(u"abstract", ToUtf32(System.ToString(isAbstract)));
            for (const UniquePtr<OperationElement>& operation : operations)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"operation");
                operation->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            isAbstract = cast<ClassElement*>(that)->isAbstract;
            operations.Clear();
            for (UniquePtr<OperationElement>& operation : cast<ClassElement*>(that)->operations)
            {
                OperationElement* clonedOperation = cast<OperationElement*>(operation->Clone());
                clonedOperation->SetContainerElement(this);
                operations.Add(clonedOperation);
            }
            fields.Clear();
            for (UniquePtr<FieldElement>& field : cast<ClassElement*>(that)->fields)
            {
                FieldElement* clonedField = cast<FieldElement*>(field->Clone());
                clonedField->SetContainerElement(this);
                fields.Add(clonedField);
            }
        }
        public nothrow IndexList<OperationElement>& Operations() 
        {
            return operations;
        }
        public void SetOperations(IndexList<OperationElement>&& operations_)
        {
            operations = operations_;
            for (UniquePtr<OperationElement>& operation : operations)
            {
                operation->SetContainerElement(this);   
            }
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
            for (UniquePtr<FieldElement>& field : fields)
            {
                field->SetContainerElement(this);
            }
        }
        public nothrow override float GetMaxChildElementWidth() const
        {
            return maxChildElementWidth;
        }
        private IndexList<OperationElement> operations;
        private IndexList<FieldElement> fields;
        private bool isAbstract;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF operationRect;
        private RectF fieldRect;
        private float maxChildElementWidth;
    }

    public class ObjectElement : ContainerElement
    {
        public nothrow ObjectElement() : base()
        {
        }
        public nothrow ObjectElement(const string& name) : base(name)
        {
        }
        suppress ObjectElement(const ObjectElement&);
        suppress void operator=(const ObjectElement&);
        suppress ObjectElement(ObjectElement&&);
        suppress void operator=(ObjectElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"object");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<ObjectElement> clone = new ObjectElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new ObjectElementPropertiesAction(diagram, elementIndex));
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            DrawFrame(graphics, layout);
            DrawCaption(graphics, layout);
            DrawFields(graphics, layout);
        }
        private void DrawFrame(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const Pen& framePen = layoutElement.FramePen();
            float roundingRadius = layoutElement.FrameRoundingRadius();
            PointF loc = Location();
            SizeF size = GetSize();
            PointF topStart(loc.x + roundingRadius - 1.0f - DefaultFrameWidth(graphics), loc.y);
            PointF topEnd(loc.x + size.w - roundingRadius + 1.0f + DefaultFrameWidth(graphics), loc.y);
            graphics.DrawLineChecked(framePen, topStart, topEnd);
            RectF topLeftRoundingRect(PointF(loc.x, loc.y), SizeF(roundingRadius, roundingRadius));
            float topLeftRoundingStartAngle = 180.0f;
            float topLeftRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, topLeftRoundingRect, topLeftRoundingStartAngle, topLeftRoudingSweepAngle);
            PointF rightStart(loc.x + size.w, loc.y + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics));
            PointF rightEnd(loc.x + size.w, loc.y + size.h - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, rightStart, rightEnd);
            RectF topRightRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y), SizeF(roundingRadius, roundingRadius));
            float topRightRoundingStartAngle = 0.0f;
            float topRightRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, topRightRoundingRect, topRightRoundingStartAngle, topRightRoudingSweepAngle);
            RectF rightBottomRoundingRect(PointF(loc.x + size.w - roundingRadius, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float rightBottomRoundingStartAngle = 0.0f;
            float rightBottomRoudingSweepAngle = 90.0f;
            graphics.DrawArcChecked(framePen, rightBottomRoundingRect, rightBottomRoundingStartAngle, rightBottomRoudingSweepAngle);
            PointF bottomStart(loc.x + roundingRadius - 1.0f - 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            PointF bottomEnd(loc.x + size.w - roundingRadius + 1.0f + 2.0f * DefaultFrameWidth(graphics), loc.y + size.h);
            graphics.DrawLineChecked(framePen, bottomStart, bottomEnd);
            RectF leftBottomRoundingRect(PointF(loc.x, loc.y + size.h - roundingRadius), SizeF(roundingRadius, roundingRadius));
            float leftBottomRoundingStartAngle = 180.0f;
            float leftBottomRoudingSweepAngle = -90.0f;
            graphics.DrawArcChecked(framePen, leftBottomRoundingRect, leftBottomRoundingStartAngle, leftBottomRoudingSweepAngle);
            PointF leftStart(loc.x, loc.y + roundingRadius - 1.0f - DefaultFrameWidth(graphics));
            PointF leftEnd(loc.x, loc.y + size.h - roundingRadius + 1.0f + DefaultFrameWidth(graphics));
            graphics.DrawLineChecked(framePen, leftStart, leftEnd);
            if (!fields.IsEmpty())
            {
                float captionY = paddingElement.Vertical() + captionTextHeight;
                PointF location = Location();
                PointF captionLineStart(location.x, location.y + captionY);
                PointF captionLineEnd(location.x + GetSize().w, location.y + captionY);
                graphics.DrawLineChecked(framePen, captionLineStart, captionLineEnd);
            }
        }
        private void DrawCaption(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            PointF location = Location();
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            const Font& font = fontElement.GetFont();
            const Brush& brush = layoutElement.TextBrush();
            graphics.DrawStringChecked(Name(), font, origin, brush);
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetClassPaddingElement();
            const ObjectLayoutElement& layoutElement = layout.GetObjectLayoutElement();
            const CaptionLayoutElement& captionLayoutElement = layoutElement.GetCaptionElement();
            const FontElement& fontElement = captionLayoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            RectF r = graphics.MeasureStringChecked(Name(), font, PointF(0, 0), layout.GetStringFormat());
            captionTextHeight = r.size.h;
            captionRect = RectF();
            captionRect.location = Location();
            captionRect.size.h = paddingElement.Vertical() + r.size.h;
            captionRect.size.w = paddingElement.Horizontal() + r.size.w;
            maxChildElementWidth = 0.0f;
            bool hasRelationship = false;
            MeasureFields(graphics, layout, hasRelationship);
            if (hasRelationship)
            {
                fieldRect.size.w = fieldRect.size.w + GetRelationshipSymbolFieldWidth(layout);
                SetRelationshipPoints();
            }
            SetSize();
            base->Measure(graphics, layout);
        }
        private void SetRelationshipPoints()
        {
            int nf = fields.Count();
            for (int i = 0; i < nf; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->SetRelationshipPoint();
            }
        }
        private void DrawFields(Graphics& graphics, Layout& layout)
        {
            int n = fields.Count();
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Draw(graphics, layout);
            }
        }
        private void MeasureFields(Graphics& graphics, Layout& layout, bool& hasRelationship)
        {
            const PaddingElement& paddingElement = layout.GetObjectPaddingElement();
            fieldRect = RectF();
            PointF location = Location();
            fieldRect.location.x = location.x;
            fieldRect.location.y = captionRect.location.y + captionRect.size.h;
            fieldRect.size.w = captionRect.size.w;
            fieldRect.size.h = paddingElement.top;
            PointF origin;
            origin.x = fieldRect.location.x + paddingElement.left;
            origin.y = fieldRect.location.y + paddingElement.top;
            int n = fields.Count();
            bool hasRelationship = false;
            for (int i = 0; i < n; ++i)
            {
                FieldElement* field = fields.Get(i);
                field->Measure(graphics, layout);
                SizeF fieldSize = field->GetSize();
                float w = fieldSize.w + paddingElement.Horizontal();
                float h = fieldSize.h;
                maxChildElementWidth = Max(maxChildElementWidth, w);
                if (field->Relationship() != null)
                {
                    hasRelationship = true;
                }
                field->SetLocation(origin);
                fieldRect.size.w = Max(fieldRect.size.w, w);
                origin.y = origin.y + h;
                fieldRect.size.h = fieldRect.size.h + h;
            }
            fieldRect.size.h = fieldRect.size.h + paddingElement.bottom;
        }
        private void SetSize()
        {
            SizeF size;
            size.w = Max(size.w, captionRect.size.w);
            float h = captionRect.size.h;
            if (!fields.IsEmpty())
            {
                size.w = Max(size.w, fieldRect.size.w);
                h = h + fieldRect.size.h;
            }
            size.h = Max(size.h, h);
            SetSize(size);
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            UniquePtr<XPathObject> fieldResult = Evaluate(u"field", parentElement);
            if (!fieldResult.IsNull())
            {
                if (fieldResult->Type() == XPathObjectType.nodeSet)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(fieldResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node->GetNodeType() == System.Dom.NodeType.elementNode)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            UniquePtr<FieldElement> field(new FieldElement());
                            field->SetContainerElement(this);
                            field->Read(element);
                            fields.Add(field.Release());
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            for (const UniquePtr<FieldElement>& field : fields)
            {
                UniquePtr<System.Dom.Element> element = new System.Dom.Element(u"field");
                field->Write(element.Get());
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(element.Release()));
            }
        }
        public nothrow IndexList<FieldElement>& Fields()
        {
            return fields;
        }
        public void SetFields(IndexList<FieldElement>&& fields_)
        {
            fields = fields_;
            for (UniquePtr<FieldElement>& field : fields)
            {
                field->SetContainerElement(this);
            }
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            fields.Clear();
            for (UniquePtr<FieldElement>& field : cast<ObjectElement*>(that)->fields)
            {
                FieldElement* clonedField = cast<FieldElement*>(field->Clone());
                clonedField->SetContainerElement(this);
                fields.Add(clonedField);
            }
        }
        public nothrow override float GetMaxChildElementWidth() const
        {
            return maxChildElementWidth;
        }
        private IndexList<FieldElement> fields;
        private float captionTextHeight;
        private RectF captionRect;
        private RectF fieldRect;
        private float maxChildElementWidth;
    }

    public class NoteElement : ContainerElement
    {
        public nothrow NoteElement() : base("note")
        {
        }
        suppress NoteElement(const NoteElement&);
        suppress void operator=(const NoteElement&);
        suppress NoteElement(NoteElement&&);
        suppress void operator=(NoteElement&&);
        public override System.Dom.Element* CreateDomElement() const
        {
            return new System.Dom.Element(u"note");
        }
        public override DiagramElement* Clone() const
        {
            UniquePtr<NoteElement> clone = new NoteElement();
            clone->SetFrom(this);
            return clone.Release();
        }
        public override nothrow void AddActions(Diagram& diagram, int elementIndex, ContextMenu* contextMenu)
        {
            base->AddActions(diagram, elementIndex, contextMenu);
            MenuItem* propertiesMenuItem = new MenuItem("Properties...");
            contextMenu->AddMenuItemAction(propertiesMenuItem, new NoteElementPropertiesAction(diagram, elementIndex));
        }
        public override void Read(System.Dom.Element* parentElement)
        {
            base->Read(parentElement);
            UniquePtr<XPathObject> lineResult = Evaluate(u"line", parentElement);
            if (!lineResult.IsNull())
            {
                if (lineResult.Get() is XPathNodeSet*)
                {
                    XPathNodeSet* nodeSet = cast<XPathNodeSet*>(lineResult.Get());
                    int n = nodeSet->Length();
                    for (int i = 0; i < n; ++i)
                    {
                        System.Dom.Node* node = (*nodeSet)[i];
                        if (node is System.Dom.Element*)
                        {
                            System.Dom.Element* element = cast<System.Dom.Element*>(node);
                            lines.Add(ToUtf8(element->GetAttribute(u"value")));
                        }
                    }
                }
            }
        }
        public override void Write(System.Dom.Element* parentElement)
        {
            base->Write(parentElement);
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                System.Dom.Element* lineElement = new System.Dom.Element(u"line");
                lineElement->SetAttribute(u"value", ToUtf32(lines[i]));
                parentElement->AppendChild(UniquePtr<System.Dom.Node>(lineElement));
            }
        }
        public override void Measure(Graphics& graphics, Layout& layout)
        {
            const PaddingElement& paddingElement = layout.GetNotePaddingElement();
            const NoteLayoutElement& layoutElement = layout.GetNoteLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            StringFormat stringFormat;
            SizeF size = SizeF();
            Size cornerBitmapSize(11, 11);
            SizeF cornerBitmapSizeF(ScreenMetrics.Get().HorizontalPixelsToMM(cornerBitmapSize.w), ScreenMetrics.Get().VerticalPixelsToMM(cornerBitmapSize.h));
            size.h = paddingElement.Vertical();
            lineSize = SizeF();
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const string& line = lines[i];
                RectF lineRect = graphics.MeasureStringChecked(line, font, PointF(0, 0), stringFormat);
                lineSize.h = Max(lineSize.h, lineRect.size.h);
                size.w = Max(size.w, paddingElement.Horizontal() + lineRect.size.w + cornerBitmapSizeF.w);
                size.h = size.h + lineSize.h;
            }
            SetSize(size);
        }
        public override void Draw(Graphics& graphics, Layout& layout)
        {
            base->Draw(graphics, layout);
            const PaddingElement& paddingElement = layout.GetNotePaddingElement();
            const NoteLayoutElement& layoutElement = layout.GetNoteLayoutElement();
            const FontElement& fontElement = layoutElement.GetFontElement();
            const Font& font = fontElement.GetFont();
            const ColorElement& textColorElement = layoutElement.TextColorElement();
            const Brush* brush = textColorElement.GetBrush(layout);
            const Pen& framePen = layoutElement.FramePen();
            PointF location = Location();
            SizeF size = GetSize();
            Size cornerBitmapSize(11, 11);
            SizeF cornerBitmapSizeF(ScreenMetrics.Get().HorizontalPixelsToMM(cornerBitmapSize.w), ScreenMetrics.Get().VerticalPixelsToMM(cornerBitmapSize.h));
            PointF cornerBitmapLocF(location.x + size.w - cornerBitmapSizeF.w, location.y);
            Point cornerBitmapLoc(GetDiagram()->GetCanvas()->ToControlLocation(cornerBitmapLocF));
            Bitmap* noteCornerBitmap = GetDiagram()->GetCanvas()->GetNoteCornerBitmap();
            graphics.DrawLineChecked(framePen, location, PointF(location.x + size.w - cornerBitmapSizeF.w, location.y));
            graphics.DrawLineChecked(framePen, PointF(location.x + size.w, location.y + cornerBitmapSizeF.h), PointF(location.x + size.w, location.y + size.h));
            graphics.DrawLineChecked(framePen, location, PointF(location.x, location.y + size.h));
            graphics.DrawLineChecked(framePen, PointF(location.x, location.y + size.h), PointF(location.x + size.w, location.y + size.h));
            PointF origin(location.x + paddingElement.left, location.y + paddingElement.top);
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const string& line = lines[i];
                graphics.DrawStringChecked(line, font, origin, *brush);
                origin.y = origin.y + lineSize.h;
            }
            RectF r(cornerBitmapLocF, cornerBitmapSizeF);
            ImageAttributes imageAttributes;
            Color transparentColor(0u, 128u, 128u);
            imageAttributes.SetColorKey(transparentColor, transparentColor, ColorAdjustType.default_);
            RectF s(PointF(0, 0), cornerBitmapSizeF);
            SmoothingMode prevSmoothingMode = graphics.GetSmoothingModeChecked();
            graphics.SetSmoothingModeChecked(SmoothingMode.none);
            graphics.DrawImageChecked(*noteCornerBitmap, r, s, Unit.millimeter, imageAttributes);
            graphics.SetSmoothingModeChecked(prevSmoothingMode);
            base->Measure(graphics, layout);
        }
        public override void SetFrom(DiagramElement* that)
        {
            base->SetFrom(that);
            for (const string& line : cast<NoteElement*>(that)->lines)
            {
                lines.Add(line);
            }
            lineSize = cast<NoteElement*>(that)->lineSize;
        }
        public nothrow inline const List<string>& Lines() const
        {
            return lines;
        }
        public nothrow void SetLines(const List<string>& lines_)
        {
            lines = lines_;
        }
        private List<string> lines;
        private SizeF lineSize;
    }
}

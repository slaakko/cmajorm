// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

namespace System
{
	private long pageSize = -1;
	
	internal nothrow long PageSize() 
	{
		if (pageSize == -1)
		{
			pageSize = memory_page_size();
		}
		return pageSize;
	}
	
    internal class Block
    {
        public nothrow Block() : next(this), size(0)
        {
        }
        public Block* next;
        public long size;
    }
	
    public nothrow void* malloc(long numBytes)
    {
		if (numBytes <= 0)
		{
			return null;
		}
        Block* block = Memory.AllocateBlock(numBytes);
        if (block == null)
        {
            return null;
        }
        else
        {
            return block + 1;
        }
    }

    public void* MemAlloc(long numBytes)
    {
        void* ptr = malloc(numBytes);
        if (ptr == null)
        {
            exit(254);
        }
        else
        {
            return ptr;
        }
    }
    
    public nothrow void MemFree(void* ptr)
    {
        Block* block = cast<Block*>(ptr) - 1;
        Memory.FreeBlock(block);
    }

	public nothrow void DumpHeap()
	{
		Memory.Dump();
	}

    internal static class Memory
    {
        static nothrow Memory() : baseBlock(), free(&baseBlock)
        {
        }
        public nothrow static Block* AllocateBlock(long numBytes)
        {
            long numUnits = (numBytes + sizeof(Block) - 1) / sizeof(Block) + 1;
            Block* prev = free;
            Block* p = prev->next;
            while (true)
            {
                if (p->size >= numUnits)
                {
                    if (p->size == numUnits)
                    {
                        prev->next = p->next;
                    }
                    else
                    {
                        p->size = p->size - numUnits;
                        p = p + p->size;
                        p->size = numUnits;
                    }
                    free = prev;
                    return p;
                }
                if (p == free)
                {
                    p = AllocateMoreMemory(numUnits);
                    if (p == null)
                    {
                        return null;
                    }
                }
                prev = p; 
                p = p->next;
            }
        }
        public static nothrow void FreeBlock(Block* block)
        {
            Block* p = free;
            for ( ; !(block > p && block < p->next); p = p->next)
            {
                if (p >= p->next && (block > p || block < p->next)) break;
            }
            if (block + block->size == p->next)
            {
                block->size = block->size + p->next->size;
                block->next = p->next->next;
            }
            else
            {
                block->next = p->next;
            }
            if (p + p->size == block)
            {
                p->size = p->size + block->size;
                p->next = block->next;
            }
            else
            {
                p->next = block;
            }
            free = p;
        }
		public static nothrow void Dump()
		{
			dump_heap(cast<ulong>(cast<void*>(free)));
		}
        private static nothrow Block* AllocateMoreMemory(long numUnits)
        {
            long numBytes = numUnits * sizeof(Block);
			long pgsz = PageSize();
			if (pgsz == -1)
			{
				return null;
			}
            if (numBytes < pgsz)
            {
                numBytes = pgsz;
            }
			int numPages = cast<int>((numBytes - 1) / pgsz + 1);
			long start = heap_start();
			if (start == -1)
			{
				return null;
			}
			long length = heap_length();
			if (length == -1)
			{
				return null;
			}
			long p = start + length;
			long amountAllocated = allocate_memory_pages(numPages);
			if (amountAllocated == -1)
			{
				return null;
			}
            Block* u = cast<Block*>(cast<void*>(cast<ulong>(p)));
            u->next = null;
            u->size = amountAllocated;
            FreeBlock(u);
            return free;
        }
        private static Block baseBlock;
        private static Block* free;
    }
}

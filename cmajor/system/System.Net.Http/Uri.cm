using System;
using System.Collections;
using System.Lex;
using System.Parsing;
using System.Net.Http;
using UriTokens;

// this file has been automatically generated from 'D:/work/cmajorm/cmajor/system/System.Net.Http/Uri.parser' using soulcm parser generator scmpg version 3.0.0

public static class Uri
{
    public static UriReference Parse(UriLexer& lexer)
    {
        UniquePtr<Value<UriReference>> value;
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->WriteBeginRule(u"parse");
                lexer.Log()->IncIndent();
            }
        #endif
        ++lexer;
        System.Lex.Span span = lexer.GetSpan();
        Match match = uri_reference(lexer);
        value.Reset(cast<Value<UriReference>*>(match.value));
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->DecIndent();
                lexer.Log()->WriteEndRule(u"parse");
            }
        #endif
        if (match.hit)
        {
            if (*lexer == System.Lex.END_TOKEN)
            {
                return value->value;
            }
            else
            {
                lexer.ThrowExpectationFailure(lexer.GetSpan(), GetEndTokenInfo());
            }
        }
        else
        {
            lexer.ThrowExpectationFailure(span, u"uri_reference");
        }
        return value->value;
    }
    public static Match uri_reference(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"uri_reference");
            }
        #endif
        UniquePtr<Value<UriReference>> au;
        UniquePtr<Value<UriReference>> rr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = Uri.absolute_uri(lexer);
                au.Reset(cast<Value<UriReference>*>(match.value));
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"uri_reference");
                        #endif
                        return Match(true, new Value<UriReference>(au->value));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.relative_ref(lexer);
                        rr.Reset(cast<Value<UriReference>*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"uri_reference");
                                #endif
                                return Match(true, new Value<UriReference>(rr->value));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"uri_reference");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"uri_reference");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match absolute_uri(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"absolute_uri");
            }
        #endif
        UriReference uriReference;
        UniquePtr<Value<string>> schm;
        UniquePtr<Value<string>> qry;
        UniquePtr<Value<string>> frg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.scheme(lexer);
                                    schm.Reset(cast<Value<string>*>(match.value));
                                    if (match.hit)
                                    {
                                        uriReference.SetScheme(schm->value);
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == COLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match = Uri.hier_part(lexer, &uriReference);
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch10 = &match;
                            {
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == QUEST)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch13 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch14 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.query(lexer);
                                                qry.Reset(cast<Value<string>*>(match.value));
                                                if (match.hit)
                                                {
                                                    uriReference.SetQuery(qry->value);
                                                }
                                                *parentMatch14 = match;
                                            }
                                            *parentMatch13 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch10 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch16 = &match;
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == HASH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch18 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch20 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.fragment(lexer);
                                            frg.Reset(cast<Value<string>*>(match.value));
                                            if (match.hit)
                                            {
                                                uriReference.SetFragment(frg->value);
                                            }
                                            *parentMatch20 = match;
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch17 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch16 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"absolute_uri");
                    #endif
                    return Match(true, new Value<UriReference>(uriReference));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"absolute_uri");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"absolute_uri");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match scheme(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"scheme");
            }
        #endif
        string s;
        UniquePtr<Value<char>> sc;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.scheme_char(lexer);
                            sc.Reset(cast<Value<char>*>(match.value));
                            if (match.hit)
                            {
                                s.Append(sc->value);
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch5 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.scheme_char(lexer);
                                    sc.Reset(cast<Value<char>*>(match.value));
                                    if (match.hit)
                                    {
                                        s.Append(sc->value);
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"scheme");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match scheme_char(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"scheme_char");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case ALPHA: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case DIGIT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case DASH: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                    #endif
                    return Match(true, new Value<char>('-'));
                }
                break;
            }
            case PLUS: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                    #endif
                    return Match(true, new Value<char>('+'));
                }
                break;
            }
            case DOT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                    #endif
                    return Match(true, new Value<char>('.'));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"scheme_char");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"scheme_char");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match hier_part(UriLexer& lexer, UriReference* uriReference)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"hier_part");
            }
        #endif
        UniquePtr<Value<Authority>> a;
        UniquePtr<Value<string>> pae;
        UniquePtr<Value<string>> pa;
        UniquePtr<Value<string>> pr;
        UniquePtr<Value<string>> pe;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == SLASH)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == SLASH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.authority(lexer);
                                    a.Reset(cast<Value<Authority>*>(match.value));
                                    if (match.hit)
                                    {
                                        uriReference->SetAuthority(a->value);
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.path_abempty(lexer);
                                pae.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    uriReference->SetPath(pae->value);
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.path_absolute(lexer);
                                pa.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    uriReference->SetPath(pa->value);
                                }
                                *parentMatch12 = match;
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch14 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.path_rootless(lexer);
                            pr.Reset(cast<Value<string>*>(match.value));
                            if (match.hit)
                            {
                                uriReference->SetPath(pr->value);
                            }
                            *parentMatch14 = match;
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch15 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch16 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.path_empty(lexer);
                        pe.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            uriReference->SetPath(pe->value);
                        }
                        *parentMatch16 = match;
                    }
                    *parentMatch15 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"hier_part");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"hier_part");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match relative_ref(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"relative_ref");
            }
        #endif
        UriReference uriReference;
        UniquePtr<Value<string>> qry;
        UniquePtr<Value<string>> frg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match = Uri.relative_part(lexer, &uriReference);
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == QUEST)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.query(lexer);
                                                qry.Reset(cast<Value<string>*>(match.value));
                                                if (match.hit)
                                                {
                                                    uriReference.SetQuery(qry->value);
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch5 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch11 = &match;
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                Match match(false);
                                Match* parentMatch13 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == HASH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch13 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.fragment(lexer);
                                            frg.Reset(cast<Value<string>*>(match.value));
                                            if (match.hit)
                                            {
                                                uriReference.SetFragment(frg->value);
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    *parentMatch13 = match;
                                }
                                *parentMatch12 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch11 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"relative_ref");
                    #endif
                    return Match(true, new Value<UriReference>(uriReference));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"relative_ref");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"relative_ref");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match relative_part(UriLexer& lexer, UriReference* uriReference)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"relative_part");
            }
        #endif
        UniquePtr<Value<Authority>> a;
        UniquePtr<Value<string>> pae;
        UniquePtr<Value<string>> pa;
        UniquePtr<Value<string>> pn;
        UniquePtr<Value<string>> pe;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == SLASH)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == SLASH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.authority(lexer);
                                    a.Reset(cast<Value<Authority>*>(match.value));
                                    if (match.hit)
                                    {
                                        uriReference->SetAuthority(a->value);
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.path_abempty(lexer);
                                pae.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    uriReference->SetPath(pae->value);
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch12 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.path_absolute(lexer);
                                pa.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    uriReference->SetPath(pa->value);
                                }
                                *parentMatch12 = match;
                            }
                            *parentMatch11 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch14 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.path_noscheme(lexer);
                            pn.Reset(cast<Value<string>*>(match.value));
                            if (match.hit)
                            {
                                uriReference->SetPath(pn->value);
                            }
                            *parentMatch14 = match;
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch15 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch16 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.path_empty(lexer);
                        pe.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            uriReference->SetPath(pe->value);
                        }
                        *parentMatch16 = match;
                    }
                    *parentMatch15 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"relative_part");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"relative_part");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match authority(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"authority");
            }
        #endif
        Authority a;
        UniquePtr<Value<string>> ui;
        UniquePtr<Value<string>> h;
        UniquePtr<Value<int>> p;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = Uri.userinfo(lexer);
                                    ui.Reset(cast<Value<string>*>(match.value));
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == AT)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                a.SetUserInfo(ui->value);
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch4 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.host(lexer);
                                h.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    a.SetHost(h->value);
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch11 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch12 = &match;
                        {
                            Match match(false);
                            Match* parentMatch13 = &match;
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == COLON)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch14 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch16 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.port(lexer);
                                            p.Reset(cast<Value<int>*>(match.value));
                                            if (match.hit)
                                            {
                                                a.SetPort(p->value);
                                            }
                                            *parentMatch16 = match;
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch14 = match;
                                }
                                *parentMatch13 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch12 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch11 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"authority");
                    #endif
                    return Match(true, new Value<Authority>(a));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"authority");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"authority");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match userinfo(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"userinfo");
            }
        #endif
        string s;
        UniquePtr<Value<char>> u;
        UniquePtr<Value<char>> e;
        UniquePtr<Value<char>> d;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.unreserved(lexer);
                                                u.Reset(cast<Value<char>*>(match.value));
                                                if (match.hit)
                                                {
                                                    s.Append(u->value);
                                                }
                                                *parentMatch7 = match;
                                            }
                                            *parentMatch6 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch9 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = Uri.pct_encoded(lexer);
                                                        e.Reset(cast<Value<char>*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            s.Append(e->value);
                                                        }
                                                        *parentMatch9 = match;
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                *parentMatch6 = match;
                                            }
                                        }
                                        *parentMatch5 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.sub_delims(lexer);
                                                    d.Reset(cast<Value<char>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append(d->value);
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch5 = match;
                                        }
                                    }
                                    *parentMatch4 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch13 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == COLON)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append(':');
                                                }
                                                *parentMatch13 = match;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch4 = match;
                                    }
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"userinfo");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"userinfo");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"userinfo");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match host(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"host");
            }
        #endif
        UniquePtr<Value<string>> iplit;
        UniquePtr<Value<string>> ipv4;
        UniquePtr<Value<string>> rn;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = Uri.ip_literal(lexer);
                    iplit.Reset(cast<Value<string>*>(match.value));
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"host");
                            #endif
                            return Match(true, new Value<string>(iplit->value));
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.ipv4_address(lexer);
                            ipv4.Reset(cast<Value<string>*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"host");
                                    #endif
                                    return Match(true, new Value<string>(ipv4->value));
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.reg_name(lexer);
                        rn.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"host");
                                #endif
                                return Match(true, new Value<string>(rn->value));
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"host");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"host");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ip_literal(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ip_literal");
            }
        #endif
        string s;
        UniquePtr<Value<string>> ipv6;
        UniquePtr<Value<string>> ipvf;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == LBRACKET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s.Append('[');
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = Uri.ipv6_address(lexer);
                                        ipv6.Reset(cast<Value<string>*>(match.value));
                                        if (match.hit)
                                        {
                                            s.Append(ipv6->value);
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.ipv_future(lexer);
                                                ipvf.Reset(cast<Value<string>*>(match.value));
                                                if (match.hit)
                                                {
                                                    s.Append(ipvf->value);
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch11 = &match;
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == RBRACKET)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s.Append(']');
                            }
                            *parentMatch12 = match;
                        }
                        *parentMatch11 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ip_literal");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ip_literal");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ip_literal");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ipv4_address(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ipv4_address");
            }
        #endif
        string s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == DIGIT)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append(lexer.GetChar(pos));
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(true);
                                            Match* parentMatch11 = &match;
                                            while (true)
                                            {
                                                long save = lexer.GetPos();
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch13 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match(false);
                                                            if (*lexer == DIGIT)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                s.Append(lexer.GetChar(pos));
                                                            }
                                                            *parentMatch13 = match;
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch11 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.SetPos(save);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch14 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == DOT)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append('.');
                                                }
                                                *parentMatch15 = match;
                                            }
                                            *parentMatch14 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch16 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch17 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch18 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == DIGIT)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append(lexer.GetChar(pos));
                                                    }
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch18 = match;
                                            }
                                            *parentMatch17 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(true);
                                            Match* parentMatch20 = &match;
                                            while (true)
                                            {
                                                long save = lexer.GetPos();
                                                {
                                                    Match match(false);
                                                    Match* parentMatch21 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch22 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match(false);
                                                            if (*lexer == DIGIT)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            if (match.hit)
                                                            {
                                                                s.Append(lexer.GetChar(pos));
                                                            }
                                                            *parentMatch22 = match;
                                                        }
                                                        *parentMatch21 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch20 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.SetPos(save);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        *parentMatch16 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch23 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch24 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        if (*lexer == DOT)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            s.Append('.');
                                        }
                                        *parentMatch24 = match;
                                    }
                                    *parentMatch23 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch25 = &match;
                            {
                                Match match(false);
                                Match* parentMatch26 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch27 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch28 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == DIGIT)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                s.Append(lexer.GetChar(pos));
                                            }
                                            *parentMatch28 = match;
                                        }
                                        *parentMatch27 = match;
                                    }
                                    *parentMatch26 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(true);
                                    Match* parentMatch29 = &match;
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch30 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch31 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == DIGIT)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append(lexer.GetChar(pos));
                                                    }
                                                    *parentMatch31 = match;
                                                }
                                                *parentMatch30 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch29 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch25 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch32 = &match;
                        {
                            Match match(false);
                            Match* parentMatch33 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == DOT)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    s.Append('.');
                                }
                                *parentMatch33 = match;
                            }
                            *parentMatch32 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch34 = &match;
                    {
                        Match match(false);
                        Match* parentMatch35 = &match;
                        {
                            Match match(false);
                            Match* parentMatch36 = &match;
                            {
                                Match match(false);
                                Match* parentMatch37 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == DIGIT)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s.Append(lexer.GetChar(pos));
                                    }
                                    *parentMatch37 = match;
                                }
                                *parentMatch36 = match;
                            }
                            *parentMatch35 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch38 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch39 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch40 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match(false);
                                            if (*lexer == DIGIT)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                s.Append(lexer.GetChar(pos));
                                            }
                                            *parentMatch40 = match;
                                        }
                                        *parentMatch39 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch38 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch34 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv4_address");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv4_address");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ipv4_address");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ipv6_address(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ipv6_address");
            }
        #endif
        string s;
        UniquePtr<Value<char>> c;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.ipv6_char(lexer);
                            c.Reset(cast<Value<char>*>(match.value));
                            if (match.hit)
                            {
                                s.Append(c->value);
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch5 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.ipv6_char(lexer);
                                    c.Reset(cast<Value<char>*>(match.value));
                                    if (match.hit)
                                    {
                                        s.Append(c->value);
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_address");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_address");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ipv6_address");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ipv6_char(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ipv6_char");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case DIGIT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case HEX: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case COLON: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                    #endif
                    return Match(true, new Value<char>(':'));
                }
                break;
            }
            case DOT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                    #endif
                    return Match(true, new Value<char>('.'));
                }
                break;
            }
            case SLASH: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                    #endif
                    return Match(true, new Value<char>('/'));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv6_char");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ipv6_char");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ipv_future(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ipv_future");
            }
        #endif
        string s;
        UniquePtr<Value<char>> u;
        UniquePtr<Value<char>> d;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                bool pass = true;
                                Match match(false);
                                if (*lexer == ALPHA)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    pass = lexer.GetChar(pos) == 'v';
                                }
                                if (match.hit && !pass)
                                {
                                    match = Match(false);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == DIGIT)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append(lexer.GetChar(pos));
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch11 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match(false);
                                                        if (*lexer == HEX)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            s.Append(lexer.GetChar(pos));
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch11 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(true);
                                    Match* parentMatch13 = &match;
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch14 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch15 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch16 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match(false);
                                                        if (*lexer == DIGIT)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            s.Append(lexer.GetChar(pos));
                                                        }
                                                        *parentMatch16 = match;
                                                    }
                                                    *parentMatch15 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch17 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch18 = &match;
                                                            {
                                                                long pos = lexer.GetPos();
                                                                Match match(false);
                                                                if (*lexer == HEX)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                if (match.hit)
                                                                {
                                                                    s.Append(lexer.GetChar(pos));
                                                                }
                                                                *parentMatch18 = match;
                                                            }
                                                            *parentMatch17 = match;
                                                        }
                                                        *parentMatch15 = match;
                                                    }
                                                }
                                                *parentMatch14 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch13 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch19 = &match;
                        {
                            Match match(false);
                            Match* parentMatch20 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match(false);
                                if (*lexer == DOT)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                if (match.hit)
                                {
                                    s.Append('.');
                                }
                                *parentMatch20 = match;
                            }
                            *parentMatch19 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch21 = &match;
                    {
                        Match match(false);
                        Match* parentMatch22 = &match;
                        {
                            Match match(false);
                            Match* parentMatch23 = &match;
                            {
                                Match match(false);
                                Match* parentMatch24 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch25 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch26 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.unreserved(lexer);
                                            u.Reset(cast<Value<char>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append(u->value);
                                            }
                                            *parentMatch26 = match;
                                        }
                                        *parentMatch25 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch27 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch28 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.sub_delims(lexer);
                                                    d.Reset(cast<Value<char>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append(d->value);
                                                    }
                                                    *parentMatch28 = match;
                                                }
                                                *parentMatch27 = match;
                                            }
                                            *parentMatch25 = match;
                                        }
                                    }
                                    *parentMatch24 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch29 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch30 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == COLON)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append(':');
                                                }
                                                *parentMatch30 = match;
                                            }
                                            *parentMatch29 = match;
                                        }
                                        *parentMatch24 = match;
                                    }
                                }
                                *parentMatch23 = match;
                            }
                            *parentMatch22 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch31 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch32 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch33 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch34 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch35 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.unreserved(lexer);
                                                    u.Reset(cast<Value<char>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append(u->value);
                                                    }
                                                    *parentMatch35 = match;
                                                }
                                                *parentMatch34 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch36 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch37 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = Uri.sub_delims(lexer);
                                                            d.Reset(cast<Value<char>*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                s.Append(d->value);
                                                            }
                                                            *parentMatch37 = match;
                                                        }
                                                        *parentMatch36 = match;
                                                    }
                                                    *parentMatch34 = match;
                                                }
                                            }
                                            *parentMatch33 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch38 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch39 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match(false);
                                                        if (*lexer == COLON)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            s.Append(':');
                                                        }
                                                        *parentMatch39 = match;
                                                    }
                                                    *parentMatch38 = match;
                                                }
                                                *parentMatch33 = match;
                                            }
                                        }
                                        *parentMatch32 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch31 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch21 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv_future");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ipv_future");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ipv_future");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match port(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"port");
            }
        #endif
        string s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    if (*lexer == DIGIT)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    if (match.hit)
                                    {
                                        s.Append(lexer.GetChar(pos));
                                    }
                                    *parentMatch4 = match;
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"port");
                    #endif
                    return Match(true, new Value<int>(ParseInt(s)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"port");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"port");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match reg_name(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"reg_name");
            }
        #endif
        string s;
        UniquePtr<Value<char>> u;
        UniquePtr<Value<char>> e;
        UniquePtr<Value<char>> d;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.unreserved(lexer);
                                            u.Reset(cast<Value<char>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append(u->value);
                                            }
                                            *parentMatch6 = match;
                                        }
                                        *parentMatch5 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.pct_encoded(lexer);
                                                    e.Reset(cast<Value<char>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append(e->value);
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                *parentMatch7 = match;
                                            }
                                            *parentMatch5 = match;
                                        }
                                    }
                                    *parentMatch4 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.sub_delims(lexer);
                                                d.Reset(cast<Value<char>*>(match.value));
                                                if (match.hit)
                                                {
                                                    s.Append(d->value);
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch4 = match;
                                    }
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"reg_name");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"reg_name");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"reg_name");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match path_abempty(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"path_abempty");
            }
        #endif
        string s;
        UniquePtr<Value<string>> seg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == SLASH)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch4 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.segment(lexer);
                                            seg.Reset(cast<Value<string>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append('/').Append(seg->value);
                                            }
                                            *parentMatch6 = match;
                                        }
                                        *parentMatch5 = match;
                                    }
                                    *parentMatch4 = match;
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_abempty");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_abempty");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"path_abempty");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match path_absolute(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"path_absolute");
            }
        #endif
        string s;
        UniquePtr<Value<string>> snz;
        UniquePtr<Value<string>> seg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                if (*lexer == SLASH)
                {
                    ++lexer;
                    match.hit = true;
                }
                if (match.hit)
                {
                    s.Append('/');
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.segment_nz(lexer);
                                snz.Reset(cast<Value<string>*>(match.value));
                                if (match.hit)
                                {
                                    s.Append(snz->value);
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match(true);
                                Match* parentMatch8 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch10 = &match;
                                                {
                                                    Match match(false);
                                                    if (*lexer == SLASH)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch11 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        {
                                                            long pos = lexer.GetPos();
                                                            Match match = Uri.segment(lexer);
                                                            seg.Reset(cast<Value<string>*>(match.value));
                                                            if (match.hit)
                                                            {
                                                                s.Append('/').Append(seg->value);
                                                            }
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch11 = match;
                                                    }
                                                    *parentMatch10 = match;
                                                }
                                                *parentMatch9 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch8 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch7 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_absolute");
                            #endif
                            return Match(true, new Value<string>(s));
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_absolute");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"path_absolute");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match path_noscheme(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"path_noscheme");
            }
        #endif
        string s;
        UniquePtr<Value<string>> snz;
        UniquePtr<Value<string>> seg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.segment_nz_nc(lexer);
                        snz.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            s.Append(snz->value);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == SLASH)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.segment(lexer);
                                                    seg.Reset(cast<Value<string>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append('/').Append(seg->value);
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_noscheme");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_noscheme");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"path_noscheme");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match path_rootless(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"path_rootless");
            }
        #endif
        string s;
        UniquePtr<Value<string>> snz;
        UniquePtr<Value<string>> seg;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.segment_nz(lexer);
                        snz.Reset(cast<Value<string>*>(match.value));
                        if (match.hit)
                        {
                            s.Append(snz->value);
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            Match match(false);
                                            if (*lexer == SLASH)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.segment(lexer);
                                                    seg.Reset(cast<Value<string>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append('/').Append(seg->value);
                                                    }
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_rootless");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_rootless");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"path_rootless");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match path_empty(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"path_empty");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(true);
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_empty");
                    #endif
                    return Match(true, new Value<string>(string()));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"path_empty");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"path_empty");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match segment(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"segment");
            }
        #endif
        string s;
        UniquePtr<Value<char>> pc;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.pchar(lexer);
                                    pc.Reset(cast<Value<char>*>(match.value));
                                    if (match.hit)
                                    {
                                        s.Append(pc->value);
                                    }
                                    *parentMatch4 = match;
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"segment");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match segment_nz(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"segment_nz");
            }
        #endif
        string s;
        UniquePtr<Value<char>> pc;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.pchar(lexer);
                            pc.Reset(cast<Value<char>*>(match.value));
                            if (match.hit)
                            {
                                s.Append(pc->value);
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch5 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.pchar(lexer);
                                    pc.Reset(cast<Value<char>*>(match.value));
                                    if (match.hit)
                                    {
                                        s.Append(pc->value);
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment_nz");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment_nz");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"segment_nz");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match segment_nz_nc(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"segment_nz_nc");
            }
        #endif
        string s;
        UniquePtr<Value<char>> u;
        UniquePtr<Value<char>> e;
        UniquePtr<Value<char>> d;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = Uri.unreserved(lexer);
                                        u.Reset(cast<Value<char>*>(match.value));
                                        if (match.hit)
                                        {
                                            s.Append(u->value);
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch9 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.pct_encoded(lexer);
                                                e.Reset(cast<Value<char>*>(match.value));
                                                if (match.hit)
                                                {
                                                    s.Append(e->value);
                                                }
                                                *parentMatch9 = match;
                                            }
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.sub_delims(lexer);
                                            d.Reset(cast<Value<char>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append(d->value);
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match(false);
                                        if (*lexer == AT)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        if (match.hit)
                                        {
                                            s.Append('@');
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch14 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch15 = &match;
                            {
                                Match match(false);
                                Match* parentMatch16 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch17 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch18 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch19 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match = Uri.unreserved(lexer);
                                                u.Reset(cast<Value<char>*>(match.value));
                                                if (match.hit)
                                                {
                                                    s.Append(u->value);
                                                }
                                                *parentMatch19 = match;
                                            }
                                            *parentMatch18 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch20 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match(false);
                                                    Match* parentMatch21 = &match;
                                                    {
                                                        long pos = lexer.GetPos();
                                                        Match match = Uri.pct_encoded(lexer);
                                                        e.Reset(cast<Value<char>*>(match.value));
                                                        if (match.hit)
                                                        {
                                                            s.Append(e->value);
                                                        }
                                                        *parentMatch21 = match;
                                                    }
                                                    *parentMatch20 = match;
                                                }
                                                *parentMatch18 = match;
                                            }
                                        }
                                        *parentMatch17 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match = Uri.sub_delims(lexer);
                                                    d.Reset(cast<Value<char>*>(match.value));
                                                    if (match.hit)
                                                    {
                                                        s.Append(d->value);
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            *parentMatch17 = match;
                                        }
                                    }
                                    *parentMatch16 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch24 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch25 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == AT)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append('@');
                                                }
                                                *parentMatch25 = match;
                                            }
                                            *parentMatch24 = match;
                                        }
                                        *parentMatch16 = match;
                                    }
                                }
                                *parentMatch15 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch14 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment_nz_nc");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"segment_nz_nc");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"segment_nz_nc");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match query(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"query");
            }
        #endif
        string s;
        UniquePtr<Value<char>> pc;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.pchar(lexer);
                                            pc.Reset(cast<Value<char>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append(pc->value);
                                            }
                                            *parentMatch6 = match;
                                        }
                                        *parentMatch5 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == SLASH)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append('/');
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                *parentMatch7 = match;
                                            }
                                            *parentMatch5 = match;
                                        }
                                    }
                                    *parentMatch4 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == QUEST)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append('?');
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch4 = match;
                                    }
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"query");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"query");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"query");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match fragment(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"fragment");
            }
        #endif
        string s;
        UniquePtr<Value<char>> pc;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    long save = lexer.GetPos();
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Match match = Uri.pchar(lexer);
                                            pc.Reset(cast<Value<char>*>(match.value));
                                            if (match.hit)
                                            {
                                                s.Append(pc->value);
                                            }
                                            *parentMatch6 = match;
                                        }
                                        *parentMatch5 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    if (*lexer == SLASH)
                                                    {
                                                        ++lexer;
                                                        match.hit = true;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append('/');
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                *parentMatch7 = match;
                                            }
                                            *parentMatch5 = match;
                                        }
                                    }
                                    *parentMatch4 = match;
                                    if (!match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        lexer.SetPos(save);
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                if (*lexer == QUEST)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append('?');
                                                }
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch4 = match;
                                    }
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"fragment");
                    #endif
                    return Match(true, new Value<string>(s));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"fragment");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"fragment");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match pchar(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"pchar");
            }
        #endif
        UniquePtr<Value<char>> u;
        UniquePtr<Value<char>> e;
        UniquePtr<Value<char>> d;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.unreserved(lexer);
                            u.Reset(cast<Value<char>*>(match.value));
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                                    #endif
                                    return Match(true, new Value<char>(u->value));
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match = Uri.pct_encoded(lexer);
                                    e.Reset(cast<Value<char>*>(match.value));
                                    if (match.hit)
                                    {
                                        {
                                            #if (DEBUG)
                                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                                            #endif
                                            return Match(true, new Value<char>(e->value));
                                        }
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.sub_delims(lexer);
                                d.Reset(cast<Value<char>*>(match.value));
                                if (match.hit)
                                {
                                    {
                                        #if (DEBUG)
                                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                                        #endif
                                        return Match(true, new Value<char>(d->value));
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            if (*lexer == COLON)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                {
                                    #if (DEBUG)
                                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                                    #endif
                                    return Match(true, new Value<char>(':'));
                                }
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        if (*lexer == AT)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                                #endif
                                return Match(true, new Value<char>('@'));
                            }
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch11 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pchar");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"pchar");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match unreserved(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"unreserved");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case ALPHA: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case HEX: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case DIGIT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case DOT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>('.'));
                }
                break;
            }
            case DASH: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>('-'));
                }
                break;
            }
            case UNDERSCORE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>('_'));
                }
                break;
            }
            case TILDE: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                    #endif
                    return Match(true, new Value<char>('~'));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"unreserved");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"unreserved");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match reserved(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"reserved");
            }
        #endif
        UniquePtr<Value<char>> gd;
        UniquePtr<Value<char>> sd;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = Uri.gen_delims(lexer);
                gd.Reset(cast<Value<char>*>(match.value));
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"reserved");
                        #endif
                        return Match(true, new Value<char>(gd->value));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = Uri.sub_delims(lexer);
                        sd.Reset(cast<Value<char>*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"reserved");
                                #endif
                                return Match(true, new Value<char>(sd->value));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"reserved");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"reserved");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match gen_delims(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"gen_delims");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case COLON: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>(':'));
                }
                break;
            }
            case SLASH: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>('/'));
                }
                break;
            }
            case QUEST: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>('?'));
                }
                break;
            }
            case HASH: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>('#'));
                }
                break;
            }
            case LBRACKET: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>('['));
                }
                break;
            }
            case RBRACKET: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>(']'));
                }
                break;
            }
            case AT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                    #endif
                    return Match(true, new Value<char>('@'));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"gen_delims");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"gen_delims");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match sub_delims(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"sub_delims");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case EXCLAMATION: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('!'));
                }
                break;
            }
            case DOLLAR: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('$'));
                }
                break;
            }
            case AMP: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('&'));
                }
                break;
            }
            case SQ: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('\''));
                }
                break;
            }
            case LPAREN: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('('));
                }
                break;
            }
            case RPAREN: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>(')'));
                }
                break;
            }
            case ASTERISK: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('*'));
                }
                break;
            }
            case PLUS: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('+'));
                }
                break;
            }
            case COMMA: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>(','));
                }
                break;
            }
            case SEMICOLON: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>(';'));
                }
                break;
            }
            case EQ: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                    #endif
                    return Match(true, new Value<char>('='));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"sub_delims");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"sub_delims");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match pct_encoded(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"pct_encoded");
            }
        #endif
        string s;
        UniquePtr<Value<char>> x1;
        UniquePtr<Value<char>> x2;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == PERCENT)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = Uri.hex(lexer);
                                x1.Reset(cast<Value<char>*>(match.value));
                                if (match.hit)
                                {
                                    s.Append(x1->value);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match = Uri.hex(lexer);
                            x2.Reset(cast<Value<char>*>(match.value));
                            if (match.hit)
                            {
                                s.Append(x2->value);
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pct_encoded");
                    #endif
                    return Match(true, new Value<char>(cast<char>(ParseHexByte(s))));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"pct_encoded");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"pct_encoded");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match hex(UriLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"hex");
            }
        #endif
        Match match(false);
        long pos = lexer.GetPos();
        Span span = lexer.GetSpan();
        switch (*lexer)
        {
            case DIGIT: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"hex");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
            case HEX: 
            {
                ++lexer;
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"hex");
                    #endif
                    return Match(true, new Value<char>(lexer.GetChar(pos)));
                }
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"hex");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"hex");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

using System;
using System.Collections;
using System.Text.Parsing;

// this source file has been automatically generated from 'HttpGrammar.parser' using cmparsergen version 2.0.0.

namespace System.Net.Http
{
    public class HttpChunkHeaderGrammar : System.Text.Parsing.Grammar
    {
        public HttpChunkHeaderGrammar() : this(new ParsingDomain())
        {
        }
        public HttpChunkHeaderGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpChunkHeaderGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, ulong* chunkSize, ChunkExtensionAdder* adder)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<ulong*>(chunkSize)));
            stack.Push(UniquePtr<Object>(new ValueObject<ChunkExtensionAdder*>(adder)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class headerRule : System.Text.Parsing.RuleParser
        {
            public headerRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ulong*"), ToUtf32("chunkSize")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ChunkExtensionAdder*"), ToUtf32("adder")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> adder_value = stack.Pop();
                context->adder = *cast<ValueObject<ChunkExtensionAdder*>*>(adder_value.Get());
                UniquePtr<Object> chunkSize_value = stack.Pop();
                context->chunkSize = *cast<ValueObject<ulong*>*>(chunkSize_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* chunkHeaderNonterminalParser = GetNonterminal(ToUtf32("chunkHeader"));
                chunkHeaderNonterminalParser->SetPre(PrechunkHeader);
            }
            public void PrechunkHeader(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ulong*>(context->chunkSize)));
                stack.Push(UniquePtr<Object>(new ValueObject<ChunkExtensionAdder*>(context->adder)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : chunkSize(), adder()
                {
                }
                public ulong* chunkSize;
                public ChunkExtensionAdder* adder;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("chunkHeader"), this, ToUtf32("HttpGrammar.chunkHeader")));
            AddRule(new headerRule(ToUtf32("header"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("chunkHeader"), ToUtf32("chunkHeader"), 2)));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpDateGrammar : System.Text.Parsing.Grammar
    {
        public HttpDateGrammar() : this(new ParsingDomain())
        {
        }
        public HttpDateGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpDateGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, DateTime* date)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<DateTime*>(date)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class dateRule : System.Text.Parsing.RuleParser
        {
            public dateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("DateTime*"), ToUtf32("date")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> date_value = stack.Pop();
                context->date = *cast<ValueObject<DateTime*>*>(date_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* dateValueNonterminalParser = GetNonterminal(ToUtf32("dateValue"));
                dateValueNonterminalParser->SetPre(PredateValue);
            }
            public void PredateValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<DateTime*>(context->date)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : date()
                {
                }
                public DateTime* date;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("dateValue"), this, ToUtf32("HttpGrammar.dateValue")));
            AddRule(new dateRule(ToUtf32("date"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("dateValue"), ToUtf32("dateValue"), 1)));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpStatusLineGrammar : System.Text.Parsing.Grammar
    {
        public HttpStatusLineGrammar() : this(new ParsingDomain())
        {
        }
        public HttpStatusLineGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpStatusLineGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, HttpStatus* httpStatus)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<HttpStatus*>(httpStatus)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class statusRule : System.Text.Parsing.RuleParser
        {
            public statusRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("HttpStatus*"), ToUtf32("httpStatus")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> httpStatus_value = stack.Pop();
                context->httpStatus = *cast<ValueObject<HttpStatus*>*>(httpStatus_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* statusLineNonterminalParser = GetNonterminal(ToUtf32("statusLine"));
                statusLineNonterminalParser->SetPre(PrestatusLine);
            }
            public void PrestatusLine(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<HttpStatus*>(context->httpStatus)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : httpStatus()
                {
                }
                public HttpStatus* httpStatus;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("statusLine"), this, ToUtf32("HttpGrammar.statusLine")));
            AddRule(new statusRule(ToUtf32("status"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("statusLine"), ToUtf32("statusLine"), 1)));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpGrammar : System.Text.Parsing.Grammar
    {
        public HttpGrammar() : this(new ParsingDomain())
        {
        }
        public HttpGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, HttpStatus* httpStatus)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<HttpStatus*>(httpStatus)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class statusLineRule : System.Text.Parsing.RuleParser
        {
            public statusLineRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("HttpStatus*"), ToUtf32("httpStatus")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> httpStatus_value = stack.Pop();
                context->httpStatus = *cast<ValueObject<HttpStatus*>*>(httpStatus_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpVersionNonterminalParser = GetNonterminal(ToUtf32("httpVersion"));
                httpVersionNonterminalParser->SetPost(PosthttpVersion);
                NonterminalParser* statusCodeNonterminalParser = GetNonterminal(ToUtf32("statusCode"));
                statusCodeNonterminalParser->SetPost(PoststatusCode);
                NonterminalParser* reasonPhraseNonterminalParser = GetNonterminal(ToUtf32("reasonPhrase"));
                reasonPhraseNonterminalParser->SetPost(PostreasonPhrase);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                *context->httpStatus = HttpStatus(context->fromhttpVersion, context->fromstatusCode, context->fromreasonPhrase);
            }
            public void PosthttpVersion(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpVersion_value = stack.Pop();
                    context->fromhttpVersion = *cast<ValueObject<ustring>*>(fromhttpVersion_value.Get());
                }
            }
            public void PoststatusCode(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromstatusCode_value = stack.Pop();
                    context->fromstatusCode = *cast<ValueObject<ushort>*>(fromstatusCode_value.Get());
                }
            }
            public void PostreasonPhrase(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromreasonPhrase_value = stack.Pop();
                    context->fromreasonPhrase = *cast<ValueObject<ustring>*>(fromreasonPhrase_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : httpStatus(), fromhttpVersion(), fromstatusCode(), fromreasonPhrase()
                {
                }
                public HttpStatus* httpStatus;
                public ustring fromhttpVersion;
                public ushort fromstatusCode;
                public ustring fromreasonPhrase;
            }
        }

        public class httpVersionRule : System.Text.Parsing.RuleParser
        {
            public httpVersionRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public class statusCodeRule : System.Text.Parsing.RuleParser
        {
            public statusCodeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ushort"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ushort>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseUShort(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ushort value;
            }
        }

        public class reasonPhraseRule : System.Text.Parsing.RuleParser
        {
            public reasonPhraseRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public class commaSeparatedFieldValueRule : System.Text.Parsing.RuleParser
        {
            public commaSeparatedFieldValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("List<HttpFieldValue>*"), ToUtf32("values")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> values_value = stack.Pop();
                context->values = *cast<ValueObject<List<HttpFieldValue>*>*>(values_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* generalFieldValueNonterminalParser = GetNonterminal(ToUtf32("generalFieldValue"));
                generalFieldValueNonterminalParser->SetPre(PregeneralFieldValue);
            }
            public void PregeneralFieldValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<List<HttpFieldValue>*>(context->values)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : values()
                {
                }
                public List<HttpFieldValue>* values;
            }
        }

        public class generalFieldValueRule : System.Text.Parsing.RuleParser
        {
            public generalFieldValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("List<HttpFieldValue>*"), ToUtf32("values")));
                AddLocalVariable(AttrOrVar(ToUtf32("HttpFieldValue"), ToUtf32("fieldValue")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> values_value = stack.Pop();
                context->values = *cast<ValueObject<List<HttpFieldValue>*>*>(values_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
                NonterminalParser* generalParameterNonterminalParser = GetNonterminal(ToUtf32("generalParameter"));
                generalParameterNonterminalParser->SetPre(PregeneralParameter);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->values->Add(context->fieldValue);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->fieldValue.SetFieldValue(context->fromhttpToken);
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public void PregeneralParameter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<HttpFieldValue*>(&context->fieldValue)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : values(), fieldValue(), fromhttpToken()
                {
                }
                public List<HttpFieldValue>* values;
                public HttpFieldValue fieldValue;
                public ustring fromhttpToken;
            }
        }

        public class generalParameterRule : System.Text.Parsing.RuleParser
        {
            public generalParameterRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("HttpFieldValue*"), ToUtf32("fieldValue")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> fieldValue_value = stack.Pop();
                context->fieldValue = *cast<ValueObject<HttpFieldValue*>*>(fieldValue_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* attributeNonterminalParser = GetNonterminal(ToUtf32("attribute"));
                attributeNonterminalParser->SetPost(Postattribute);
                NonterminalParser* attrvalNonterminalParser = GetNonterminal(ToUtf32("attrval"));
                attrvalNonterminalParser->SetPost(Postattrval);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->fieldValue->SetParameter(context->fromattribute, context->fromattrval);
            }
            public void Postattribute(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromattribute_value = stack.Pop();
                    context->fromattribute = *cast<ValueObject<ustring>*>(fromattribute_value.Get());
                }
            }
            public void Postattrval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromattrval_value = stack.Pop();
                    context->fromattrval = *cast<ValueObject<ustring>*>(fromattrval_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : fieldValue(), fromattribute(), fromattrval()
                {
                }
                public HttpFieldValue* fieldValue;
                public ustring fromattribute;
                public ustring fromattrval;
            }
        }

        public class chunkHeaderRule : System.Text.Parsing.RuleParser
        {
            public chunkHeaderRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ulong*"), ToUtf32("chunkSize")));
                AddInheritedAttribute(AttrOrVar(ToUtf32("ChunkExtensionAdder*"), ToUtf32("adder")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> adder_value = stack.Pop();
                context->adder = *cast<ValueObject<ChunkExtensionAdder*>*>(adder_value.Get());
                UniquePtr<Object> chunkSize_value = stack.Pop();
                context->chunkSize = *cast<ValueObject<ulong*>*>(chunkSize_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* chunkExtensionsNonterminalParser = GetNonterminal(ToUtf32("chunkExtensions"));
                chunkExtensionsNonterminalParser->SetPre(PrechunkExtensions);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                *context->chunkSize = ParseHexULong(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public void PrechunkExtensions(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<ChunkExtensionAdder*>(context->adder)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : chunkSize(), adder()
                {
                }
                public ulong* chunkSize;
                public ChunkExtensionAdder* adder;
            }
        }

        public class chunkExtensionsRule : System.Text.Parsing.RuleParser
        {
            public chunkExtensionsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("ChunkExtensionAdder*"), ToUtf32("adder")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> adder_value = stack.Pop();
                context->adder = *cast<ValueObject<ChunkExtensionAdder*>*>(adder_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* chunkExtNameNonterminalParser = GetNonterminal(ToUtf32("chunkExtName"));
                chunkExtNameNonterminalParser->SetPost(PostchunkExtName);
                NonterminalParser* chunkExtValNonterminalParser = GetNonterminal(ToUtf32("chunkExtVal"));
                chunkExtValNonterminalParser->SetPost(PostchunkExtVal);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->adder->AddChunkExtension(context->fromchunkExtName, context->fromchunkExtVal);
            }
            public void PostchunkExtName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromchunkExtName_value = stack.Pop();
                    context->fromchunkExtName = *cast<ValueObject<ustring>*>(fromchunkExtName_value.Get());
                }
            }
            public void PostchunkExtVal(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromchunkExtVal_value = stack.Pop();
                    context->fromchunkExtVal = *cast<ValueObject<ustring>*>(fromchunkExtVal_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : adder(), fromchunkExtName(), fromchunkExtVal()
                {
                }
                public ChunkExtensionAdder* adder;
                public ustring fromchunkExtName;
                public ustring fromchunkExtVal;
            }
        }

        public class chunkExtNameRule : System.Text.Parsing.RuleParser
        {
            public chunkExtNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
            }
        }

        public class chunkExtValRule : System.Text.Parsing.RuleParser
        {
            public chunkExtValRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
                NonterminalParser* quotedStringNonterminalParser = GetNonterminal(ToUtf32("quotedString"));
                quotedStringNonterminalParser->SetPost(PostquotedString);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromquotedString;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public void PostquotedString(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromquotedString_value = stack.Pop();
                    context->fromquotedString = *cast<ValueObject<ustring>*>(fromquotedString_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken(), fromquotedString()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
                public ustring fromquotedString;
            }
        }

        public class parameterRule : System.Text.Parsing.RuleParser
        {
            public parameterRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Pair<ustring, ustring>"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Pair<ustring, ustring>>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* attributeNonterminalParser = GetNonterminal(ToUtf32("attribute"));
                attributeNonterminalParser->SetPost(Postattribute);
                NonterminalParser* attrvalNonterminalParser = GetNonterminal(ToUtf32("attrval"));
                attrvalNonterminalParser->SetPost(Postattrval);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = MakePair(context->fromattribute, context->fromattrval);
            }
            public void Postattribute(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromattribute_value = stack.Pop();
                    context->fromattribute = *cast<ValueObject<ustring>*>(fromattribute_value.Get());
                }
            }
            public void Postattrval(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromattrval_value = stack.Pop();
                    context->fromattrval = *cast<ValueObject<ustring>*>(fromattrval_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromattribute(), fromattrval()
                {
                }
                public Pair<ustring, ustring> value;
                public ustring fromattribute;
                public ustring fromattrval;
            }
        }

        public class attributeRule : System.Text.Parsing.RuleParser
        {
            public attributeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
            }
        }

        public class attrvalRule : System.Text.Parsing.RuleParser
        {
            public attrvalRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
                NonterminalParser* quotedStringNonterminalParser = GetNonterminal(ToUtf32("quotedString"));
                quotedStringNonterminalParser->SetPost(PostquotedString);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromquotedString;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public void PostquotedString(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromquotedString_value = stack.Pop();
                    context->fromquotedString = *cast<ValueObject<ustring>*>(fromquotedString_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken(), fromquotedString()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
                public ustring fromquotedString;
            }
        }

        public class mediaTypeRule : System.Text.Parsing.RuleParser
        {
            public mediaTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("MimeType*"), ToUtf32("mediaType")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> mediaType_value = stack.Pop();
                context->mediaType = *cast<ValueObject<MimeType*>*>(mediaType_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* typeNonterminalParser = GetNonterminal(ToUtf32("type"));
                typeNonterminalParser->SetPost(Posttype);
                NonterminalParser* subtypeNonterminalParser = GetNonterminal(ToUtf32("subtype"));
                subtypeNonterminalParser->SetPost(Postsubtype);
                NonterminalParser* parameterNonterminalParser = GetNonterminal(ToUtf32("parameter"));
                parameterNonterminalParser->SetPost(Postparameter);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->mediaType->SetValue(context->fromtype, context->fromsubtype);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->mediaType->SetParameter(context->fromparameter.first, context->fromparameter.second);
            }
            public void Posttype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtype_value = stack.Pop();
                    context->fromtype = *cast<ValueObject<ustring>*>(fromtype_value.Get());
                }
            }
            public void Postsubtype(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsubtype_value = stack.Pop();
                    context->fromsubtype = *cast<ValueObject<ustring>*>(fromsubtype_value.Get());
                }
            }
            public void Postparameter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromparameter_value = stack.Pop();
                    context->fromparameter = *cast<ValueObject<Pair<ustring, ustring>>*>(fromparameter_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : mediaType(), fromtype(), fromsubtype(), fromparameter()
                {
                }
                public MimeType* mediaType;
                public ustring fromtype;
                public ustring fromsubtype;
                public Pair<ustring, ustring> fromparameter;
            }
        }

        public class typeRule : System.Text.Parsing.RuleParser
        {
            public typeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
            }
        }

        public class subtypeRule : System.Text.Parsing.RuleParser
        {
            public subtypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
            }
        }

        public class httpHeaderRule : System.Text.Parsing.RuleParser
        {
            public httpHeaderRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("HttpHeader"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<HttpHeader>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* fieldNameNonterminalParser = GetNonterminal(ToUtf32("fieldName"));
                fieldNameNonterminalParser->SetPost(PostfieldName);
                NonterminalParser* fieldValueNonterminalParser = GetNonterminal(ToUtf32("fieldValue"));
                fieldValueNonterminalParser->SetPost(PostfieldValue);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = HttpHeader(context->fromfieldName, context->fromfieldValue);
            }
            public void PostfieldName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfieldName_value = stack.Pop();
                    context->fromfieldName = *cast<ValueObject<ustring>*>(fromfieldName_value.Get());
                }
            }
            public void PostfieldValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfieldValue_value = stack.Pop();
                    context->fromfieldValue = *cast<ValueObject<ustring>*>(fromfieldValue_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromfieldName(), fromfieldValue()
                {
                }
                public HttpHeader value;
                public ustring fromfieldName;
                public ustring fromfieldValue;
            }
        }

        public class fieldNameRule : System.Text.Parsing.RuleParser
        {
            public fieldNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpTokenNonterminalParser = GetNonterminal(ToUtf32("httpToken"));
                httpTokenNonterminalParser->SetPost(PosthttpToken);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpToken;
            }
            public void PosthttpToken(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpToken_value = stack.Pop();
                    context->fromhttpToken = *cast<ValueObject<ustring>*>(fromhttpToken_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpToken()
                {
                }
                public ustring value;
                public ustring fromhttpToken;
            }
        }

        public class fieldValueRule : System.Text.Parsing.RuleParser
        {
            public fieldValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public class dateValueRule : System.Text.Parsing.RuleParser
        {
            public dateValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("DateTime*"), ToUtf32("date")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> date_value = stack.Pop();
                context->date = *cast<ValueObject<DateTime*>*>(date_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpDateNonterminalParser = GetNonterminal(ToUtf32("httpDate"));
                httpDateNonterminalParser->SetPost(PosthttpDate);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                *context->date = context->fromhttpDate;
            }
            public void PosthttpDate(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpDate_value = stack.Pop();
                    context->fromhttpDate = *cast<ValueObject<DateTime>*>(fromhttpDate_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : date(), fromhttpDate()
                {
                }
                public DateTime* date;
                public DateTime fromhttpDate;
            }
        }

        public class httpDateRule : System.Text.Parsing.RuleParser
        {
            public httpDateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("DateTime"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DateTime>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* rfc1123DateNonterminalParser = GetNonterminal(ToUtf32("rfc1123Date"));
                rfc1123DateNonterminalParser->SetPost(Postrfc1123Date);
                NonterminalParser* rfc850DateNonterminalParser = GetNonterminal(ToUtf32("rfc850Date"));
                rfc850DateNonterminalParser->SetPost(Postrfc850Date);
                NonterminalParser* asctimeDateNonterminalParser = GetNonterminal(ToUtf32("asctimeDate"));
                asctimeDateNonterminalParser->SetPost(PostasctimeDate);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromrfc1123Date;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromrfc850Date;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromasctimeDate;
            }
            public void Postrfc1123Date(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromrfc1123Date_value = stack.Pop();
                    context->fromrfc1123Date = *cast<ValueObject<DateTime>*>(fromrfc1123Date_value.Get());
                }
            }
            public void Postrfc850Date(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromrfc850Date_value = stack.Pop();
                    context->fromrfc850Date = *cast<ValueObject<DateTime>*>(fromrfc850Date_value.Get());
                }
            }
            public void PostasctimeDate(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromasctimeDate_value = stack.Pop();
                    context->fromasctimeDate = *cast<ValueObject<DateTime>*>(fromasctimeDate_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromrfc1123Date(), fromrfc850Date(), fromasctimeDate()
                {
                }
                public DateTime value;
                public DateTime fromrfc1123Date;
                public DateTime fromrfc850Date;
                public DateTime fromasctimeDate;
            }
        }

        public class rfc1123DateRule : System.Text.Parsing.RuleParser
        {
            public rfc1123DateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("DateTime"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DateTime>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* date1NonterminalParser = GetNonterminal(ToUtf32("date1"));
                date1NonterminalParser->SetPost(Postdate1);
                NonterminalParser* timeNonterminalParser = GetNonterminal(ToUtf32("time"));
                timeNonterminalParser->SetPost(Posttime);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = DateTime(context->fromdate1, context->fromtime);
            }
            public void Postdate1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromdate1_value = stack.Pop();
                    context->fromdate1 = *cast<ValueObject<Date>*>(fromdate1_value.Get());
                }
            }
            public void Posttime(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtime_value = stack.Pop();
                    context->fromtime = *cast<ValueObject<int>*>(fromtime_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromdate1(), fromtime()
                {
                }
                public DateTime value;
                public Date fromdate1;
                public int fromtime;
            }
        }

        public class rfc850DateRule : System.Text.Parsing.RuleParser
        {
            public rfc850DateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("DateTime"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DateTime>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* date2NonterminalParser = GetNonterminal(ToUtf32("date2"));
                date2NonterminalParser->SetPost(Postdate2);
                NonterminalParser* timeNonterminalParser = GetNonterminal(ToUtf32("time"));
                timeNonterminalParser->SetPost(Posttime);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = DateTime(context->fromdate2, context->fromtime);
            }
            public void Postdate2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromdate2_value = stack.Pop();
                    context->fromdate2 = *cast<ValueObject<Date>*>(fromdate2_value.Get());
                }
            }
            public void Posttime(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtime_value = stack.Pop();
                    context->fromtime = *cast<ValueObject<int>*>(fromtime_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromdate2(), fromtime()
                {
                }
                public DateTime value;
                public Date fromdate2;
                public int fromtime;
            }
        }

        public class asctimeDateRule : System.Text.Parsing.RuleParser
        {
            public asctimeDateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("DateTime"));
                AddLocalVariable(AttrOrVar(ToUtf32("Date"), ToUtf32("monthDay")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<DateTime>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* date3NonterminalParser = GetNonterminal(ToUtf32("date3"));
                date3NonterminalParser->SetPost(Postdate3);
                NonterminalParser* timeNonterminalParser = GetNonterminal(ToUtf32("time"));
                timeNonterminalParser->SetPost(Posttime);
                NonterminalParser* yearNonterminalParser = GetNonterminal(ToUtf32("Year"));
                yearNonterminalParser->SetPost(PostYear);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = DateTime(Date(context->fromYear, context->monthDay.GetMonth(), context->monthDay.Day()), context->fromtime);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->monthDay = context->fromdate3;
            }
            public void Postdate3(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromdate3_value = stack.Pop();
                    context->fromdate3 = *cast<ValueObject<Date>*>(fromdate3_value.Get());
                }
            }
            public void Posttime(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromtime_value = stack.Pop();
                    context->fromtime = *cast<ValueObject<int>*>(fromtime_value.Get());
                }
            }
            public void PostYear(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromYear_value = stack.Pop();
                    context->fromYear = *cast<ValueObject<short>*>(fromYear_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), monthDay(), fromdate3(), fromtime(), fromYear()
                {
                }
                public DateTime value;
                public Date monthDay;
                public Date fromdate3;
                public int fromtime;
                public short fromYear;
            }
        }

        public class date1Rule : System.Text.Parsing.RuleParser
        {
            public date1Rule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Date"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Date>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* dayNonterminalParser = GetNonterminal(ToUtf32("Day"));
                dayNonterminalParser->SetPost(PostDay);
                NonterminalParser* monthNonterminalParser = GetNonterminal(ToUtf32("month"));
                monthNonterminalParser->SetPost(Postmonth);
                NonterminalParser* yearNonterminalParser = GetNonterminal(ToUtf32("Year"));
                yearNonterminalParser->SetPost(PostYear);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Date(context->fromYear, context->frommonth, context->fromDay);
            }
            public void PostDay(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDay_value = stack.Pop();
                    context->fromDay = *cast<ValueObject<sbyte>*>(fromDay_value.Get());
                }
            }
            public void Postmonth(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frommonth_value = stack.Pop();
                    context->frommonth = *cast<ValueObject<Month>*>(frommonth_value.Get());
                }
            }
            public void PostYear(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromYear_value = stack.Pop();
                    context->fromYear = *cast<ValueObject<short>*>(fromYear_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromDay(), frommonth(), fromYear()
                {
                }
                public Date value;
                public sbyte fromDay;
                public Month frommonth;
                public short fromYear;
            }
        }

        public class date2Rule : System.Text.Parsing.RuleParser
        {
            public date2Rule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Date"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Date>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* dayNonterminalParser = GetNonterminal(ToUtf32("Day"));
                dayNonterminalParser->SetPost(PostDay);
                NonterminalParser* monthNonterminalParser = GetNonterminal(ToUtf32("month"));
                monthNonterminalParser->SetPost(Postmonth);
                NonterminalParser* year2NonterminalParser = GetNonterminal(ToUtf32("Year2"));
                year2NonterminalParser->SetPost(PostYear2);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Date(context->fromYear2, context->frommonth, context->fromDay);
            }
            public void PostDay(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDay_value = stack.Pop();
                    context->fromDay = *cast<ValueObject<sbyte>*>(fromDay_value.Get());
                }
            }
            public void Postmonth(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frommonth_value = stack.Pop();
                    context->frommonth = *cast<ValueObject<Month>*>(frommonth_value.Get());
                }
            }
            public void PostYear2(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromYear2_value = stack.Pop();
                    context->fromYear2 = *cast<ValueObject<short>*>(fromYear2_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromDay(), frommonth(), fromYear2()
                {
                }
                public Date value;
                public sbyte fromDay;
                public Month frommonth;
                public short fromYear2;
            }
        }

        public class date3Rule : System.Text.Parsing.RuleParser
        {
            public date3Rule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Date"));
                AddLocalVariable(AttrOrVar(ToUtf32("Month"), ToUtf32("m")));
                AddLocalVariable(AttrOrVar(ToUtf32("sbyte"), ToUtf32("d")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Date>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* monthNonterminalParser = GetNonterminal(ToUtf32("month"));
                monthNonterminalParser->SetPost(Postmonth);
                NonterminalParser* dayNonterminalParser = GetNonterminal(ToUtf32("Day"));
                dayNonterminalParser->SetPost(PostDay);
                NonterminalParser* day1NonterminalParser = GetNonterminal(ToUtf32("Day1"));
                day1NonterminalParser->SetPost(PostDay1);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Date(0, context->m, context->d);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->m = context->frommonth;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->d = context->fromDay;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->d = context->fromDay1;
            }
            public void Postmonth(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frommonth_value = stack.Pop();
                    context->frommonth = *cast<ValueObject<Month>*>(frommonth_value.Get());
                }
            }
            public void PostDay(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDay_value = stack.Pop();
                    context->fromDay = *cast<ValueObject<sbyte>*>(fromDay_value.Get());
                }
            }
            public void PostDay1(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromDay1_value = stack.Pop();
                    context->fromDay1 = *cast<ValueObject<sbyte>*>(fromDay1_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), m(), d(), frommonth(), fromDay(), fromDay1()
                {
                }
                public Date value;
                public Month m;
                public sbyte d;
                public Month frommonth;
                public sbyte fromDay;
                public sbyte fromDay1;
            }
        }

        public class YearRule : System.Text.Parsing.RuleParser
        {
            public YearRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("short"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<short>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseShort(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public short value;
            }
        }

        public class Year2Rule : System.Text.Parsing.RuleParser
        {
            public Year2Rule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("short"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<short>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = 2000 + ParseShort(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public short value;
            }
        }

        public class DayRule : System.Text.Parsing.RuleParser
        {
            public DayRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("sbyte"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<sbyte>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseSByte(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public sbyte value;
            }
        }

        public class Day1Rule : System.Text.Parsing.RuleParser
        {
            public Day1Rule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("sbyte"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<sbyte>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseSByte(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public sbyte value;
            }
        }

        public class monthRule : System.Text.Parsing.RuleParser
        {
            public monthRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Month"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Month>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                ActionParser* a6ActionParser = GetAction(ToUtf32("A6"));
                a6ActionParser->SetAction(A6Action);
                ActionParser* a7ActionParser = GetAction(ToUtf32("A7"));
                a7ActionParser->SetAction(A7Action);
                ActionParser* a8ActionParser = GetAction(ToUtf32("A8"));
                a8ActionParser->SetAction(A8Action);
                ActionParser* a9ActionParser = GetAction(ToUtf32("A9"));
                a9ActionParser->SetAction(A9Action);
                ActionParser* a10ActionParser = GetAction(ToUtf32("A10"));
                a10ActionParser->SetAction(A10Action);
                ActionParser* a11ActionParser = GetAction(ToUtf32("A11"));
                a11ActionParser->SetAction(A11Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.january;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.february;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.march;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.april;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.may;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.june;
            }
            public void A6Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.july;
            }
            public void A7Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.august;
            }
            public void A8Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.september;
            }
            public void A9Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.october;
            }
            public void A10Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.november;
            }
            public void A11Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Month.december;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Month value;
            }
        }

        public class timeRule : System.Text.Parsing.RuleParser
        {
            public timeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("int"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* hourNonterminalParser = GetNonterminal(ToUtf32("Hour"));
                hourNonterminalParser->SetPost(PostHour);
                NonterminalParser* minNonterminalParser = GetNonterminal(ToUtf32("Min"));
                minNonterminalParser->SetPost(PostMin);
                NonterminalParser* secNonterminalParser = GetNonterminal(ToUtf32("Sec"));
                secNonterminalParser->SetPost(PostSec);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = 3600 * context->fromHour + 60 * context->fromMin + context->fromSec;
            }
            public void PostHour(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromHour_value = stack.Pop();
                    context->fromHour = *cast<ValueObject<int>*>(fromHour_value.Get());
                }
            }
            public void PostMin(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromMin_value = stack.Pop();
                    context->fromMin = *cast<ValueObject<int>*>(fromMin_value.Get());
                }
            }
            public void PostSec(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromSec_value = stack.Pop();
                    context->fromSec = *cast<ValueObject<int>*>(fromSec_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromHour(), fromMin(), fromSec()
                {
                }
                public int value;
                public int fromHour;
                public int fromMin;
                public int fromSec;
            }
        }

        public class HourRule : System.Text.Parsing.RuleParser
        {
            public HourRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("int"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseInt(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public int value;
            }
        }

        public class MinRule : System.Text.Parsing.RuleParser
        {
            public MinRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("int"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseInt(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public int value;
            }
        }

        public class SecRule : System.Text.Parsing.RuleParser
        {
            public SecRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("int"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseInt(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public int value;
            }
        }

        public class deltaSecondsRule : System.Text.Parsing.RuleParser
        {
            public deltaSecondsRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("int"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<int>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ParseInt(ToUtf8(ustring(matchBegin, matchEnd)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public int value;
            }
        }

        public class httpTokenRule : System.Text.Parsing.RuleParser
        {
            public httpTokenRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* cHARNonterminalParser = GetNonterminal(ToUtf32("CHAR"));
                cHARNonterminalParser->SetPost(PostCHAR);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public void PostCHAR(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCHAR_value = stack.Pop();
                    context->fromCHAR = *cast<ValueObject<uchar>*>(fromCHAR_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromCHAR()
                {
                }
                public ustring value;
                public uchar fromCHAR;
            }
        }

        public class ctextRule : System.Text.Parsing.RuleParser
        {
            public ctextRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("uchar"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uchar>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = *matchBegin;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public uchar value;
            }
        }

        public class quotedStringRule : System.Text.Parsing.RuleParser
        {
            public quotedStringRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* qdtextNonterminalParser = GetNonterminal(ToUtf32("qdtext"));
                qdtextNonterminalParser->SetPost(Postqdtext);
                NonterminalParser* quotedPairNonterminalParser = GetNonterminal(ToUtf32("quotedPair"));
                quotedPairNonterminalParser->SetPost(PostquotedPair);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Append(context->fromqdtext);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value.Append(context->fromquotedPair);
            }
            public void Postqdtext(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromqdtext_value = stack.Pop();
                    context->fromqdtext = *cast<ValueObject<uchar>*>(fromqdtext_value.Get());
                }
            }
            public void PostquotedPair(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromquotedPair_value = stack.Pop();
                    context->fromquotedPair = *cast<ValueObject<uchar>*>(fromquotedPair_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromqdtext(), fromquotedPair()
                {
                }
                public ustring value;
                public uchar fromqdtext;
                public uchar fromquotedPair;
            }
        }

        public class qdtextRule : System.Text.Parsing.RuleParser
        {
            public qdtextRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("uchar"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uchar>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = *matchBegin;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public uchar value;
            }
        }

        public class quotedPairRule : System.Text.Parsing.RuleParser
        {
            public quotedPairRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("uchar"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uchar>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* cHARNonterminalParser = GetNonterminal(ToUtf32("CHAR"));
                cHARNonterminalParser->SetPost(PostCHAR);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromCHAR;
            }
            public void PostCHAR(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromCHAR_value = stack.Pop();
                    context->fromCHAR = *cast<ValueObject<uchar>*>(fromCHAR_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromCHAR()
                {
                }
                public uchar value;
                public uchar fromCHAR;
            }
        }

        public class CHARRule : System.Text.Parsing.RuleParser
        {
            public CHARRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("uchar"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<uchar>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = *matchBegin;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public uchar value;
            }
        }

        public override void GetReferencedGrammars()
        {
        }
        public override void CreateRules()
        {
            AddRule(new statusLineRule(ToUtf32("statusLine"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("httpVersion"), ToUtf32("httpVersion"), 0),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("statusCode"), ToUtf32("statusCode"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("reasonPhrase"), ToUtf32("reasonPhrase"), 0))))));
            AddRule(new httpVersionRule(ToUtf32("httpVersion"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.StringParser(ToUtf32("HTTP")),
                                        new System.Text.Parsing.CharParser('/')),
                                    new System.Text.Parsing.PositiveParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))),
                                new System.Text.Parsing.CharParser('.')),
                            new System.Text.Parsing.PositiveParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0)))))));
            AddRule(new statusCodeRule(ToUtf32("statusCode"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new reasonPhraseRule(ToUtf32("reasonPhrase"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.DifferenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("TEXT"), ToUtf32("TEXT"), 0),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("CR"), ToUtf32("CR"), 0),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("LF"), ToUtf32("LF"), 0))))))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("charset"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0)));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("contentCoding"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0)));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("transferCoding"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.StringParser(ToUtf32("chunked")),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("transferExtension"), ToUtf32("transferExtension"), 0))));
            AddRule(new commaSeparatedFieldValueRule(ToUtf32("commaSeparatedFieldValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ListParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("generalFieldValue"), ToUtf32("generalFieldValue"), 1),
                    new System.Text.Parsing.CharParser(','))));
            AddRule(new generalFieldValueRule(ToUtf32("generalFieldValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0)),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser(';'),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("generalParameter"), ToUtf32("generalParameter"), 1)))))))));
            AddRule(new generalParameterRule(ToUtf32("generalParameter"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("attribute"), ToUtf32("attribute"), 0),
                            new System.Text.Parsing.OptionalParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.CharParser('='),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("attrval"), ToUtf32("attrval"), 0)))))))));
            AddRule(new chunkHeaderRule(ToUtf32("chunkHeader"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.PositiveParser(
                                new System.Text.Parsing.HexDigitParser()))),
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("chunkExtensions"), ToUtf32("chunkExtensions"), 1)))));
            AddRule(new chunkExtensionsRule(ToUtf32("chunkExtensions"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.KleeneStarParser(
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser(';'),
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("chunkExtName"), ToUtf32("chunkExtName"), 0),
                                        new System.Text.Parsing.OptionalParser(
                                            new System.Text.Parsing.GroupingParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.CharParser('='),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("chunkExtVal"), ToUtf32("chunkExtVal"), 0))))))))))));
            AddRule(new chunkExtNameRule(ToUtf32("chunkExtName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0))));
            AddRule(new chunkExtValRule(ToUtf32("chunkExtVal"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("quotedString"), ToUtf32("quotedString"), 0)))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("transferExtension"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(';'),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("parameter"), ToUtf32("parameter"), 0)))))));
            AddRule(new parameterRule(ToUtf32("parameter"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("attribute"), ToUtf32("attribute"), 0),
                                new System.Text.Parsing.CharParser('=')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("attrval"), ToUtf32("attrval"), 0))))));
            AddRule(new attributeRule(ToUtf32("attribute"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0))));
            AddRule(new attrvalRule(ToUtf32("attrval"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("quotedString"), ToUtf32("quotedString"), 0)))));
            AddRule(new mediaTypeRule(ToUtf32("mediaType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("type"), ToUtf32("type"), 0),
                                    new System.Text.Parsing.CharParser('/')),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("subtype"), ToUtf32("subtype"), 0)))),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser(';'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("parameter"), ToUtf32("parameter"), 0))))))));
            AddRule(new typeRule(ToUtf32("type"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0))));
            AddRule(new subtypeRule(ToUtf32("subtype"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0))));
            AddRule(new httpHeaderRule(ToUtf32("httpHeader"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("fieldName"), ToUtf32("fieldName"), 0),
                                new System.Text.Parsing.CharParser(':')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("fieldValue"), ToUtf32("fieldValue"), 0))))));
            AddRule(new fieldNameRule(ToUtf32("fieldName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpToken"), ToUtf32("httpToken"), 0))));
            AddRule(new fieldValueRule(ToUtf32("fieldValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.AnyCharParser())))));
            AddRule(new dateValueRule(ToUtf32("dateValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpDate"), ToUtf32("httpDate"), 0))));
            AddRule(new httpDateRule(ToUtf32("httpDate"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("rfc1123Date"), ToUtf32("rfc1123Date"), 0)),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("rfc850Date"), ToUtf32("rfc850Date"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("asctimeDate"), ToUtf32("asctimeDate"), 0)))));
            AddRule(new rfc1123DateRule(ToUtf32("rfc1123Date"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("wkday"), ToUtf32("wkday"), 0),
                                                    new System.Text.Parsing.CharParser(',')),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("date1"), ToUtf32("date1"), 0)),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("time"), ToUtf32("time"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.StringParser(ToUtf32("GMT")))))));
            AddRule(new rfc850DateRule(ToUtf32("rfc850Date"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.SequenceParser(
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("weekday"), ToUtf32("weekday"), 0),
                                                    new System.Text.Parsing.StringParser(ToUtf32(","))),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("date2"), ToUtf32("date2"), 0)),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("time"), ToUtf32("time"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.StringParser(ToUtf32("GMT")))))));
            AddRule(new asctimeDateRule(ToUtf32("asctimeDate"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("wkday"), ToUtf32("wkday"), 0),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("date3"), ToUtf32("date3"), 0))),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("time"), ToUtf32("time"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Year"), ToUtf32("Year"), 0))))));
            AddRule(new date1Rule(ToUtf32("date1"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Day"), ToUtf32("Day"), 0),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("month"), ToUtf32("month"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Year"), ToUtf32("Year"), 0))))));
            AddRule(new date2Rule(ToUtf32("date2"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Day"), ToUtf32("Day"), 0),
                                        new System.Text.Parsing.CharParser('-')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("month"), ToUtf32("month"), 0)),
                                new System.Text.Parsing.CharParser('-')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Year2"), ToUtf32("Year2"), 0))))));
            AddRule(new date3Rule(ToUtf32("date3"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("month"), ToUtf32("month"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Day"), ToUtf32("Day"), 0)),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Day1"), ToUtf32("Day1"), 0)))))))));
            AddRule(new YearRule(ToUtf32("Year"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0)),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new Year2Rule(ToUtf32("Year2"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new DayRule(ToUtf32("Day"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new Day1Rule(ToUtf32("Day1"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0)))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("wkday"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.StringParser(ToUtf32("Mon")),
                                        new System.Text.Parsing.StringParser(ToUtf32("Tue"))),
                                    new System.Text.Parsing.StringParser(ToUtf32("Wed"))),
                                new System.Text.Parsing.StringParser(ToUtf32("Thu"))),
                            new System.Text.Parsing.StringParser(ToUtf32("Fri"))),
                        new System.Text.Parsing.StringParser(ToUtf32("Sat"))),
                    new System.Text.Parsing.StringParser(ToUtf32("Sun")))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("weekday"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.StringParser(ToUtf32("Monday")),
                                        new System.Text.Parsing.StringParser(ToUtf32("Tuesday"))),
                                    new System.Text.Parsing.StringParser(ToUtf32("Wednesday"))),
                                new System.Text.Parsing.StringParser(ToUtf32("Thursday"))),
                            new System.Text.Parsing.StringParser(ToUtf32("Friday"))),
                        new System.Text.Parsing.StringParser(ToUtf32("Saturday"))),
                    new System.Text.Parsing.StringParser(ToUtf32("Sunday")))));
            AddRule(new monthRule(ToUtf32("month"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.AlternativeParser(
                                                    new System.Text.Parsing.AlternativeParser(
                                                        new System.Text.Parsing.AlternativeParser(
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                                                new System.Text.Parsing.StringParser(ToUtf32("Jan"))),
                                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                                new System.Text.Parsing.StringParser(ToUtf32("Feb")))),
                                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                            new System.Text.Parsing.StringParser(ToUtf32("Mar")))),
                                                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                        new System.Text.Parsing.StringParser(ToUtf32("Apr")))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                    new System.Text.Parsing.StringParser(ToUtf32("May")))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                                new System.Text.Parsing.StringParser(ToUtf32("Jun")))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A6"),
                                            new System.Text.Parsing.StringParser(ToUtf32("Jul")))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A7"),
                                        new System.Text.Parsing.StringParser(ToUtf32("Aug")))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A8"),
                                    new System.Text.Parsing.StringParser(ToUtf32("Sep")))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A9"),
                                new System.Text.Parsing.StringParser(ToUtf32("Oct")))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A10"),
                            new System.Text.Parsing.StringParser(ToUtf32("Nov")))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A11"),
                        new System.Text.Parsing.StringParser(ToUtf32("Dec"))))));
            AddRule(new timeRule(ToUtf32("time"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Hour"), ToUtf32("Hour"), 0),
                                        new System.Text.Parsing.CharParser(':')),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Min"), ToUtf32("Min"), 0)),
                                new System.Text.Parsing.CharParser(':')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Sec"), ToUtf32("Sec"), 0))))));
            AddRule(new HourRule(ToUtf32("Hour"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new MinRule(ToUtf32("Min"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new SecRule(ToUtf32("Sec"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new deltaSecondsRule(ToUtf32("deltaSeconds"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.PositiveParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("DIGIT"), ToUtf32("DIGIT"), 0))))));
            AddRule(new httpTokenRule(ToUtf32("httpToken"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.PositiveParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.DifferenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("CHAR"), ToUtf32("CHAR"), 0),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("CTL"), ToUtf32("CTL"), 0),
                                            new System.Text.Parsing.NonterminalParser(ToUtf32("sep"), ToUtf32("sep"), 0))))))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("sep"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.CharSetParser(ToUtf32("()<>@,;:\\\"/[]?={}")),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("HT"), ToUtf32("HT"), 0))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("comment"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.CharParser('('),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("ctext"), ToUtf32("ctext"), 0),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("quotedPair"), ToUtf32("quotedPair"), 0)),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("comment"), ToUtf32("comment"), 0))))),
                    new System.Text.Parsing.CharParser(')'))));
            AddRule(new ctextRule(ToUtf32("ctext"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.DifferenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TEXT"), ToUtf32("TEXT"), 0),
                            new System.Text.Parsing.CharSetParser(ToUtf32("()")))))));
            AddRule(new quotedStringRule(ToUtf32("quotedString"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.CharParser('\"'),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.AlternativeParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("qdtext"), ToUtf32("qdtext"), 0)),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("quotedPair"), ToUtf32("quotedPair"), 0)))))),
                    new System.Text.Parsing.CharParser('\"'))));
            AddRule(new qdtextRule(ToUtf32("qdtext"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.DifferenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("TEXT"), ToUtf32("TEXT"), 0),
                            new System.Text.Parsing.CharParser('\"'))))));
            AddRule(new quotedPairRule(ToUtf32("quotedPair"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.CharParser('\\'),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("CHAR"), ToUtf32("CHAR"), 0)))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("OCTET"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.RangeParser(0u, 255u)));
            AddRule(new CHARRule(ToUtf32("CHAR"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.RangeParser(0u, 127u))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("UPALPHA"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharSetParser(ToUtf32("A-Z"))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("LOALPHA"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharSetParser(ToUtf32("a-z"))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("ALPHA"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("UPALPHA"), ToUtf32("UPALPHA"), 0),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("LOALPHA"), ToUtf32("LOALPHA"), 0))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("DIGIT"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharSetParser(ToUtf32("0-9"))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("CTL"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.RangeParser(0u, 31u),
                    new System.Text.Parsing.CharParser('\x0000007F'))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("CR"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharParser('\r')));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("LF"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharParser('\n')));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("SP"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharParser(' ')));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("HT"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharParser('\t')));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("QUOTE"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharParser('\"')));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("CRLF"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.NonterminalParser(ToUtf32("CR"), ToUtf32("CR"), 0),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("LF"), ToUtf32("LF"), 0))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("LWS"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.OptionalParser(
                        new System.Text.Parsing.NonterminalParser(ToUtf32("CRLF"), ToUtf32("CRLF"), 0)),
                    new System.Text.Parsing.PositiveParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("HT"), ToUtf32("HT"), 0)))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("TEXT"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.DifferenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("OCTET"), ToUtf32("OCTET"), 0),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("CTL"), ToUtf32("CTL"), 0))),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("CR"), ToUtf32("CR"), 0)),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("LF"), ToUtf32("LF"), 0)),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("SP"), ToUtf32("SP"), 0)),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("HT"), ToUtf32("HT"), 0))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("HEX"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.CharSetParser(ToUtf32("A-Fa-f0-9"))));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpFieldValueGrammar : System.Text.Parsing.Grammar
    {
        public HttpFieldValueGrammar() : this(new ParsingDomain())
        {
        }
        public HttpFieldValueGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpFieldValueGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, List<HttpFieldValue>* values)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<List<HttpFieldValue>*>(values)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class csvFieldValueRule : System.Text.Parsing.RuleParser
        {
            public csvFieldValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("List<HttpFieldValue>*"), ToUtf32("values")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> values_value = stack.Pop();
                context->values = *cast<ValueObject<List<HttpFieldValue>*>*>(values_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* commaSeparatedFieldValueNonterminalParser = GetNonterminal(ToUtf32("commaSeparatedFieldValue"));
                commaSeparatedFieldValueNonterminalParser->SetPre(PrecommaSeparatedFieldValue);
            }
            public void PrecommaSeparatedFieldValue(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<List<HttpFieldValue>*>(context->values)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : values()
                {
                }
                public List<HttpFieldValue>* values;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("commaSeparatedFieldValue"), this, ToUtf32("HttpGrammar.commaSeparatedFieldValue")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("LWS"), this, ToUtf32("HttpGrammar.LWS")));
            AddRule(new csvFieldValueRule(ToUtf32("csvFieldValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("commaSeparatedFieldValue"), ToUtf32("commaSeparatedFieldValue"), 1)));
            SetSkipRuleName(ToUtf32("LWS"));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpMediaTypeGrammar : System.Text.Parsing.Grammar
    {
        public HttpMediaTypeGrammar() : this(new ParsingDomain())
        {
        }
        public HttpMediaTypeGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpMediaTypeGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public void Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName, MimeType* mediaType)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            stack.Push(UniquePtr<Object>(new ValueObject<MimeType*>(mediaType)));
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
        }

        public class mediaTypeValueRule : System.Text.Parsing.RuleParser
        {
            public mediaTypeValueRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                AddInheritedAttribute(AttrOrVar(ToUtf32("MimeType*"), ToUtf32("mediaType")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                UniquePtr<Object> mediaType_value = stack.Pop();
                context->mediaType = *cast<ValueObject<MimeType*>*>(mediaType_value.Get());
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                NonterminalParser* mediaTypeNonterminalParser = GetNonterminal(ToUtf32("mediaType"));
                mediaTypeNonterminalParser->SetPre(PremediaType);
            }
            public void PremediaType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                stack.Push(UniquePtr<Object>(new ValueObject<MimeType*>(context->mediaType)));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : mediaType()
                {
                }
                public MimeType* mediaType;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("mediaType"), this, ToUtf32("HttpGrammar.mediaType")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("LWS"), this, ToUtf32("HttpGrammar.LWS")));
            AddRule(new mediaTypeValueRule(ToUtf32("mediaTypeValue"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.NonterminalParser(ToUtf32("mediaType"), ToUtf32("mediaType"), 1)));
            SetSkipRuleName(ToUtf32("LWS"));
        }
    }
} // System.Net.Http
namespace System.Net.Http
{
    public class HttpHeaderGrammar : System.Text.Parsing.Grammar
    {
        public HttpHeaderGrammar() : this(new ParsingDomain())
        {
        }
        public HttpHeaderGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("HttpHeaderGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.Net.Http")), parsingDomain)
        {
            SetOwner(0);
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public HttpHeader Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            HttpHeader result = *cast<ValueObject<HttpHeader>*>(value.Get());
            return result;
        }

        public class headerRule : System.Text.Parsing.RuleParser
        {
            public headerRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("HttpHeader"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<HttpHeader>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* httpHeaderNonterminalParser = GetNonterminal(ToUtf32("httpHeader"));
                httpHeaderNonterminalParser->SetPost(PosthttpHeader);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromhttpHeader;
            }
            public void PosthttpHeader(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromhttpHeader_value = stack.Pop();
                    context->fromhttpHeader = *cast<ValueObject<HttpHeader>*>(fromhttpHeader_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromhttpHeader()
                {
                }
                public HttpHeader value;
                public HttpHeader fromhttpHeader;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Net.Http.HttpGrammar"));
            if (grammar0 == null)
            {
                grammar0 = new System.Net.Http.HttpGrammar(pd);
            }
            AddGrammarReference(grammar0);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("httpHeader"), this, ToUtf32("HttpGrammar.httpHeader")));
            AddRule(new headerRule(ToUtf32("header"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("httpHeader"), ToUtf32("httpHeader"), 0))));
        }
    }
} // System.Net.Http

using System.Net.Http;
using HttpTokens;

parser Http
{
    uselexer HttpLexer;
    
    token(var string s) : string
        ::= (((chr:ch - (ctl:c | tspecial:t)){ s.Append(ch); })+){ return s; }
        ;
        
    comment(var string s) : string
        ::= (LPAREN (ctext:ct{ s.Append(ct); } quoted_pair:qp{ s.Append(qp); } | comment:c{ s.Append(c); })* RPAREN){ return s; }
        ;
        
    parameter : Pair<string, string>
        ::= (attribute:a LWS EQ LWS attrval:av){ return MakePair(a, av); }
        ;
        
    attribute : string
        ::= token:t{ return t; }
        ;
        
    attrval : string
        ::= token:t{ return t; } | quoted_string:qs{ return qs; }
        ;

    hex : char
        ::= DIGIT{ return lexer.GetChar(pos); } | HEX{ return lexer.GetChar(pos); }
        ;
        
    chr : char
        ::= DIGIT{ return lexer.GetChar(pos); } | HEX{ return lexer.GetChar(pos); } | 
            ALPHA{ return lexer.GetChar(pos); } | HT{ return '\t'; } | DQ{ return '"'; } | CR{ return '\r'; } | LF{ return '\n'; } | 
            CTL{ return lexer.GetChar(pos); } | SP{ return ' '; } | COLON{ return ':'; } | SEMICOLON{ return ';'; } | COMMA{ return ','; } | DOT{ return '.'; } | LPAREN{ return '('; } | RPAREN{ return ')'; } | 
            LANGLE{ return '<'; } | RANGLE{ return '>'; } | LBRACKET{ return '['; } | RBRACKET{ return ']'; } | LBRACE{ return '{'; } | RBRACE{ return '}'; } | 
            SLASH{ return '/'; } | BACKSLASH{ return '\\'; } | EQ{ return '='; } | CHAR{ return lexer.GetChar(pos); }
        ;
        
    text : char
        ::= (octet:o - ctl:c){ return o; }
        ;
        
    ctext : char
        ::= (text:t - (LPAREN | RPAREN)){ return t; }
        ;
        
    quoted_string(var string s) : string
        ::= (DQ (qdtext:qdt{ s.Append(qdt); } | quoted_pair:qp{ s.Append(qp); })* DQ){ return s; }
        ;

    qdtext : char
        ::= (text:t - DQ){ return t; }
        ;
        
    quoted_pair : char
        ::= BACKSLASH chr:ch{ return ch; }
        ;

    ctl : char
        ::= HT{ return '\t'; } | CR{ return '\r'; } | LF{ return '\n'; } | CTL{ return lexer.GetChar(pos); }
        ;
        
    tspecial : char
        ::= LPAREN{ return '('; } | RPAREN{ return ')'; } | LANGLE{ return '<'; } | RANGLE{ return '>'; } | AT{ return '@'; } | COMMA{ return ','; } | SEMICOLON{ return ';'; } | COLON{ return ':'; } | BACKSLASH{ return '\\'; } | 
            DQ{ return '"'; } | SLASH{ return '/'; } | LBRACKET{ return '['; } | RBRACKET{ return ']'; } | QUEST{ return '?'; } | EQ{ return '='; } | LBRACE{ return '{'; } | RBRACE{ return '}'; } | 
            SP{ return ' '; } | HT{ return '\t'; } 
        ;
                        
    octet : char
        ::= chr:c{ return c; } | OCTET{ return lexer.GetChar(pos); }
        ;
}

/*
parser Http
{
    uselexer TrivialLexer;

    statusLine(HttpStatus* httpStatus)
        ::= (httpVersion:v SP:sp1 statusCode:sc SP:sp2 reasonPhrase:p){ (*httpStatus) = HttpStatus(v, sc, p); }
        ;
            
    httpVersion(var ustring s) : ustring
        ::= ("HTTP"{ s.Append(u"HTTP"); } '/'{ s.Append('/'); } (DIGIT:d1{ s.Append(d1); })+ '.'{ s.Append('.'); } (DIGIT:d2{ s.Append(d2); })+){ return s; }
        ;
    
    statusCode(var ustring s) : ushort
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); } DIGIT:d3{ s.Append(d3); }){ return ParseUShort(ToUtf8(s)); }
        ;
    
    reasonPhrase(var ustring s) : ustring
        ::= (((TEXT:text - (CR:cr | LF:lf)){ s.Append(text); })*){ return s; }
        ;
    
    charset 
        ::= httpToken:ht
        ;
    
    contentCoding
        ::= httpToken:ht
        ;
    
    transferCoding
        ::= "chunked" | transferExtension:te
        ;
    
    commaSeparatedFieldValue(List<HttpFieldValue>* values)
        ::= LWS:lws1? generalFieldValue(values):gfv1 (LWS:lws2? ',' LWS:lws? generalFieldValue(values):gfv2)* LWS:lws3?
        ;
    
    generalFieldValue(List<HttpFieldValue>* values, var HttpFieldValue fieldValue)
        ::= (httpToken:ht{ fieldValue.SetFieldValue(ht); } (';' generalParameter(&fieldValue):gp)*){ values->Add(fieldValue); }
        ;
    
    generalParameter(HttpFieldValue* fieldValue)
        ::= (attribute:a ('=' attrval:av)?){ fieldValue->SetParameter(a, av); }
        ;

    chunkHeader(var ustring s, ulong* chunkSize, ChunkExtensionAdder* adder)
        ::= ((HEX:hex{ s.Append(hex); })+){ *chunkSize = ParseHexULong(ToUtf8(s)); } chunkExtensions(adder):cexts?
        ;

    chunkExtensions(ChunkExtensionAdder* adder)
        ::= (';' (chunkExtName:cn ('=' chunkExtVal:cv)?){ adder->AddChunkExtension(cn, cv); })*
        ;

    chunkExtName : ustring
        ::= httpToken:ht{ return ht; }
        ;

    chunkExtVal : ustring
        ::= httpToken:ht{ return ht; } | quotedString:qs{ return qs; }
        ;

    transferExtension
        ::= httpToken:ht (';' parameter:p)*
        ;

    mediaType(MimeType* mimeType, var Pair<ustring, ustring> param)
        ::= LWS:lws1? (type:t '/' subtype:st){ mimeType->SetValue(t, st); } (LWS:lws2? ';' LWS:lws3? parameter:p{ param = p; mimeType->SetParameter(param.first, param.second); })* LWS:lws4?
        ;

    parameter : Pair<ustring, ustring>
        ::= (attribute:a '=' attrval:av){ return MakePair(a, av); }
        ;
        
    attribute : ustring
        ::= httpToken:ht{ return ht; }
        ;
        
    attrval : ustring
        ::= httpToken:ht{ return ht; } | quotedString:qs{ return qs; }
        ;

    type : ustring
        ::= httpToken:ht{ return ht; }
        ;

    subtype : ustring
        ::= httpToken:ht{ return ht; }
        ;

    httpHeader : HttpHeader
        ::= (fieldName:fn ':' fieldValue:fv){ return HttpHeader(fn, fv); }
        ;

    fieldName : ustring
        ::= httpToken:ht{ return ht; }
        ;

    fieldValue(var ustring v) : ustring
        ::= (("[^]"{ Token token = lexer.GetToken(pos); v.Append(*token.match.begin); })*){ return v; }
        ;

    dateValue(DateTime* date)
        ::= httpDate:hd{ *date = hd; }
        ;
            
    httpDate : DateTime
        ::= rfc1123Date:d1{ return d1; } | rfc850Date:d2{ return d2; } | asctimeDate:d3{ return d3; }
        ;

    rfc1123Date : DateTime
        ::= (wkday:wd ',' SP:sp1 date1:d1 SP:sp2 time:t SP:sp3 "GMT"){ return DateTime(d1, t); }
        ;

    rfc850Date : DateTime
        ::= (weekday:wd "," SP:sp1 date2:d2 SP:sp2 time:t SP:sp3 "GMT"){ return DateTime(d2, t); }
        ;

    asctimeDate(var Date monthday) : DateTime
        ::= (wkday:wd SP:sp1 date3:md{ monthday = md; } SP:sp2 time:t SP:sp3 Year:y){ return DateTime(Date(y, monthday.GetMonth(), monthday.Day()), t); }
        ;

    date1 : Date
        ::= (Day:day SP:sp1 month:m SP:sp2 Year:y){ return Date(y, m, day); }
        ;

    date2 : Date
        ::= (Day:day '-' month:m '-' Year2:y){ return Date(y, m, day); }
        ;

    date3(var sbyte d) : Date
        ::= (month:m SP:sp (Day:day{ d = day; } | Day1:day1{ d = day1; })){ return Date(0, m, d); }
        ;

    Year(var ustring s) : short
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); } DIGIT:d3{ s.Append(d3); } DIGIT:d4{ s.Append(d4); }){ return ParseShort(ToUtf8(s)); }
        ;

    Year2(var ustring s) : short
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); }){ return 2000 + ParseShort(ToUtf8(s)); }
        ;

    Day(var ustring s) : sbyte
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); }){ return ParseSByte(ToUtf8(s)); }
        ;

    Day1(var ustring s) : sbyte
        ::= SP:sp DIGIT:digit{ s.Append(digit); return ParseSByte(ToUtf8(s)); }
        ;

    wkday
        ::= "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
        ;

    weekday
        ::= "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday"
        ;

    month : Month
        ::= "Jan"{ return Month.january; }
        |   "Feb"{ return Month.february; }
        |   "Mar"{ return Month.march; }
        |   "Apr"{ return Month.april; }
        |   "May"{ return Month.may; }
        |   "Jun"{ return Month.june; }
        |   "Jul"{ return Month.july; }
        |   "Aug"{ return Month.august; }
        |   "Sep"{ return Month.september; }
        |   "Oct"{ return Month.october; }
        |   "Nov"{ return Month.november; }
        |   "Dec"{ return Month.december; }
        ;

    time : int
        ::= (Hour:hour ':' Min:min ':' Sec:sec){ return 3600 * hour + 60 * min + sec; }
        ;

    Hour(var ustring s) : int
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); }){ return ParseInt(ToUtf8(s)); }
        ;

    Min(var ustring s) : int
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); }){ return ParseInt(ToUtf8(s)); }
        ;

    Sec(var ustring s) : int
        ::= (DIGIT:d1{ s.Append(d1); } DIGIT:d2{ s.Append(d2); }){ return ParseInt(ToUtf8(s)); }
        ;

    deltaSeconds(var ustring s) : int
        ::= ((DIGIT:digit{ s.Append(digit); })+){ return ParseInt(ToUtf8(s)); }
        ;

    httpToken(var ustring value) : ustring
        ::= (((CHAR:chr - (CTL:ctl | sep:s)){ value.Append(chr); })+){ return value; }
        ;

    sep
        ::= "[\"()<>@,;:/[\]?={}]" | SP:sp| HT:ht
        ;

    comment
        ::= '(' (ctext:ct | quotedPair:qp | comment:c)* ')'
        ;

    ctext : uchar
        ::= (TEXT:text - "[()]"){ return text; }
        ;

    quotedString(var ustring value) : ustring
        ::= ('"' (qdtext:qdt{ value.Append(qdt); } | quotedPair:qp{ value.Append(qp); })* '"'){ return value; }
        ;

    qdtext : uchar
        ::= (TEXT:text - '"'){ return text; }
        ;
            
    quotedPair : uchar
        ::= "[\\]" CHAR:chr{ return chr; }
        ;
            
    TEXT : uchar
        ::= (OCTET:octet - CTL:ctl){ return octet; } | CR:cr{ return cr; } | LF:lf{ return lf; } | SP:sp{ return sp; } | HT:ht{ return ht; }
        ;
    
    OCTET : uchar
        ::= "[\x0-\xff]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    ALPHA : uchar
        ::= UPALPHA:upalpha{ return upalpha; } | LOALPHA:loalpha{ return loalpha; }
        ;
        
    UPALPHA : uchar
        ::= "[A-Z]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    LOALPHA : uchar
        ::= "[a-z]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    DIGIT : uchar
        ::= "[0-9]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    CTL : uchar
        ::= "[\x0-\x1f\x7f]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    CHAR : uchar
        ::= "[\x0-0x7f]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
        
    LWS
        ::= CRLF:crlf? (SP:sp | HT:ht)+
        ;
        
    CRLF
        ::= CR:cr LF:lf
        ;
    
    CR : uchar
        ::= '\r'{ return '\r'; }
        ;
        
    LF : uchar
        ::= '\n'{ return '\n'; }
        ;
        
    SP : uchar
        ::= ' '{ return ' '; }
        ;
        
    HT : uchar
        ::= '\t'{ return '\t'; }
        ;
        
    QUOTE : uchar
        ::= '"'{ return '"'; }
        ;
        
    HEX : uchar
        ::= "[A-Fa-f0-9]"{ Token token = lexer.GetToken(pos); return *token.match.begin; }
        ;
}

parser HttpHeaderParser
{
    uselexer TrivialLexer;
    main;
    
    using Http.httpHeader;
    
    header : HttpHeader
        ::= httpHeader:hdr{ return hdr; }
        ;
}

parser HttpStatusLineParser
{
    uselexer TrivialLexer;
    main;
    
    using Http.statusLine;
    
    status(HttpStatus* httpStatus) 
        ::= statusLine(httpStatus):stl
        ;
}

parser HttpChunkHeaderParser
{
    uselexer TrivialLexer;
    main;
    
    using Http.chunkHeader;
    
    header(ulong* chunkSize, ChunkExtensionAdder* adder)
        ::= chunkHeader(chunkSize, adder):chdr
        ;
}

parser HttpFieldValueParser
{
    uselexer TrivialLexer;
    main;
    
    using Http.commaSeparatedFieldValue;
    
    csvFieldValue(List<HttpFieldValue>* values)
        ::= commaSeparatedFieldValue(values):csv
        ;
}

parser HttpMediaTypeParser
{
    uselexer TrivialLexer;
    main;
    
    using Http.mediaType;
    
    mediaTypeValue(MimeType* mimeType)
        ::= mediaType(mimeType):mt
        ;
}

parser HttpDateParser
{
    uselexer TrivialLexer;
    main;

    using Http.dateValue;
    
    date(DateTime* dateTime)
        ::= dateValue(dateTime):dv
        ;
}
*/
using System;
using System.Collections;
using System.Lex;
using System.Parsing;

namespace
{
    public const int[4] s70 = [34, 110, 111, 34];
    public const int[5] s69 = [34, 121, 101, 115, 34];
    public const int[2] s65 = [63, 62];
    public const int[2] s64 = [63, 62];
    public const int[2] s63 = [60, 63];
    public const int[3] s62 = [45, 45, 62];
    public const int[4] s61 = [60, 33, 45, 45];
    public const int[3] s60 = [38, 35, 120];
    public const int[2] s59 = [38, 35];
    public const int[3] s54 = [93, 93, 62];
    public const int[3] s53 = [93, 93, 62];
    public const int[9] s52 = [60, 33, 91, 67, 68, 65, 84, 65, 91];
    public const int[3] s50 = [93, 93, 62];
    public const int[2] s47 = [60, 47];
    public const int[2] s46 = [47, 62];
    public const int[6] s45 = [80, 85, 66, 76, 73, 67];
    public const int[10] s44 = [60, 33, 78, 79, 84, 65, 84, 73, 79, 78];
    public const int[5] s43 = [78, 68, 65, 84, 65];
    public const int[8] s40 = [60, 33, 69, 78, 84, 73, 84, 89];
    public const int[8] s39 = [60, 33, 69, 78, 84, 73, 84, 89];
    public const int[6] s38 = [35, 70, 73, 88, 69, 68];
    public const int[8] s37 = [35, 73, 77, 80, 76, 73, 69, 68];
    public const int[9] s36 = [35, 82, 69, 81, 85, 73, 82, 69, 68];
    public const int[8] s35 = [78, 79, 84, 65, 84, 73, 79, 78];
    public const int[8] s34 = [78, 77, 84, 79, 75, 69, 78, 83];
    public const int[7] s33 = [78, 77, 84, 79, 75, 69, 78];
    public const int[8] s32 = [69, 78, 84, 73, 84, 73, 69, 83];
    public const int[6] s31 = [69, 78, 84, 73, 84, 89];
    public const int[6] s30 = [73, 68, 82, 69, 70, 83];
    public const int[5] s29 = [73, 68, 82, 69, 70];
    public const int[2] s28 = [73, 68];
    public const int[5] s27 = [67, 68, 65, 84, 65];
    public const int[9] s26 = [60, 33, 65, 84, 84, 76, 73, 83, 84];
    public const int[7] s25 = [35, 80, 67, 68, 65, 84, 65];
    public const int[2] s24 = [41, 42];
    public const int[7] s23 = [35, 80, 67, 68, 65, 84, 65];
    public const int[3] s22 = [65, 78, 89];
    public const int[5] s21 = [69, 77, 80, 84, 89];
    public const int[9] s20 = [60, 33, 69, 76, 69, 77, 69, 78, 84];
    public const int[6] s14 = [80, 85, 66, 76, 73, 67];
    public const int[6] s13 = [83, 89, 83, 84, 69, 77];
    public const int[9] s12 = [60, 33, 68, 79, 67, 84, 89, 80, 69];
    public const int[10] s11 = [115, 116, 97, 110, 100, 97, 108, 111, 110, 101];
    public const int[8] s8 = [101, 110, 99, 111, 100, 105, 110, 103];
    public const int[7] s6 = [118, 101, 114, 115, 105, 111, 110];
    public const int[2] s5 = [63, 62];
    public const int[5] s4 = [60, 63, 120, 109, 108];
    public const Range[6] s0 = [{9, 9}, {10, 10}, {13, 13}, {32, 55295u}, {57344u, 65533u}, {65536, 1114111}];
    public const Range[4] s1 = [{32, 32}, {9, 9}, {13, 13}, {10, 10}];
    public const Range[16] s2 = [{58, 58}, {65, 90}, {95, 95}, {97, 122}, {192u, 214u}, {216u, 246u}, {248u, 767}, {880, 893}, {895, 8191}, {8204, 8205}, {8304, 8591}, {11264, 12271}, {12289, 55295u}, {63744u, 64975u}, {65008u, 65533u}, {65536, 983039}];
    public const Range[6] s3 = [{45, 45}, {46, 46}, {48, 57}, {183u, 183u}, {768, 879}, {8255, 8256}];
    public const Range[1] s7 = [{48, 57}];
    public const Range[2] s9 = [{65, 90}, {97, 122}];
    public const Range[6] s10 = [{65, 90}, {97, 122}, {48, 57}, {46, 46}, {95, 95}, {45, 45}];
    public const Range[1] s15 = [{34, 34}];
    public const Range[1] s16 = [{39, 39}];
    public const Range[3] s17 = [{32, 32}, {13, 13}, {10, 10}];
    public const Range[3] s18 = [{97, 122}, {65, 90}, {48, 57}];
    public const Range[19] s19 = [{45, 45}, {39, 39}, {40, 40}, {41, 41}, {43, 43}, {44, 44}, {46, 46}, {47, 47}, {58, 58}, {61, 61}, {63, 63}, {59, 59}, {33, 33}, {42, 42}, {35, 35}, {64, 64}, {36, 36}, {95, 95}, {37, 37}];
    public const Range[3] s41 = [{37, 37}, {38, 38}, {34, 34}];
    public const Range[3] s42 = [{37, 37}, {38, 38}, {39, 39}];
    public const Range[2] s48 = [{60, 60}, {38, 38}];
    public const Range[2] s49 = [{60, 60}, {38, 38}];
    public const Range[2] s51 = [{60, 60}, {38, 38}];
    public const Range[3] s55 = [{60, 60}, {38, 38}, {34, 34}];
    public const Range[3] s56 = [{60, 60}, {38, 38}, {39, 39}];
    public const Range[1] s57 = [{48, 57}];
    public const Range[3] s58 = [{48, 57}, {97, 102}, {65, 70}];
    public const Range[2] s66 = [{120, 120}, {88, 88}];
    public const Range[2] s67 = [{109, 109}, {77, 77}];
    public const Range[2] s68 = [{108, 108}, {76, 76}];
} // namespace
public static class XmlParser
{
    public static void Parse(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            if (lexer.Log() != null)
            {
                lexer.Log()->WriteBeginRule(u"parse");
                lexer.Log()->IncIndent();
            }
        #endif
        ++lexer;
        System.Lex.Span span = lexer.GetSpan();
        Match match = Document(lexer, processor);
        if (match.hit)
        {
            if (*lexer == System.Lex.END_TOKEN)
            {
                return;
            }
            else
            {
                lexer.ThrowExpectationFailure(lexer.GetSpan(), GetEndTokenInfo());
            }
        }
        else
        {
            lexer.ThrowExpectationFailure(span, u"Document");
        }
        return;
    }
    public static Match Document(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Document");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                if (match.hit)
                {
                    processor->StartDocument();
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match = XmlParser.Prolog(lexer, processor);
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match = XmlParser.Element(lexer, processor);
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                Match* parentMatch9 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match = XmlParser.Misc(lexer, processor);
                                                *parentMatch10 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch9 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    if (match.hit)
                    {
                        processor->EndDocument();
                    }
                    *parentMatch3 = match;
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Document");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Document");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Char(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Char");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                for (const Range& range : s0)
                {
                    if (*lexer >= range.first && *lexer <= range.last)
                    {
                        match.hit = true;
                        ++lexer;
                        break;
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Token token = lexer.GetToken(pos);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Char");
                    #endif
                    return Match(true, new Value<uchar>(cast<uchar>(token.id)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Char");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Char");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match S(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"S");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            for (const Range& range : s1)
            {
                if (*lexer >= range.first && *lexer <= range.last)
                {
                    match.hit = true;
                    ++lexer;
                    break;
                }
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(true);
            Match* parentMatch1 = &match;
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match(false);
                    for (const Range& range : s1)
                    {
                        if (*lexer >= range.first && *lexer <= range.last)
                        {
                            match.hit = true;
                            ++lexer;
                            break;
                        }
                    }
                    if (match.hit)
                    {
                        *parentMatch1 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"S");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"S");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NameStartChar(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NameStartChar");
            }
        #endif
        Match match(false);
        for (const Range& range : s2)
        {
            if (*lexer >= range.first && *lexer <= range.last)
            {
                match.hit = true;
                ++lexer;
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NameStartChar");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NameStartChar");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NameChar(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NameChar");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.NameStartChar(lexer);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    for (const Range& range : s3)
                    {
                        if (*lexer >= range.first && *lexer <= range.last)
                        {
                            match.hit = true;
                            ++lexer;
                            break;
                        }
                    }
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NameChar");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NameChar");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Name(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Name");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match = XmlParser.NameStartChar(lexer);
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match = XmlParser.NameChar(lexer);
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Name");
                    #endif
                    return Match(true, new Value<ustring>(lexer.GetMatch(s)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Name");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Name");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Names(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Names");
            }
        #endif
        UniquePtr<Value<ustring>> name1;
        UniquePtr<Value<ustring>> name2;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = XmlParser.Name(lexer);
            name1.Reset(cast<Value<ustring>*>(match.value));
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == 32)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch4 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        Match match = XmlParser.Name(lexer);
                                        name2.Reset(cast<Value<ustring>*>(match.value));
                                        *parentMatch5 = match;
                                    }
                                    *parentMatch4 = match;
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Names");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Names");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Nmtoken(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Nmtoken");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = XmlParser.NameChar(lexer);
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(true);
            Match* parentMatch1 = &match;
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match = XmlParser.NameChar(lexer);
                    if (match.hit)
                    {
                        *parentMatch1 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Nmtoken");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Nmtoken");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Nmtokens(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Nmtokens");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match = XmlParser.Nmtoken(lexer);
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                Match* parentMatch2 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch3 = &match;
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == 32)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch4 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        Match match = XmlParser.Nmtoken(lexer);
                                        *parentMatch5 = match;
                                    }
                                    *parentMatch4 = match;
                                }
                                *parentMatch3 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch2 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Nmtokens");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Nmtokens");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Prolog(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Prolog");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.XMLDecl(lexer, processor);
                    if (match.hit)
                    {
                        *parentMatch2 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match = XmlParser.Misc(lexer, processor);
                                if (match.hit)
                                {
                                    *parentMatch4 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch6 = &match;
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match = XmlParser.DocTypeDecl(lexer, processor);
                            *parentMatch8 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(true);
                                Match* parentMatch10 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match = XmlParser.Misc(lexer, processor);
                                            if (match.hit)
                                            {
                                                *parentMatch10 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch6 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Prolog");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Prolog");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match XMLDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"XMLDecl");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            for (int i : s4)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = XmlParser.VersionInfo(lexer, processor);
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.EncodingDecl(lexer, processor);
                                if (match.hit)
                                {
                                    *parentMatch7 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch9 = &match;
                        {
                            Match match = XmlParser.SDDecl(lexer, processor);
                            if (match.hit)
                            {
                                *parentMatch9 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch11 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(true);
                for (int i : s5)
                {
                    if (*lexer == i)
                    {
                        ++lexer;
                    }
                    else
                    {
                        match.hit = false;
                        break;
                    }
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"XMLDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"XMLDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match VersionInfo(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"VersionInfo");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s6)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    Match match = XmlParser.Eq(lexer);
                    *parentMatch4 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match = XmlParser.VersionNumber(lexer, processor);
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"VersionInfo");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"VersionInfo");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match VersionNum(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"VersionNum");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(false);
                            if (*lexer == 49)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            if (match.hit)
                            {
                                s = span;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(false);
                            if (*lexer == 46)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Span span = lexer.GetSpan();
                                    Match match(false);
                                    for (const Range& range : s7)
                                    {
                                        if (*lexer >= range.first && *lexer <= range.last)
                                        {
                                            match.hit = true;
                                            ++lexer;
                                            break;
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        s.end = span.end;
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch10 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            for (const Range& range : s7)
                                            {
                                                if (*lexer >= range.first && *lexer <= range.last)
                                                {
                                                    match.hit = true;
                                                    ++lexer;
                                                    break;
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                            }
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch10 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->Version(lexer.GetMatch(s));
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"VersionNum");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"VersionNum");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match VersionNumDQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"VersionNumDQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == 34)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.VersionNum(lexer, processor);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                if (*lexer == 34)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"VersionNumDQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"VersionNumDQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match VersionNumSQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"VersionNumSQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == 39)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.VersionNum(lexer, processor);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                if (*lexer == 39)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"VersionNumSQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"VersionNumSQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match VersionNumber(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"VersionNumber");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.VersionNumDQ(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.VersionNumSQ(lexer, processor);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"VersionNumber");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"VersionNumber");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EncodingDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EncodingDecl");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s8)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    Match match = XmlParser.Eq(lexer);
                    *parentMatch4 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match = XmlParser.EncName(lexer, processor);
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EncodingDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EncodingDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EncodingName(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EncodingName");
            }
        #endif
        Span s;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Span span = lexer.GetSpan();
                        Match match(false);
                        for (const Range& range : s9)
                        {
                            if (*lexer >= range.first && *lexer <= range.last)
                            {
                                match.hit = true;
                                ++lexer;
                                break;
                            }
                        }
                        if (match.hit)
                        {
                            s = span;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(true);
                        Match* parentMatch5 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            for (const Range& range : s10)
                                            {
                                                if (*lexer >= range.first && *lexer <= range.last)
                                                {
                                                    match.hit = true;
                                                    ++lexer;
                                                    break;
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                s.end = span.end;
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->Encoding(lexer.GetMatch(s));
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EncodingName");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EncodingName");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EncNameDQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EncNameDQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == 34)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.EncodingName(lexer, processor);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                if (*lexer == 34)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EncNameDQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EncNameDQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EncNameSQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EncNameSQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == 39)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.EncodingName(lexer, processor);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                if (*lexer == 39)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EncNameSQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EncNameSQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EncName(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EncName");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.EncNameDQ(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.EncNameSQ(lexer, processor);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EncName");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EncName");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SDDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SDDecl");
            }
        #endif
        UniquePtr<Value<bool>> yn;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s11)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    Match match = XmlParser.Eq(lexer);
                    *parentMatch4 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match = XmlParser.YesNo(lexer);
                    yn.Reset(cast<Value<bool>*>(match.value));
                    if (match.hit)
                    {
                        processor->Standalone(yn->value);
                    }
                    *parentMatch6 = match;
                }
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SDDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SDDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DocTypeDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DocTypeDecl");
            }
        #endif
        UniquePtr<Value<ustring>> rootElementName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                for (int i : s12)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                rootElementName.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match = XmlParser.S(lexer);
                                        *parentMatch11 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match = XmlParser.ExternalID(lexer);
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch9 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch14 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            if (match.hit)
                            {
                                *parentMatch14 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch13 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch15 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch16 = &match;
                    {
                        Match match(false);
                        Match* parentMatch17 = &match;
                        {
                            Match match(false);
                            Match* parentMatch18 = &match;
                            {
                                Match match(false);
                                Match* parentMatch19 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == 91)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch20 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            Match match = XmlParser.IntSubset(lexer, processor);
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch20 = match;
                                    }
                                    *parentMatch19 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch22 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == 93)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch22 = match;
                                    }
                                    *parentMatch19 = match;
                                }
                                *parentMatch18 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch23 = &match;
                                {
                                    Match match(true);
                                    long save = lexer.GetPos();
                                    Match* parentMatch24 = &match;
                                    {
                                        Match match = XmlParser.S(lexer);
                                        if (match.hit)
                                        {
                                            *parentMatch24 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                        }
                                    }
                                    *parentMatch23 = match;
                                }
                                *parentMatch18 = match;
                            }
                            *parentMatch17 = match;
                        }
                        if (match.hit)
                        {
                            *parentMatch16 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch15 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch25 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch25 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DocTypeDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DocTypeDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ExternalID(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ExternalID");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s13)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch5 = &match;
                    {
                        Match match = XmlParser.SystemLiteral(lexer);
                        *parentMatch5 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(true);
                                        for (int i : s14)
                                        {
                                            if (*lexer == i)
                                            {
                                                ++lexer;
                                            }
                                            else
                                            {
                                                match.hit = false;
                                                break;
                                            }
                                        }
                                        *parentMatch11 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch12 = &match;
                                        {
                                            Match match = XmlParser.S(lexer);
                                            *parentMatch12 = match;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match = XmlParser.PubidLiteral(lexer);
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch9 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch14 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch14 = match;
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch8 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch15 = &match;
                            {
                                Match match = XmlParser.SystemLiteral(lexer);
                                *parentMatch15 = match;
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ExternalID");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ExternalID");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match SystemLiteral(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"SystemLiteral");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == 34)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                Match* parentMatch6 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(lexer.Pos() != lexer.End());
                                            for (const Range& range : s15)
                                            {
                                                if (*lexer >= range.first && *lexer <= range.last)
                                                {
                                                    match.hit = false;
                                                    break;
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                ++lexer;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch6 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(false);
                        if (*lexer == 34)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch8 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                Match match(false);
                                if (*lexer == 39)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch11 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch13 = &match;
                                    {
                                        Match match(true);
                                        Match* parentMatch14 = &match;
                                        {
                                            while (true)
                                            {
                                                long save = lexer.GetPos();
                                                {
                                                    Match match(lexer.Pos() != lexer.End());
                                                    for (const Range& range : s16)
                                                    {
                                                        if (*lexer >= range.first && *lexer <= range.last)
                                                        {
                                                            match.hit = false;
                                                            break;
                                                        }
                                                    }
                                                    if (match.hit)
                                                    {
                                                        ++lexer;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        *parentMatch14 = match;
                                                    }
                                                    else
                                                    {
                                                        lexer.SetPos(save);
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        *parentMatch13 = match;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch11 = match;
                            }
                            *parentMatch10 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch15 = &match;
                            {
                                Match match(false);
                                if (*lexer == 39)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch15 = match;
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch8 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"SystemLiteral");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"SystemLiteral");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PubidLiteral(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PubidLiteral");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            Match* parentMatch5 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match = XmlParser.PubidChar(lexer);
                                        if (match.hit)
                                        {
                                            *parentMatch5 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch6 = &match;
                {
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch6 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            if (*lexer == 39)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch9 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch12 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch14 = &match;
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match = XmlParser.PubidChar(lexer);
                                                        *parentMatch14 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch15 = &match;
                                                        {
                                                            long tmp = lexer.GetPos();
                                                            lexer.SetPos(save);
                                                            save = tmp;
                                                            Match match(false);
                                                            if (*lexer == 39)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch15 = match;
                                                        }
                                                        if (!match.hit)
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                        *parentMatch14 = Match(!match.hit, match.value);
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch12 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch11 = match;
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch8 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch16 = &match;
                        {
                            Match match(false);
                            if (*lexer == 39)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch16 = match;
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch7 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PubidLiteral");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PubidLiteral");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PubidChar(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PubidChar");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                for (const Range& range : s17)
                {
                    if (*lexer >= range.first && *lexer <= range.last)
                    {
                        match.hit = true;
                        ++lexer;
                        break;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch2 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(false);
                        for (const Range& range : s18)
                        {
                            if (*lexer >= range.first && *lexer <= range.last)
                            {
                                match.hit = true;
                                ++lexer;
                                break;
                            }
                        }
                        *parentMatch2 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    for (const Range& range : s19)
                    {
                        if (*lexer >= range.first && *lexer <= range.last)
                        {
                            match.hit = true;
                            ++lexer;
                            break;
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PubidChar");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PubidChar");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match IntSubset(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"IntSubset");
            }
        #endif
        Match match(true);
        Match* parentMatch0 = &match;
        {
            while (true)
            {
                long save = lexer.GetPos();
                {
                    Match match(false);
                    Match* parentMatch1 = &match;
                    {
                        Match match(false);
                        Match* parentMatch2 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match = XmlParser.MarkupDecl(lexer, processor);
                            *parentMatch2 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch3 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match = XmlParser.DeclSep(lexer, processor);
                                    *parentMatch3 = match;
                                }
                                *parentMatch2 = match;
                            }
                        }
                        *parentMatch1 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch0 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                        break;
                    }
                }
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"IntSubset");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"IntSubset");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match MarkupDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"MarkupDecl");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match = XmlParser.ElementDecl(lexer, processor);
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match = XmlParser.AttlistDecl(lexer, processor);
                                    *parentMatch5 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            lexer.SetPos(save);
                            {
                                Match match = XmlParser.EntityDecl(lexer, processor);
                                *parentMatch6 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        lexer.SetPos(save);
                        {
                            Match match = XmlParser.NotationDecl(lexer, processor);
                            *parentMatch7 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = XmlParser.PI(lexer, processor);
                        *parentMatch8 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch9 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.Comment(lexer, processor);
                    *parentMatch9 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"MarkupDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"MarkupDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DeclSep(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DeclSep");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.PEReference(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DeclSep");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DeclSep");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ElementDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ElementDecl");
            }
        #endif
        UniquePtr<Value<ustring>> elementName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                for (int i : s20)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                elementName.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match = XmlParser.ContentSpec(lexer);
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch11 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ElementDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ElementDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ContentSpec(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ContentSpec");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(true);
                    for (int i : s21)
                    {
                        if (*lexer == i)
                        {
                            ++lexer;
                        }
                        else
                        {
                            match.hit = false;
                            break;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch3 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(true);
                            for (int i : s22)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            *parentMatch3 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = XmlParser.Mixed(lexer);
                        *parentMatch4 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.Children(lexer);
                    *parentMatch5 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ContentSpec");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ContentSpec");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Children(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Children");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match = XmlParser.Choice(lexer);
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch3 = &match;
                        lexer.SetPos(save);
                        {
                            Match match = XmlParser.Seq(lexer);
                            *parentMatch3 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch5 = &match;
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                if (*lexer == 63)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch8 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch9 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        if (*lexer == 42)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch9 = match;
                                    }
                                    *parentMatch8 = match;
                                }
                            }
                            *parentMatch7 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    if (*lexer == 43)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch10 = match;
                                }
                                *parentMatch7 = match;
                            }
                        }
                        *parentMatch6 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch5 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Children");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Children");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CP(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CP");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match = XmlParser.Name(lexer);
                        name.Reset(cast<Value<ustring>*>(match.value));
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch4 = &match;
                            lexer.SetPos(save);
                            {
                                Match match = XmlParser.Choice(lexer);
                                *parentMatch4 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        lexer.SetPos(save);
                        {
                            Match match = XmlParser.Seq(lexer);
                            *parentMatch5 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch6 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch7 = &match;
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(false);
                                if (*lexer == 63)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch10 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(false);
                                        if (*lexer == 42)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch10 = match;
                                }
                            }
                            *parentMatch9 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(false);
                                    if (*lexer == 43)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch9 = match;
                            }
                        }
                        *parentMatch8 = match;
                    }
                    if (match.hit)
                    {
                        *parentMatch7 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch6 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CP");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CP");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Choice(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Choice");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == 40)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match = XmlParser.CP(lexer);
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch13 = &match;
                                        {
                                            Match match(true);
                                            long save = lexer.GetPos();
                                            Match* parentMatch14 = &match;
                                            {
                                                Match match = XmlParser.S(lexer);
                                                if (match.hit)
                                                {
                                                    *parentMatch14 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                }
                                            }
                                            *parentMatch13 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch15 = &match;
                                            {
                                                Match match(false);
                                                if (*lexer == 124)
                                                {
                                                    ++lexer;
                                                    match.hit = true;
                                                }
                                                *parentMatch15 = match;
                                            }
                                            *parentMatch13 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch16 = &match;
                                        {
                                            Match match(true);
                                            long save = lexer.GetPos();
                                            Match* parentMatch17 = &match;
                                            {
                                                Match match = XmlParser.S(lexer);
                                                if (match.hit)
                                                {
                                                    *parentMatch17 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                }
                                            }
                                            *parentMatch16 = match;
                                        }
                                        *parentMatch12 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch18 = &match;
                                    {
                                        Match match = XmlParser.CP(lexer);
                                        *parentMatch18 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        if (match.hit)
                        {
                            Match match(true);
                            Match* parentMatch19 = &match;
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch20 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch23 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch24 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch24 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch25 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == 124)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch25 = match;
                                                    }
                                                    *parentMatch23 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch26 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch27 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch27 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch26 = match;
                                                }
                                                *parentMatch22 = match;
                                            }
                                            *parentMatch21 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch28 = &match;
                                            {
                                                Match match = XmlParser.CP(lexer);
                                                *parentMatch28 = match;
                                            }
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch20 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch19 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch29 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch30 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch30 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch29 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch31 = &match;
            {
                Match match(false);
                if (*lexer == 41)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch31 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Choice");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Choice");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Seq(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Seq");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == 40)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match = XmlParser.CP(lexer);
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        Match* parentMatch9 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch12 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch14 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch14 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch15 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == 44)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch15 = match;
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch16 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch17 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch17 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch16 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch18 = &match;
                                            {
                                                Match match = XmlParser.CP(lexer);
                                                *parentMatch18 = match;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch19 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch20 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch20 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch19 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch21 = &match;
            {
                Match match(false);
                if (*lexer == 41)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch21 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Seq");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Seq");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Mixed(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Mixed");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                if (*lexer == 40)
                                {
                                    ++lexer;
                                    match.hit = true;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(true);
                                    long save = lexer.GetPos();
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match = XmlParser.S(lexer);
                                        if (match.hit)
                                        {
                                            *parentMatch7 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                        }
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(true);
                                for (int i : s23)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(true);
                            Match* parentMatch10 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch12 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch14 = &match;
                                                    {
                                                        Match match(true);
                                                        long save = lexer.GetPos();
                                                        Match* parentMatch15 = &match;
                                                        {
                                                            Match match = XmlParser.S(lexer);
                                                            if (match.hit)
                                                            {
                                                                *parentMatch15 = match;
                                                            }
                                                            else
                                                            {
                                                                lexer.SetPos(save);
                                                            }
                                                        }
                                                        *parentMatch14 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch16 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == 124)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch16 = match;
                                                        }
                                                        *parentMatch14 = match;
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch17 = &match;
                                                    {
                                                        Match match(true);
                                                        long save = lexer.GetPos();
                                                        Match* parentMatch18 = &match;
                                                        {
                                                            Match match = XmlParser.S(lexer);
                                                            if (match.hit)
                                                            {
                                                                *parentMatch18 = match;
                                                            }
                                                            else
                                                            {
                                                                lexer.SetPos(save);
                                                            }
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch19 = &match;
                                                {
                                                    Match match = XmlParser.Name(lexer);
                                                    name.Reset(cast<Value<ustring>*>(match.value));
                                                    *parentMatch19 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch10 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch20 = &match;
                    {
                        Match match(true);
                        long save = lexer.GetPos();
                        Match* parentMatch21 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            if (match.hit)
                            {
                                *parentMatch21 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                            }
                        }
                        *parentMatch20 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch22 = &match;
                {
                    Match match(true);
                    for (int i : s24)
                    {
                        if (*lexer == i)
                        {
                            ++lexer;
                        }
                        else
                        {
                            match.hit = false;
                            break;
                        }
                    }
                    *parentMatch22 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch23 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch24 = &match;
                    {
                        Match match(false);
                        Match* parentMatch25 = &match;
                        {
                            Match match(false);
                            Match* parentMatch26 = &match;
                            {
                                Match match(false);
                                Match* parentMatch27 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == 40)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch27 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch28 = &match;
                                    {
                                        Match match(true);
                                        long save = lexer.GetPos();
                                        Match* parentMatch29 = &match;
                                        {
                                            Match match = XmlParser.S(lexer);
                                            if (match.hit)
                                            {
                                                *parentMatch29 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                            }
                                        }
                                        *parentMatch28 = match;
                                    }
                                    *parentMatch27 = match;
                                }
                                *parentMatch26 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch30 = &match;
                                {
                                    Match match(true);
                                    for (int i : s25)
                                    {
                                        if (*lexer == i)
                                        {
                                            ++lexer;
                                        }
                                        else
                                        {
                                            match.hit = false;
                                            break;
                                        }
                                    }
                                    *parentMatch30 = match;
                                }
                                *parentMatch26 = match;
                            }
                            *parentMatch25 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch31 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch32 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch32 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch31 = match;
                            }
                            *parentMatch25 = match;
                        }
                        *parentMatch24 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch33 = &match;
                        {
                            Match match(false);
                            if (*lexer == 41)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch33 = match;
                        }
                        *parentMatch24 = match;
                    }
                    *parentMatch23 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Mixed");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Mixed");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttlistDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttlistDecl");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            for (int i : s26)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = XmlParser.S(lexer);
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match = XmlParser.Name(lexer);
                            name.Reset(cast<Value<ustring>*>(match.value));
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match(true);
                        Match* parentMatch8 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match = XmlParser.AttDef(lexer, processor);
                                    if (match.hit)
                                    {
                                        *parentMatch8 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch9 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch10 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch10 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch9 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch11 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch11 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttlistDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttlistDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttDef(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttDef");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                name.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch7 = &match;
                    {
                        Match match = XmlParser.AttType(lexer);
                        *parentMatch7 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch8 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch8 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match = XmlParser.DefaultDecl(lexer, processor);
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttDef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttDef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttType(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttType");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match = XmlParser.StringType(lexer);
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch2 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = XmlParser.TokenizedType(lexer);
                        *parentMatch2 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.EnumeratedType(lexer);
                    *parentMatch3 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match StringType(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"StringType");
            }
        #endif
        Match match(true);
        for (int i : s27)
        {
            if (*lexer == i)
            {
                ++lexer;
            }
            else
            {
                match.hit = false;
                break;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"StringType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"StringType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match TokenizedType(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"TokenizedType");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long save = lexer.GetPos();
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long save = lexer.GetPos();
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match(true);
                                for (int i : s28)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match(true);
                                        for (int i : s29)
                                        {
                                            if (*lexer == i)
                                            {
                                                ++lexer;
                                            }
                                            else
                                            {
                                                match.hit = false;
                                                break;
                                            }
                                        }
                                        *parentMatch6 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                            }
                            *parentMatch4 = match;
                            if (!match.hit)
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                lexer.SetPos(save);
                                {
                                    Match match(true);
                                    for (int i : s30)
                                    {
                                        if (*lexer == i)
                                        {
                                            ++lexer;
                                        }
                                        else
                                        {
                                            match.hit = false;
                                            break;
                                        }
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch4 = match;
                            }
                        }
                        *parentMatch3 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(true);
                                for (int i : s31)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch3 = match;
                        }
                    }
                    *parentMatch2 = match;
                    if (!match.hit)
                    {
                        Match match(false);
                        Match* parentMatch9 = &match;
                        lexer.SetPos(save);
                        {
                            Match match(true);
                            for (int i : s32)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            *parentMatch9 = match;
                        }
                        *parentMatch2 = match;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch10 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(true);
                        for (int i : s33)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch10 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                lexer.SetPos(save);
                {
                    Match match(true);
                    for (int i : s34)
                    {
                        if (*lexer == i)
                        {
                            ++lexer;
                        }
                        else
                        {
                            match.hit = false;
                            break;
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"TokenizedType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"TokenizedType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EnumeratedType(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EnumeratedType");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.NotationType(lexer);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.Enumeration(lexer);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EnumeratedType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EnumeratedType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NotationType(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NotationType");
            }
        #endif
        UniquePtr<Value<ustring>> f;
        UniquePtr<Value<ustring>> n;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(true);
                                    for (int i : s35)
                                    {
                                        if (*lexer == i)
                                        {
                                            ++lexer;
                                        }
                                        else
                                        {
                                            match.hit = false;
                                            break;
                                        }
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match = XmlParser.S(lexer);
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch8 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == 40)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch8 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch9 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch10 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch10 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch9 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch11 = &match;
                        {
                            Match match = XmlParser.Name(lexer);
                            f.Reset(cast<Value<ustring>*>(match.value));
                            *parentMatch11 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        Match match(true);
                        Match* parentMatch13 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch14 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch15 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch16 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch17 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch18 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch18 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch19 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == 124)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch19 = match;
                                                    }
                                                    *parentMatch17 = match;
                                                }
                                                *parentMatch16 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch20 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch21 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch21 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch20 = match;
                                                }
                                                *parentMatch16 = match;
                                            }
                                            *parentMatch15 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch22 = &match;
                                            {
                                                Match match = XmlParser.Name(lexer);
                                                n.Reset(cast<Value<ustring>*>(match.value));
                                                *parentMatch22 = match;
                                            }
                                            *parentMatch15 = match;
                                        }
                                        *parentMatch14 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch13 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch23 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch24 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch24 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch23 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch25 = &match;
            {
                Match match(false);
                if (*lexer == 41)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch25 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NotationType");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NotationType");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Enumeration(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Enumeration");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            if (*lexer == 40)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch6 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match = XmlParser.Nmtoken(lexer);
                            *parentMatch7 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        Match match(true);
                        Match* parentMatch9 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch10 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch11 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch12 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch13 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch14 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch14 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch15 = &match;
                                                    {
                                                        Match match(false);
                                                        if (*lexer == 124)
                                                        {
                                                            ++lexer;
                                                            match.hit = true;
                                                        }
                                                        *parentMatch15 = match;
                                                    }
                                                    *parentMatch13 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            if (match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch16 = &match;
                                                {
                                                    Match match(true);
                                                    long save = lexer.GetPos();
                                                    Match* parentMatch17 = &match;
                                                    {
                                                        Match match = XmlParser.S(lexer);
                                                        if (match.hit)
                                                        {
                                                            *parentMatch17 = match;
                                                        }
                                                        else
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                    }
                                                    *parentMatch16 = match;
                                                }
                                                *parentMatch12 = match;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch18 = &match;
                                            {
                                                Match match = XmlParser.Nmtoken(lexer);
                                                *parentMatch18 = match;
                                            }
                                            *parentMatch11 = match;
                                        }
                                        *parentMatch10 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch9 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch19 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch20 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch20 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch19 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch21 = &match;
            {
                Match match(false);
                if (*lexer == 41)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch21 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Enumeration");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Enumeration");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DefaultDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DefaultDecl");
            }
        #endif
        UniquePtr<Value<ustring>> attVAlue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match(true);
                for (int i : s36)
                {
                    if (*lexer == i)
                    {
                        ++lexer;
                    }
                    else
                    {
                        match.hit = false;
                        break;
                    }
                }
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch2 = &match;
                    lexer.SetPos(save);
                    {
                        Match match(true);
                        for (int i : s37)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch2 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch4 = &match;
                    {
                        Match match(false);
                        Match* parentMatch5 = &match;
                        {
                            Match match(true);
                            long save = lexer.GetPos();
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(true);
                                        for (int i : s38)
                                        {
                                            if (*lexer == i)
                                            {
                                                ++lexer;
                                            }
                                            else
                                            {
                                                match.hit = false;
                                                break;
                                            }
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match = XmlParser.S(lexer);
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    *parentMatch7 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch6 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                }
                            }
                            *parentMatch5 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match = XmlParser.AttValue(lexer, processor);
                                attVAlue.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch10 = match;
                            }
                            *parentMatch5 = match;
                        }
                        *parentMatch4 = match;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DefaultDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DefaultDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EntityDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EntityDecl");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.GEDecl(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.PEDecl(lexer, processor);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EntityDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EntityDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match GEDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"GEDecl");
            }
        #endif
        UniquePtr<Value<ustring>> entityName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                for (int i : s39)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                entityName.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match = XmlParser.EntityDef(lexer, processor);
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch11 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch11 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch12 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch12 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"GEDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"GEDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PEDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PEDecl");
            }
        #endif
        UniquePtr<Value<ustring>> peName;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch7 = &match;
                                    {
                                        Match match(true);
                                        for (int i : s40)
                                        {
                                            if (*lexer == i)
                                            {
                                                ++lexer;
                                            }
                                            else
                                            {
                                                match.hit = false;
                                                break;
                                            }
                                        }
                                        *parentMatch7 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch8 = &match;
                                        {
                                            Match match = XmlParser.S(lexer);
                                            *parentMatch8 = match;
                                        }
                                        *parentMatch7 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch9 = &match;
                                    {
                                        Match match(false);
                                        if (*lexer == 37)
                                        {
                                            ++lexer;
                                            match.hit = true;
                                        }
                                        *parentMatch9 = match;
                                    }
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch10 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch10 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                peName.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch11 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch12 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch12 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch13 = &match;
                    {
                        Match match = XmlParser.PEDef(lexer, processor);
                        *parentMatch13 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch15 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch15 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch14 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch16 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch16 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PEDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PEDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EntityDef(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EntityDef");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.EntityValue(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch2 = &match;
                    {
                        Match match(false);
                        Match* parentMatch3 = &match;
                        {
                            Match match = XmlParser.ExternalID(lexer);
                            *parentMatch3 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch4 = &match;
                            {
                                Match match(true);
                                long save = lexer.GetPos();
                                Match* parentMatch5 = &match;
                                {
                                    Match match = XmlParser.NDataDecl(lexer);
                                    if (match.hit)
                                    {
                                        *parentMatch5 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                    }
                                }
                                *parentMatch4 = match;
                            }
                            *parentMatch3 = match;
                        }
                        *parentMatch2 = match;
                    }
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EntityDef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EntityDef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PEDef(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PEDef");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.EntityValue(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.ExternalID(lexer);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PEDef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PEDef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EntityValue(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EntityValue");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        Match* parentMatch4 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(lexer.Pos() != lexer.End());
                                                for (const Range& range : s41)
                                                {
                                                    if (*lexer >= range.first && *lexer <= range.last)
                                                    {
                                                        match.hit = false;
                                                        break;
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    ++lexer;
                                                }
                                                *parentMatch7 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch8 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match = XmlParser.PEReference(lexer, processor);
                                                        *parentMatch8 = match;
                                                    }
                                                    *parentMatch7 = match;
                                                }
                                            }
                                            *parentMatch6 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match = XmlParser.Reference(lexer, processor);
                                                    *parentMatch9 = match;
                                                }
                                                *parentMatch6 = match;
                                            }
                                        }
                                        *parentMatch5 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch4 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch10 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch12 = &match;
                    {
                        Match match(false);
                        Match* parentMatch13 = &match;
                        {
                            Match match(false);
                            if (*lexer == 39)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch13 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch14 = &match;
                            {
                                Match match(true);
                                Match* parentMatch15 = &match;
                                {
                                    while (true)
                                    {
                                        long save = lexer.GetPos();
                                        {
                                            Match match(false);
                                            Match* parentMatch16 = &match;
                                            {
                                                Match match(false);
                                                Match* parentMatch17 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch18 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match(lexer.Pos() != lexer.End());
                                                        for (const Range& range : s42)
                                                        {
                                                            if (*lexer >= range.first && *lexer <= range.last)
                                                            {
                                                                match.hit = false;
                                                                break;
                                                            }
                                                        }
                                                        if (match.hit)
                                                        {
                                                            ++lexer;
                                                        }
                                                        *parentMatch18 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch19 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match = XmlParser.PEReference(lexer, processor);
                                                                *parentMatch19 = match;
                                                            }
                                                            *parentMatch18 = match;
                                                        }
                                                    }
                                                    *parentMatch17 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch20 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match = XmlParser.Reference(lexer, processor);
                                                            *parentMatch20 = match;
                                                        }
                                                        *parentMatch17 = match;
                                                    }
                                                }
                                                *parentMatch16 = match;
                                            }
                                            if (match.hit)
                                            {
                                                *parentMatch15 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                                break;
                                            }
                                        }
                                    }
                                }
                                *parentMatch14 = match;
                            }
                            *parentMatch13 = match;
                        }
                        *parentMatch12 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch21 = &match;
                        {
                            Match match(false);
                            if (*lexer == 39)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch21 = match;
                        }
                        *parentMatch12 = match;
                    }
                    *parentMatch11 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EntityValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EntityValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NDataDecl(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NDataDecl");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s43)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch4 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch5 = &match;
            {
                Match match = XmlParser.Name(lexer);
                name.Reset(cast<Value<ustring>*>(match.value));
                *parentMatch5 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NDataDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NDataDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PEReference(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PEReference");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                if (*lexer == 37)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.Name(lexer);
                    name.Reset(cast<Value<ustring>*>(match.value));
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                if (*lexer == 59)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PEReference");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PEReference");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match NotationDecl(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"NotationDecl");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                for (int i : s44)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.S(lexer);
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.Name(lexer);
                                name.Reset(cast<Value<ustring>*>(match.value));
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match = XmlParser.S(lexer);
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch9 = &match;
                    {
                        Match match(false);
                        Match* parentMatch10 = &match;
                        {
                            Match match(false);
                            Match* parentMatch11 = &match;
                            {
                                long save = lexer.GetPos();
                                Match match = XmlParser.ExternalID(lexer);
                                *parentMatch11 = match;
                                if (!match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    lexer.SetPos(save);
                                    {
                                        Match match = XmlParser.PublicID(lexer);
                                        *parentMatch12 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                            }
                            *parentMatch10 = match;
                        }
                        *parentMatch9 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch13 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch14 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch14 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch13 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch15 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch15 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"NotationDecl");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"NotationDecl");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PublicID(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PublicID");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                for (int i : s45)
                {
                    if (*lexer == i)
                    {
                        ++lexer;
                    }
                    else
                    {
                        match.hit = false;
                        break;
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match = XmlParser.PubidLiteral(lexer);
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PublicID");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PublicID");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Element(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Element");
            }
        #endif
        ustring tagName;
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == 60)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                long pos = lexer.GetPos();
                                Match match = XmlParser.Name(lexer);
                                name.Reset(cast<Value<ustring>*>(match.value));
                                if (match.hit)
                                {
                                    tagName = name->value;
                                    processor->BeginStartTag(tagName);
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        Match match(true);
                        Match* parentMatch7 = &match;
                        {
                            while (true)
                            {
                                long save = lexer.GetPos();
                                {
                                    Match match(false);
                                    Match* parentMatch8 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch9 = &match;
                                        {
                                            Match match = XmlParser.S(lexer);
                                            *parentMatch9 = match;
                                        }
                                        if (match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch10 = &match;
                                            {
                                                Match match = XmlParser.Attribute(lexer, processor);
                                                *parentMatch10 = match;
                                            }
                                            *parentMatch9 = match;
                                        }
                                        *parentMatch8 = match;
                                    }
                                    if (match.hit)
                                    {
                                        *parentMatch7 = match;
                                    }
                                    else
                                    {
                                        lexer.SetPos(save);
                                        break;
                                    }
                                }
                            }
                        }
                        *parentMatch6 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch11 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch12 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch12 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch11 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch13 = &match;
            {
                Match match(false);
                Match* parentMatch14 = &match;
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        long save = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch16 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match(true);
                            for (int i : s46)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            if (match.hit)
                            {
                                processor->EndStartTag(span, lexer.FileName());
                                processor->EndTag(tagName, span, lexer.FileName());
                            }
                            *parentMatch16 = match;
                        }
                        *parentMatch15 = match;
                        if (!match.hit)
                        {
                            Match match(false);
                            Match* parentMatch17 = &match;
                            lexer.SetPos(save);
                            {
                                Match match(false);
                                Match* parentMatch18 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch19 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch20 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(false);
                                            if (*lexer == 62)
                                            {
                                                ++lexer;
                                                match.hit = true;
                                            }
                                            if (match.hit)
                                            {
                                                processor->EndStartTag(span, lexer.FileName());
                                            }
                                            *parentMatch20 = match;
                                        }
                                        *parentMatch19 = match;
                                    }
                                    if (match.hit)
                                    {
                                        Match match(false);
                                        Match* parentMatch21 = &match;
                                        {
                                            Match match = XmlParser.Content(lexer, processor);
                                            *parentMatch21 = match;
                                        }
                                        *parentMatch19 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch22 = &match;
                                    {
                                        Match match = XmlParser.ETag(lexer, processor);
                                        *parentMatch22 = match;
                                    }
                                    *parentMatch18 = match;
                                }
                                *parentMatch17 = match;
                            }
                            *parentMatch15 = match;
                        }
                    }
                    *parentMatch14 = match;
                }
                *parentMatch13 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Element");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Element");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match ETag(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"ETag");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(true);
                    for (int i : s47)
                    {
                        if (*lexer == i)
                        {
                            ++lexer;
                        }
                        else
                        {
                            match.hit = false;
                            break;
                        }
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Span span = lexer.GetSpan();
                            Match match = XmlParser.Name(lexer);
                            name.Reset(cast<Value<ustring>*>(match.value));
                            if (match.hit)
                            {
                                processor->EndTag(name->value, span, lexer.FileName());
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch5 = &match;
                {
                    Match match(true);
                    long save = lexer.GetPos();
                    Match* parentMatch6 = &match;
                    {
                        Match match = XmlParser.S(lexer);
                        if (match.hit)
                        {
                            *parentMatch6 = match;
                        }
                        else
                        {
                            lexer.SetPos(save);
                        }
                    }
                    *parentMatch5 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch7 = &match;
            {
                Match match(false);
                if (*lexer == 62)
                {
                    ++lexer;
                    match.hit = true;
                }
                *parentMatch7 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"ETag");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"ETag");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Content(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Content");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(true);
            long save = lexer.GetPos();
            Match* parentMatch1 = &match;
            {
                Match match = XmlParser.CharData(lexer, processor);
                if (match.hit)
                {
                    *parentMatch1 = match;
                }
                else
                {
                    lexer.SetPos(save);
                }
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch2 = &match;
            {
                Match match(true);
                Match* parentMatch3 = &match;
                {
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch4 = &match;
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long save = lexer.GetPos();
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch9 = &match;
                                                {
                                                    long save = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch10 = &match;
                                                    {
                                                        long save = lexer.GetPos();
                                                        Match match = XmlParser.Element(lexer, processor);
                                                        *parentMatch10 = match;
                                                        if (!match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch11 = &match;
                                                            lexer.SetPos(save);
                                                            {
                                                                Match match = XmlParser.Reference(lexer, processor);
                                                                *parentMatch11 = match;
                                                            }
                                                            *parentMatch10 = match;
                                                        }
                                                    }
                                                    *parentMatch9 = match;
                                                    if (!match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch12 = &match;
                                                        lexer.SetPos(save);
                                                        {
                                                            Match match = XmlParser.CDSect(lexer, processor);
                                                            *parentMatch12 = match;
                                                        }
                                                        *parentMatch9 = match;
                                                    }
                                                }
                                                *parentMatch8 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match = XmlParser.PI(lexer, processor);
                                                        *parentMatch13 = match;
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                            }
                                            *parentMatch7 = match;
                                            if (!match.hit)
                                            {
                                                Match match(false);
                                                Match* parentMatch14 = &match;
                                                lexer.SetPos(save);
                                                {
                                                    Match match = XmlParser.Comment(lexer, processor);
                                                    *parentMatch14 = match;
                                                }
                                                *parentMatch7 = match;
                                            }
                                        }
                                        *parentMatch6 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch15 = &match;
                                    {
                                        Match match(true);
                                        long save = lexer.GetPos();
                                        Match* parentMatch16 = &match;
                                        {
                                            Match match = XmlParser.CharData(lexer, processor);
                                            if (match.hit)
                                            {
                                                *parentMatch16 = match;
                                            }
                                            else
                                            {
                                                lexer.SetPos(save);
                                            }
                                        }
                                        *parentMatch15 = match;
                                    }
                                    *parentMatch5 = match;
                                }
                                *parentMatch4 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch3 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch2 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Content");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Content");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CharDataChar(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CharDataChar");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(lexer.Pos() != lexer.End());
            for (const Range& range : s48)
            {
                if (*lexer >= range.first && *lexer <= range.last)
                {
                    match.hit = false;
                    break;
                }
            }
            if (match.hit)
            {
                ++lexer;
            }
            if (match.hit)
            {
                Token token = lexer.GetToken(pos);
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CharDataChar");
                    #endif
                    return Match(true, new Value<uchar>(cast<uchar>(token.id)));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CharDataChar");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CharDataChar");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CharData(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CharData");
            }
        #endif
        ustring s;
        UniquePtr<Value<uchar>> chr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                long save = lexer.GetPos();
                {
                    Match match(true);
                    Match* parentMatch3 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch4 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch5 = &match;
                                    {
                                        long pos = lexer.GetPos();
                                        Match match = XmlParser.CharDataChar(lexer);
                                        chr.Reset(cast<Value<uchar>*>(match.value));
                                        if (match.hit)
                                        {
                                            s.Append(chr->value);
                                        }
                                        *parentMatch5 = match;
                                    }
                                    *parentMatch4 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch3 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch6 = &match;
                    {
                        long tmp = lexer.GetPos();
                        lexer.SetPos(save);
                        save = tmp;
                        Match match(false);
                        Match* parentMatch7 = &match;
                        {
                            Match match(false);
                            Match* parentMatch8 = &match;
                            {
                                Match match(false);
                                Match* parentMatch9 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch10 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(lexer.Pos() != lexer.End());
                                                for (const Range& range : s49)
                                                {
                                                    if (*lexer >= range.first && *lexer <= range.last)
                                                    {
                                                        match.hit = false;
                                                        break;
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    ++lexer;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch10 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch9 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch11 = &match;
                                    {
                                        Match match(true);
                                        for (int i : s50)
                                        {
                                            if (*lexer == i)
                                            {
                                                ++lexer;
                                            }
                                            else
                                            {
                                                match.hit = false;
                                                break;
                                            }
                                        }
                                        *parentMatch11 = match;
                                    }
                                    *parentMatch9 = match;
                                }
                                *parentMatch8 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch12 = &match;
                                {
                                    Match match(true);
                                    Match* parentMatch13 = &match;
                                    {
                                        while (true)
                                        {
                                            long save = lexer.GetPos();
                                            {
                                                Match match(lexer.Pos() != lexer.End());
                                                for (const Range& range : s51)
                                                {
                                                    if (*lexer >= range.first && *lexer <= range.last)
                                                    {
                                                        match.hit = false;
                                                        break;
                                                    }
                                                }
                                                if (match.hit)
                                                {
                                                    ++lexer;
                                                }
                                                if (match.hit)
                                                {
                                                    *parentMatch13 = match;
                                                }
                                                else
                                                {
                                                    lexer.SetPos(save);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    *parentMatch12 = match;
                                }
                                *parentMatch8 = match;
                            }
                            *parentMatch7 = match;
                        }
                        *parentMatch6 = match;
                    }
                    if (!match.hit)
                    {
                        lexer.SetPos(save);
                    }
                    *parentMatch2 = Match(!match.hit, match.value);
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->Text(s);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CharData");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CharData");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CDSect(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CDSect");
            }
        #endif
        ustring s;
        UniquePtr<Value<uchar>> chr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s52)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            Match* parentMatch5 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch9 = &match;
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match = XmlParser.Char(lexer);
                                                        chr.Reset(cast<Value<uchar>*>(match.value));
                                                        *parentMatch9 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch10 = &match;
                                                        {
                                                            long tmp = lexer.GetPos();
                                                            lexer.SetPos(save);
                                                            save = tmp;
                                                            Match match(true);
                                                            for (int i : s53)
                                                            {
                                                                if (*lexer == i)
                                                                {
                                                                    ++lexer;
                                                                }
                                                                else
                                                                {
                                                                    match.hit = false;
                                                                    break;
                                                                }
                                                            }
                                                            *parentMatch10 = match;
                                                        }
                                                        if (!match.hit)
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                        *parentMatch9 = Match(!match.hit, match.value);
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    s.Append(chr->value);
                                                }
                                                *parentMatch7 = match;
                                            }
                                            *parentMatch6 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch5 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch11 = &match;
                    {
                        Match match(true);
                        for (int i : s54)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch11 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->CDataSection(s);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CDSect");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CDSect");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Attribute(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Attribute");
            }
        #endif
        UniquePtr<Value<ustring>> attName;
        UniquePtr<Value<ustring>> attValue;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match = XmlParser.Name(lexer);
                attName.Reset(cast<Value<ustring>*>(match.value));
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.Eq(lexer);
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                Match* parentMatch4 = &match;
                {
                    long pos = lexer.GetPos();
                    Span span = lexer.GetSpan();
                    Match match = XmlParser.AttValue(lexer, processor);
                    attValue.Reset(cast<Value<ustring>*>(match.value));
                    if (match.hit)
                    {
                        processor->AddAttribute(attName->value, attValue->value, span, lexer.FileName());
                    }
                    *parentMatch4 = match;
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Attribute");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Attribute");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttValueDQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttValueDQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        processor->BeginAttributeValue();
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(lexer.Pos() != lexer.End());
                                            for (const Range& range : s55)
                                            {
                                                if (*lexer >= range.first && *lexer <= range.last)
                                                {
                                                    match.hit = false;
                                                    break;
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                ++lexer;
                                            }
                                            if (match.hit)
                                            {
                                                processor->AttValue().Append(lexer.GetMatch(span));
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match = XmlParser.Reference(lexer, processor);
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch6 = match;
                                        }
                                    }
                                    *parentMatch5 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch4 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == 34)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        ustring value = processor->AttValue();
                        processor->EndAttributeValue();
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValueDQ");
                            #endif
                            return Match(true, new Value<ustring>(value));
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValueDQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttValueDQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttValueSQ(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttValueSQ");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == 39)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        processor->BeginAttributeValue();
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(true);
                    Match* parentMatch4 = &match;
                    {
                        while (true)
                        {
                            long save = lexer.GetPos();
                            {
                                Match match(false);
                                Match* parentMatch5 = &match;
                                {
                                    Match match(false);
                                    Match* parentMatch6 = &match;
                                    {
                                        long save = lexer.GetPos();
                                        Match match(false);
                                        Match* parentMatch7 = &match;
                                        {
                                            long pos = lexer.GetPos();
                                            Span span = lexer.GetSpan();
                                            Match match(lexer.Pos() != lexer.End());
                                            for (const Range& range : s56)
                                            {
                                                if (*lexer >= range.first && *lexer <= range.last)
                                                {
                                                    match.hit = false;
                                                    break;
                                                }
                                            }
                                            if (match.hit)
                                            {
                                                ++lexer;
                                            }
                                            if (match.hit)
                                            {
                                                processor->AttValue().Append(lexer.GetMatch(span));
                                            }
                                            *parentMatch7 = match;
                                        }
                                        *parentMatch6 = match;
                                        if (!match.hit)
                                        {
                                            Match match(false);
                                            Match* parentMatch8 = &match;
                                            lexer.SetPos(save);
                                            {
                                                Match match = XmlParser.Reference(lexer, processor);
                                                *parentMatch8 = match;
                                            }
                                            *parentMatch6 = match;
                                        }
                                    }
                                    *parentMatch5 = match;
                                }
                                if (match.hit)
                                {
                                    *parentMatch4 = match;
                                }
                                else
                                {
                                    lexer.SetPos(save);
                                    break;
                                }
                            }
                        }
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch9 = &match;
            {
                Match match(false);
                Match* parentMatch10 = &match;
                {
                    long pos = lexer.GetPos();
                    Match match(false);
                    if (*lexer == 39)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    if (match.hit)
                    {
                        ustring value = processor->AttValue();
                        processor->EndAttributeValue();
                        {
                            #if (DEBUG)
                                if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValueSQ");
                            #endif
                            return Match(true, new Value<ustring>(value));
                        }
                    }
                    *parentMatch10 = match;
                }
                *parentMatch9 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValueSQ");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttValueSQ");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match AttValue(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"AttValue");
            }
        #endif
        UniquePtr<Value<ustring>> attValueDQ;
        UniquePtr<Value<ustring>> attValueSQ;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match = XmlParser.AttValueDQ(lexer, processor);
                attValueDQ.Reset(cast<Value<ustring>*>(match.value));
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValue");
                        #endif
                        return Match(true, new Value<ustring>(attValueDQ->value));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match = XmlParser.AttValueSQ(lexer, processor);
                        attValueSQ.Reset(cast<Value<ustring>*>(match.value));
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValue");
                                #endif
                                return Match(true, new Value<ustring>(attValueSQ->value));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"AttValue");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"AttValue");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match EntityRef(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"EntityRef");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Span span = lexer.GetSpan();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        if (*lexer == 38)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match = XmlParser.Name(lexer);
                            name.Reset(cast<Value<ustring>*>(match.value));
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch5 = &match;
                    {
                        Match match(false);
                        if (*lexer == 59)
                        {
                            ++lexer;
                            match.hit = true;
                        }
                        *parentMatch5 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->EntityRef(name->value, span, lexer.FileName());
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"EntityRef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"EntityRef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match DecCodePoint(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"DecCodePoint");
            }
        #endif
        uint val;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            for (const Range& range : s57)
                            {
                                if (*lexer >= range.first && *lexer <= range.last)
                                {
                                    match.hit = true;
                                    ++lexer;
                                    break;
                                }
                            }
                            if (match.hit)
                            {
                                Token token = lexer.GetToken(pos);
                                val = 10u * val + cast<uint>(token.id) - cast<uint>('0');
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch5 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    for (const Range& range : s57)
                                    {
                                        if (*lexer >= range.first && *lexer <= range.last)
                                        {
                                            match.hit = true;
                                            ++lexer;
                                            break;
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        Token token = lexer.GetToken(pos);
                                        val = 10u * val + cast<uint>(token.id) - cast<uint>('0');
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DecCodePoint");
                    #endif
                    return Match(true, new Value<uint>(val));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"DecCodePoint");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"DecCodePoint");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match HexCodePoint(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"HexCodePoint");
            }
        #endif
        uint val;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            long pos = lexer.GetPos();
                            Match match(false);
                            for (const Range& range : s58)
                            {
                                if (*lexer >= range.first && *lexer <= range.last)
                                {
                                    match.hit = true;
                                    ++lexer;
                                    break;
                                }
                            }
                            if (match.hit)
                            {
                                Token token = lexer.GetToken(pos);
                                if (token.id >= cast<int>('0') && token.id <= cast<int>('9')) val = 16u * val + cast<uint>(token.id) - cast<uint>('0');
                                else if (token.id >= cast<int>('a') && token.id <= cast<int>('f')) val = 16u * val + 10u + cast<uint>(token.id) - cast<uint>('a');
                                else if (token.id >= cast<int>('A') && token.id <= cast<int>('F')) val = 16u * val + 10u + cast<uint>(token.id) - cast<uint>('A');
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(true);
                    Match* parentMatch5 = &match;
                    while (true)
                    {
                        long save = lexer.GetPos();
                        {
                            Match match(false);
                            Match* parentMatch6 = &match;
                            {
                                Match match(false);
                                Match* parentMatch7 = &match;
                                {
                                    long pos = lexer.GetPos();
                                    Match match(false);
                                    for (const Range& range : s58)
                                    {
                                        if (*lexer >= range.first && *lexer <= range.last)
                                        {
                                            match.hit = true;
                                            ++lexer;
                                            break;
                                        }
                                    }
                                    if (match.hit)
                                    {
                                        Token token = lexer.GetToken(pos);
                                        if (token.id >= cast<int>('0') && token.id <= cast<int>('9')) val = 16u * val + cast<uint>(token.id) - cast<uint>('0');
                                        else if (token.id >= cast<int>('a') && token.id <= cast<int>('f')) val = 16u * val + 10u + cast<uint>(token.id) - cast<uint>('a');
                                        else if (token.id >= cast<int>('A') && token.id <= cast<int>('F')) val = 16u * val + 10u + cast<uint>(token.id) - cast<uint>('A');
                                    }
                                    *parentMatch7 = match;
                                }
                                *parentMatch6 = match;
                            }
                            if (match.hit)
                            {
                                *parentMatch5 = match;
                            }
                            else
                            {
                                lexer.SetPos(save);
                                break;
                            }
                        }
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"HexCodePoint");
                    #endif
                    return Match(true, new Value<uint>(val));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"HexCodePoint");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"HexCodePoint");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match CharRef(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"CharRef");
            }
        #endif
        UniquePtr<Value<uint>> decCodePoint;
        UniquePtr<Value<uint>> hexCodePoint;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            for (int i : s59)
                            {
                                if (*lexer == i)
                                {
                                    ++lexer;
                                }
                                else
                                {
                                    match.hit = false;
                                    break;
                                }
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match = XmlParser.DecCodePoint(lexer);
                                decCodePoint.Reset(cast<Value<uint>*>(match.value));
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch6 = &match;
                        {
                            Match match(false);
                            if (*lexer == 59)
                            {
                                ++lexer;
                                match.hit = true;
                            }
                            *parentMatch6 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    processor->Text(ustring(cast<uchar>(decCodePoint->value)));
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch7 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch8 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(false);
                        Match* parentMatch9 = &match;
                        {
                            Match match(false);
                            Match* parentMatch10 = &match;
                            {
                                Match match(false);
                                Match* parentMatch11 = &match;
                                {
                                    Match match(true);
                                    for (int i : s60)
                                    {
                                        if (*lexer == i)
                                        {
                                            ++lexer;
                                        }
                                        else
                                        {
                                            match.hit = false;
                                            break;
                                        }
                                    }
                                    *parentMatch11 = match;
                                }
                                if (match.hit)
                                {
                                    Match match(false);
                                    Match* parentMatch12 = &match;
                                    {
                                        Match match = XmlParser.HexCodePoint(lexer);
                                        hexCodePoint.Reset(cast<Value<uint>*>(match.value));
                                        *parentMatch12 = match;
                                    }
                                    *parentMatch11 = match;
                                }
                                *parentMatch10 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch13 = &match;
                                {
                                    Match match(false);
                                    if (*lexer == 59)
                                    {
                                        ++lexer;
                                        match.hit = true;
                                    }
                                    *parentMatch13 = match;
                                }
                                *parentMatch10 = match;
                            }
                            *parentMatch9 = match;
                        }
                        if (match.hit)
                        {
                            processor->Text(ustring(cast<uchar>(hexCodePoint->value)));
                        }
                        *parentMatch8 = match;
                    }
                    *parentMatch7 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"CharRef");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"CharRef");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Reference(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Reference");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match = XmlParser.EntityRef(lexer, processor);
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch1 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.CharRef(lexer, processor);
                    *parentMatch1 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Reference");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Reference");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Misc(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Misc");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long save = lexer.GetPos();
                Match match = XmlParser.Comment(lexer, processor);
                *parentMatch1 = match;
                if (!match.hit)
                {
                    Match match(false);
                    Match* parentMatch2 = &match;
                    lexer.SetPos(save);
                    {
                        Match match = XmlParser.PI(lexer, processor);
                        *parentMatch2 = match;
                    }
                    *parentMatch1 = match;
                }
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                lexer.SetPos(save);
                {
                    Match match = XmlParser.S(lexer);
                    *parentMatch3 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Misc");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Misc");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Comment(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Comment");
            }
        #endif
        ustring s;
        UniquePtr<Value<uchar>> chr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(true);
                        for (int i : s61)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(true);
                            Match* parentMatch5 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch6 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch7 = &match;
                                            {
                                                long save = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch8 = &match;
                                                {
                                                    long pos = lexer.GetPos();
                                                    Match match(false);
                                                    Match* parentMatch9 = &match;
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch10 = &match;
                                                        long save = lexer.GetPos();
                                                        {
                                                            Match match = XmlParser.Char(lexer);
                                                            chr.Reset(cast<Value<uchar>*>(match.value));
                                                            *parentMatch10 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch11 = &match;
                                                            {
                                                                long tmp = lexer.GetPos();
                                                                lexer.SetPos(save);
                                                                save = tmp;
                                                                Match match(false);
                                                                if (*lexer == 45)
                                                                {
                                                                    ++lexer;
                                                                    match.hit = true;
                                                                }
                                                                *parentMatch11 = match;
                                                            }
                                                            if (!match.hit)
                                                            {
                                                                lexer.SetPos(save);
                                                            }
                                                            *parentMatch10 = Match(!match.hit, match.value);
                                                        }
                                                        *parentMatch9 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        s.Append(chr->value);
                                                    }
                                                    *parentMatch8 = match;
                                                }
                                                *parentMatch7 = match;
                                                if (!match.hit)
                                                {
                                                    Match match(false);
                                                    Match* parentMatch12 = &match;
                                                    lexer.SetPos(save);
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch13 = &match;
                                                        {
                                                            Match match(false);
                                                            if (*lexer == 45)
                                                            {
                                                                ++lexer;
                                                                match.hit = true;
                                                            }
                                                            *parentMatch13 = match;
                                                        }
                                                        if (match.hit)
                                                        {
                                                            Match match(false);
                                                            Match* parentMatch14 = &match;
                                                            {
                                                                Match match(false);
                                                                Match* parentMatch15 = &match;
                                                                {
                                                                    long pos = lexer.GetPos();
                                                                    Match match(false);
                                                                    Match* parentMatch16 = &match;
                                                                    {
                                                                        Match match(false);
                                                                        Match* parentMatch17 = &match;
                                                                        long save = lexer.GetPos();
                                                                        {
                                                                            Match match = XmlParser.Char(lexer);
                                                                            chr.Reset(cast<Value<uchar>*>(match.value));
                                                                            *parentMatch17 = match;
                                                                        }
                                                                        if (match.hit)
                                                                        {
                                                                            Match match(false);
                                                                            Match* parentMatch18 = &match;
                                                                            {
                                                                                long tmp = lexer.GetPos();
                                                                                lexer.SetPos(save);
                                                                                save = tmp;
                                                                                Match match(false);
                                                                                if (*lexer == 45)
                                                                                {
                                                                                    ++lexer;
                                                                                    match.hit = true;
                                                                                }
                                                                                *parentMatch18 = match;
                                                                            }
                                                                            if (!match.hit)
                                                                            {
                                                                                lexer.SetPos(save);
                                                                            }
                                                                            *parentMatch17 = Match(!match.hit, match.value);
                                                                        }
                                                                        *parentMatch16 = match;
                                                                    }
                                                                    if (match.hit)
                                                                    {
                                                                        s.Append('-').Append(chr->value);
                                                                    }
                                                                    *parentMatch15 = match;
                                                                }
                                                                *parentMatch14 = match;
                                                            }
                                                            *parentMatch13 = match;
                                                        }
                                                        *parentMatch12 = match;
                                                    }
                                                    *parentMatch7 = match;
                                                }
                                            }
                                            *parentMatch6 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch5 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch19 = &match;
                    {
                        Match match(true);
                        for (int i : s62)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch19 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->Comment(s);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Comment");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Comment");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PI(TrivialLexer& lexer, System.Xml.XmlProcessor* processor)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PI");
            }
        #endif
        ustring data;
        UniquePtr<Value<ustring>> target;
        UniquePtr<Value<uchar>> chr;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        Match match(false);
                        Match* parentMatch4 = &match;
                        {
                            Match match(false);
                            Match* parentMatch5 = &match;
                            {
                                Match match(true);
                                for (int i : s63)
                                {
                                    if (*lexer == i)
                                    {
                                        ++lexer;
                                    }
                                    else
                                    {
                                        match.hit = false;
                                        break;
                                    }
                                }
                                *parentMatch5 = match;
                            }
                            if (match.hit)
                            {
                                Match match(false);
                                Match* parentMatch6 = &match;
                                {
                                    Match match = XmlParser.PITarget(lexer);
                                    target.Reset(cast<Value<ustring>*>(match.value));
                                    *parentMatch6 = match;
                                }
                                *parentMatch5 = match;
                            }
                            *parentMatch4 = match;
                        }
                        if (match.hit)
                        {
                            Match match(false);
                            Match* parentMatch7 = &match;
                            {
                                Match match = XmlParser.S(lexer);
                                *parentMatch7 = match;
                            }
                            *parentMatch4 = match;
                        }
                        *parentMatch3 = match;
                    }
                    if (match.hit)
                    {
                        Match match(false);
                        Match* parentMatch8 = &match;
                        {
                            Match match(true);
                            Match* parentMatch9 = &match;
                            {
                                while (true)
                                {
                                    long save = lexer.GetPos();
                                    {
                                        Match match(false);
                                        Match* parentMatch10 = &match;
                                        {
                                            Match match(false);
                                            Match* parentMatch11 = &match;
                                            {
                                                long pos = lexer.GetPos();
                                                Match match(false);
                                                Match* parentMatch12 = &match;
                                                {
                                                    Match match(false);
                                                    Match* parentMatch13 = &match;
                                                    long save = lexer.GetPos();
                                                    {
                                                        Match match = XmlParser.Char(lexer);
                                                        chr.Reset(cast<Value<uchar>*>(match.value));
                                                        *parentMatch13 = match;
                                                    }
                                                    if (match.hit)
                                                    {
                                                        Match match(false);
                                                        Match* parentMatch14 = &match;
                                                        {
                                                            long tmp = lexer.GetPos();
                                                            lexer.SetPos(save);
                                                            save = tmp;
                                                            Match match(true);
                                                            for (int i : s64)
                                                            {
                                                                if (*lexer == i)
                                                                {
                                                                    ++lexer;
                                                                }
                                                                else
                                                                {
                                                                    match.hit = false;
                                                                    break;
                                                                }
                                                            }
                                                            *parentMatch14 = match;
                                                        }
                                                        if (!match.hit)
                                                        {
                                                            lexer.SetPos(save);
                                                        }
                                                        *parentMatch13 = Match(!match.hit, match.value);
                                                    }
                                                    *parentMatch12 = match;
                                                }
                                                if (match.hit)
                                                {
                                                    data.Append(chr->value);
                                                }
                                                *parentMatch11 = match;
                                            }
                                            *parentMatch10 = match;
                                        }
                                        if (match.hit)
                                        {
                                            *parentMatch9 = match;
                                        }
                                        else
                                        {
                                            lexer.SetPos(save);
                                            break;
                                        }
                                    }
                                }
                            }
                            *parentMatch8 = match;
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch15 = &match;
                    {
                        Match match(true);
                        for (int i : s65)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        *parentMatch15 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                processor->PI(target->value, data);
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PI");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PI");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match PITarget(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"PITarget");
            }
        #endif
        UniquePtr<Value<ustring>> name;
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long pos = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                Match* parentMatch2 = &match;
                long save = lexer.GetPos();
                {
                    Match match = XmlParser.Name(lexer);
                    name.Reset(cast<Value<ustring>*>(match.value));
                    *parentMatch2 = match;
                }
                if (match.hit)
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long tmp = lexer.GetPos();
                        lexer.SetPos(save);
                        save = tmp;
                        Match match = XmlParser.Xml(lexer);
                        *parentMatch3 = match;
                    }
                    if (!match.hit)
                    {
                        lexer.SetPos(save);
                    }
                    *parentMatch2 = Match(!match.hit, match.value);
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                {
                    #if (DEBUG)
                        if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PITarget");
                    #endif
                    return Match(true, new Value<ustring>(name->value));
                }
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"PITarget");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"PITarget");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Xml(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Xml");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(false);
                for (const Range& range : s66)
                {
                    if (*lexer >= range.first && *lexer <= range.last)
                    {
                        match.hit = true;
                        ++lexer;
                        break;
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                {
                    Match match(false);
                    for (const Range& range : s67)
                    {
                        if (*lexer >= range.first && *lexer <= range.last)
                        {
                            match.hit = true;
                            ++lexer;
                            break;
                        }
                    }
                    *parentMatch2 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch3 = &match;
            {
                Match match(false);
                for (const Range& range : s68)
                {
                    if (*lexer >= range.first && *lexer <= range.last)
                    {
                        match.hit = true;
                        ++lexer;
                        break;
                    }
                }
                *parentMatch3 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Xml");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Xml");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match Eq(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"Eq");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            Match match(false);
            Match* parentMatch1 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch2 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    if (match.hit)
                    {
                        *parentMatch2 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch1 = match;
            }
            if (match.hit)
            {
                Match match(false);
                Match* parentMatch3 = &match;
                {
                    Match match(false);
                    if (*lexer == 61)
                    {
                        ++lexer;
                        match.hit = true;
                    }
                    *parentMatch3 = match;
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
        }
        if (match.hit)
        {
            Match match(false);
            Match* parentMatch4 = &match;
            {
                Match match(true);
                long save = lexer.GetPos();
                Match* parentMatch5 = &match;
                {
                    Match match = XmlParser.S(lexer);
                    if (match.hit)
                    {
                        *parentMatch5 = match;
                    }
                    else
                    {
                        lexer.SetPos(save);
                    }
                }
                *parentMatch4 = match;
            }
            *parentMatch0 = match;
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"Eq");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"Eq");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
    public static Match YesNo(TrivialLexer& lexer)
    {
        #if (DEBUG)
            Span debugSpan;
            bool writeToLog = lexer.Log() != null;
            if (writeToLog)
            {
                debugSpan = lexer.GetSpan();
                System.Lex.WriteBeginRuleToLog(lexer, u"YesNo");
            }
        #endif
        Match match(false);
        Match* parentMatch0 = &match;
        {
            long save = lexer.GetPos();
            Match match(false);
            Match* parentMatch1 = &match;
            {
                long pos = lexer.GetPos();
                Match match(true);
                for (int i : s69)
                {
                    if (*lexer == i)
                    {
                        ++lexer;
                    }
                    else
                    {
                        match.hit = false;
                        break;
                    }
                }
                if (match.hit)
                {
                    {
                        #if (DEBUG)
                            if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"YesNo");
                        #endif
                        return Match(true, new Value<bool>(true));
                    }
                }
                *parentMatch1 = match;
            }
            *parentMatch0 = match;
            if (!match.hit)
            {
                Match match(false);
                Match* parentMatch2 = &match;
                lexer.SetPos(save);
                {
                    Match match(false);
                    Match* parentMatch3 = &match;
                    {
                        long pos = lexer.GetPos();
                        Match match(true);
                        for (int i : s70)
                        {
                            if (*lexer == i)
                            {
                                ++lexer;
                            }
                            else
                            {
                                match.hit = false;
                                break;
                            }
                        }
                        if (match.hit)
                        {
                            {
                                #if (DEBUG)
                                    if (writeToLog) System.Lex.WriteSuccessToLog(lexer, debugSpan, u"YesNo");
                                #endif
                                return Match(true, new Value<bool>(false));
                            }
                        }
                        *parentMatch3 = match;
                    }
                    *parentMatch2 = match;
                }
                *parentMatch0 = match;
            }
        }
        #if (DEBUG)
            if (writeToLog)
            {
                if (match.hit)
                {
                    System.Lex.WriteSuccessToLog(lexer, debugSpan, u"YesNo");
                }
                else
                {
                    System.Lex.WriteFailureToLog(lexer, u"YesNo");
                }
            }
        #endif
        if (!match.hit)
        {
            match.value = null;
        }
        return match;
    }
}

// =================================
// Copyright (c) 2019 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Threading;

namespace System.Unicode
{
    public class UnicodeException : Exception
    {
        public nothrow UnicodeException(const string& message_) : base(message_)
        {
        }
    }
    
    public void ThrowUnicodeException(const string& message)
    {
        throw UnicodeException(message);
    }
    
    public string PathToUnicodeDirectory()
    {
        string cmajorRoot = RtGetEnvironmentVariable("CMAJOR_ROOT");
        if (cmajorRoot.IsEmpty())
        {
            ThrowUnicodeException("CMAJOR_ROOT environment variable not set (set it to /path/to/cmajor directory)");
            return string();
        }
        return Path.Combine(cmajorRoot, "unicode");
    }
    
    public string PathToUcdBinFile()
    {        
        return Path.Combine(PathToUnicodeDirectory(), "cmajor_ucd.bin");
    }
    
    public string MakeCanonicalPropertyName(const string& s)
    {
        string result;
        for (char c : s)
        {
            if (c != '_' && c != ' ' && c != '-')
            {
                result.Append(c);
            }
        }
        return ToLower(result);
    }
    
    public enum BinaryPropertyId : byte
    {
        asciiHexDigit,
        alphabetic,
        bidiControl,
        bidiMirrored,
        cased,
        compositionExclusion,
        caseIgnorable,
        fullCompositionExclusion,
        changesWhenCasefolded,
        changesWhenCaseMapped,
        changesWhenNFKCCasefolded,
        changesWhenLowercased,
        changesWhenTitlecased,
        changesWhenUppercased,
        dash,
        deprecated,
        defaultIgnorableCodePoint,
        diacritic,
        extender,
        graphemeBase,
        graphemeExtend,
        graphemeLink,
        hexDigit,
        hyphen,
        idContinue,
        ideographic,
        idStart,
        idsBinaryOperator,
        idsTrinaryOperator,
        joinControl,
        logicalOrderException,
        lowercase,
        math,
        noncharacterCodePoint,
        otherAlphabetic,
        otherDefaultIgnorableCodePoint,
        otherGraphemeExtend,
        otherIdContinue,
        otherIdStart,
        otherLowercase,
        otherMath,
        otherUppercase,
        patternSyntax,
        patternWhiteSpace,
        prependedConcatenationMark,
        quotationMark,
        radical,
        softDotted,
        sentenceterminal,
        terminalPunctuation,
        unifiedIdeograph,
        uppercase,
        variationSelector,
        whiteSpace,
        xidContinue,
        xidStart,
        expandsOnNFC,
        expandsOnNFD,
        expandsOnNFKC,
        expandsOnNFKD
    }
    
    public class BinaryProperty
    {
        public nothrow BinaryProperty(BinaryPropertyId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow BinaryPropertyId Id()
        {
            return id;
        }
        public inline nothrow const string& ShortName()
        {
            return shortName;
        }
        public inline nothrow const string& LongName()
        {
            return longName;
        }
        private BinaryPropertyId id;
        private string shortName;
        private string longName;
    }
    
    public class BinaryPropertyTable
    {
        static BinaryPropertyTable() : instance(new BinaryPropertyTable())
        {
        }
        public static nothrow BinaryPropertyTable& Instance()
        {
            return *instance;
        }
        public nothrow const BinaryProperty* GetBinaryProperty(BinaryPropertyId id) const
        {
            HashMap<uint, void*>.ConstIterator it = binaryPropertyIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != binaryPropertyIdMap.CEnd())
            {
                return cast<BinaryProperty*>(it->second);
            }
            return null;
        }
        public const BinaryProperty* GetBinaryPropertyByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<BinaryProperty*>(it->second);
            }
            return null;
        }
        public const BinaryProperty* GetBinaryPropertyByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<BinaryProperty*>(it->second);
            }
            return null;
        }
        private BinaryPropertyTable() : binaryProperties(), binaryPropertyIdMap(), shortNameMap(), longNameMap()
        {
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.asciiHexDigit, "AHex", "Ascii Hex Digit"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.alphabetic, "Alpha", "Alphabetic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.bidiControl, "Bidi C", "Bidi Control"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.bidiMirrored, "Bidi M", "Bidi Mirrored"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.cased, "Cased", "Cased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.compositionExclusion, "CE", "Composition Exclusion"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.caseIgnorable, "CI", "Case Ignorable"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.fullCompositionExclusion, "Comp Ex", "Full Composition Exclusion"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenCasefolded, "CWCF", "Changes When Casefolded"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenCaseMapped, "CWCM", "Changes When Casemapped"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenNFKCCasefolded, "CWKCF", "Changes When NFKC Casefolded"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenLowercased, "CWL", "Changes When Lowercased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenTitlecased, "CWT", "Changes When Titlecased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.changesWhenUppercased, "CWU", "Changes When Uppercased"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.dash, "Dash", "Dash"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.deprecated, "Dep", "Deprecated"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.defaultIgnorableCodePoint, "DI", "Default Ignorable Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.diacritic, "Dia", "Diacritic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.extender, "Ext", "Extender"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeBase, "Gr Base", "Grapheme Base"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeExtend, "Gr Ext", "Grapheme Extend"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.graphemeLink, "Gr Link", "Grapheme Link"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.hexDigit, "Hex", "Hex Digit"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.hyphen, "Hyphen", "Hyphen"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idContinue, "IDC", "ID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.ideographic, "Ideo", "Ideographic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idStart, "IDS", "ID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idsBinaryOperator, "IDSB", "IDS Binary Operator"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.idsTrinaryOperator, "IDST", "IDS Trinary Operator"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.joinControl, "Join C", "Join Control"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.logicalOrderException, "LOE", "Logical Order Exception"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.lowercase, "Lower", "Lowercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.math, "Math", "Math"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.noncharacterCodePoint, "NChar", "Noncharacter Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherAlphabetic, "OAlpha", "Other Alphabetic"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherDefaultIgnorableCodePoint, "ODI", "Other Default Ignorable Code Point"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherGraphemeExtend, "OGr Ext", "Other Grapheme Extend"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherIdContinue, "OIDC", "Other ID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherIdStart, "OIDS", "Other ID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherLowercase, "OLower", "Other Lowercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherMath, "OMath", "Other Math"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.otherUppercase, "OUpper", "Other Uppercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.patternSyntax, "Pat Syn", "Pattern Syntax"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.patternWhiteSpace, "Pat WS", "Pattern White Space"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.prependedConcatenationMark, "PCM", "Prepended Concatenation Mark"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.quotationMark, "QMark", "Quotation Mark"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.radical, "Radical", "Radical"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.softDotted, "SD", "Soft Dotted"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.sentenceterminal, "STerm", "Sentence Terminal"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.terminalPunctuation, "Term", "Terminal Punctuation"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.unifiedIdeograph, "UIdeo", "Unified Ideograph"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.uppercase, "Upper", "Uppercase"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.variationSelector, "VS", "Variation Selector"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.whiteSpace, "WSpace", "White Space"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.xidContinue, "XIDC", "XID Continue"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.xidStart, "XIDS", "XID Start"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFC, "XO NFC", "Expands On NFC"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFD, "XO NFD", "Expands On NFD"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFKC, "XO NFKC", "Expands On NFKC"));
            binaryProperties.Add(new BinaryProperty(BinaryPropertyId.expandsOnNFKD, "XO NFKD", "Expands On NFKD"));
            for (BinaryProperty* binaryProperty : binaryProperties)
            {
                binaryPropertyIdMap[cast<uint>(cast<byte>(binaryProperty->Id()))] = binaryProperty;
                shortNameMap[MakeCanonicalPropertyName(binaryProperty->ShortName())] = binaryProperty;
                longNameMap[MakeCanonicalPropertyName(binaryProperty->LongName())] = binaryProperty;
            }
        }
        public ~BinaryPropertyTable()
        {
            for (BinaryProperty* binaryProperty : binaryProperties)
            {
                delete binaryProperty;
            }
        }
        private List<BinaryProperty*> binaryProperties;
        private HashMap<uint, void*> binaryPropertyIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
        private static UniquePtr<BinaryPropertyTable> instance;
    }    
    
    public nothrow const BinaryProperty* GetBinaryProperty(BinaryPropertyId id)
    {
        return BinaryPropertyTable.Instance().GetBinaryProperty(id);
    }

    public const BinaryProperty* GetBinaryPropertyByShortName(string shortName)
    {
        return BinaryPropertyTable.Instance().GetBinaryPropertyByShortName(shortName);
    }

    public const BinaryProperty* GetBinaryPropertyByLongName(string longName)
    {
        return BinaryPropertyTable.Instance().GetBinaryPropertyByLongName(longName);
    }
    
    public enum BlockId : ushort
    {
        none = 0u,
        adlam, aegeanNumbers, ahom, alchemical, alphabeticPf, anatolianHieroglyphs, ancientGreekMusic, ancientGreekNumbers, ancientSymbols,
        arabic, arabicExtA, arabicMath, arabicPfA, arabicPfB, arabicSup, armenian, arrows, ascii, avestan,
        balinese, bamum, bamumSup, bassaVah, batak, bengali, bhaisuki, blockElements, bopomofo, bopomofoExt, boxDrawing,
        brahmi, braille, buginese, buhid, byzantineMusic,
        carian, caucasianAlbanian, chakma, cham, cherokee, cherokeeSup, chessSymbols,
        cjk, cjkCompat, cjkCompatForms, cjkCompatIdeographs, cjkCompatIdeographsSup, cjkExtA, cjkExtB, cjkExtC, cjkExtD, cjkExtE, cjkExtF,
        cjkRadicalsSup, cjkStrokes, cjkSymbols, compatJamo, controlPictures, coptic, copticEpactNumbers, countingRod, cuneiform,
        cuneiformNumbers, currencySymbols, cypriotSyllabary, cyrillic, cyrillicExtA, cyrillicExtB, cyrillicExtC, cyrillicSup,
        deseret, devanagari, devanagariExt, diacriticals, diariticalsForSymbols, diacriticalsSup, diacriticalsExt, dingbats, dogra, domino, duployan,
        earlyDynasticCuneiform, egyptianHieroglyphs, elbasan, emoticons, enclosedAlphanum, enclosedAlphanumSup, enclosedCjk, enclosedIdeographicSup,
        ethiopic, ethiopicExt, ethiopicExtA, ethiopicSup,
        geometricShapes, geometricShapesExt, georgian, georgianExt, georgianSup, glagolitic, glagoliticSup, gothic, grantha, greek, greekExt, gujarati, gunjalaGondi, gurmukhi,
        halfAndFullForms, halfMarks, hangul, hanifiRohingya, hanunoo, hatran, hebrew, highPuSurrogates, highSurrogates, hiragana,
        idc, ideographicSymbols, imperialAramaic, indicNumberForms, inscriptionalPahlavi, inscriptionalParthian, ipaExt, indicSiyaqNumbers,
        jamo, jamoExtA, jamoExtB, javanese, kaithi, kanaExtA, kanaSup, kanbun, kangxi, kannada, katakana, katakanaExt, kayahLi, kharoshthi, khmer, khmerSymbols, khojki, khudawadi,
        lao, latin1Sup, latinExtA, latinExtAdditional, latinExtB, latinExtC, latinExtD, latinExtE, lepcha, letterlikeSymbols, limbu,
        linearA, linearBIdeograms, linearBSyllabary, lisu, lowSurrogates, lycian, lydian,
        mahajani, mahjong, makasar, malayalam, mandaic, manichean, marchen, masaramGondi, mathAlphanum, mathOperators, mayanNumerals, medefaidrin, meeteiMayek, meeteiMayekExt, mendeKikakui, meroiticCursive, meroiticHieroglyphs,
        miao, miscArrows, miscMathSymbolsA, miscMathSymbolsB, miscPictographs, miscSymbols, miscTechnical, modi, modifierLetters, modifierToneLetters, mongolian, mongolianSup,
        mro, music, multani, myanmar, myanmarExtA, myanmarExtB,
        nabataean, nb, newTaiLue, newa, nko, numberForms, nushu,
        ocr, ogham, olChiki, oldHungarian, oldItalic, oldNorthArabian, oldPermic, oldPersian, oldSogdian, oldSouthArabian, oldTurkic, oriya, ornamentalDingbats, osage, osmanya,
        pahawhHmong, palmyrene, pauCinHau, phagsPa, phaistos, phoenician, phoneticExt, phoneticExtSup, playingCards, psalterPahlavi, pua, punctuation,
        rejang, rumi, runic,
        samaritan, saurashtra, sharada, shavian, shorthandFormatControls, siddham, sinhala, sinhalaArchaicNumbers, smallForms, sogdian, soraSompeng, soyombo, specials, sundanese, sundaneseSup,
        supArrowsA, supArrowsB, supArrowsC, supMathOperators, supPuaA, supPuaB, supPunctuation, supSymbolsAndPictographs, superAndSub, suttonSignWriting, sylotiNagri, syriac,
        syriacSup, 
        tagalog, tagbanwa, tags, taiLe, taiTham, taiViet, taiXuanJing, takri, tamil, tangut, tangutComponents, telugu, thaana, thai, tibetan, tifinagh, tirhuta, transportAndMap,
        ucas, ucasExt, ugaritic, vai, vedicExt, verticalForms, vs, vsSup, warangCiti, yiRadicals, yiSyllables, yijing, zanabazarSquare
    }

    public class Block 
    {
        public nothrow Block(BlockId id_, const string& shortName_, const string& longName_, uchar start_, uchar end_) : 
            id(id_), shortName(shortName_), longName(longName_), start(start_), end(end_)
        {
        }
        public inline nothrow BlockId Id()
        {
            return id;
        }
        public inline nothrow const string& ShortName()
        {
            return shortName;
        }
        public inline nothrow const string& LongName()
        {
            return longName;
        }
        public inline nothrow uchar Start()
        {
            return start;
        }
        public inline nothrow uchar End()
        {
            return end;
        }
        private BlockId id;
        private string shortName;
        private string longName;
        private uchar start;
        private uchar end;
    }
    
    public class BlockTable
    {
        static BlockTable() : instance(new BlockTable())
        {
        }
        public static BlockTable& Instance()
        {
            return *instance;
        }
        public inline nothrow const Block* GetBlock(BlockId id) const
        {
            HashMap<uint, void*>.ConstIterator it = blockIdMap.CFind(cast<uint>(cast<ushort>(id)));
            if (it != blockIdMap.CEnd())
            {
                return cast<Block*>(it->second);
            }
            return null;
        }
        public inline const Block* GetBlockByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<Block*>(it->second);
            }
            return null;
        }
        public inline const Block* GetBlockByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<Block*>(it->second);
            }
            return null;
        }
        private BlockTable() : blocks(), blockIdMap(), shortNameMap(), longNameMap()
        {
            blocks.Add(new Block(BlockId.ascii, "ASCII", "Basic Latin", cast<uchar>(0x0000u), cast<uchar>(0x007Fu)));
            blocks.Add(new Block(BlockId.latin1Sup, "Latin 1 Sup", "Latin-1 Supplement", cast<uchar>(0x0080u), cast<uchar>(0x00FFu)));
            blocks.Add(new Block(BlockId.latinExtA, "Latin Ext A", "Latin Extended-A", cast<uchar>(0x0100u), cast<uchar>(0x017Fu)));
            blocks.Add(new Block(BlockId.latinExtB, "Latin Ext B", "Latin Extended-B", cast<uchar>(0x0180u), cast<uchar>(0x0024Fu)));
            blocks.Add(new Block(BlockId.ipaExt, "IPA Ext", "IPA Extensions", cast<uchar>(0x0250u), cast<uchar>(0x02AFu)));
            blocks.Add(new Block(BlockId.modifierLetters, "Modifier Letters", "Spacing Modifier Letters", cast<uchar>(0x02B0u), cast<uchar>(0x02FFu)));
            blocks.Add(new Block(BlockId.diacriticals, "Diacriticals", "Combining Diacritical Marks", cast<uchar>(0x0300u), cast<uchar>(0x036Fu)));
            blocks.Add(new Block(BlockId.greek, "Greek", "Greek and Coptic", cast<uchar>(0x0370u), cast<uchar>(0x03FFu)));
            blocks.Add(new Block(BlockId.cyrillic, "Cyrillic", "Cyrillic", cast<uchar>(0x0400u), cast<uchar>(0x04FFu)));
            blocks.Add(new Block(BlockId.cyrillicSup, "Cyrillic Sup", "Cyrillic Supplement", cast<uchar>(0x0500u), cast<uchar>(0x052Fu)));
            blocks.Add(new Block(BlockId.armenian, "Armenian", "Armenian", cast<uchar>(0x0530u), cast<uchar>(0x058Fu)));
            blocks.Add(new Block(BlockId.hebrew, "Hebrew", "Hebrew", cast<uchar>(0x0590u), cast<uchar>(0x05FFu)));
            blocks.Add(new Block(BlockId.arabic, "Arabic", "Arabic", cast<uchar>(0x0600u), cast<uchar>(0x06FFu)));
            blocks.Add(new Block(BlockId.syriac, "Syriac", "Syriac", cast<uchar>(0x0700u), cast<uchar>(0x074Fu)));
            blocks.Add(new Block(BlockId.arabicSup, "Arabic Sup", "Arabic Supplement", cast<uchar>(0x0750u), cast<uchar>(0x077Fu)));
            blocks.Add(new Block(BlockId.thaana, "Thaana", "Thaana", cast<uchar>(0x0780u), cast<uchar>(0x07BFu)));
            blocks.Add(new Block(BlockId.nko, "Nko", "Nko", cast<uchar>(0x07C0u), cast<uchar>(0x07FFu)));
            blocks.Add(new Block(BlockId.samaritan, "Samaritan", "Samaritan", cast<uchar>(0x0800u), cast<uchar>(0x083Fu)));
            blocks.Add(new Block(BlockId.mandaic, "Mandaic", "Mandaic", cast<uchar>(0x0840u), cast<uchar>(0x085Fu)));
            blocks.Add(new Block(BlockId.syriacSup, "Syriac Sup", "Syriac Supplement", cast<uchar>(0x0860), cast<uchar>(0x086F)));
            blocks.Add(new Block(BlockId.arabicExtA, "Arabic Ext A", "Arabic Extended-A", cast<uchar>(0x08A0u), cast<uchar>(0x08FFu)));
            blocks.Add(new Block(BlockId.devanagari, "Devanagari", "Devanagari", cast<uchar>(0x0900u), cast<uchar>(0x097Fu)));
            blocks.Add(new Block(BlockId.bengali, "Bengali", "Bengali", cast<uchar>(0x0980u), cast<uchar>(0x09FFu)));
            blocks.Add(new Block(BlockId.gurmukhi, "Gurmukhi", "Gurmukhi", cast<uchar>(0x0A00u), cast<uchar>(0x0A7Fu)));
            blocks.Add(new Block(BlockId.gujarati, "Gujarati", "Gujarati", cast<uchar>(0x0A80u), cast<uchar>(0x0AFFu)));
            blocks.Add(new Block(BlockId.oriya, "Oriya", "Oriya", cast<uchar>(0x0B00u), cast<uchar>(0x0B7Fu)));
            blocks.Add(new Block(BlockId.tamil, "Tamil", "Tamil", cast<uchar>(0x0B80u), cast<uchar>(0x0BFFu)));
            blocks.Add(new Block(BlockId.telugu, "Telugu", "Telugu", cast<uchar>(0x0C00u), cast<uchar>(0x0C7Fu)));
            blocks.Add(new Block(BlockId.kannada, "Kannada", "Kannada", cast<uchar>(0x0C80u), cast<uchar>(0x0CFFu)));
            blocks.Add(new Block(BlockId.malayalam, "Malayalam", "Malayalam", cast<uchar>(0x0D00u), cast<uchar>(0x0D7Fu)));
            blocks.Add(new Block(BlockId.sinhala, "Sinhala", "Sinhala", cast<uchar>(0x0D80u), cast<uchar>(0x0DFFu)));
            blocks.Add(new Block(BlockId.thai, "Thai", "Thai", cast<uchar>(0x0E00u), cast<uchar>(0x0E7Fu)));
            blocks.Add(new Block(BlockId.lao, "Lao", "Lao", cast<uchar>(0x0E80u), cast<uchar>(0x0EFFu)));
            blocks.Add(new Block(BlockId.tibetan, "Tibetan", "Tibetan", cast<uchar>(0x0F00u), cast<uchar>(0x0FFFu)));
            blocks.Add(new Block(BlockId.myanmar, "Myanmar", "Myanmar", cast<uchar>(0x1000u), cast<uchar>(0x109Fu)));
            blocks.Add(new Block(BlockId.georgian, "Georgian", "Georgian", cast<uchar>(0x10A0u), cast<uchar>(0x10FFu)));
            blocks.Add(new Block(BlockId.jamo, "Jamo", "Hangul Jamo", cast<uchar>(0x1100u), cast<uchar>(0x11FFu)));
            blocks.Add(new Block(BlockId.ethiopic, "Ethiopic", "Ethiopic", cast<uchar>(0x1200u), cast<uchar>(0x137Fu)));
            blocks.Add(new Block(BlockId.ethiopicSup, "Ethiopic Sup", "Ethiopic Supplement", cast<uchar>(0x1380u), cast<uchar>(0x139Fu)));
            blocks.Add(new Block(BlockId.cherokee, "Cherokee", "Cherokee", cast<uchar>(0x13A0u), cast<uchar>(0x13FFu)));
            blocks.Add(new Block(BlockId.ucas, "UCAS", "Unified Canadian Aboriginal Syllabics", cast<uchar>(0x1400u), cast<uchar>(0x167Fu)));
            blocks.Add(new Block(BlockId.ogham, "Ogham", "Ogham", cast<uchar>(0x1680u), cast<uchar>(0x169Fu)));
            blocks.Add(new Block(BlockId.runic, "Runic", "Runic", cast<uchar>(0x16A0u), cast<uchar>(0x16FFu)));
            blocks.Add(new Block(BlockId.tagalog, "Tagalog", "Tagalog", cast<uchar>(0x1700u), cast<uchar>(0x171Fu)));
            blocks.Add(new Block(BlockId.hanunoo, "Hanunoo", "Hanunoo", cast<uchar>(0x1720u), cast<uchar>(0x173Fu)));
            blocks.Add(new Block(BlockId.buhid, "Buhid", "Buhid", cast<uchar>(0x1740u), cast<uchar>(0x175Fu)));
            blocks.Add(new Block(BlockId.tagbanwa, "Tagbanwa", "Tagbanwa", cast<uchar>(0x1760u), cast<uchar>(0x177Fu)));
            blocks.Add(new Block(BlockId.khmer, "Khmer", "Khmer", cast<uchar>(0x1780u), cast<uchar>(0x17FFu)));
            blocks.Add(new Block(BlockId.mongolian, "Mongolian", "Mongolian", cast<uchar>(0x1800u), cast<uchar>(0x18AFu)));
            blocks.Add(new Block(BlockId.ucasExt, "UCAS Ext", "Unified Canadian Aboriginal Syllabics Extended", cast<uchar>(0x18B0u), cast<uchar>(0x18FFu)));
            blocks.Add(new Block(BlockId.limbu, "Limbu", "Limbu", cast<uchar>(0x1900u), cast<uchar>(0x194Fu)));
            blocks.Add(new Block(BlockId.taiLe, "Tai Le", "Tai Le", cast<uchar>(0x1950u), cast<uchar>(0x197Fu)));
            blocks.Add(new Block(BlockId.newTaiLue, "New Tai Lue", "New Tai Lue", cast<uchar>(0x1980u), cast<uchar>(0x19DFu)));
            blocks.Add(new Block(BlockId.khmerSymbols, "Khmer Symbols", "Khmer Symbols", cast<uchar>(0x19E0u), cast<uchar>(0x19FFu)));
            blocks.Add(new Block(BlockId.buginese, "Buginese", "Buginese", cast<uchar>(0x1A00u), cast<uchar>(0x1A1Fu)));
            blocks.Add(new Block(BlockId.taiTham, "Tai Tham", "Tai Tham", cast<uchar>(0x1A20u), cast<uchar>(0x1AAFu)));
            blocks.Add(new Block(BlockId.diacriticalsExt, "Diacriticals Ext", "Combining Diacritical Marks Extended", cast<uchar>(0x1AB0u), cast<uchar>(0x1AFFu)));
            blocks.Add(new Block(BlockId.balinese, "Balinese", "Balinese", cast<uchar>(0x1B00u), cast<uchar>(0x1B7Fu)));
            blocks.Add(new Block(BlockId.sundanese, "Sundanese", "Sundanese", cast<uchar>(0x1B80u), cast<uchar>(0x1BBFu)));
            blocks.Add(new Block(BlockId.batak, "Batak", "Batak", cast<uchar>(0x1BC0u), cast<uchar>(0x1BFFu)));
            blocks.Add(new Block(BlockId.lepcha, "Lepcha", "Lepcha", cast<uchar>(0x1C00u), cast<uchar>(0x1C4Fu)));
            blocks.Add(new Block(BlockId.olChiki, "Ol Chiki", "Ol Chiki", cast<uchar>(0x1C50u), cast<uchar>(0x1C7Fu)));
            blocks.Add(new Block(BlockId.cyrillicExtC, "Cyrillic Ext C", "Cyrillic Extended-C", cast<uchar>(0x1C80u), cast<uchar>(0x1C8Fu)));
            blocks.Add(new Block(BlockId.georgianExt, "Georgian Ext", "Georgian Extended", cast<uchar>(0x1C90), cast<uchar>(0x1CBF)));
            blocks.Add(new Block(BlockId.sundaneseSup, "Sundanese Sup", "Sundanese Supplement", cast<uchar>(0x1CC0u), cast<uchar>(0x1CCFu)));
            blocks.Add(new Block(BlockId.vedicExt, "Vedic Ext", "Vedic Extensions", cast<uchar>(0x1CD0u), cast<uchar>(0x1CFFu)));
            blocks.Add(new Block(BlockId.phoneticExt, "Phonetic Ext", "Phonetic Extensions", cast<uchar>(0x1D00u), cast<uchar>(0x1D7Fu)));
            blocks.Add(new Block(BlockId.phoneticExtSup, "Phonetic Ext Sup", "Phonetic Extensions Supplement", cast<uchar>(0x1D80u), cast<uchar>(0x1DBFu)));
            blocks.Add(new Block(BlockId.diacriticalsSup, "Diacriticals Sup", "Combining Diacritical Marks Supplement", cast<uchar>(0x1DC0u), cast<uchar>(0x1DFFu)));
            blocks.Add(new Block(BlockId.latinExtAdditional, "Latin Ext Additional", "Latin Extended Additional", cast<uchar>(0x1E00u), cast<uchar>(0x1EFFu)));
            blocks.Add(new Block(BlockId.greekExt, "Greek Ext", "Greek Extended", cast<uchar>(0x1F00u), cast<uchar>(0x1FFFu)));
            blocks.Add(new Block(BlockId.punctuation, "Punctuation", "General Punctuation", cast<uchar>(0x2000u), cast<uchar>(0x206Fu)));
            blocks.Add(new Block(BlockId.superAndSub, "Super And Sub", "Superscripts and Subscripts", cast<uchar>(0x2070u), cast<uchar>(0x209Fu)));
            blocks.Add(new Block(BlockId.currencySymbols, "Currency Symbols", "Currency Symbols", cast<uchar>(0x20A0u), cast<uchar>(0x20CFu)));
            blocks.Add(new Block(BlockId.diariticalsForSymbols, "Diacriticals For Symbols", "Combining Diacritical Marks for Symbols", cast<uchar>(0x20D0u), cast<uchar>(0x20FFu)));
            blocks.Add(new Block(BlockId.letterlikeSymbols, "Letterlike Symbols", "Letterlike Symbols", cast<uchar>(0x2100u), cast<uchar>(0x214Fu)));
            blocks.Add(new Block(BlockId.numberForms, "Number Forms", "Number Forms", cast<uchar>(0x2150u), cast<uchar>(0x218Fu)));
            blocks.Add(new Block(BlockId.arrows, "Arrows", "Arrows", cast<uchar>(0x2190u), cast<uchar>(0x21FFu)));
            blocks.Add(new Block(BlockId.mathOperators, "Math Operators", "Mathematical Operators", cast<uchar>(0x2200u), cast<uchar>(0x22FFu)));
            blocks.Add(new Block(BlockId.miscTechnical, "Misc Technical", "Miscellaneous Technical", cast<uchar>(0x2300u), cast<uchar>(0x23FFu)));
            blocks.Add(new Block(BlockId.controlPictures, "Control Pictures", "Control Pictures", cast<uchar>(0x2400u), cast<uchar>(0x243Fu)));
            blocks.Add(new Block(BlockId.ocr, "OCR", "Optical Character Regognition", cast<uchar>(0x2440u), cast<uchar>(0x245Fu)));
            blocks.Add(new Block(BlockId.enclosedAlphanum, "Enclosed Alphanum", "Enclosed Alphanumerics", cast<uchar>(0x2460u), cast<uchar>(0x24FFu)));
            blocks.Add(new Block(BlockId.boxDrawing, "Box Drawing", "Box Drawing", cast<uchar>(0x2500u), cast<uchar>(0x257Fu)));
            blocks.Add(new Block(BlockId.blockElements, "Block Elements", "Block Elements", cast<uchar>(0x2580u), cast<uchar>(0x259Fu)));
            blocks.Add(new Block(BlockId.geometricShapes, "Geometric Shapes", "Geometric Shapes", cast<uchar>(0x25A0u), cast<uchar>(0x25FFu)));
            blocks.Add(new Block(BlockId.miscSymbols, "Misc Symbols", "Miscellaneous Symbols", cast<uchar>(0x2600u), cast<uchar>(0x26FFu)));
            blocks.Add(new Block(BlockId.dingbats, "Dingbats", "Dingbats", cast<uchar>(0x2700u), cast<uchar>(0x27BFu)));
            blocks.Add(new Block(BlockId.miscMathSymbolsA, "Misc Math Symbols A", "Miscellaneous Mathematical Symbols - A", cast<uchar>(0x27C0u), cast<uchar>(0x27EFu)));
            blocks.Add(new Block(BlockId.supArrowsA, "Sup Arrows A", "Supplemental Arrows-A", cast<uchar>(0x27F0u), cast<uchar>(0x27FFu)));
            blocks.Add(new Block(BlockId.braille, "Braille", "Braille Patterns", cast<uchar>(0x2800u), cast<uchar>(0x28FFu)));
            blocks.Add(new Block(BlockId.supArrowsB, "Sup Arrows B", "Supplemental Arrows-B", cast<uchar>(0x2900u), cast<uchar>(0x297Fu)));
            blocks.Add(new Block(BlockId.miscMathSymbolsB, "Misc Math Symbols B", "Miscellaneous Mathematical Symbols-B", cast<uchar>(0x2980u), cast<uchar>(0x29FFu)));
            blocks.Add(new Block(BlockId.supMathOperators, "Sup Math Operators", "Supplemental Mathematical Operators", cast<uchar>(0x2A00u), cast<uchar>(0x2AFFu)));
            blocks.Add(new Block(BlockId.miscArrows, "Misc Arrows", "Miscellaneous Symbols and Arrows", cast<uchar>(0x2B00u), cast<uchar>(0x2BFFu)));
            blocks.Add(new Block(BlockId.glagolitic, "Glagolitic", "Glagolitic", cast<uchar>(0x2C00u), cast<uchar>(0x2C5Fu)));
            blocks.Add(new Block(BlockId.latinExtC, "Latin Ext C", "Latin Extended-C", cast<uchar>(0x2C60u), cast<uchar>(0x2C7Fu)));
            blocks.Add(new Block(BlockId.coptic, "Coptic", "Coptic", cast<uchar>(0x2C80u), cast<uchar>(0x2CFFu)));
            blocks.Add(new Block(BlockId.georgianSup, "Georgian Sup", "Georgian Supplement", cast<uchar>(0x2D00u), cast<uchar>(0x2D2Fu)));
            blocks.Add(new Block(BlockId.tifinagh, "Tifinagh", "Tifinagh", cast<uchar>(0x2D30u), cast<uchar>(0x2D7Fu)));
            blocks.Add(new Block(BlockId.ethiopicExt, "Ethiopic Ext", "Ethiopic Extended", cast<uchar>(0x2D80u), cast<uchar>(0x2DDFu)));
            blocks.Add(new Block(BlockId.cyrillicExtA, "Cyrillic Ext A", "Cyrillic Extended-A", cast<uchar>(0x2DE0u), cast<uchar>(0x2DFFu)));
            blocks.Add(new Block(BlockId.supPunctuation, "Sup Punctuation", "Supplemental Punctuation", cast<uchar>(0x2E00u), cast<uchar>(0x2E7Fu)));
            blocks.Add(new Block(BlockId.cjkRadicalsSup, "CJK Radicals Sup", "CJK Radicals Supplement", cast<uchar>(0x2E80u), cast<uchar>(0x2EFFu)));
            blocks.Add(new Block(BlockId.kangxi, "Kangxi", "Kangxi Radicals", cast<uchar>(0x2F00u), cast<uchar>(0x2FDFu)));
            blocks.Add(new Block(BlockId.idc, "IDC", "Ideographic Description Characters", cast<uchar>(0x2FF0u), cast<uchar>(0x2FFFu)));
            blocks.Add(new Block(BlockId.cjkSymbols, "CJK Symbols", "CJK Symbols and Punctuation", cast<uchar>(0x3000u), cast<uchar>(0x303Fu)));
            blocks.Add(new Block(BlockId.hiragana, "Hiragana", "Hiragana", cast<uchar>(0x3040u), cast<uchar>(0x309Fu)));
            blocks.Add(new Block(BlockId.katakana, "Katakana", "Katakana", cast<uchar>(0x30A0u), cast<uchar>(0x30FFu)));
            blocks.Add(new Block(BlockId.bopomofo, "Bopomofo", "Bopomofo", cast<uchar>(0x3100u), cast<uchar>(0x312Fu)));
            blocks.Add(new Block(BlockId.compatJamo, "Compat Jamo", "Hangul Compatibility Jamo", cast<uchar>(0x3130u), cast<uchar>(0x318Fu)));
            blocks.Add(new Block(BlockId.kanbun, "Kanbun", "Kanbun", cast<uchar>(0x3190u), cast<uchar>(0x319Fu)));
            blocks.Add(new Block(BlockId.bopomofoExt, "Bopomofo Ext", "Bopomofo Extended", cast<uchar>(0x31A0u), cast<uchar>(0x31BFu)));
            blocks.Add(new Block(BlockId.cjkStrokes, "CJK Strokes", "CJK Strokes", cast<uchar>(0x31C0u), cast<uchar>(0x31EFu)));
            blocks.Add(new Block(BlockId.katakanaExt, "Katakana Ext", "Katakana Phonetic Extensions", cast<uchar>(0x31F0u), cast<uchar>(0x31FFu)));
            blocks.Add(new Block(BlockId.enclosedCjk, "Enclosed CJK", "Enclosed CJK Letters and Months", cast<uchar>(0x3200u), cast<uchar>(0x32FFu)));
            blocks.Add(new Block(BlockId.cjkCompat, "CJK Compat", "CJK Compatibility", cast<uchar>(0x3300u), cast<uchar>(0x33FFu)));
            blocks.Add(new Block(BlockId.cjkExtA, "CJK Ext A", "CJK Unified Ideographic Extension A", cast<uchar>(0x3400u), cast<uchar>(0x4DBFu)));
            blocks.Add(new Block(BlockId.yijing, "Yijing", "Yijing Hexagram Symbols", cast<uchar>(0x4DC0u), cast<uchar>(0x4DFFu)));
            blocks.Add(new Block(BlockId.cjk, "CJK", "CJK Unified Ideographs", cast<uchar>(0x4E00u), cast<uchar>(0x9FFFu)));
            blocks.Add(new Block(BlockId.yiSyllables, "Yi Syllables", "Yi Syllables", cast<uchar>(0xA000u), cast<uchar>(0xA48Fu)));
            blocks.Add(new Block(BlockId.yiRadicals, "Yi Radicals", "Yi Radicals", cast<uchar>(0xA090u), cast<uchar>(0xA4CFu)));
            blocks.Add(new Block(BlockId.lisu, "Lisu", "Lisu", cast<uchar>(0xA0D0u), cast<uchar>(0xA4FFu)));
            blocks.Add(new Block(BlockId.vai, "Vai", "Vai", cast<uchar>(0xA500u), cast<uchar>(0xA63Fu)));
            blocks.Add(new Block(BlockId.cyrillicExtB, "Cyrillic Ext B", "Cyrillic Extended-B", cast<uchar>(0xA640u), cast<uchar>(0xA69Fu)));
            blocks.Add(new Block(BlockId.bamum, "Bamum", "Bamum", cast<uchar>(0xA6A0u), cast<uchar>(0xA6FFu)));
            blocks.Add(new Block(BlockId.modifierToneLetters, "Modifier Tone Letters", "Modifier Tone Letters", cast<uchar>(0xA700u), cast<uchar>(0xA71Fu)));
            blocks.Add(new Block(BlockId.latinExtD, "Latin Ext D", "Latin Extended-D", cast<uchar>(0xA720u), cast<uchar>(0xA7FFu)));
            blocks.Add(new Block(BlockId.sylotiNagri, "Syloti Nagri", "Syloti Nagri", cast<uchar>(0xA800u), cast<uchar>(0xA82Fu)));
            blocks.Add(new Block(BlockId.indicNumberForms, "Indic Number Forms", "Common Indic Number Forms", cast<uchar>(0xA830u), cast<uchar>(0xA83Fu)));
            blocks.Add(new Block(BlockId.phagsPa, "Phags Pa", "Phags-Pa", cast<uchar>(0xA840u), cast<uchar>(0xA87Fu)));
            blocks.Add(new Block(BlockId.saurashtra, "Saurashtra", "Saurashtra", cast<uchar>(0xA880u), cast<uchar>(0xA8DFu)));
            blocks.Add(new Block(BlockId.devanagariExt, "Devanagari Ext", "Devanagari Extended", cast<uchar>(0xA8E0u), cast<uchar>(0xA8FFu)));
            blocks.Add(new Block(BlockId.kayahLi, "Kayah Li", "Kayah Li", cast<uchar>(0xA900u), cast<uchar>(0xA92Fu)));
            blocks.Add(new Block(BlockId.rejang, "Rejang", "Rejang", cast<uchar>(0xA930u), cast<uchar>(0xA95Fu)));
            blocks.Add(new Block(BlockId.jamoExtA, "Jamo Ext A", "Hangul Jamo Extended-A", cast<uchar>(0xA960u), cast<uchar>(0xA97Fu)));
            blocks.Add(new Block(BlockId.javanese, "Javanese", "Javanese", cast<uchar>(0xA980u), cast<uchar>(0xA9DFu)));
            blocks.Add(new Block(BlockId.myanmarExtB, "Myanmar Ext B", "Myanmar Extended - B", cast<uchar>(0xA9E0u), cast<uchar>(0xA9FFu)));
            blocks.Add(new Block(BlockId.cham, "Cham","Cham", cast<uchar>(0xAA00u), cast<uchar>(0xAA5Fu)));
            blocks.Add(new Block(BlockId.myanmarExtA, "Myanmar Ext A", "Myanmar Extended-A", cast<uchar>(0xAA60u), cast<uchar>(0xAA7Fu)));
            blocks.Add(new Block(BlockId.taiViet, "Tai Viet", "Tai Viet", cast<uchar>(0xAA80u), cast<uchar>(0xAADFu)));
            blocks.Add(new Block(BlockId.meeteiMayekExt, "Meetei Mayek Ext", "Meetei Mayek Extensions", cast<uchar>(0xAAE0u), cast<uchar>(0xAAFFu)));
            blocks.Add(new Block(BlockId.ethiopicExtA, "Ethiopic Ext A", "Ethiopic Extended-A", cast<uchar>(0xAB00u), cast<uchar>(0xAB2Fu)));
            blocks.Add(new Block(BlockId.latinExtE, "Latin Ext E", "Latin Extended-E", cast<uchar>(0xAB30u), cast<uchar>(0xAB6Fu)));
            blocks.Add(new Block(BlockId.cherokeeSup, "Cherokee Sup", "Cherokee Supplement", cast<uchar>(0xAB70u), cast<uchar>(0xABBFu)));
            blocks.Add(new Block(BlockId.meeteiMayek, "Meetei Mayek", "Meetei Mayek", cast<uchar>(0xABC0u), cast<uchar>(0xABFFu)));
            blocks.Add(new Block(BlockId.hangul, "Hangul", "Hangul Syllables", cast<uchar>(0xAC00u), cast<uchar>(0xD7AFu)));
            blocks.Add(new Block(BlockId.jamoExtB, "Jamo Ext B", "Hangul Jamo Extended-B", cast<uchar>(0xD7B0u), cast<uchar>(0xD7FFu)));
            blocks.Add(new Block(BlockId.highSurrogates, "High Surrogates", "High Surrogates", cast<uchar>(0xD800u), cast<uchar>(0xDB7Fu)));
            blocks.Add(new Block(BlockId.highPuSurrogates,  "High PU Surrogates", "High Private Use Surrogates", cast<uchar>(0xDB80u), cast<uchar>(0xDBFFu)));
            blocks.Add(new Block(BlockId.lowSurrogates, "Low Surrogates", "Low Surrogates", cast<uchar>(0xDC00u), cast<uchar>(0xDFFFu)));
            blocks.Add(new Block(BlockId.pua, "PUA", "Private Use Area", cast<uchar>(0xE000u), cast<uchar>(0xF8FFu)));
            blocks.Add(new Block(BlockId.cjkCompatIdeographs, "CJK Compat Ideographs", "CJK Compatibility Ideographs", cast<uchar>(0xF900u), cast<uchar>(0xFAFFu)));
            blocks.Add(new Block(BlockId.alphabeticPf, "Alphabetic PF", "Alphabetic Presentations Forms", cast<uchar>(0xFB00u), cast<uchar>(0xFB4Fu)));
            blocks.Add(new Block(BlockId.arabicPfA, "Arabic PF A", "Arabic Presentation Forms-A", cast<uchar>(0xFB50u), cast<uchar>(0xFDFFu)));
            blocks.Add(new Block(BlockId.vs, "VS", "Variation Selectors", cast<uchar>(0xFE00u), cast<uchar>(0xFE0Fu)));
            blocks.Add(new Block(BlockId.verticalForms, "Vertical Forms", "Vertical Forms", cast<uchar>(0xFE10u), cast<uchar>(0xFE1Fu)));
            blocks.Add(new Block(BlockId.halfMarks, "Half Marks", "Combining Half Marks", cast<uchar>(0xFE20u), cast<uchar>(0xFE2Fu)));
            blocks.Add(new Block(BlockId.cjkCompatForms, "CJK Compat Forms", "CJK Compatibility Forms", cast<uchar>(0xFE30u), cast<uchar>(0xFE4Fu)));
            blocks.Add(new Block(BlockId.smallForms, "Small Forms", "Small Form Variants", cast<uchar>(0xFE50u), cast<uchar>(0xFE6Fu)));
            blocks.Add(new Block(BlockId.arabicPfB, "Arabic PF B", "Arabic Presentation Forms-B", cast<uchar>(0xFE70u), cast<uchar>(0xFEFFu)));
            blocks.Add(new Block(BlockId.halfAndFullForms, "Half And Full Forms", "Halfwidth and Fullwidth Forms", cast<uchar>(0xFF00u), cast<uchar>(0xFFEFu)));
            blocks.Add(new Block(BlockId.specials, "Specials", "Specials", cast<uchar>(0xFFF0u), cast<uchar>(0xFFFFu)));
            blocks.Add(new Block(BlockId.linearBSyllabary, "Linear B Syllabary", "Linear B Syllabary", cast<uchar>(0x10000u), cast<uchar>(0x1007Fu)));
            blocks.Add(new Block(BlockId.linearBIdeograms, "Linear B Ideograms", "Linear B Ideograms", cast<uchar>(0x10080u), cast<uchar>(0x100FFu)));
            blocks.Add(new Block(BlockId.aegeanNumbers, "Aegean Numbers", "Aegean Numbers", cast<uchar>(0x10100u), cast<uchar>(0x1013Fu)));
            blocks.Add(new Block(BlockId.ancientGreekNumbers, "Ancient Greek Numbers", "Ancient Greek Numbers", cast<uchar>(0x10140u), cast<uchar>(0x1018Fu)));
            blocks.Add(new Block(BlockId.ancientSymbols, "Ancient Symbols", "Ancient Symbols", cast<uchar>(0x10190u), cast<uchar>(0x101CFu)));
            blocks.Add(new Block(BlockId.phaistos, "Phaistos", "Phaistos Disc", cast<uchar>(0x101D0u), cast<uchar>(0x101FFu)));
            blocks.Add(new Block(BlockId.lycian, "Lycian", "Lycian", cast<uchar>(0x10280u), cast<uchar>(0x1029Fu)));
            blocks.Add(new Block(BlockId.carian, "Carian", "Carian", cast<uchar>(0x102A0u), cast<uchar>(0x102DFu)));
            blocks.Add(new Block(BlockId.copticEpactNumbers, "Coptic Epact Numbers", "Coptic Epact Numbers", cast<uchar>(0x102E0u), cast<uchar>(0x102FFu)));
            blocks.Add(new Block(BlockId.oldItalic, "Old Italic", "Old Italic", cast<uchar>(0x10300u), cast<uchar>(0x1032Fu)));
            blocks.Add(new Block(BlockId.gothic, "Gothic", "Gothic", cast<uchar>(0x10330u), cast<uchar>(0x1034Fu)));
            blocks.Add(new Block(BlockId.oldPermic, "Old Permic", "Old Permic", cast<uchar>(0x10350u), cast<uchar>(0x1037Fu)));
            blocks.Add(new Block(BlockId.ugaritic, "Ugaritic", "Ugaritic", cast<uchar>(0x10380u), cast<uchar>(0x1039Fu)));
            blocks.Add(new Block(BlockId.oldPersian, "Old Persian", "Old Persian", cast<uchar>(0x103A0u), cast<uchar>(0x103DFu)));
            blocks.Add(new Block(BlockId.deseret, "Deseret", "Deseret", cast<uchar>(0x10400u), cast<uchar>(0x1044Fu)));
            blocks.Add(new Block(BlockId.shavian, "Shavian", "Shavian", cast<uchar>(0x10450u), cast<uchar>(0x1047Fu)));
            blocks.Add(new Block(BlockId.osmanya, "Osmanya", "Osmanya", cast<uchar>(0x10480u), cast<uchar>(0x104AFu)));
            blocks.Add(new Block(BlockId.osage, "Osage", "Osage", cast<uchar>(0x104B0u), cast<uchar>(0x104FFu)));
            blocks.Add(new Block(BlockId.elbasan, "Elbasan", "Elbasan", cast<uchar>(0x10500u), cast<uchar>(0x1052Fu)));
            blocks.Add(new Block(BlockId.caucasianAlbanian, "Caucasian Albanian", "Caucasian Albanian", cast<uchar>(0x10530u), cast<uchar>(0x1056Fu)));
            blocks.Add(new Block(BlockId.linearA, "Linear A", "Linear A", cast<uchar>(0x10600u), cast<uchar>(0x1077Fu)));
            blocks.Add(new Block(BlockId.cypriotSyllabary, "Cypriot Syllabary", "Cypriot Syllabary", cast<uchar>(0x10800u), cast<uchar>(0x1083Fu)));
            blocks.Add(new Block(BlockId.imperialAramaic, "Imperial Aramaic", "Imperial Aramaic", cast<uchar>(0x10840u), cast<uchar>(0x1085Fu)));
            blocks.Add(new Block(BlockId.palmyrene, "Palmyrene", "Palmyrene", cast<uchar>(0x10860u), cast<uchar>(0x1087Fu)));
            blocks.Add(new Block(BlockId.nabataean, "Nabataean", "Nabataean", cast<uchar>(0x10880u), cast<uchar>(0x108AFu)));
            blocks.Add(new Block(BlockId.hatran, "Hatran", "Hatran", cast<uchar>(0x108E0u), cast<uchar>(0x108FFu)));
            blocks.Add(new Block(BlockId.phoenician, "Phoenician", "Phoenician", cast<uchar>(0x10900u), cast<uchar>(0x1091Fu)));
            blocks.Add(new Block(BlockId.lydian, "Lydian", "Lydian", cast<uchar>(0x10920u), cast<uchar>(0x1093Fu)));
            blocks.Add(new Block(BlockId.meroiticHieroglyphs, "Meroitic Hieroglyphs", "Meroitic Hieroglyphs", cast<uchar>(0x10980u), cast<uchar>(0x1099Fu)));
            blocks.Add(new Block(BlockId.meroiticCursive, "Meroitic Cursive", "Meroitic Cursive", cast<uchar>(0x109A0u), cast<uchar>(0x109FFu)));
            blocks.Add(new Block(BlockId.kharoshthi, "Kharoshthi", "Kharoshthi", cast<uchar>(0x10A00u), cast<uchar>(0x10A5Fu)));
            blocks.Add(new Block(BlockId.oldSouthArabian, "Old South Arabian", "Old South Arabian", cast<uchar>(0x10A60u), cast<uchar>(0x10A7Fu)));
            blocks.Add(new Block(BlockId.oldNorthArabian, "Old North Arabian", "Old North Arabian", cast<uchar>(0x10A80u), cast<uchar>(0x10A9Fu)));
            blocks.Add(new Block(BlockId.manichean, "Manichaean", "Manichaean", cast<uchar>(0x10AC0u), cast<uchar>(0x10AFFu)));
            blocks.Add(new Block(BlockId.avestan, "Avestan", "Avestan", cast<uchar>(0x10B00u), cast<uchar>(0x10B3Fu)));
            blocks.Add(new Block(BlockId.inscriptionalParthian, "Inscriptional Parthian", "Inscriptional Parthian", cast<uchar>(0x10B40u), cast<uchar>(0x10B5Fu)));
            blocks.Add(new Block(BlockId.inscriptionalPahlavi, "Inscriptional Pahlavi", "Inscriptional Pahlavi", cast<uchar>(0x10B60u), cast<uchar>(0x10B7Fu)));
            blocks.Add(new Block(BlockId.psalterPahlavi, "Psalter Pahlavi", "Psalter Pahlavi", cast<uchar>(0x10B80u), cast<uchar>(0x10BAFu)));
            blocks.Add(new Block(BlockId.oldTurkic, "Old Turkic", "Old Turkic", cast<uchar>(0x10C00u), cast<uchar>(0x10C4Fu)));
            blocks.Add(new Block(BlockId.oldHungarian, "Old Hungarian", "Old Hungarian", cast<uchar>(0x10C80u), cast<uchar>(0x10CFFu)));
            blocks.Add(new Block(BlockId.hanifiRohingya, "Hanifi Rohingya", "Hanifi Rohingya", cast<uchar>(0x10D00u), cast<uchar>(0x10D3Fu)));
            blocks.Add(new Block(BlockId.rumi, "Rumi", "Rumi Numeral Symbols", cast<uchar>(0x10E60u), cast<uchar>(0x10E7Fu)));
            blocks.Add(new Block(BlockId.oldSogdian, "Old Sogdian", "Old Sogdian", cast<uchar>(0x10F00u), cast<uchar>(0x10F2Fu)));
            blocks.Add(new Block(BlockId.sogdian, "Sogdian", "Sogdian", cast<uchar>(0x10F30u), cast<uchar>(0x10F6Fu)));
            blocks.Add(new Block(BlockId.brahmi, "Brahmi", "Brahmi", cast<uchar>(0x11000u), cast<uchar>(0x1107Fu)));
            blocks.Add(new Block(BlockId.kaithi, "Kaithi", "Kaithi", cast<uchar>(0x11080u), cast<uchar>(0x110CFu)));
            blocks.Add(new Block(BlockId.soraSompeng, "Sora Sompeng", "Sora Sompeng", cast<uchar>(0x110D0u), cast<uchar>(0x110FFu)));
            blocks.Add(new Block(BlockId.chakma, "Chakma", "Chakma", cast<uchar>(0x11100u), cast<uchar>(0x1114Fu)));
            blocks.Add(new Block(BlockId.mahajani, "Mahajani", "Mahajani", cast<uchar>(0x11150u), cast<uchar>(0x1117Fu)));
            blocks.Add(new Block(BlockId.sharada, "Sharada", "Sharada", cast<uchar>(0x11180u), cast<uchar>(0x111DFu)));
            blocks.Add(new Block(BlockId.sinhalaArchaicNumbers, "Sinhala Archaic Numbers", "Sinhala Archaic Numbers", cast<uchar>(0x111E0u), cast<uchar>(0x111FFu)));
            blocks.Add(new Block(BlockId.khojki, "Khojki", "Khojki", cast<uchar>(0x11200u), cast<uchar>(0x1124Fu)));
            blocks.Add(new Block(BlockId.multani, "Multani", "Multani", cast<uchar>(0x11280u), cast<uchar>(0x112AFu)));
            blocks.Add(new Block(BlockId.khudawadi, "Khudawadi", "Khudawadi", cast<uchar>(0x112B0u), cast<uchar>(0x112FFu)));
            blocks.Add(new Block(BlockId.grantha, "Grantha", "Grantha", cast<uchar>(0x11300u), cast<uchar>(0x1137Fu)));
            blocks.Add(new Block(BlockId.newa, "Newa", "Newa", cast<uchar>(0x11400u), cast<uchar>(0x1147Fu)));
            blocks.Add(new Block(BlockId.tirhuta, "Tirhuta", "Tirhuta", cast<uchar>(0x11480u), cast<uchar>(0x114DFu)));
            blocks.Add(new Block(BlockId.siddham, "Siddham", "Siddham", cast<uchar>(0x11580u), cast<uchar>(0x115FFu)));
            blocks.Add(new Block(BlockId.modi, "Modi", "Modi", cast<uchar>(0x11600u), cast<uchar>(0x1165Fu)));
            blocks.Add(new Block(BlockId.mongolianSup, "Mongolian Sup", "Mongolian Supplement", cast<uchar>(0x11660u), cast<uchar>(0x1167Fu)));
            blocks.Add(new Block(BlockId.takri, "Takri", "Takri", cast<uchar>(0x11680u), cast<uchar>(0x116CFu)));
            blocks.Add(new Block(BlockId.ahom, "Ahom", "Ahom", cast<uchar>(0x11700u), cast<uchar>(0x1173Fu)));
            blocks.Add(new Block(BlockId.dogra, "Dogra", "Dogra", cast<uchar>(0x11800u), cast<uchar>(0x1184Fu)));
            blocks.Add(new Block(BlockId.warangCiti, "Warang Citi", "Warang Citi", cast<uchar>(0x118A0u), cast<uchar>(0x118FFu)));
            blocks.Add(new Block(BlockId.zanabazarSquare, "Zanabazar Square", "Zanabazar Square", cast<uchar>(0x11A00u), cast<uchar>(0x11A4FFu)));
            blocks.Add(new Block(BlockId.soyombo, "Soyombo", "Soyombo", cast<uchar>(0x11A50u), cast<uchar>(0x11AAFu)));
            blocks.Add(new Block(BlockId.pauCinHau, "Pau Cin Hau", "Pau Cin Hau", cast<uchar>(0x11AC0u), cast<uchar>(0x11AFFu)));
            blocks.Add(new Block(BlockId.bhaisuki, "Bhaiksuki", "Bhaiksuki", cast<uchar>(0x11C00u), cast<uchar>(0x11C6Fu)));
            blocks.Add(new Block(BlockId.marchen, "Marchen", "Marchen", cast<uchar>(0x11C70u), cast<uchar>(0x11CBFu)));
            blocks.Add(new Block(BlockId.cuneiform, "Cuneiform", "Cuneiform", cast<uchar>(0x12000u), cast<uchar>(0x123FFu)));
            blocks.Add(new Block(BlockId.cuneiformNumbers, "Cuneiform Numbers", "Cuneiform Numbers and Punctuation", cast<uchar>(0x12400u), cast<uchar>(0x1247Fu)));
            blocks.Add(new Block(BlockId.earlyDynasticCuneiform, "Early Dynastic Cuneiform", "Early Dynastic Cuneiform", cast<uchar>(0x12480u), cast<uchar>(0x1254Fu)));
            blocks.Add(new Block(BlockId.egyptianHieroglyphs, "Egyptian Hieroglyphs", "Egyptian Hieroglyphs", cast<uchar>(0x13000u), cast<uchar>(0x1342Fu)));
            blocks.Add(new Block(BlockId.anatolianHieroglyphs, "Anatolian Hieroglyphs", "Anatolian Hieroglyphs", cast<uchar>(0x14400u), cast<uchar>(0x1467Fu)));
            blocks.Add(new Block(BlockId.bamumSup, "Bamum Sup", "Bamum Supplement", cast<uchar>(0x16800u), cast<uchar>(0x16A3Fu)));
            blocks.Add(new Block(BlockId.mro, "Mro", "Mro", cast<uchar>(0x16A40u), cast<uchar>(0x16A6Fu)));
            blocks.Add(new Block(BlockId.bassaVah, "Bassa Vah", "Bassa Vah", cast<uchar>(0x16AD0u), cast<uchar>(0x16AFFu)));
            blocks.Add(new Block(BlockId.pahawhHmong, "Pahawh Hmong", "Pahawh Hmong", cast<uchar>(0x16B00u), cast<uchar>(0x16B8Fu)));
            blocks.Add(new Block(BlockId.medefaidrin, "Medefaidrin", "Medefaidrin", cast<uchar>(0x16E40u), cast<uchar>(0x16E9Fu)));
            blocks.Add(new Block(BlockId.miao, "Miao", "Miao", cast<uchar>(0x16F00u), cast<uchar>(0x16F9Fu)));
            blocks.Add(new Block(BlockId.ideographicSymbols, "Ideographic Symbols", "Ideographic Symbols and Punctuation", cast<uchar>(0x16FE0u), cast<uchar>(0x16FFFu)));
            blocks.Add(new Block(BlockId.tangut, "Tangut", "Tangut", cast<uchar>(0x17000u), cast<uchar>(0x187FFu)));
            blocks.Add(new Block(BlockId.tangutComponents, "Tangut Components", "Tangut Components", cast<uchar>(0x18800u), cast<uchar>(0x18AFFu)));
            blocks.Add(new Block(BlockId.kanaSup, "Kana Sup", "Kana Supplement", cast<uchar>(0x1B000u), cast<uchar>(0x1B0FFu)));
            blocks.Add(new Block(BlockId.kanaExtA, "Kana Ext A", "Kana Extended-A", cast<uchar>(0x1B100u), cast<uchar>(0x1B12Fu))); 
            blocks.Add(new Block(BlockId.nushu, "Nushu", "Nushu", cast<uchar>(0x1B170u), cast<uchar>(0x1B2FFu))); 
            blocks.Add(new Block(BlockId.duployan, "Duployan", "Duployan", cast<uchar>(0x1BC00u), cast<uchar>(0x1BC9Fu)));
            blocks.Add(new Block(BlockId.shorthandFormatControls, "Shorthand Format Controls", "Shorthand Format Controls", cast<uchar>(0x1BCA0u), cast<uchar>(0x1BCAFu)));
            blocks.Add(new Block(BlockId.byzantineMusic, "Byzantine Music", "Byzantine Musical Symbols", cast<uchar>(0x1D000u), cast<uchar>(0x1D0FFu)));
            blocks.Add(new Block(BlockId.music, "Music", "Musical Symbols", cast<uchar>(0x1D100u), cast<uchar>(0x1D1FFu)));
            blocks.Add(new Block(BlockId.ancientGreekMusic, "Ancient Greek Music", "Ancient Greek Musical Notation", cast<uchar>(0x1D200u), cast<uchar>(0x1D24Fu)));
            blocks.Add(new Block(BlockId.mayanNumerals, "Mayan Numerals", "Mayan Numerals", cast<uchar>(0x1D2E0u), cast<uchar>(0x1D2FFu)));
            blocks.Add(new Block(BlockId.taiXuanJing, "Tai Xuan Jing", "Tai Xuan Jing Symbols", cast<uchar>(0x1D300u), cast<uchar>(0x1D35Fu)));
            blocks.Add(new Block(BlockId.countingRod, "Counting Rod", "Counting Rod Numerals", cast<uchar>(0x1D360u), cast<uchar>(0x1D37Fu)));
            blocks.Add(new Block(BlockId.mathAlphanum, "Math Alphanum", "Mathematical Alphanumeric Symbols", cast<uchar>(0x1D400u), cast<uchar>(0x1D7FFu)));
            blocks.Add(new Block(BlockId.suttonSignWriting, "Sutton SignWriting", "Sutton SignWriting", cast<uchar>(0x1D800u), cast<uchar>(0x1DAAFu)));
            blocks.Add(new Block(BlockId.glagoliticSup, "Glagolitic Sup", "Glagolitic Supplement", cast<uchar>(0x1E000u), cast<uchar>(0x1E02Fu)));
            blocks.Add(new Block(BlockId.mendeKikakui, "Mende Kikakui", "Mende Kikakui", cast<uchar>(0x1E800u), cast<uchar>(0x1E8DFu)));
            blocks.Add(new Block(BlockId.adlam, "Adlam", "Adlam", cast<uchar>(0x1E900u), cast<uchar>(0x1E95Fu)));
            blocks.Add(new Block(BlockId.arabicMath, "Arabic Math", "Arabic Mathematical Alphabetic Symbols", cast<uchar>(0x1EE00u), cast<uchar>(0x1EEFFu)));
            blocks.Add(new Block(BlockId.mahjong, "Mahjong", "Mahjong Tiles", cast<uchar>(0x1F000u), cast<uchar>(0x1F02Fu)));
            blocks.Add(new Block(BlockId.domino, "Domino", "Domino Tiles", cast<uchar>(0x1F030u), cast<uchar>(0x1F09Fu)));
            blocks.Add(new Block(BlockId.playingCards, "Playing Cards", "Playing Cards", cast<uchar>(0x1F0A0u), cast<uchar>(0x1F0FFu)));
            blocks.Add(new Block(BlockId.enclosedAlphanumSup, "Enclosed Alphanum Sup", "Enclosed Alphanumeric Supplement", cast<uchar>(0x1F100u), cast<uchar>(0x1F1FFu)));
            blocks.Add(new Block(BlockId.enclosedIdeographicSup, "Enclosed Ideographic Sup", "Enclosed Ideographic Supplement", cast<uchar>(0x1F200u), cast<uchar>(0x1F2FFu)));
            blocks.Add(new Block(BlockId.miscPictographs, "Misc Pictographs", "Miscellaneous Symbols and Pictographs", cast<uchar>(0x1F300u), cast<uchar>(0x1F5FFu)));
            blocks.Add(new Block(BlockId.emoticons, "Emoticons", "Emoticons", cast<uchar>(0x1F600u), cast<uchar>(0x1F64Fu)));
            blocks.Add(new Block(BlockId.ornamentalDingbats, "Ornamental Dingbats", "Ornamental Dingbats", cast<uchar>(0x1F650u), cast<uchar>(0x1F67Fu)));
            blocks.Add(new Block(BlockId.transportAndMap, "Transport And Map", "Transport and Map Symbols", cast<uchar>(0x1F680u), cast<uchar>(0x1F6FFu)));
            blocks.Add(new Block(BlockId.alchemical, "Alchemical", "Alchemical Symbols", cast<uchar>(0x1F700u), cast<uchar>(0x1F77Fu)));
            blocks.Add(new Block(BlockId.geometricShapesExt, "Geometric Shapes Ext", "Geometric Shapes Extended", cast<uchar>(0x1F780u), cast<uchar>(0x1F7FFu)));
            blocks.Add(new Block(BlockId.supArrowsC, "Sup Arrows C", "Supplemental Arrows-C", cast<uchar>(0x1F800u), cast<uchar>(0x1F8FFu)));
            blocks.Add(new Block(BlockId.supSymbolsAndPictographs, "Sup Symbols And Pictographs", "Supplemental Symbols and Pictographs", cast<uchar>(0x1F900u), cast<uchar>(0x1F9FFu)));
            blocks.Add(new Block(BlockId.chessSymbols, "Chess Symbols", "Chess Symbols", cast<uchar>(0x1FA00u), cast<uchar>(0x1FA6Fu)));
            blocks.Add(new Block(BlockId.cjkExtB, "CJK Ext B", "CJK Unified Ideographs Extension B", cast<uchar>(0x20000u), cast<uchar>(0x2A6DFu)));
            blocks.Add(new Block(BlockId.cjkExtC, "CJK Ext C", "CJK Unified Ideographs Extension C", cast<uchar>(0x2A700u), cast<uchar>(0x2B73Fu)));
            blocks.Add(new Block(BlockId.cjkExtD, "CJK Ext D", "CJK Unified Ideographs Extension D", cast<uchar>(0x2B740u), cast<uchar>(0x2B81Fu)));
            blocks.Add(new Block(BlockId.cjkExtE, "CJK Ext E", "CJK Unified Ideographs Extension E", cast<uchar>(0x2B820u), cast<uchar>(0x2CEAFu)));
            blocks.Add(new Block(BlockId.cjkExtF, "CJK Ext F", "CJK Unified Ideographs Extension F", cast<uchar>(0x2CEB0u), cast<uchar>(0x2EBEFu)));
            blocks.Add(new Block(BlockId.cjkCompatIdeographsSup, "CJK Compat Ideographs Sup", "CJK Compatibility Ideographs Supplement", cast<uchar>(0x2F800u), cast<uchar>(0x2FA1Fu)));
            blocks.Add(new Block(BlockId.tags, "Tags", "Tags", cast<uchar>(0xE0000u), cast<uchar>(0xE007Fu)));
            blocks.Add(new Block(BlockId.vsSup, "VS Sup", "Variation Selectors Supplement", cast<uchar>(0xE0100u), cast<uchar>(0xE01EFu)));
            blocks.Add(new Block(BlockId.supPuaA, "Sup PUA A", "Supplementary Private Use Area-A", cast<uchar>(0xF0000u), cast<uchar>(0xFFFFFu)));
            blocks.Add(new Block(BlockId.supPuaB, "Sup PUA B", "Supplementary Private Use Area-B", cast<uchar>(0x100000u), cast<uchar>(0x10FFFFu)));
            for (Block* block : blocks)
            {
                blockIdMap[cast<uint>(cast<ushort>(block->Id()))] = block;
                shortNameMap[MakeCanonicalPropertyName(block->ShortName())] = block;
                longNameMap[MakeCanonicalPropertyName(block->LongName())] = block;
            }
        }
        public ~BlockTable()
        {
            for (Block* block : blocks)
            {
                delete block;
            }
        }
        private static UniquePtr<BlockTable> instance;
        private List<Block*> blocks;
        private HashMap<uint, void*> blockIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
    }
    
    public const Block* GetBlock(BlockId id)
    {
        return BlockTable.Instance().GetBlock(id);
    }

    public const Block* GetBlockByShortName(const string& shortName)
    {
        return BlockTable.Instance().GetBlockByShortName(shortName); 
    }

    public const Block* GetBlockByLongName(const string& longName)
    {
        return BlockTable.Instance().GetBlockByLongName(longName); 
    }

    public enum GeneralCategoryId : uint
    {
        none = 0u,
        Lu = 1u << 0u, Ll = 1u << 1u, Lt = 1u << 2u, Lm = 1u << 3u, Lo = 1u << 4u, 
        LC = Lu | Ll | Lt,
        L = Lu | Ll | Lt | Lm | Lo,
        Mn = 1u << 5u, Mc = 1u << 6u, Me = 1u << 7u,
        M = Mn | Mc | Me,
        Nd = 1u << 8u, Nl = 1u << 9u, No = 1u << 10u,
        N = Nd | Nl | No,
        Pc = 1u << 11u, Pd = 1u << 12u, Ps = 1u << 13u, Pe = 1u << 14u, Pi = 1u << 15u, Pf = 1u << 16u, Po = 1u << 17u,
        P = Pc | Pd | Ps | Pe | Pi | Pf | Po,
        Sm = 1u << 18u, Sc = 1u << 19u, Sk = 1u << 20u, So = 1u << 21u,
        S = Sm | Sc | Sk | So,
        Zs = 1u << 22u, Zl = 1u << 23u, Zp = 1u << 24u,
        Z = Zs | Zl | Zp,
        Cc = 1u << 25u, Cf = 1u << 26u, Cs = 1u << 27u, Co = 1u << 28u, Cn = 1u << 29u,
        C = Cc | Cf | Cs | Co | Cn,
        G = L | M | N | P | S | Zs,
        B = L | N | P | S | Zs
    }

    public class GeneralCategory
    {
        public nothrow GeneralCategory(GeneralCategoryId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow GeneralCategoryId Id()
        {
            return id;
        }
        public inline nothrow const string& ShortName()
        {
            return shortName;
        }
        public inline nothrow const string& LongName()
        {
            return longName;
        }
        private GeneralCategoryId id;
        private string shortName;
        private string longName;
    }

    public class GeneralCategoryTable
    {
        static GeneralCategoryTable() : instance(new GeneralCategoryTable())
        {
        }
        public static GeneralCategoryTable& Instance()
        {
            return *instance;
        }
        public nothrow const GeneralCategory* GetGeneralCategory(GeneralCategoryId id) const
        {
            HashMap<uint, void*>.ConstIterator it = generalCategoryIdMap.CFind(cast<uint>(id));
            if (it != generalCategoryIdMap.CEnd())
            {
                return cast<GeneralCategory*>(it->second);
            }
            return null;
        }
        public const GeneralCategory* GetGeneralCategoryByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<GeneralCategory*>(it->second);
            }
            return null;
        }
        public const GeneralCategory* GetGeneralCategoryByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<GeneralCategory*>(it->second);
            }
            return null;
        }
        private GeneralCategoryTable() : generalCategories(), generalCategoryIdMap(), shortNameMap(), longNameMap()
        {
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Lu, "Lu", "Uppercase Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Lu, "Ll", "Lowercase Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Lt, "Lt", "Titlecase Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.LC, "LC", "Cased Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Lm, "Lm", "Modifier Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Lo, "Lo", "Other Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.L, "L", "Letter"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Mn, "Mn", "Nonspacing Mark"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Mc, "Mc", "Spacing Mark"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Me, "Me", "Enclosing Mark"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.M, "M", "Mark"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Nd, "Nd", "Decimal Number"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Nl, "Nl", "Letter Number"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.No, "No", "Other Number"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.N, "N", "Number"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Pc, "Pc", "Connector Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Pd, "Pd", "Dash Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Ps, "Ps", "Open Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Pe, "Pe", "Close Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Pi, "Pi", "Initial Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Pf, "Pf", "Final Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Po, "Po", "Other Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.P, "P", "Punctuation"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Sm, "Sm", "Math Symbol"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Sc, "Sc", "Currency Symbol"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Sk, "Sk", "Modifier Symbol"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.So, "So", "Other Symbol"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.S, "S", "Symbol"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Zs, "Zs", "Space Separator"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Zl, "Zl", "Line Separator"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Zp, "Zp", "Paragraph Separator"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Z, "Z", "Separator"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Cc, "Cc", "Control"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Cf, "Cf", "Format"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Cs, "Cs", "Surrogate"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Co, "Co", "Private Use"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.Cn, "Cn", "Unassigned"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.C, "C", "Other"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.G, "G", "Graphic"));
            generalCategories.Add(new GeneralCategory(GeneralCategoryId.B, "B", "Base"));
            for (GeneralCategory* generalCategory : generalCategories)
            {
                generalCategoryIdMap[generalCategory->Id()] = generalCategory;
                shortNameMap[MakeCanonicalPropertyName(generalCategory->ShortName())] = generalCategory;
                longNameMap[MakeCanonicalPropertyName(generalCategory->LongName())] = generalCategory;
            }
        }
        public ~GeneralCategoryTable()
        {
            for (GeneralCategory* generalCategory : generalCategories)
            {
                delete generalCategory;
            }
        }
        private static UniquePtr<GeneralCategoryTable> instance;
        private List<GeneralCategory*> generalCategories;
        private HashMap<uint, void*> generalCategoryIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
    }

    public const GeneralCategory* GetGeneralCategory(GeneralCategoryId id)
    {
        return GeneralCategoryTable.Instance().GetGeneralCategory(id);
    }
    
    public const GeneralCategory* GetGeneralCategoryByShortName(const string& shortName)
    {
        return GeneralCategoryTable.Instance().GetGeneralCategoryByShortName(shortName);
    }
    
    public const GeneralCategory* GetGeneralCategoryByLongName(const string& longName)
    {
        return GeneralCategoryTable.Instance().GetGeneralCategoryByLongName(longName);
    }
    
    public enum AgeId : byte
    {
        age_unassigned = 0u,
        age_1_1, 
        age_2_0, age_2_1,
        age_3_0, age_3_1, age_3_2,
        age_4_0, age_4_1,
        age_5_0, age_5_1, age_5_2,
        age_6_0, age_6_1, age_6_2, age_6_3,
        age_7_0,
        age_8_0,
        age_9_0,
        age_10_0,
        age_11_0
    }

    public class Age
    {
        public nothrow Age(AgeId id_, const string& version_) : id(id_), version(version_)
        {
        }
        public inline nothrow AgeId Id() const
        {
            return id;
        }
        public inline nothrow const string& Version() const
        {
            return version; 
        }
        private AgeId id;
        private string version;
    }

    public class AgeTable
    {
        static AgeTable() : instance(new AgeTable())
        {
        }
        public static AgeTable& Instance()
        {
            return *instance;
        }
        public const Age* GetAge(AgeId id) const
        {
            HashMap<uint, void*>.ConstIterator it = ageIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != ageIdMap.CEnd())
            {
                return cast<Age*>(it->second);
            }
            return null;
        }
        public const Age* GetAge(const string& version) const
        {
            HashMap<string, void*>.ConstIterator it = versionMap.CFind(version);
            if (it != versionMap.CEnd())
            {
                return cast<Age*>(it->second);
            }
            return null;
        }
        private AgeTable() : ages(), ageIdMap(), versionMap()
        {
            ages.Add(new Age(AgeId.age_1_1, "1.1"));
            ages.Add(new Age(AgeId.age_2_0, "2.0"));
            ages.Add(new Age(AgeId.age_2_1, "2.1"));
            ages.Add(new Age(AgeId.age_3_0, "3.0"));
            ages.Add(new Age(AgeId.age_3_1, "3.1"));
            ages.Add(new Age(AgeId.age_3_2, "3.2"));
            ages.Add(new Age(AgeId.age_4_0, "4.0"));
            ages.Add(new Age(AgeId.age_4_1, "4.1"));
            ages.Add(new Age(AgeId.age_5_0, "5.0"));
            ages.Add(new Age(AgeId.age_5_1, "5.1"));
            ages.Add(new Age(AgeId.age_5_2, "5.2"));
            ages.Add(new Age(AgeId.age_6_0, "6.0"));
            ages.Add(new Age(AgeId.age_6_1, "6.1"));
            ages.Add(new Age(AgeId.age_6_2, "6.2"));
            ages.Add(new Age(AgeId.age_6_3, "6.3"));
            ages.Add(new Age(AgeId.age_7_0, "7.0"));
            ages.Add(new Age(AgeId.age_8_0, "8.0"));
            ages.Add(new Age(AgeId.age_9_0, "9.0"));
            ages.Add(new Age(AgeId.age_10_0, "10.0"));
            ages.Add(new Age(AgeId.age_11_0, "11.0"));
            for (Age* age : ages)
            {
                ageIdMap[cast<uint>(cast<byte>(age->Id()))] = age;
                versionMap[age->Version()] = age;
            }
        }
        public ~AgeTable()
        {
            for (Age* age : ages)
            {
                delete age;
            }
        }
        private static UniquePtr<AgeTable> instance;
        private List<Age*> ages;
        private HashMap<uint, void*> ageIdMap;
        private HashMap<string, void*> versionMap;
    }

    public const Age* GetAge(AgeId id)
    {
        return AgeTable.Instance().GetAge(id);
    }

    public const Age* GetAge(const string& version)
    {
        return AgeTable.Instance().GetAge(version);
    }

    public enum ScriptId : byte
    {
        none = 0u,
        adlm, aghb, ahom, arab, armi, armn, avst,
        bali, bamu, bass, batk, beng, bhks, bopo, brah, brai, bugi, buhd,
        cakm, cans, cari, cham, cher, copt, cprt, cyrl,
        deva, dogr, dsrt, dupl, 
        elba, egyp, ethi, 
        geor, glag, gong, gonm, goth, gran, grek, gujr, guru, 
        hang, hani, hano, hatr, hebr, hira, hluw, hmng, hrkt, hung,
        ital, 
        java,
        kali, kana, khar, khmr, khoj, knda, kthi, 
        lana, laoo, latn, lepc, limb, lina, linb, lisu, lyci, lydi,
        mahj, maka, mand, mani, marc, medf, mend, merc, mero, mlym, modi, mong, mroo, mtei, mult, mymr,
        narb, nbat, newa, nkoo, nshu,
        ogam, olck, orkh, orya, osge, osma, 
        palm, pauc, perm, phag, phli, phlp, phnx, plrd, prti,
        qaai,
        rjng, rohg, runr, 
        samr, sarb, saur, sgnw, shaw, shrd, sidd, sind, sinh, sogd, sogo, sora, soyo, sund, sylo, syrc, 
        tagb, takr, tale, talu, taml, tang, tavt, telu, tfng, tglg, thaa, thai, tibt, tirh,
        ugar,
        vaii, 
        wara,
        xpeo, xsux,
        yiii, zanb,
        zinh, zyyy, zzzz
    }
    
    public class Script
    {
        public nothrow Script(ScriptId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow ScriptId Id() const
        {
            return id;
        }
        public inline nothrow const string& ShortName() const
        {
            return shortName;
        }
        public inline nothrow const string& LongName() const
        {
            return longName;
        }
        private ScriptId id;
        private string shortName;
        private string longName;
    }
    
    public class ScriptTable
    {
        static ScriptTable() : instance(new ScriptTable())
        {
        }
        public static ScriptTable& Instance()
        {
            return *instance;
        }
        public const Script* GetScript(ScriptId id) const
        {
            HashMap<uint, void*>.ConstIterator it = scriptIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != scriptIdMap.CEnd())
            {
                return cast<Script*>(it->second);
            }
            return null;
        }
        public const Script* GetScriptByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<Script*>(it->second);
            }
            return null;
        }
        public const Script* GetScriptByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<Script*>(it->second);
            }
            return null;
        }
        private ScriptTable() : scripts(), scriptIdMap(), shortNameMap(), longNameMap()
        {
            scripts.Add(new Script(ScriptId.adlm, "Adlm", "Adlam"));
            scripts.Add(new Script(ScriptId.aghb, "Aghb", "Caucasian Albanian"));
            scripts.Add(new Script(ScriptId.ahom, "Ahom", "Ahom"));
            scripts.Add(new Script(ScriptId.arab, "Arab", "Arabic"));
            scripts.Add(new Script(ScriptId.armi, "Armi", "Imperial Aramaic"));
            scripts.Add(new Script(ScriptId.armn, "Armn", "Armenian"));
            scripts.Add(new Script(ScriptId.avst, "Avst", "Avestan"));
            scripts.Add(new Script(ScriptId.bali, "Bali", "Balinese"));
            scripts.Add(new Script(ScriptId.bamu, "Bamu", "Bamum"));
            scripts.Add(new Script(ScriptId.bass, "Bass", "Bassa Vah"));
            scripts.Add(new Script(ScriptId.batk, "Batk", "Batak")); 
            scripts.Add(new Script(ScriptId.beng, "Beng", "Bengali"));
            scripts.Add(new Script(ScriptId.bhks, "Bhks", "Bhaisuki"));
            scripts.Add(new Script(ScriptId.bopo, "Bopo", "Bopomofo"));
            scripts.Add(new Script(ScriptId.brah, "Brah", "Brahmi"));
            scripts.Add(new Script(ScriptId.brai, "Brai", "Braille"));
            scripts.Add(new Script(ScriptId.bugi, "Bugi", "Buginese"));
            scripts.Add(new Script(ScriptId.buhd, "Buhd", "Buhid"));
            scripts.Add(new Script(ScriptId.cakm, "Cakm", "Chakma"));
            scripts.Add(new Script(ScriptId.cans, "Cans", "Canadian Aboriginal"));
            scripts.Add(new Script(ScriptId.cari, "Cari", "Carian"));
            scripts.Add(new Script(ScriptId.cham, "Cham", "Cham"));
            scripts.Add(new Script(ScriptId.cher, "Cher", "Cherokee"));
            scripts.Add(new Script(ScriptId.copt, "Copt", "Coptic"));
            scripts.Add(new Script(ScriptId.cprt, "Cprt", "Cypriot"));
            scripts.Add(new Script(ScriptId.cyrl, "Cyrl", "Cyrillic"));
            scripts.Add(new Script(ScriptId.deva, "Deva", "Devanagari"));
            scripts.Add(new Script(ScriptId.dogr, "Dogr", "Dogra"));
            scripts.Add(new Script(ScriptId.dsrt, "Dsrt", "Deseret"));
            scripts.Add(new Script(ScriptId.dupl, "Dupl", "Duployan"));
            scripts.Add(new Script(ScriptId.egyp, "Egyp", "Egyptian Hieroglyphs"));
            scripts.Add(new Script(ScriptId.elba, "Elba", "Elbasan"));
            scripts.Add(new Script(ScriptId.ethi, "Ethi", "Ethiopian"));
            scripts.Add(new Script(ScriptId.geor, "Geor", "Georgian"));
            scripts.Add(new Script(ScriptId.glag, "Glag", "Glagolitic"));
            scripts.Add(new Script(ScriptId.gong, "Gong", "Gunjala Gondi"));
            scripts.Add(new Script(ScriptId.gonm, "Gonm", "Masaram Gondi"));
            scripts.Add(new Script(ScriptId.goth, "Goth", "Gothic"));
            scripts.Add(new Script(ScriptId.gran, "Gran", "Grantha"));
            scripts.Add(new Script(ScriptId.grek, "Grek", "Greek"));
            scripts.Add(new Script(ScriptId.gujr, "Gujr", "Gujarati"));
            scripts.Add(new Script(ScriptId.guru, "Guru", "Gurmukhi"));
            scripts.Add(new Script(ScriptId.hang, "Hang", "Hangul"));
            scripts.Add(new Script(ScriptId.hani, "Hani", "Han"));
            scripts.Add(new Script(ScriptId.hano, "Hano", "Hanunoo"));
            scripts.Add(new Script(ScriptId.hatr, "Hatr", "Hatran"));
            scripts.Add(new Script(ScriptId.hebr, "Hebr", "Hebrew"));
            scripts.Add(new Script(ScriptId.hira, "Hira", "Hiragana"));
            scripts.Add(new Script(ScriptId.hluw, "Hluw", "Anatolian Hieroglyphs"));
            scripts.Add(new Script(ScriptId.hmng, "Hmng", "Pahawh Hmong"));
            scripts.Add(new Script(ScriptId.hrkt, "Hrkt", "Katakana Or Hiragana"));
            scripts.Add(new Script(ScriptId.hung, "Hung", "Old Hungarian"));
            scripts.Add(new Script(ScriptId.ital, "Ital", "Old Italic"));
            scripts.Add(new Script(ScriptId.java, "Java", "Javanese"));
            scripts.Add(new Script(ScriptId.kali, "Kali", "Kayah Li"));
            scripts.Add(new Script(ScriptId.kana, "Kana", "Katakana"));
            scripts.Add(new Script(ScriptId.khar, "Khar", "Kharoshthi"));
            scripts.Add(new Script(ScriptId.khmr, "Khmr", "Khmer"));
            scripts.Add(new Script(ScriptId.khoj, "Khoj", "Khojki"));
            scripts.Add(new Script(ScriptId.knda, "Knda", "Kannada"));
            scripts.Add(new Script(ScriptId.kthi, "Kthi", "Kaithi"));
            scripts.Add(new Script(ScriptId.lana, "Lana", "Tai Tham"));
            scripts.Add(new Script(ScriptId.laoo, "Laoo", "Lao"));
            scripts.Add(new Script(ScriptId.latn, "Latn", "Latin"));
            scripts.Add(new Script(ScriptId.lepc, "Lepc", "Lepcha"));
            scripts.Add(new Script(ScriptId.limb, "Limb", "Limbu"));
            scripts.Add(new Script(ScriptId.lina, "Lina", "Linear A"));
            scripts.Add(new Script(ScriptId.linb, "Linb", "Linear B"));
            scripts.Add(new Script(ScriptId.lisu, "Lisu", "Lisu"));
            scripts.Add(new Script(ScriptId.lyci, "Lyci", "Lycian"));
            scripts.Add(new Script(ScriptId.lydi, "Lydi", "Lydian"));
            scripts.Add(new Script(ScriptId.mahj, "Mahj", "Mahajani"));
            scripts.Add(new Script(ScriptId.maka, "Maka", "Makasar"));
            scripts.Add(new Script(ScriptId.mand, "Mand", "Mandaic"));
            scripts.Add(new Script(ScriptId.mani, "Mani", "Manichaean"));
            scripts.Add(new Script(ScriptId.marc, "Marc", "Marchen"));
            scripts.Add(new Script(ScriptId.medf, "Medf", "Medefaidrin"));
            scripts.Add(new Script(ScriptId.mend, "Mend", "Mende Kikakui"));
            scripts.Add(new Script(ScriptId.merc, "Merc", "Meroitic Cursive"));
            scripts.Add(new Script(ScriptId.mero, "Mero", "Meroitic Hieroglyphs"));
            scripts.Add(new Script(ScriptId.mlym, "Mlym", "Malayalam"));
            scripts.Add(new Script(ScriptId.modi, "Modi", "Modi"));
            scripts.Add(new Script(ScriptId.mong, "Mong", "Mongolian"));
            scripts.Add(new Script(ScriptId.mroo, "Mroo", "Mro"));
            scripts.Add(new Script(ScriptId.mtei, "Mtei", "Meetei Mayak"));
            scripts.Add(new Script(ScriptId.mult, "Mult", "Multani"));
            scripts.Add(new Script(ScriptId.mymr, "Mymr", "Myanmar"));
            scripts.Add(new Script(ScriptId.narb, "Narb", "Old North Arabian"));
            scripts.Add(new Script(ScriptId.nbat, "Nbat", "Nabataean"));
            scripts.Add(new Script(ScriptId.newa, "Newa", "Newa"));
            scripts.Add(new Script(ScriptId.nkoo, "Nkoo", "Nko"));
            scripts.Add(new Script(ScriptId.nshu, "Nshu", "Nushu"));
            scripts.Add(new Script(ScriptId.ogam, "Ogam", "Ogham"));
            scripts.Add(new Script(ScriptId.olck, "Olck", "Ol Chiki"));
            scripts.Add(new Script(ScriptId.orkh, "Orkh", "Old Turkic"));
            scripts.Add(new Script(ScriptId.orya, "Orya", "Oriya"));
            scripts.Add(new Script(ScriptId.osge, "Osge", "Osage"));
            scripts.Add(new Script(ScriptId.osma, "Osma", "Osmanya"));
            scripts.Add(new Script(ScriptId.palm, "Palm", "Palmyrene"));
            scripts.Add(new Script(ScriptId.pauc, "Pauc", "Pau Cin Hau"));
            scripts.Add(new Script(ScriptId.perm, "Perm", "Old Permic"));
            scripts.Add(new Script(ScriptId.phag, "Phag", "Phags Pa"));
            scripts.Add(new Script(ScriptId.phli, "Phli", "Inscriptional Pahlavi"));
            scripts.Add(new Script(ScriptId.phlp, "Phlp", "Psalter Pahlavi"));
            scripts.Add(new Script(ScriptId.phnx, "Phnx", "Phoenician"));
            scripts.Add(new Script(ScriptId.plrd, "Plrd", "Miao"));
            scripts.Add(new Script(ScriptId.prti, "Prti", "Inscriptional Parthian"));
            scripts.Add(new Script(ScriptId.rjng, "Rjng", "Rejang"));
            scripts.Add(new Script(ScriptId.rohg, "Rohg", "Hanifi Rohingya"));
            scripts.Add(new Script(ScriptId.runr, "Runr", "Runic"));
            scripts.Add(new Script(ScriptId.samr, "Samr", "Samaritan"));
            scripts.Add(new Script(ScriptId.sarb, "Sarb", "Old South Arabian"));
            scripts.Add(new Script(ScriptId.saur, "Saur", "Saurashtra"));
            scripts.Add(new Script(ScriptId.sgnw, "Sgnw", "SignWriting"));
            scripts.Add(new Script(ScriptId.shaw, "Shaw", "Shawian"));
            scripts.Add(new Script(ScriptId.shrd, "Shrd", "Sharada"));
            scripts.Add(new Script(ScriptId.sidd, "Sidd", "Shiddham"));
            scripts.Add(new Script(ScriptId.sind, "Sind", "Khudawadi"));
            scripts.Add(new Script(ScriptId.sinh, "Sinh", "Sinhala"));
            scripts.Add(new Script(ScriptId.sogd, "Sogd", "Sogdian"));
            scripts.Add(new Script(ScriptId.sogo, "Sogo", "Old Sogdian"));
            scripts.Add(new Script(ScriptId.sora, "Sora", "Sora Sompeng"));
            scripts.Add(new Script(ScriptId.soyo, "Soyo", "Soyombo"));
            scripts.Add(new Script(ScriptId.sund, "Sund", "Sundanese"));
            scripts.Add(new Script(ScriptId.sylo, "Sylo", "Syloti Nagri"));
            scripts.Add(new Script(ScriptId.syrc, "Syrc", "Syriac"));
            scripts.Add(new Script(ScriptId.tagb, "Tagb", "Tagbanwa"));
            scripts.Add(new Script(ScriptId.takr, "Takr", "Takri"));
            scripts.Add(new Script(ScriptId.tale, "Tale", "Tai Le"));
            scripts.Add(new Script(ScriptId.talu, "Talu", "New Tai Lue"));
            scripts.Add(new Script(ScriptId.taml, "Taml", "Tamil"));
            scripts.Add(new Script(ScriptId.tang, "Tang", "Tangut"));
            scripts.Add(new Script(ScriptId.tavt, "Tavt", "Tai Viet"));
            scripts.Add(new Script(ScriptId.telu, "Telu", "Telugu"));
            scripts.Add(new Script(ScriptId.tfng, "Tfng", "Tifinag"));
            scripts.Add(new Script(ScriptId.tglg, "Tglg", "Tagalog"));
            scripts.Add(new Script(ScriptId.thaa, "Thaa", "Thaana"));
            scripts.Add(new Script(ScriptId.thai, "Thai", "Thai"));
            scripts.Add(new Script(ScriptId.tibt, "Tibt", "Tibetan"));
            scripts.Add(new Script(ScriptId.tirh, "Tirh", "Tirhuta"));
            scripts.Add(new Script(ScriptId.ugar, "Ugar", "Ugaritic"));
            scripts.Add(new Script(ScriptId.vaii, "Vaii", "Vai"));
            scripts.Add(new Script(ScriptId.wara, "Wara", "Warang Citi"));
            scripts.Add(new Script(ScriptId.xpeo, "Xpeo", "Old Persian"));
            scripts.Add(new Script(ScriptId.xsux, "Xsux", "Cuneiform"));
            scripts.Add(new Script(ScriptId.yiii, "Yiii", "Yi"));
            scripts.Add(new Script(ScriptId.zanb, "Zanb", "Zanabazar Square"));
            scripts.Add(new Script(ScriptId.zinh, "Zinh", "Inherited"));
            scripts.Add(new Script(ScriptId.zyyy, "Zyyy", "Common"));
            scripts.Add(new Script(ScriptId.zzzz, "Zzzz", "Unknown"));
            for (Script* script : scripts)
            {
                scriptIdMap[cast<uint>(cast<byte>(script->Id()))] = script;
                shortNameMap[MakeCanonicalPropertyName(script->ShortName())] = script;
                longNameMap[MakeCanonicalPropertyName(script->LongName())] = script;
            }
        }
        public ~ScriptTable()
        {
            for (Script* script : scripts)
            {
                delete script;
            }
        }
        private static UniquePtr<ScriptTable> instance;
        private List<Script*> scripts;
        private HashMap<uint, void*> scriptIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
    }            

    public const Script* GetScript(ScriptId id)
    {
        return ScriptTable.Instance().GetScript(id);
    }

    public const Script* GetScriptByShortName(const string& shortName)
    {
        return ScriptTable.Instance().GetScriptByShortName(shortName);
    }

    public const Script* GetScriptByLongName(const string& longName)
    {
        return ScriptTable.Instance().GetScriptByLongName(longName);
    }
    
    public class CharacterInfo
    {
        public nothrow CharacterInfo() : 
            binaryProperties(0u), generalCategory(GeneralCategoryId.none), upper(cast<uchar>(0u)), lower(cast<uchar>(0u)), title(cast<uchar>(0u)), 
            folding(cast<uchar>(0u)), block(BlockId.none), age(AgeId.age_unassigned), script(ScriptId.none)
        {
        }
        public inline nothrow bool GetBinaryProperty(BinaryPropertyId binaryPropertyId) const
        {
            ulong mask = cast<ulong>(1u) << cast<ulong>(cast<byte>(binaryPropertyId));
            return (binaryProperties & mask) != 0u;
        }
        public inline nothrow bool HasGeneralCategory(GeneralCategoryId generalCategory_) const
        {
            return (generalCategory & generalCategory_) != GeneralCategoryId.none;
        }
        public inline nothrow GeneralCategoryId GeneralCategoryValue() const
        {
            return generalCategory;
        }
        public inline nothrow uchar Upper() const
        {
            return upper;
        }
        public inline nothrow uchar Lower() const
        {
            return lower;
        }
        public inline nothrow uchar Title() const
        {
            return title;
        }
        public inline nothrow uchar Folding() const
        {
            return folding;
        }
        public inline nothrow BlockId BlockValue() const
        {
            return block;
        }
        public inline nothrow AgeId AgeValue() const
        {
            return age;
        }
        public inline nothrow ScriptId ScriptValue() const
        {
            return script;
        }
        public void Read(BinaryReader& reader)
        {
            binaryProperties = reader.ReadULong();
            generalCategory = cast<GeneralCategoryId>(reader.ReadUInt());
            upper = reader.ReadUChar();
            lower = reader.ReadUChar();
            title = reader.ReadUChar();
            folding = reader.ReadUChar();
            block = cast<BlockId>(reader.ReadUShort());
            age = cast<AgeId>(reader.ReadByte());
            script = cast<ScriptId>(reader.ReadByte());
        }
        private ulong binaryProperties;
        private GeneralCategoryId generalCategory;
        private uchar upper;
        private uchar lower;
        private uchar title;
        private uchar folding;
        private BlockId block;
        private AgeId age;
        private ScriptId script;
    }

    public const long numInfosInPage = 1024;
    public const uint characterInfoSize = 32u;
    public const uint characterInfoPageSize = cast<uint>(numInfosInPage) * characterInfoSize;

    public enum NumericTypeId : byte
    {
        none = 0u,
        de, di, nu
    }

    public class NumericType
    {
        public nothrow NumericType(NumericTypeId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow NumericTypeId Id() const
        {
            return id;
        }
        public inline nothrow const string& ShortName() const
        {
            return shortName;
        }
        public inline nothrow const string& LongName() const
        {
            return longName;
        }
        private NumericTypeId id;
        private string shortName;
        private string longName;
    }
    
    public class NumericTypeTable
    {
        static NumericTypeTable() : instance(new NumericTypeTable())
        {
        }
        public static NumericTypeTable& Instance()
        {
            return *instance;
        }
        public const NumericType* GetNumericType(NumericTypeId id) const
        {
            HashMap<uint, void*>.ConstIterator it = numericTypeIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != numericTypeIdMap.CEnd())
            {
                return cast<NumericType*>(it->second);
            }
            return null;
        }
        public const NumericType* GetNumericTypeByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<NumericType*>(it->second);
            }
            return null;
        }
        public const NumericType* GetNumericTypeByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<NumericType*>(it->second);
            }
            return null;
        }
        private NumericTypeTable() : numericTypes(), numericTypeIdMap(), shortNameMap(), longNameMap()
        {
            numericTypes.Add(new NumericType(NumericTypeId.none, "None", "None"));
            numericTypes.Add(new NumericType(NumericTypeId.de, "De", "Decimal"));
            numericTypes.Add(new NumericType(NumericTypeId.di, "Di", "Digit"));
            numericTypes.Add(new NumericType(NumericTypeId.nu, "Nu", "Numeric"));
            for (NumericType* numericType : numericTypes)
            {
                numericTypeIdMap[cast<uint>(cast<byte>(numericType->Id()))] = numericType;
                shortNameMap[MakeCanonicalPropertyName(numericType->ShortName())] = numericType;
                longNameMap[MakeCanonicalPropertyName(numericType->LongName())] = numericType;
            }
        }
        public ~NumericTypeTable()
        {
            for (NumericType* numericType : numericTypes)
            {
                delete numericType;
            }
        }
        private List<NumericType*> numericTypes;
        private HashMap<uint, void*> numericTypeIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
        private static UniquePtr<NumericTypeTable> instance;
    }

    public const NumericType* GetNumericType(NumericTypeId id)
    {
        return NumericTypeTable.Instance().GetNumericType(id);
    }

    public const NumericType* GetNumericTypeByShortName(const string& shortName)
    {
        return NumericTypeTable.Instance().GetNumericTypeByShortName(shortName);
    }

    public const NumericType* GetNumericTypeByLongName(const string& longName)
    {
        return NumericTypeTable.Instance().GetNumericTypeByLongName(longName);
    }

    public enum BidiClassId : byte
    {
        none = 0u,
        al, an, b, bn, cs, en, es, et, fsi, l, lre, lri, lro, nsm, on, pdf, pdi, r, rle, rli, rlo, s, ws
    }
    
    public class BidiClass
    {
        public nothrow BidiClass(BidiClassId id_, const string& shortName_, const string& longName_) : id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow BidiClassId Id() const
        {
            return id;
        }
        public inline nothrow const string& ShortName() const
        {
            return shortName;
        }
        public inline nothrow const string& LongName() const
        {
            return longName;
        }
        private BidiClassId id;
        private string shortName;
        private string longName;
    }
    
    public class BidiClassTable
    {
        static BidiClassTable() : instance(new BidiClassTable())
        {
        }
        public static BidiClassTable& Instance() 
        {
            return *instance;
        }
        public const BidiClass* GetBidiClass(BidiClassId id) const
        {
            HashMap<uint, void*>.ConstIterator it = bidiClassIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != bidiClassIdMap.CEnd())
            {
                return cast<BidiClass*>(it->second);
            }
            return null;
        }
        public const BidiClass* GetBidiClassByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<BidiClass*>(it->second);
            }
            return null;
        }
        public const BidiClass* GetBidiClassByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(MakeCanonicalPropertyName(longName));
            if (it != longNameMap.CEnd())
            {
                return cast<BidiClass*>(it->second);
            }
            return null;
        }
        private BidiClassTable() : bidiClasses(), bidiClassIdMap(), shortNameMap(), longNameMap()
        {
            bidiClasses.Add(new BidiClass(BidiClassId.al, "AL", "Arabic Letter"));
            bidiClasses.Add(new BidiClass(BidiClassId.an, "AN", "Arabic Number"));
            bidiClasses.Add(new BidiClass(BidiClassId.b, "B", "Paragraph Separator"));
            bidiClasses.Add(new BidiClass(BidiClassId.bn, "BN", "Boundary Neutral"));
            bidiClasses.Add(new BidiClass(BidiClassId.cs, "CS", "Common Separator"));
            bidiClasses.Add(new BidiClass(BidiClassId.en, "EN", "European Number"));
            bidiClasses.Add(new BidiClass(BidiClassId.es, "ES", "European Separator"));
            bidiClasses.Add(new BidiClass(BidiClassId.et, "ET", "European Terminator"));
            bidiClasses.Add(new BidiClass(BidiClassId.fsi, "FSI", "First Strong Isolate"));
            bidiClasses.Add(new BidiClass(BidiClassId.l, "L", "Left To Right"));
            bidiClasses.Add(new BidiClass(BidiClassId.lre, "LRE", "Left To Right Embedding"));
            bidiClasses.Add(new BidiClass(BidiClassId.lri, "LRI", "Left To Right Isolate"));
            bidiClasses.Add(new BidiClass(BidiClassId.lro, "LRO", "Left To Right Override"));
            bidiClasses.Add(new BidiClass(BidiClassId.nsm, "NSM", "Nonspacing Mark"));
            bidiClasses.Add(new BidiClass(BidiClassId.on, "ON", "Other Neutral"));
            bidiClasses.Add(new BidiClass(BidiClassId.pdf, "PDF", "Pop Directional Format"));
            bidiClasses.Add(new BidiClass(BidiClassId.pdi, "PDI", "Pop Directional Isolate"));
            bidiClasses.Add(new BidiClass(BidiClassId.r, "R", "Right To Left"));
            bidiClasses.Add(new BidiClass(BidiClassId.rle, "RLE", "Right To Left Embedding"));
            bidiClasses.Add(new BidiClass(BidiClassId.rli, "RLI", "Right To Left Isolate"));
            bidiClasses.Add(new BidiClass(BidiClassId.rlo, "RLO", "Right To Left Override"));
            bidiClasses.Add(new BidiClass(BidiClassId.s, "S", "Segment Separator"));
            bidiClasses.Add(new BidiClass(BidiClassId.ws, "WS", "White Space"));
            for (BidiClass* bidiClass : bidiClasses)
            {
                bidiClassIdMap[cast<uint>(cast<byte>(bidiClass->Id()))] = bidiClass;
                shortNameMap[MakeCanonicalPropertyName(bidiClass->ShortName())] = bidiClass;
                longNameMap[MakeCanonicalPropertyName(bidiClass->LongName())] = bidiClass;
            }
        }
        public ~BidiClassTable()
        {
            for (BidiClass* bidiClass : bidiClasses)
            {
                delete bidiClass;
            }
        }
        private static UniquePtr<BidiClassTable> instance;
        private List<BidiClass*> bidiClasses;
        private HashMap<uint, void*> bidiClassIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
    }
     
    public const BidiClass* GetBidiClass(BidiClassId id)
    {
        return BidiClassTable.Instance().GetBidiClass(id);
    }

    public const BidiClass* GetBidiClassByShortName(const string& shortName)
    {
        return BidiClassTable.Instance().GetBidiClassByShortName(shortName);
    }

    public const BidiClass* GetBidiClassByLongName(const string& longName)
    {
        return BidiClassTable.Instance().GetBidiClassByLongName(longName);
    }

    public enum BidiPairedBracketTypeId : byte
    {
        none = 0u,
        o, c
    }

    public class BidiPairedBracketType
    {
        public nothrow BidiPairedBracketType(BidiPairedBracketTypeId id_, const string& shortName_, const string& longName_) : 
            id(id_), shortName(shortName_), longName(longName_)
        {
        }
        public inline nothrow BidiPairedBracketTypeId Id() const 
        {
            return id;
        }
        public inline nothrow const string& ShortName() const
        {
            return shortName;
        }
        public inline nothrow const string& LongName() const
        {
            return longName;
        }
        private BidiPairedBracketTypeId id;
        private string shortName;
        private string longName;
    }
    
    public class BidiPairedBracketTypeTable
    {
        static BidiPairedBracketTypeTable() : instance(new BidiPairedBracketTypeTable())
        {
        }
        public static BidiPairedBracketTypeTable& Instance()
        {
            return *instance; 
        }
        public const BidiPairedBracketType* GetBidiPairedBracketType(BidiPairedBracketTypeId id) const
        {
            HashMap<uint, void*>.ConstIterator it = bidiPairedBracketTypeIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != bidiPairedBracketTypeIdMap.CEnd())
            {
                return cast<BidiPairedBracketType*>(it->second);
            }
            return null;
        }
        public const BidiPairedBracketType* GetBidiPairedBracketTypeByShortName(const string& shortName) const
        {
            HashMap<string, void*>.ConstIterator it = shortNameMap.CFind(MakeCanonicalPropertyName(shortName));
            if (it != shortNameMap.CEnd())
            {
                return cast<BidiPairedBracketType*>(it->second);
            }
            return null;
        }
        public const BidiPairedBracketType* GetBidiPairedBracketTypeByLongName(const string& longName) const
        {
            HashMap<string, void*>.ConstIterator it = longNameMap.CFind(longName);
            if (it != longNameMap.CEnd())
            {
                return cast<BidiPairedBracketType*>(it->second);
            }
            return null;
        }
        private BidiPairedBracketTypeTable() : bidiPairedBracketTypes(), bidiPairedBracketTypeIdMap(), shortNameMap(), longNameMap()
        {
            bidiPairedBracketTypes.Add(new BidiPairedBracketType(BidiPairedBracketTypeId.o, "O", "Open"));
            bidiPairedBracketTypes.Add(new BidiPairedBracketType(BidiPairedBracketTypeId.c, "C", "Close"));
            bidiPairedBracketTypes.Add(new BidiPairedBracketType(BidiPairedBracketTypeId.none, "N", "None"));
            for (BidiPairedBracketType* bidiPairedBracketType : bidiPairedBracketTypes)
            {
                bidiPairedBracketTypeIdMap[cast<uint>(cast<byte>(bidiPairedBracketType->Id()))] = bidiPairedBracketType;
                shortNameMap[MakeCanonicalPropertyName(bidiPairedBracketType->ShortName())] = bidiPairedBracketType;
                longNameMap[MakeCanonicalPropertyName(bidiPairedBracketType->LongName())] = bidiPairedBracketType;
            }
        }
        public ~BidiPairedBracketTypeTable()
        {
            for (BidiPairedBracketType* bidiPairedBracketType : bidiPairedBracketTypes)
            {
                delete bidiPairedBracketType;
            }
        }
        private static UniquePtr<BidiPairedBracketTypeTable> instance;
        private List<BidiPairedBracketType*> bidiPairedBracketTypes;
        private HashMap<uint, void*> bidiPairedBracketTypeIdMap;
        private HashMap<string, void*> shortNameMap;
        private HashMap<string, void*> longNameMap;
    }

    public const BidiPairedBracketType* GetBidiPairedBracketType(BidiPairedBracketTypeId id)
    {
        return BidiPairedBracketTypeTable.Instance().GetBidiPairedBracketType(id);
    }

    public const BidiPairedBracketType* GetBidiPairedBracketTypeByShortName(const string& shortName)
    {
        return BidiPairedBracketTypeTable.Instance().GetBidiPairedBracketTypeByShortName(shortName);
    }

    public const BidiPairedBracketType* GetBidiPairedBracketTypeByLongName(const string& longName)
    {
        return BidiPairedBracketTypeTable.Instance().GetBidiPairedBracketTypeByLongName(longName);
    }

    public enum AliasTypeId : byte
    {
        none = 0u,
        correction, control, alternate, figment, abbreviation
    }

    public class AliasType
    {
        public nothrow AliasType(AliasTypeId id_, const string& name_) : id(id_), name(name_)
        {
        }
        public nothrow inline AliasTypeId Id() const
        {
            return id;
        }
        public nothrow inline const string& Name() const
        {
            return name;
        }
        private AliasTypeId id;
        private string name;
    }
    
    public class AliasTypeTable
    {
        static AliasTypeTable() : instance(new AliasTypeTable())
        {
        }
        public static AliasTypeTable& Instance() 
        {
            return *instance;
        }
        public const AliasType* GetAliasType(AliasTypeId id) const
        {
            HashMap<uint, void*>.ConstIterator it = aliasTypeIdMap.CFind(cast<uint>(cast<byte>(id)));
            if (it != aliasTypeIdMap.CEnd())
            {
                return cast<AliasType*>(it->second);
            }
            return null;
        }
        public const AliasType* GetAliasType(const string& name) const
        {
            HashMap<string, void*>.ConstIterator it = nameMap.CFind(name);
            if (it != nameMap.CEnd())
            {
                return cast<AliasType*>(it->second);
            }
            return null;
        }
        private AliasTypeTable() : aliasTypes(), aliasTypeIdMap(), nameMap()
        {
            aliasTypes.Add(new AliasType(AliasTypeId.abbreviation, "abbreviation"));
            aliasTypes.Add(new AliasType(AliasTypeId.alternate, "alternate"));
            aliasTypes.Add(new AliasType(AliasTypeId.control, "control"));
            aliasTypes.Add(new AliasType(AliasTypeId.correction, "correction"));
            aliasTypes.Add(new AliasType(AliasTypeId.figment, "figment"));
            for (AliasType* aliasType : aliasTypes)
            {
                aliasTypeIdMap[cast<uint>(cast<byte>(aliasType->Id()))] = aliasType;
                nameMap[aliasType->Name()] = aliasType;
            }
        }
        public ~AliasTypeTable()
        {
            for (AliasType* aliasType : aliasTypes)
            {
                delete aliasType;
            }
        }
        private static UniquePtr<AliasTypeTable> instance;
        private List<AliasType*> aliasTypes;
        private HashMap<uint, void*> aliasTypeIdMap;
        private HashMap<string, void*> nameMap;
    }

    public const AliasType* GetAliasType(AliasTypeId id)
    {
        return AliasTypeTable.Instance().GetAliasType(id);
    }

    public const AliasType* GetAliasType(const string& name)
    {
        return AliasTypeTable.Instance().GetAliasType(name);
    }

    public class Alias
    {
        public nothrow Alias() : typeId(AliasTypeId.none), name()
        {
        }
        public nothrow Alias(AliasTypeId typeId_, const string& name_) : typeId(typeId_), name(name_)
        {
        }
        public inline nothrow AliasTypeId TypeId() const
        {
            return typeId;
        }
        public inline nothrow const string& Name() const
        {
            return name;
        }
        public void Read(BinaryReader& reader)
        {
            typeId = cast<AliasTypeId>(reader.ReadByte());
            name = reader.ReadString();
        }
        private AliasTypeId typeId;
        private string name;
    }

    public class ExtendedCharacterInfo
    {
        public nothrow ExtendedCharacterInfo() : 
            characterName(), unicode1Name(), canonicalCombiningClass(0u), fullUpper(), fullLower(), fullTitle(), fullFolding(), bidiClass(BidiClassId.none),
            numericType(NumericTypeId.none), numericValue(), aliases(), bidiMirroringGlyph(cast<uchar>(0u)), bidiPairedBracketType(BidiPairedBracketTypeId.none), 
            bidiPairedBracket(cast<uchar>(0u))
        {
        }
        public nothrow inline const string& CharacterName() const
        {
            return characterName;
        }
        public nothrow inline const string& Unicode1Name() const
        {
            return unicode1Name;
        }
        public nothrow inline byte CanonicalCombiningClass() const
        {
            return canonicalCombiningClass;
        }
        public nothrow inline const ustring& FullUpper() const
        {
            return fullUpper;
        }
        public nothrow inline const ustring& FullLower() const
        {
            return fullLower;
        }
        public nothrow inline const ustring& FullTitle() const
        {
            return fullTitle;
        }
        public nothrow inline const ustring& FullFolding() const
        {
            return fullFolding;
        }
        public nothrow inline BidiClassId BidiClassValue() const
        {
            return bidiClass;
        }
        public nothrow inline NumericTypeId NumericTypeValue() const
        {
            return numericType;
        }
        public nothrow inline const ustring& NumericValue() const
        {
            return numericValue;
        }
        public nothrow inline const List<Alias>& Aliases() const
        {
            return aliases;
        }
        public nothrow inline uchar BidiMirroringGlyph() const
        {
            return bidiMirroringGlyph;
        }
        public nothrow inline BidiPairedBracketTypeId BidiPairedBracketTypeValue() const
        {
            return bidiPairedBracketType;
        }
        public nothrow inline uchar BidiPairedBracket()
        {
            return bidiPairedBracket;
        }
        public void Read(BinaryReader& reader)
        {
            characterName = reader.ReadString();
            unicode1Name = reader.ReadString();
            canonicalCombiningClass = reader.ReadByte();
            byte nu = reader.ReadByte();
            for (byte i = 0u; i < nu; ++i)
            {
                fullUpper.Append(reader.ReadUChar());
            }
            byte nl = reader.ReadByte();
            for (byte i = 0u; i < nl; ++i)
            {
                fullLower.Append(reader.ReadUChar());
            }
            byte nt = reader.ReadByte();
            for (byte i = 0u; i < nt; ++i)
            {
                fullTitle.Append(reader.ReadUChar());
            }
            byte nf = reader.ReadByte();
            for (byte i = 0u; i < nf; ++i)
            {
                fullFolding.Append(reader.ReadUChar());
            }
            bidiClass = cast<BidiClassId>(reader.ReadByte());
            numericType = cast<NumericTypeId>(reader.ReadByte());
            numericValue = reader.ReadUString();
            byte na = reader.ReadByte();
            for (byte i = 0u; i < na; ++i)
            {
                Alias alias;
                alias.Read(reader);
                aliases.Add(alias);
            }
            bidiMirroringGlyph = reader.ReadUChar();
            bidiPairedBracketType = cast<BidiPairedBracketTypeId>(reader.ReadByte());
            bidiPairedBracket = reader.ReadUChar();
        }
        private string characterName;
        private string unicode1Name;
        private byte canonicalCombiningClass;
        private ustring fullUpper;
        private ustring fullLower;
        private ustring fullTitle;
        private ustring fullFolding;
        private BidiClassId bidiClass;
        private NumericTypeId numericType;
        private ustring numericValue;
        private List<Alias> aliases;
        private uchar bidiMirroringGlyph;
        private BidiPairedBracketTypeId bidiPairedBracketType;
        private uchar bidiPairedBracket;
    }
    
    public class CharacterInfoPage
    {
        public CharacterInfoPage() : characterInfos()
        {
            characterInfos.Resize(numInfosInPage);
        }
        public const CharacterInfo& operator[](long index) const
        {
            return *characterInfos[index];
        }
        public void Read(BinaryReader& reader)
        {
            for (long i = 0; i < numInfosInPage; ++i)
            {
                CharacterInfo* characterInfo = new CharacterInfo();
                characterInfo->Read(reader);
                characterInfos[i].Reset(characterInfo);
            }
        }
        private List<UniquePtr<CharacterInfo>> characterInfos;
    }
    
    public class ExtendedCharacterInfoPage
    {
        public ExtendedCharacterInfoPage() : extendedCharacterInfos()
        {
            extendedCharacterInfos.Resize(numInfosInPage);
        }
        public const ExtendedCharacterInfo& operator[](long index) const
        {
            return *extendedCharacterInfos[index];
        }
        public void Read(BinaryReader& reader)
        {
            for (long i = 0; i < numInfosInPage; ++i)
            {
                ExtendedCharacterInfo* extendedCharacterInfo = new ExtendedCharacterInfo();
                extendedCharacterInfo->Read(reader);
                extendedCharacterInfos[i].Reset(extendedCharacterInfo);
            }
        }
        private List<UniquePtr<ExtendedCharacterInfo>> extendedCharacterInfos;
    }
    
    public class ExtendedCharacterInfoHeader
    {
        public ExtendedCharacterInfoHeader() : extendedPageStarts()
        {
        }
        public uint operator[](long index) const
        {
            return extendedPageStarts[index]; 
        }
        public void Read(BinaryReader& reader)
        {
            uint n = reader.ReadUInt();
            extendedPageStarts.Resize(n);
            for (uint i = 0u; i < n; ++i)
            {
                extendedPageStarts[i] = reader.ReadUInt();
            }
        }
        private List<uint> extendedPageStarts;
    }
    
    public const byte cmajor_ucd_version_1 = cast<byte>('1');
    public const byte cmajor_ucd_version_2 = cast<byte>('2');
    public const byte current_cmajor_ucd_version = cmajor_ucd_version_2;
    
    public class CharacterTable
    {
        static CharacterTable() : instance(new CharacterTable())
        {
        }
        public static CharacterTable& Instance()
        {
            return *instance;
        }
        public const CharacterInfo& GetCharacterInfo(uchar codePoint)
        {
            if (codePoint > cast<uchar>(0x10FFFF))
            {
                throw UnicodeException("invalid Unicode code point " + ToHexString(cast<uint>(codePoint)));
            }
            long pageIndex = cast<long>(codePoint) / numInfosInPage;
            if (pages.Count() <= pageIndex)
            {
                LockGuard<Mutex> lock(characterTableLock);
                while (pages.Count() <= pageIndex)
                {
                    pages.Add(UniquePtr<CharacterInfoPage>());
                }
            }
            CharacterInfoPage* page = pages[pageIndex].Get();
            if (page == null)
            {
                LockGuard<Mutex> lock(characterTableLock);
                if (page == null)
                {
                    string pathToUcdBinFile = PathToUcdBinFile();
                    if (!File.Exists(pathToUcdBinFile))
                    {
                        throw UnicodeException("Error: Cmajor Unicode database file '" + pathToUcdBinFile + "' does not exist.");
                    }
                    BinaryReader reader = File.OpenBinary(pathToUcdBinFile);
                    if (!headerRead)
                    {
                        ReadHeader(reader);
                    }
                    uint pageStart = headerSize + characterInfoPageSize * cast<uint>(pageIndex);
                    reader.Seek(cast<long>(pageStart), Origin.seekSet);
                    page = new CharacterInfoPage();
                    page->Read(reader);
                    pages[pageIndex].Reset(page);
                }
            }
            long infoIndex = cast<long>(codePoint) % numInfosInPage;
            return (*page)[infoIndex];
        }
        public const ExtendedCharacterInfo& GetExtendedCharacterInfo(uchar codePoint)
        {
            if (codePoint > cast<uchar>(0x10FFFF))
            {
                throw UnicodeException("invalid Unicode code point " + ToHexString(cast<uint>(codePoint)));
            }
            long pageIndex = cast<long>(codePoint) / numInfosInPage;
            if (extendedPages.Count() <= pageIndex)
            {
                LockGuard<Mutex> lock(characterTableLock);
                while (extendedPages.Count() <= pageIndex)
                {
                    extendedPages.Add(UniquePtr<ExtendedCharacterInfoPage>());
                }
            }
            ExtendedCharacterInfoPage* extendedPage = extendedPages[pageIndex].Get();
            if (extendedPage == null)
            {
                LockGuard<Mutex> lock(characterTableLock);
                if (extendedPage == null)
                {
                    string pathToUcdBinFile = PathToUcdBinFile();
                    if (!File.Exists(pathToUcdBinFile))
                    {
                        throw UnicodeException("Error: Cmajor Unicode database file '" + pathToUcdBinFile + "' does not exist.");
                    }
                    BinaryReader reader = File.OpenBinary(pathToUcdBinFile);
                    if (!headerRead)
                    {
                        ReadHeader(reader);
                    }
                    if (extendedHeader.IsNull())
                    {
                        reader.Seek(cast<long>(extendedHeaderStart), Origin.seekSet);
                        ReadExtendedHeader(reader);
                    }
                    reader.Seek(cast<long>((*extendedHeader)[pageIndex]), Origin.seekSet);
                    extendedPage = new ExtendedCharacterInfoPage();
                    extendedPage->Read(reader);
                    extendedPages[pageIndex].Reset(extendedPage);
                }
            }
            long infoIndex = cast<long>(codePoint) % numInfosInPage;
            return (*extendedPage)[infoIndex];
        }
        private CharacterTable() : headerRead(false), pages(), extendedHeaderStart(0u), extendedHeaderEnd(0u), extendedHeader(), extendedPages(), characterTableLock()
        {
            headerMagic.Resize(8);
            string hdrmgc = "CMAJUCD";
            for (long i = 0; i < 8; ++i)
            {
                if (i < 7)
                {
                    headerMagic[i] = cast<byte>(hdrmgc[i]);
                }
                else
                {
                    headerMagic[i] = current_cmajor_ucd_version;
                }
            }
        }
        private void ReadHeader(BinaryReader& reader)
        {
            headerRead = true;
            List<byte> magic;
            magic.Resize(8);
            for (long i = 0; i < 8; ++i)
            {
                magic[i] = reader.ReadByte();
            }
            for (long i = 0; i < 7; ++i)
            {
                if (magic[i] != cast<byte>(headerMagic[i]))
                {
                    throw UnicodeException("invalid cmajor_ucd.bin header magic: 'CMAJUCD' expected");
                }
            }
            if (magic[7] != headerMagic[7])
            {
                throw UnicodeException("invalid cmajor_ucd.bin version: version " + 
                    string(cast<char>(headerMagic[7]), 1) + " expected, version " + 
                    string(cast<char>(magic[7]), 1) + " read");
            }
            extendedHeaderStart = reader.ReadUInt();
            extendedHeaderEnd = reader.ReadUInt();
        }
        private void ReadExtendedHeader(BinaryReader& reader)
        {
            extendedHeader.Reset(new ExtendedCharacterInfoHeader());
            extendedHeader->Read(reader);
        }
        public ~CharacterTable()
        {
        }
        private const uint headerSize = 16u;
        private static UniquePtr<CharacterTable> instance;
        private List<byte> headerMagic;
        private bool headerRead;
        private List<UniquePtr<CharacterInfoPage>> pages;
        private uint extendedHeaderStart;
        private uint extendedHeaderEnd;
        private UniquePtr<ExtendedCharacterInfoHeader> extendedHeader;
        private List<UniquePtr<ExtendedCharacterInfoPage>> extendedPages;
        private Mutex characterTableLock;
    }

    public const CharacterInfo& GetCharacterInfo(uchar codePoint)
    {
        return CharacterTable.Instance().GetCharacterInfo(codePoint);
    }
    
    public const ExtendedCharacterInfo& GetExtendedCharacterInfo(uchar codePoint)
    {
        return CharacterTable.Instance().GetExtendedCharacterInfo(codePoint);
    }
    
    public GeneralCategoryId GetGeneralCategory(uchar c) 
    {
        return GetCharacterInfo(c).GeneralCategoryValue();
    }
    
    public bool HasGeneralCategory(uchar c, GeneralCategoryId generalCategory)
    {
        return GetCharacterInfo(c).HasGeneralCategory(generalCategory);
    }
}

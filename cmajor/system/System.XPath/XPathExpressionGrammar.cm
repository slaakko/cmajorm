using System;
using System.Collections;
using System.Text.Parsing;
using Axis = System.Dom.Axis;

// this source file has been automatically generated from 'XPathExpressionGrammar.parser' using cmparsergen version 2.0.0.

namespace System.XPath
{
    public class XPathExpressionGrammar : System.Text.Parsing.Grammar
    {
        public XPathExpressionGrammar() : this(new ParsingDomain())
        {
        }
        public XPathExpressionGrammar(ParsingDomain* parsingDomain) : base(ToUtf32("XPathExpressionGrammar"), parsingDomain->GetNamespaceScope(ToUtf32("System.XPath")), parsingDomain)
        {
            SetOwner(0);
            keywords0.Add(ToUtf32("namespace"));
            keywords0.Add(ToUtf32("descendant"));
            keywords0.Add(ToUtf32("parent"));
            keywords0.Add(ToUtf32("preceding"));
            keywords0.Add(ToUtf32("ancestor"));
            keywords0.Add(ToUtf32("preceding-sibling"));
            keywords0.Add(ToUtf32("self"));
            keywords0.Add(ToUtf32("following"));
            keywords0.Add(ToUtf32("following-sibling"));
            keywords0.Add(ToUtf32("descendant-or-self"));
            keywords0.Add(ToUtf32("child"));
            keywords0.Add(ToUtf32("attribute"));
            keywords0.Add(ToUtf32("ancestor-or-self"));
            RegisterParsingDomain(parsingDomain);
            parsingDomain->AddGrammar(this);
            CreateRules();
            Link();
        }
        public XPathExpr* Parse(const uchar* start, const uchar* end, int fileIndex, const string& fileName)
        {
            Scanner scanner(start, end, fileName, fileIndex, SkipRule());
            UniquePtr<XmlLog> xmlLog;
            if (Log() != null)
            {
                xmlLog.Reset(new XmlLog(*Log(), MaxLogLineLength()));
                scanner.SetLog(xmlLog.Get());
                xmlLog->WriteBeginRule(u"parse");
                xmlLog->IncIndent();
            }
            Stack<UniquePtr<Object>> stack;
            UniquePtr<ParsingData> parsingData(new ParsingData(Domain()->NumRules()));
            scanner.SetParsingData(parsingData.Get());
            Match match = base->Parse(scanner, stack, parsingData.Get());
            Span stop = scanner.GetSpan();
            if (Log() != null)
            {
                xmlLog->DecIndent();
                xmlLog->WriteEndRule(u"parse");
            }
            if (!match.Hit() || stop.start != cast<int>(end - start))
            {
                if (StartRule() != null)
                {
                    throw ExpectationFailure(StartRule()->Info(), fileName, stop, start, end);
                }
                else
                {
                    throw ParsingException("grammar '" + ToUtf8(Name()) + "' has no start rule", fileName, scanner.GetSpan(), start, end);
                }
            }
            UniquePtr<Object> value = stack.Pop();
            XPathExpr* result = *cast<ValueObject<XPathExpr*>*>(value.Get());
            return result;
        }

        public class ExprRule : System.Text.Parsing.RuleParser
        {
            public ExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* orExprNonterminalParser = GetNonterminal(ToUtf32("OrExpr"));
                orExprNonterminalParser->SetPost(PostOrExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromOrExpr;
            }
            public void PostOrExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromOrExpr_value = stack.Pop();
                    context->fromOrExpr = *cast<ValueObject<XPathExpr*>*>(fromOrExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromOrExpr()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromOrExpr;
            }
        }

        public class OrExprRule : System.Text.Parsing.RuleParser
        {
            public OrExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathOrExpr(context->value, context->fromright);
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class AndExprRule : System.Text.Parsing.RuleParser
        {
            public AndExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathAndExpr(context->value, context->fromright);
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class EqualityExprRule : System.Text.Parsing.RuleParser
        {
            public EqualityExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.equal;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.notEqual;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.equal: 
                    {
                        context->value = new XPathEqualExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.notEqual: 
                    {
                        context->value = new XPathNotEqualExpr(context->value, context->fromright);
                        break;
                    }
                }
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class RelationalExprRule : System.Text.Parsing.RuleParser
        {
            public RelationalExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.lessOrEqual;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.greaterOrEqual;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.less;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.greater;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.less: 
                    {
                        context->value = new XPathLessExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.greater: 
                    {
                        context->value = new XPathGreaterExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.lessOrEqual: 
                    {
                        context->value = new XPathLessOrEqualExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.greaterOrEqual: 
                    {
                        context->value = new XPathGreaterOrEqualExpr(context->value, context->fromright);
                        break;
                    }
                }
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class AdditiveExprRule : System.Text.Parsing.RuleParser
        {
            public AdditiveExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.plus;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.minus;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.plus: 
                    {
                        context->value = new XPathAddExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.minus: 
                    {
                        context->value = new XPathSubExpr(context->value, context->fromright);
                        break;
                    }
                }
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class MultiplicativeExprRule : System.Text.Parsing.RuleParser
        {
            public MultiplicativeExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.mul;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.div;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.mod;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.mul: 
                    {
                        context->value = new XPathMulExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.div: 
                    {
                        context->value = new XPathDivExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.mod: 
                    {
                        context->value = new XPathModExpr(context->value, context->fromright);
                        break;
                    }
                }
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class UnaryExprRule : System.Text.Parsing.RuleParser
        {
            public UnaryExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* subjectNonterminalParser = GetNonterminal(ToUtf32("subject"));
                subjectNonterminalParser->SetPost(Postsubject);
                NonterminalParser* unionExprNonterminalParser = GetNonterminal(ToUtf32("unionExpr"));
                unionExprNonterminalParser->SetPost(PostunionExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathUnaryMinusExpr(context->fromsubject);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromunionExpr;
            }
            public void Postsubject(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromsubject_value = stack.Pop();
                    context->fromsubject = *cast<ValueObject<XPathExpr*>*>(fromsubject_value.Get());
                }
            }
            public void PostunionExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromunionExpr_value = stack.Pop();
                    context->fromunionExpr = *cast<ValueObject<XPathExpr*>*>(fromunionExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromsubject(), fromunionExpr()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromsubject;
                public XPathExpr* fromunionExpr;
            }
        }

        public class UnionExprRule : System.Text.Parsing.RuleParser
        {
            public UnionExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathUnionExpr(context->value, context->fromright);
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromleft;
                public XPathExpr* fromright;
            }
        }

        public class PathExprRule : System.Text.Parsing.RuleParser
        {
            public PathExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<XPathExpr>"), ToUtf32("fnc")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                ActionParser* a5ActionParser = GetAction(ToUtf32("A5"));
                a5ActionParser->SetAction(A5Action);
                NonterminalParser* locationPathNonterminalParser = GetNonterminal(ToUtf32("LocationPath"));
                locationPathNonterminalParser->SetPost(PostLocationPath);
                NonterminalParser* functionCallNonterminalParser = GetNonterminal(ToUtf32("FunctionCall"));
                functionCallNonterminalParser->SetPost(PostFunctionCall);
                NonterminalParser* filterExprNonterminalParser = GetNonterminal(ToUtf32("FilterExpr"));
                filterExprNonterminalParser->SetPost(PostFilterExpr);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLocationPath;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->fnc.Reset(context->fromFunctionCall);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFilterExpr;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.slashSlash;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.slash;
            }
            public void A5Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.slash: 
                    {
                        context->value = new XPathCombineStepExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.slashSlash: 
                    {
                        context->value = new XPathCombineStepExpr(context->value, new XPathCombineStepExpr(new XPathLocationStepExpr(Axis.descendantOrSelf, new XPathAnyNodeTest()), context->fromright));
                        break;
                    }
                }
            }
            public void PostLocationPath(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLocationPath_value = stack.Pop();
                    context->fromLocationPath = *cast<ValueObject<XPathExpr*>*>(fromLocationPath_value.Get());
                }
            }
            public void PostFunctionCall(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionCall_value = stack.Pop();
                    context->fromFunctionCall = *cast<ValueObject<XPathFunctionCall*>*>(fromFunctionCall_value.Get());
                }
            }
            public void PostFilterExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFilterExpr_value = stack.Pop();
                    context->fromFilterExpr = *cast<ValueObject<XPathExpr*>*>(fromFilterExpr_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fnc(), fromLocationPath(), fromFunctionCall(), fromFilterExpr(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public UniquePtr<XPathExpr> fnc;
                public XPathExpr* fromLocationPath;
                public XPathFunctionCall* fromFunctionCall;
                public XPathExpr* fromFilterExpr;
                public XPathExpr* fromright;
            }
        }

        public class FilterExprRule : System.Text.Parsing.RuleParser
        {
            public FilterExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* primaryNonterminalParser = GetNonterminal(ToUtf32("primary"));
                primaryNonterminalParser->SetPost(Postprimary);
                NonterminalParser* predicateNonterminalParser = GetNonterminal(ToUtf32("predicate"));
                predicateNonterminalParser->SetPost(Postpredicate);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromprimary;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathFilterExpr(context->value, context->frompredicate);
            }
            public void Postprimary(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromprimary_value = stack.Pop();
                    context->fromprimary = *cast<ValueObject<XPathExpr*>*>(fromprimary_value.Get());
                }
            }
            public void Postpredicate(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frompredicate_value = stack.Pop();
                    context->frompredicate = *cast<ValueObject<XPathExpr*>*>(frompredicate_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromprimary(), frompredicate()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromprimary;
                public XPathExpr* frompredicate;
            }
        }

        public class LocationPathRule : System.Text.Parsing.RuleParser
        {
            public LocationPathRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* absoluteLocationPathNonterminalParser = GetNonterminal(ToUtf32("AbsoluteLocationPath"));
                absoluteLocationPathNonterminalParser->SetPost(PostAbsoluteLocationPath);
                NonterminalParser* relativeLocationPathNonterminalParser = GetNonterminal(ToUtf32("RelativeLocationPath"));
                relativeLocationPathNonterminalParser->SetPost(PostRelativeLocationPath);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAbsoluteLocationPath;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromRelativeLocationPath;
            }
            public void PostAbsoluteLocationPath(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAbsoluteLocationPath_value = stack.Pop();
                    context->fromAbsoluteLocationPath = *cast<ValueObject<XPathExpr*>*>(fromAbsoluteLocationPath_value.Get());
                }
            }
            public void PostRelativeLocationPath(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromRelativeLocationPath_value = stack.Pop();
                    context->fromRelativeLocationPath = *cast<ValueObject<XPathExpr*>*>(fromRelativeLocationPath_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromAbsoluteLocationPath(), fromRelativeLocationPath()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromAbsoluteLocationPath;
                public XPathExpr* fromRelativeLocationPath;
            }
        }

        public class AbsoluteLocationPathRule : System.Text.Parsing.RuleParser
        {
            public AbsoluteLocationPathRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* abbreviatedAbsoluteLocationPathNonterminalParser = GetNonterminal(ToUtf32("AbbreviatedAbsoluteLocationPath"));
                abbreviatedAbsoluteLocationPathNonterminalParser->SetPost(PostAbbreviatedAbsoluteLocationPath);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAbbreviatedAbsoluteLocationPath;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathRootNodeExpr();
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathCombineStepExpr(context->value, context->fromright);
            }
            public void PostAbbreviatedAbsoluteLocationPath(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAbbreviatedAbsoluteLocationPath_value = stack.Pop();
                    context->fromAbbreviatedAbsoluteLocationPath = *cast<ValueObject<XPathExpr*>*>(fromAbbreviatedAbsoluteLocationPath_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromAbbreviatedAbsoluteLocationPath(), fromright()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromAbbreviatedAbsoluteLocationPath;
                public XPathExpr* fromright;
            }
        }

        public class RelativeLocationPathRule : System.Text.Parsing.RuleParser
        {
            public RelativeLocationPathRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
                AddLocalVariable(AttrOrVar(ToUtf32("Operator"), ToUtf32("op")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                NonterminalParser* leftNonterminalParser = GetNonterminal(ToUtf32("left"));
                leftNonterminalParser->SetPost(Postleft);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromleft;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.slashSlash;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->op = Operator.slash;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                switch (context->op)
                {
                    case Operator.slash: 
                    {
                        context->value = new XPathCombineStepExpr(context->value, context->fromright);
                        break;
                    }
                    case Operator.slashSlash: 
                    {
                        context->value = new XPathCombineStepExpr(context->value, new XPathCombineStepExpr(new XPathLocationStepExpr(Axis.descendantOrSelf, new XPathAnyNodeTest()), context->fromright));
                        break;
                    }
                }
            }
            public void Postleft(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromleft_value = stack.Pop();
                    context->fromleft = *cast<ValueObject<XPathLocationStepExpr*>*>(fromleft_value.Get());
                }
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathLocationStepExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), op(), fromleft(), fromright()
                {
                }
                public XPathExpr* value;
                public Operator op;
                public XPathLocationStepExpr* fromleft;
                public XPathLocationStepExpr* fromright;
            }
        }

        public class AbbreviatedAbsoluteLocationPathRule : System.Text.Parsing.RuleParser
        {
            public AbbreviatedAbsoluteLocationPathRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* rightNonterminalParser = GetNonterminal(ToUtf32("right"));
                rightNonterminalParser->SetPost(Postright);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathCombineStepExpr(new XPathRootNodeExpr(), new XPathCombineStepExpr(new XPathLocationStepExpr(Axis.descendantOrSelf, new XPathAnyNodeTest()), context->fromright));
            }
            public void Postright(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromright_value = stack.Pop();
                    context->fromright = *cast<ValueObject<XPathExpr*>*>(fromright_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromright()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromright;
            }
        }

        public class StepRule : System.Text.Parsing.RuleParser
        {
            public StepRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathLocationStepExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathLocationStepExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* axisNonterminalParser = GetNonterminal(ToUtf32("axis"));
                axisNonterminalParser->SetPost(Postaxis);
                NonterminalParser* nodeTestNonterminalParser = GetNonterminal(ToUtf32("nodeTest"));
                nodeTestNonterminalParser->SetPost(PostnodeTest);
                NonterminalParser* predicateNonterminalParser = GetNonterminal(ToUtf32("predicate"));
                predicateNonterminalParser->SetPost(Postpredicate);
                NonterminalParser* abbreviatedStepNonterminalParser = GetNonterminal(ToUtf32("AbbreviatedStep"));
                abbreviatedStepNonterminalParser->SetPost(PostAbbreviatedStep);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathLocationStepExpr(context->fromaxis, context->fromnodeTest);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddPredicate(context->frompredicate);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAbbreviatedStep;
            }
            public void Postaxis(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromaxis_value = stack.Pop();
                    context->fromaxis = *cast<ValueObject<Axis>*>(fromaxis_value.Get());
                }
            }
            public void PostnodeTest(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromnodeTest_value = stack.Pop();
                    context->fromnodeTest = *cast<ValueObject<XPathNodeTestExpr*>*>(fromnodeTest_value.Get());
                }
            }
            public void Postpredicate(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> frompredicate_value = stack.Pop();
                    context->frompredicate = *cast<ValueObject<XPathExpr*>*>(frompredicate_value.Get());
                }
            }
            public void PostAbbreviatedStep(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAbbreviatedStep_value = stack.Pop();
                    context->fromAbbreviatedStep = *cast<ValueObject<XPathLocationStepExpr*>*>(fromAbbreviatedStep_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromaxis(), fromnodeTest(), frompredicate(), fromAbbreviatedStep()
                {
                }
                public XPathLocationStepExpr* value;
                public Axis fromaxis;
                public XPathNodeTestExpr* fromnodeTest;
                public XPathExpr* frompredicate;
                public XPathLocationStepExpr* fromAbbreviatedStep;
            }
        }

        public class AbbreviatedStepRule : System.Text.Parsing.RuleParser
        {
            public AbbreviatedStepRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathLocationStepExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathLocationStepExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathLocationStepExpr(Axis.parent, new XPathAnyNodeTest());
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathLocationStepExpr(Axis.self, new XPathAnyNodeTest());
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public XPathLocationStepExpr* value;
            }
        }

        public class AxisSpecifierRule : System.Text.Parsing.RuleParser
        {
            public AxisSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Axis"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Axis>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* axisNameNonterminalParser = GetNonterminal(ToUtf32("AxisName"));
                axisNameNonterminalParser->SetPost(PostAxisName);
                NonterminalParser* abbreviatedAxisSpecifierNonterminalParser = GetNonterminal(ToUtf32("AbbreviatedAxisSpecifier"));
                abbreviatedAxisSpecifierNonterminalParser->SetPost(PostAbbreviatedAxisSpecifier);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAxisName;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromAbbreviatedAxisSpecifier;
            }
            public void PostAxisName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAxisName_value = stack.Pop();
                    context->fromAxisName = *cast<ValueObject<Axis>*>(fromAxisName_value.Get());
                }
            }
            public void PostAbbreviatedAxisSpecifier(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromAbbreviatedAxisSpecifier_value = stack.Pop();
                    context->fromAbbreviatedAxisSpecifier = *cast<ValueObject<Axis>*>(fromAbbreviatedAxisSpecifier_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromAxisName(), fromAbbreviatedAxisSpecifier()
                {
                }
                public Axis value;
                public Axis fromAxisName;
                public Axis fromAbbreviatedAxisSpecifier;
            }
        }

        public class AxisNameRule : System.Text.Parsing.RuleParser
        {
            public AxisNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Axis"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Axis>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = GetAxis(ustring(matchBegin, matchEnd));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Axis value;
            }
        }

        public class AbbreviatedAxisSpecifierRule : System.Text.Parsing.RuleParser
        {
            public AbbreviatedAxisSpecifierRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("Axis"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<Axis>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Axis.attribute;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = Axis.child;
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public Axis value;
            }
        }

        public class PredicateRule : System.Text.Parsing.RuleParser
        {
            public PredicateRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* predicateExprNonterminalParser = GetNonterminal(ToUtf32("PredicateExpr"));
                predicateExprNonterminalParser->SetPost(PostPredicateExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPredicateExpr;
            }
            public void PostPredicateExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPredicateExpr_value = stack.Pop();
                    context->fromPredicateExpr = *cast<ValueObject<XPathExpr*>*>(fromPredicateExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromPredicateExpr()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromPredicateExpr;
            }
        }

        public class PredicateExprRule : System.Text.Parsing.RuleParser
        {
            public PredicateExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* exprNonterminalParser = GetNonterminal(ToUtf32("Expr"));
                exprNonterminalParser->SetPost(PostExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpr;
            }
            public void PostExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpr_value = stack.Pop();
                    context->fromExpr = *cast<ValueObject<XPathExpr*>*>(fromExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromExpr()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromExpr;
            }
        }

        public class NodeTestRule : System.Text.Parsing.RuleParser
        {
            public NodeTestRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathNodeTestExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathNodeTestExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* literalNonterminalParser = GetNonterminal(ToUtf32("Literal"));
                literalNonterminalParser->SetPost(PostLiteral);
                NonterminalParser* nodeTypeNonterminalParser = GetNonterminal(ToUtf32("NodeType"));
                nodeTypeNonterminalParser->SetPost(PostNodeType);
                NonterminalParser* nameTestNonterminalParser = GetNonterminal(ToUtf32("NameTest"));
                nameTestNonterminalParser->SetPost(PostNameTest);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathPILiteralTest(context->fromLiteral);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNodeType;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNameTest;
            }
            public void PostLiteral(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLiteral_value = stack.Pop();
                    context->fromLiteral = *cast<ValueObject<XPathExpr*>*>(fromLiteral_value.Get());
                }
            }
            public void PostNodeType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNodeType_value = stack.Pop();
                    context->fromNodeType = *cast<ValueObject<XPathNodeTestExpr*>*>(fromNodeType_value.Get());
                }
            }
            public void PostNameTest(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNameTest_value = stack.Pop();
                    context->fromNameTest = *cast<ValueObject<XPathNodeTestExpr*>*>(fromNameTest_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromLiteral(), fromNodeType(), fromNameTest()
                {
                }
                public XPathNodeTestExpr* value;
                public XPathExpr* fromLiteral;
                public XPathNodeTestExpr* fromNodeType;
                public XPathNodeTestExpr* fromNameTest;
            }
        }

        public class NameTestRule : System.Text.Parsing.RuleParser
        {
            public NameTestRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathNodeTestExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathNodeTestExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* nCNameNonterminalParser = GetNonterminal(ToUtf32("NCName"));
                nCNameNonterminalParser->SetPost(PostNCName);
                NonterminalParser* qNameNonterminalParser = GetNonterminal(ToUtf32("QName"));
                qNameNonterminalParser->SetPost(PostQName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathPrincipalNodeTest();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathPrefixTest(context->fromNCName);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathNameTest(context->fromQName);
            }
            public void PostNCName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNCName_value = stack.Pop();
                    context->fromNCName = *cast<ValueObject<ustring>*>(fromNCName_value.Get());
                }
            }
            public void PostQName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQName_value = stack.Pop();
                    context->fromQName = *cast<ValueObject<ustring>*>(fromQName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromNCName(), fromQName()
                {
                }
                public XPathNodeTestExpr* value;
                public ustring fromNCName;
                public ustring fromQName;
            }
        }

        public class NodeTypeRule : System.Text.Parsing.RuleParser
        {
            public NodeTypeRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathNodeTestExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathNodeTestExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathCommentNodeTest();
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathTextNodeTest();
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathPINodeTest();
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathAnyNodeTest();
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public XPathNodeTestExpr* value;
            }
        }

        public class PrimaryExprRule : System.Text.Parsing.RuleParser
        {
            public PrimaryExprRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                ActionParser* a3ActionParser = GetAction(ToUtf32("A3"));
                a3ActionParser->SetAction(A3Action);
                ActionParser* a4ActionParser = GetAction(ToUtf32("A4"));
                a4ActionParser->SetAction(A4Action);
                NonterminalParser* functionCallNonterminalParser = GetNonterminal(ToUtf32("FunctionCall"));
                functionCallNonterminalParser->SetPost(PostFunctionCall);
                NonterminalParser* variableReferenceNonterminalParser = GetNonterminal(ToUtf32("VariableReference"));
                variableReferenceNonterminalParser->SetPost(PostVariableReference);
                NonterminalParser* exprNonterminalParser = GetNonterminal(ToUtf32("Expr"));
                exprNonterminalParser->SetPost(PostExpr);
                NonterminalParser* literalNonterminalParser = GetNonterminal(ToUtf32("Literal"));
                literalNonterminalParser->SetPost(PostLiteral);
                NonterminalParser* numberNonterminalParser = GetNonterminal(ToUtf32("Number"));
                numberNonterminalParser->SetPost(PostNumber);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromFunctionCall;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromVariableReference;
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpr;
            }
            public void A3Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLiteral;
            }
            public void A4Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNumber;
            }
            public void PostFunctionCall(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionCall_value = stack.Pop();
                    context->fromFunctionCall = *cast<ValueObject<XPathFunctionCall*>*>(fromFunctionCall_value.Get());
                }
            }
            public void PostVariableReference(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromVariableReference_value = stack.Pop();
                    context->fromVariableReference = *cast<ValueObject<XPathExpr*>*>(fromVariableReference_value.Get());
                }
            }
            public void PostExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpr_value = stack.Pop();
                    context->fromExpr = *cast<ValueObject<XPathExpr*>*>(fromExpr_value.Get());
                }
            }
            public void PostLiteral(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLiteral_value = stack.Pop();
                    context->fromLiteral = *cast<ValueObject<XPathExpr*>*>(fromLiteral_value.Get());
                }
            }
            public void PostNumber(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNumber_value = stack.Pop();
                    context->fromNumber = *cast<ValueObject<XPathExpr*>*>(fromNumber_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromFunctionCall(), fromVariableReference(), fromExpr(), fromLiteral(), fromNumber()
                {
                }
                public XPathExpr* value;
                public XPathFunctionCall* fromFunctionCall;
                public XPathExpr* fromVariableReference;
                public XPathExpr* fromExpr;
                public XPathExpr* fromLiteral;
                public XPathExpr* fromNumber;
            }
        }

        public class VariableReferenceRule : System.Text.Parsing.RuleParser
        {
            public VariableReferenceRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* qNameNonterminalParser = GetNonterminal(ToUtf32("QName"));
                qNameNonterminalParser->SetPost(PostQName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathVariableReference(context->fromQName);
            }
            public void PostQName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQName_value = stack.Pop();
                    context->fromQName = *cast<ValueObject<ustring>*>(fromQName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromQName()
                {
                }
                public XPathExpr* value;
                public ustring fromQName;
            }
        }

        public class LiteralRule : System.Text.Parsing.RuleParser
        {
            public LiteralRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathLiteral(ustring(matchBegin, matchEnd));
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathLiteral(ustring(matchBegin, matchEnd));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public XPathExpr* value;
            }
        }

        public class NumberRule : System.Text.Parsing.RuleParser
        {
            public NumberRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathNumberExpr(ustring(matchBegin, matchEnd));
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathNumberExpr(ustring(matchBegin, matchEnd));
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public XPathExpr* value;
            }
        }

        public class FunctionCallRule : System.Text.Parsing.RuleParser
        {
            public FunctionCallRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathFunctionCall*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathFunctionCall*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                ActionParser* a2ActionParser = GetAction(ToUtf32("A2"));
                a2ActionParser->SetAction(A2Action);
                NonterminalParser* functionNameNonterminalParser = GetNonterminal(ToUtf32("FunctionName"));
                functionNameNonterminalParser->SetPost(PostFunctionName);
                NonterminalParser* firstNonterminalParser = GetNonterminal(ToUtf32("first"));
                firstNonterminalParser->SetPost(Postfirst);
                NonterminalParser* nextNonterminalParser = GetNonterminal(ToUtf32("next"));
                nextNonterminalParser->SetPost(Postnext);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = new XPathFunctionCall(context->fromFunctionName);
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddArgument(context->fromfirst);
            }
            public void A2Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value->AddArgument(context->fromnext);
            }
            public void PostFunctionName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromFunctionName_value = stack.Pop();
                    context->fromFunctionName = *cast<ValueObject<ustring>*>(fromFunctionName_value.Get());
                }
            }
            public void Postfirst(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromfirst_value = stack.Pop();
                    context->fromfirst = *cast<ValueObject<XPathExpr*>*>(fromfirst_value.Get());
                }
            }
            public void Postnext(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromnext_value = stack.Pop();
                    context->fromnext = *cast<ValueObject<XPathExpr*>*>(fromnext_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromFunctionName(), fromfirst(), fromnext()
                {
                }
                public XPathFunctionCall* value;
                public ustring fromFunctionName;
                public XPathExpr* fromfirst;
                public XPathExpr* fromnext;
            }
        }

        public class ArgumentRule : System.Text.Parsing.RuleParser
        {
            public ArgumentRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("XPathExpr*"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<XPathExpr*>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* exprNonterminalParser = GetNonterminal(ToUtf32("Expr"));
                exprNonterminalParser->SetPost(PostExpr);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromExpr;
            }
            public void PostExpr(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromExpr_value = stack.Pop();
                    context->fromExpr = *cast<ValueObject<XPathExpr*>*>(fromExpr_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromExpr()
                {
                }
                public XPathExpr* value;
                public XPathExpr* fromExpr;
            }
        }

        public class FunctionNameRule : System.Text.Parsing.RuleParser
        {
            public FunctionNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
                AddLocalVariable(AttrOrVar(ToUtf32("UniquePtr<XPathExpr>"), ToUtf32("nodeType")));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* qNameNonterminalParser = GetNonterminal(ToUtf32("QName"));
                qNameNonterminalParser->SetPost(PostQName);
                NonterminalParser* nodeTypeNonterminalParser = GetNonterminal(ToUtf32("NodeType"));
                nodeTypeNonterminalParser->SetPost(PostNodeType);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromQName;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->nodeType.Reset(context->fromNodeType);
            }
            public void PostQName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromQName_value = stack.Pop();
                    context->fromQName = *cast<ValueObject<ustring>*>(fromQName_value.Get());
                }
            }
            public void PostNodeType(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNodeType_value = stack.Pop();
                    context->fromNodeType = *cast<ValueObject<XPathNodeTestExpr*>*>(fromNodeType_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), nodeType(), fromQName(), fromNodeType()
                {
                }
                public ustring value;
                public UniquePtr<XPathExpr> nodeType;
                public ustring fromQName;
                public XPathNodeTestExpr* fromNodeType;
            }
        }

        public class QNameRule : System.Text.Parsing.RuleParser
        {
            public QNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                ActionParser* a1ActionParser = GetAction(ToUtf32("A1"));
                a1ActionParser->SetAction(A1Action);
                NonterminalParser* prefixedNameNonterminalParser = GetNonterminal(ToUtf32("PrefixedName"));
                prefixedNameNonterminalParser->SetPost(PostPrefixedName);
                NonterminalParser* unprefixedNameNonterminalParser = GetNonterminal(ToUtf32("UnprefixedName"));
                unprefixedNameNonterminalParser->SetPost(PostUnprefixedName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromPrefixedName;
            }
            public void A1Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromUnprefixedName;
            }
            public void PostPrefixedName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrefixedName_value = stack.Pop();
                    context->fromPrefixedName = *cast<ValueObject<ustring>*>(fromPrefixedName_value.Get());
                }
            }
            public void PostUnprefixedName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromUnprefixedName_value = stack.Pop();
                    context->fromUnprefixedName = *cast<ValueObject<ustring>*>(fromUnprefixedName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromPrefixedName(), fromUnprefixedName()
                {
                }
                public ustring value;
                public ustring fromPrefixedName;
                public ustring fromUnprefixedName;
            }
        }

        public class PrefixedNameRule : System.Text.Parsing.RuleParser
        {
            public PrefixedNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* prefixNonterminalParser = GetNonterminal(ToUtf32("Prefix"));
                prefixNonterminalParser->SetPost(PostPrefix);
                NonterminalParser* localPartNonterminalParser = GetNonterminal(ToUtf32("LocalPart"));
                localPartNonterminalParser->SetPost(PostLocalPart);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public void PostPrefix(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromPrefix_value = stack.Pop();
                    context->fromPrefix = *cast<ValueObject<ustring>*>(fromPrefix_value.Get());
                }
            }
            public void PostLocalPart(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLocalPart_value = stack.Pop();
                    context->fromLocalPart = *cast<ValueObject<ustring>*>(fromLocalPart_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromPrefix(), fromLocalPart()
                {
                }
                public ustring value;
                public ustring fromPrefix;
                public ustring fromLocalPart;
            }
        }

        public class UnprefixedNameRule : System.Text.Parsing.RuleParser
        {
            public UnprefixedNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* localPartNonterminalParser = GetNonterminal(ToUtf32("LocalPart"));
                localPartNonterminalParser->SetPost(PostLocalPart);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromLocalPart;
            }
            public void PostLocalPart(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromLocalPart_value = stack.Pop();
                    context->fromLocalPart = *cast<ValueObject<ustring>*>(fromLocalPart_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromLocalPart()
                {
                }
                public ustring value;
                public ustring fromLocalPart;
            }
        }

        public class PrefixRule : System.Text.Parsing.RuleParser
        {
            public PrefixRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* nCNameNonterminalParser = GetNonterminal(ToUtf32("NCName"));
                nCNameNonterminalParser->SetPost(PostNCName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNCName;
            }
            public void PostNCName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNCName_value = stack.Pop();
                    context->fromNCName = *cast<ValueObject<ustring>*>(fromNCName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromNCName()
                {
                }
                public ustring value;
                public ustring fromNCName;
            }
        }

        public class LocalPartRule : System.Text.Parsing.RuleParser
        {
            public LocalPartRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
                NonterminalParser* nCNameNonterminalParser = GetNonterminal(ToUtf32("NCName"));
                nCNameNonterminalParser->SetPost(PostNCName);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = context->fromNCName;
            }
            public void PostNCName(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    UniquePtr<Object> fromNCName_value = stack.Pop();
                    context->fromNCName = *cast<ValueObject<ustring>*>(fromNCName_value.Get());
                }
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value(), fromNCName()
                {
                }
                public ustring value;
                public ustring fromNCName;
            }
        }

        public class NCNameRule : System.Text.Parsing.RuleParser
        {
            public NCNameRule(const ustring& name_, Scope* enclosingScope_, int id_, Parser* definition_) : base(name_, enclosingScope_, id_, definition_)
            {
                SetValueTypeName(ToUtf32("ustring"));
            }
            public override void Enter(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData)
            {
                parsingData->PushContext(Id(), new Context());
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
            }
            public override void Leave(Stack<UniquePtr<Object>>& stack, ParsingData* parsingData, bool matched)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                if (matched)
                {
                    stack.Push(UniquePtr<Object>(new ValueObject<ustring>(context->value)));
                }
                parsingData->PopContext(Id());
            }
            public override void Link()
            {
                ActionParser* a0ActionParser = GetAction(ToUtf32("A0"));
                a0ActionParser->SetAction(A0Action);
            }
            public void A0Action(const uchar* matchBegin, const uchar* matchEnd, const Span& span, const string& fileName, ParsingData* parsingData, bool& pass)
            {
                Context* context = cast<Context*>(parsingData->GetContext(Id()));
                context->value = ustring(matchBegin, matchEnd);
            }
            public class Context : System.Text.Parsing.Context
            {
                public Context() : value()
                {
                }
                public ustring value;
            }
        }

        public override void GetReferencedGrammars()
        {
            ParsingDomain* pd = Domain();
            Grammar* grammar0 = pd->GetGrammar(ToUtf32("System.Text.Parsing.stdlib"));
            if (grammar0 == null)
            {
                grammar0 = new System.Text.Parsing.stdlib(pd);
            }
            AddGrammarReference(grammar0);
            Grammar* grammar1 = pd->GetGrammar(ToUtf32("System.Xml.XmlGrammar"));
            if (grammar1 == null)
            {
                grammar1 = new System.Xml.XmlGrammar(pd);
            }
            AddGrammarReference(grammar1);
        }
        public override void CreateRules()
        {
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("NameStartChar"), this, ToUtf32("System.Xml.XmlGrammar.NameStartChar")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("NameChar"), this, ToUtf32("System.Xml.XmlGrammar.NameChar")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("identifier"), this, ToUtf32("System.Text.Parsing.stdlib.identifier")));
            AddRuleLink(new System.Text.Parsing.RuleLink(ToUtf32("spaces"), this, ToUtf32("System.Text.Parsing.stdlib.spaces")));
            AddRule(new ExprRule(ToUtf32("Expr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("OrExpr"), ToUtf32("OrExpr"), 0))));
            AddRule(new OrExprRule(ToUtf32("OrExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("AndExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("or")),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("AndExpr"), 0))))))));
            AddRule(new AndExprRule(ToUtf32("AndExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("EqualityExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.KeywordParser(ToUtf32("and")),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("EqualityExpr"), 0))))))));
            AddRule(new EqualityExprRule(ToUtf32("EqualityExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("RelationalExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.CharParser('=')),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.StringParser(ToUtf32("!="))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("RelationalExpr"), 0))))))));
            AddRule(new RelationalExprRule(ToUtf32("RelationalExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("AdditiveExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.AlternativeParser(
                                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                    new System.Text.Parsing.StringParser(ToUtf32("<="))),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                    new System.Text.Parsing.StringParser(ToUtf32(">=")))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                new System.Text.Parsing.CharParser('<'))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                            new System.Text.Parsing.CharParser('>')))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("AdditiveExpr"), 0))))))));
            AddRule(new AdditiveExprRule(ToUtf32("AdditiveExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("MultiplicativeExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.CharParser('+')),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.CharParser('-')))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("MultiplicativeExpr"), 0))))))));
            AddRule(new MultiplicativeExprRule(ToUtf32("MultiplicativeExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("UnaryExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                                new System.Text.Parsing.CharParser('*')),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                new System.Text.Parsing.StringParser(ToUtf32("div")))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                            new System.Text.Parsing.StringParser(ToUtf32("mod"))))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("UnaryExpr"), 0))))))));
            AddRule(new UnaryExprRule(ToUtf32("UnaryExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.CharParser('-'),
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("subject"), ToUtf32("UnaryExpr"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("unionExpr"), ToUtf32("UnionExpr"), 0)))));
            AddRule(new UnionExprRule(ToUtf32("UnionExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("PathExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('|'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("PathExpr"), 0))))))));
            AddRule(new PathExprRule(ToUtf32("PathExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.DifferenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("LocationPath"), ToUtf32("LocationPath"), 0),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionCall"), ToUtf32("FunctionCall"), 0))))),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("FilterExpr"), ToUtf32("FilterExpr"), 0)),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.AlternativeParser(
                                            new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                                new System.Text.Parsing.StringParser(ToUtf32("//"))),
                                            new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                                                new System.Text.Parsing.StringParser(ToUtf32("/"))))),
                                    new System.Text.Parsing.ActionParser(ToUtf32("A5"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("RelativeLocationPath"), 0)))))))));
            AddRule(new FilterExprRule(ToUtf32("FilterExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("primary"), ToUtf32("PrimaryExpr"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("predicate"), ToUtf32("Predicate"), 0)))))));
            AddRule(new LocationPathRule(ToUtf32("LocationPath"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AbsoluteLocationPath"), ToUtf32("AbsoluteLocationPath"), 0)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("RelativeLocationPath"), ToUtf32("RelativeLocationPath"), 0)))));
            AddRule(new AbsoluteLocationPathRule(ToUtf32("AbsoluteLocationPath"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AbbreviatedAbsoluteLocationPath"), ToUtf32("AbbreviatedAbsoluteLocationPath"), 0)),
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.CharParser('/')),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("RelativeLocationPath"), 0))))))));
            AddRule(new RelativeLocationPathRule(ToUtf32("RelativeLocationPath"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("left"), ToUtf32("Step"), 0)),
                    new System.Text.Parsing.KleeneStarParser(
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.AlternativeParser(
                                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                            new System.Text.Parsing.StringParser(ToUtf32("//"))),
                                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                            new System.Text.Parsing.CharParser('/')))),
                                new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("Step"), 0))))))));
            AddRule(new AbbreviatedAbsoluteLocationPathRule(ToUtf32("AbbreviatedAbsoluteLocationPath"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.StringParser(ToUtf32("//")),
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("right"), ToUtf32("RelativeLocationPath"), 0)))));
            AddRule(new StepRule(ToUtf32("Step"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("axis"), ToUtf32("AxisSpecifier"), 0),
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("nodeTest"), ToUtf32("NodeTest"), 0))),
                        new System.Text.Parsing.KleeneStarParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("predicate"), ToUtf32("Predicate"), 0))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AbbreviatedStep"), ToUtf32("AbbreviatedStep"), 0)))));
            AddRule(new AbbreviatedStepRule(ToUtf32("AbbreviatedStep"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.StringParser(ToUtf32(".."))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.CharParser('.')))));
            AddRule(new AxisSpecifierRule(ToUtf32("AxisSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.GroupingParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("AxisName"), ToUtf32("AxisName"), 0),
                                new System.Text.Parsing.StringParser(ToUtf32("::"))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("AbbreviatedAxisSpecifier"), ToUtf32("AbbreviatedAxisSpecifier"), 0)))));
            AddRule(new AxisNameRule(ToUtf32("AxisName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.KeywordListParser(ToUtf32("identifier"), keywords0))));
            AddRule(new AbbreviatedAxisSpecifierRule(ToUtf32("AbbreviatedAxisSpecifier"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.CharParser('@')),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.EmptyParser()))));
            AddRule(new PredicateRule(ToUtf32("Predicate"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.CharParser('['),
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("PredicateExpr"), ToUtf32("PredicateExpr"), 0))),
                    new System.Text.Parsing.CharParser(']'))));
            AddRule(new PredicateExprRule(ToUtf32("PredicateExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expr"), ToUtf32("Expr"), 0))));
            AddRule(new NodeTestRule(ToUtf32("NodeTest"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.KeywordParser(ToUtf32("processing-instruction")),
                                            new System.Text.Parsing.CharParser('(')),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("Literal"), ToUtf32("Literal"), 0)),
                                    new System.Text.Parsing.CharParser(')')))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NodeType"), ToUtf32("NodeType"), 0),
                                        new System.Text.Parsing.CharParser('(')),
                                    new System.Text.Parsing.CharParser(')'))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("NameTest"), ToUtf32("NameTest"), 0)))));
            AddRule(new NameTestRule(ToUtf32("NameTest"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                            new System.Text.Parsing.CharParser('*')),
                        new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.SequenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NCName"), ToUtf32("NCName"), 0),
                                        new System.Text.Parsing.CharParser(':')),
                                    new System.Text.Parsing.CharParser('*'))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("QName"), ToUtf32("QName"), 0)))));
            AddRule(new NodeTypeRule(ToUtf32("NodeType"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                new System.Text.Parsing.KeywordParser(ToUtf32("comment"))),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.KeywordParser(ToUtf32("text")))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                            new System.Text.Parsing.KeywordParser(ToUtf32("processing-instruction")))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                        new System.Text.Parsing.KeywordParser(ToUtf32("node"))))));
            AddRule(new PrimaryExprRule(ToUtf32("PrimaryExpr"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.AlternativeParser(
                        new System.Text.Parsing.AlternativeParser(
                            new System.Text.Parsing.AlternativeParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionCall"), ToUtf32("FunctionCall"), 0)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("VariableReference"), ToUtf32("VariableReference"), 0))),
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.CharParser('('),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expr"), ToUtf32("Expr"), 0)),
                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                    new System.Text.Parsing.CharParser(')')))),
                        new System.Text.Parsing.ActionParser(ToUtf32("A3"),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("Literal"), ToUtf32("Literal"), 0))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A4"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("Number"), ToUtf32("Number"), 0)))));
            AddRule(new VariableReferenceRule(ToUtf32("VariableReference"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.CharParser('$'),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("QName"), ToUtf32("QName"), 0))))));
            AddRule(new LiteralRule(ToUtf32("Literal"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('\"'),
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.KleeneStarParser(
                                            new System.Text.Parsing.CharSetParser(ToUtf32("\""), true))))),
                            new System.Text.Parsing.CharParser('\"'))),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('\''),
                                new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.KleeneStarParser(
                                            new System.Text.Parsing.CharSetParser(ToUtf32("'"), true))))),
                            new System.Text.Parsing.CharParser('\''))))));
            AddRule(new NumberRule(ToUtf32("Number"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Digits"), ToUtf32("Digits"), 0),
                                new System.Text.Parsing.OptionalParser(
                                    new System.Text.Parsing.GroupingParser(
                                        new System.Text.Parsing.SequenceParser(
                                            new System.Text.Parsing.CharParser('.'),
                                            new System.Text.Parsing.OptionalParser(
                                                new System.Text.Parsing.NonterminalParser(ToUtf32("Digits"), ToUtf32("Digits"), 0)))))))),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.CharParser('.'),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Digits"), ToUtf32("Digits"), 0)))))));
            AddRule(new System.Text.Parsing.RuleParser(ToUtf32("Digits"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.TokenParser(
                    new System.Text.Parsing.PositiveParser(
                        new System.Text.Parsing.CharSetParser(ToUtf32("0-9"))))));
            AddRule(new FunctionCallRule(ToUtf32("FunctionCall"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.SequenceParser(
                    new System.Text.Parsing.SequenceParser(
                        new System.Text.Parsing.TokenParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("FunctionName"), ToUtf32("FunctionName"), 0)),
                                new System.Text.Parsing.CharParser('('))),
                        new System.Text.Parsing.OptionalParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.SequenceParser(
                                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("first"), ToUtf32("Argument"), 0)),
                                    new System.Text.Parsing.KleeneStarParser(
                                        new System.Text.Parsing.GroupingParser(
                                            new System.Text.Parsing.SequenceParser(
                                                new System.Text.Parsing.CharParser(','),
                                                new System.Text.Parsing.ActionParser(ToUtf32("A2"),
                                                    new System.Text.Parsing.NonterminalParser(ToUtf32("next"), ToUtf32("Argument"), 0))))))))),
                    new System.Text.Parsing.CharParser(')'))));
            AddRule(new ArgumentRule(ToUtf32("Argument"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("Expr"), ToUtf32("Expr"), 0))));
            AddRule(new FunctionNameRule(ToUtf32("FunctionName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.GroupingParser(
                        new System.Text.Parsing.DifferenceParser(
                            new System.Text.Parsing.NonterminalParser(ToUtf32("QName"), ToUtf32("QName"), 0),
                            new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                                new System.Text.Parsing.NonterminalParser(ToUtf32("NodeType"), ToUtf32("NodeType"), 0)))))));
            AddRule(new QNameRule(ToUtf32("QName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.AlternativeParser(
                    new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("PrefixedName"), ToUtf32("PrefixedName"), 0)),
                    new System.Text.Parsing.ActionParser(ToUtf32("A1"),
                        new System.Text.Parsing.NonterminalParser(ToUtf32("UnprefixedName"), ToUtf32("UnprefixedName"), 0)))));
            AddRule(new PrefixedNameRule(ToUtf32("PrefixedName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.SequenceParser(
                                new System.Text.Parsing.NonterminalParser(ToUtf32("Prefix"), ToUtf32("Prefix"), 0),
                                new System.Text.Parsing.CharParser(':')),
                            new System.Text.Parsing.NonterminalParser(ToUtf32("LocalPart"), ToUtf32("LocalPart"), 0))))));
            AddRule(new UnprefixedNameRule(ToUtf32("UnprefixedName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("LocalPart"), ToUtf32("LocalPart"), 0))));
            AddRule(new PrefixRule(ToUtf32("Prefix"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("NCName"), ToUtf32("NCName"), 0))));
            AddRule(new LocalPartRule(ToUtf32("LocalPart"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.NonterminalParser(ToUtf32("NCName"), ToUtf32("NCName"), 0))));
            AddRule(new NCNameRule(ToUtf32("NCName"), GetScope(), Domain()->GetNextRuleId(),
                new System.Text.Parsing.ActionParser(ToUtf32("A0"),
                    new System.Text.Parsing.TokenParser(
                        new System.Text.Parsing.SequenceParser(
                            new System.Text.Parsing.GroupingParser(
                                new System.Text.Parsing.DifferenceParser(
                                    new System.Text.Parsing.NonterminalParser(ToUtf32("NameStartChar"), ToUtf32("NameStartChar"), 0),
                                    new System.Text.Parsing.CharParser(':'))),
                            new System.Text.Parsing.KleeneStarParser(
                                new System.Text.Parsing.GroupingParser(
                                    new System.Text.Parsing.DifferenceParser(
                                        new System.Text.Parsing.NonterminalParser(ToUtf32("NameChar"), ToUtf32("NameChar"), 0),
                                        new System.Text.Parsing.CharParser(':')))))))));
            SetSkipRuleName(ToUtf32("spaces"));
        }
        private List<ustring> keywords0;
    }
} // System.XPath

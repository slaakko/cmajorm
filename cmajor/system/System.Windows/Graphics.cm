
// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows.API;

namespace System.Windows
{
    public enum GraphicsStatus : int
    {
        ok = 0,
        genericError = 1,
        invalidParameter = 2,
        outOfMemory = 3,
        objectBusy = 4,
        insufficientBuffer = 5,
        notImplemented = 6,
        win32Error = 7,
        wrongState = 8,
        aborted = 9,
        fileNotFound = 10,
        valueOverflow = 11,
        accessDenied = 12,
        unknownImageFormat = 13,
        fontFamilyNotFound = 14,
        fontStyleNotFound = 15,
        notTrueTypeFont = 16,
        unsupportedGdiplusVersion = 17,
        gdiplusNotInitialized = 18,
        propertyNotFound = 19,
        propertyNotSupported = 20,
        profileNotFound = 21
    }

    public string GraphicsStatusStr(GraphicsStatus status)
    {
        switch (status)
        {
            case GraphicsStatus.ok: return "ok";
            case GraphicsStatus.genericError: return "generic error";
            case GraphicsStatus.invalidParameter: return "invalid parameter";
            case GraphicsStatus.outOfMemory: return "out of memory";
            case GraphicsStatus.objectBusy: return "object busy";
            case GraphicsStatus.insufficientBuffer: return "insufficient buffer";
            case GraphicsStatus.notImplemented: return "not implemented";
            case GraphicsStatus.win32Error: return "WIN32 error";
            case GraphicsStatus.wrongState: return "wrong state";
            case GraphicsStatus.aborted: return "aborted";
            case GraphicsStatus.fileNotFound: return "file not found";
            case GraphicsStatus.valueOverflow: return "value overflow";
            case GraphicsStatus.accessDenied: return "access denied";
            case GraphicsStatus.unknownImageFormat: return "unknown image format";
            case GraphicsStatus.fontFamilyNotFound: return "font family not found";
            case GraphicsStatus.fontStyleNotFound: return "font style not found";
            case GraphicsStatus.notTrueTypeFont: return "not True Type font";
            case GraphicsStatus.unsupportedGdiplusVersion: return "unsupported GDI+ version";
            case GraphicsStatus.gdiplusNotInitialized: return "GDI+ not initialized";
            case GraphicsStatus.propertyNotFound: return "property not found";
            case GraphicsStatus.propertyNotSupported: return "property not supported";
            case GraphicsStatus.profileNotFound: return "profile not found";
        }
        return "graphics error";
    }

    public void CheckGraphicsStatus(GraphicsStatus status)
    {
        if (status != GraphicsStatus.ok)
        {
            throw Exception("GDI+ error: " + GraphicsStatusStr(status));
        }
    }

    public class Color
    {
        public nothrow Color() : alpha(255u), red(0u), green(0u), blue(0u)
        {
        }
        public nothrow Color(byte alpha_, byte red_, byte green_, byte blue_) : alpha(alpha_), red(red_), green(green_), blue(blue_)
        {
        }
        public nothrow Color(byte red_, byte green_, byte blue_) : alpha(255u), red(red_), green(green_), blue(blue_)
        {
        }
        public static nothrow Color AliceBlue() 
        {
            return Color(0xF0u, 0xF8u, 0xFFu);
        }
        public static nothrow Color AntiqueWhite()
        {
            return Color(0xFAu, 0xEBu, 0xD7u);
        }
        public static nothrow Color Aqua()
        {
            return Color(0x00u, 0xFFu, 0xFFu);
        }
        public static nothrow Color Aquamarine()
        {
            return Color(0x7Fu, 0xFFu, 0xD4u);
        }
        public static nothrow Color Azure()
        {
            return Color(0xF0u, 0xFFu, 0xFFu);
        }
        public static nothrow Color Beige()
        {
            return Color(0xF5u, 0xF5u, 0xDCu);
        }
        public static nothrow Color Bisque()
        {
            return Color(0xFFu, 0xE4u, 0xC4u);
        }
        public static nothrow Color Black()
        {
            return Color(0x00u, 0x00u, 0x00u);
        }
        public static nothrow Color BlanchedAlmond()
        {
            return Color(0xFFu, 0xEBu, 0xCDu);
        }
        public static nothrow Color Blue()
        {
            return Color(0x00u, 0x00u, 0xFFu);
        }
        public static nothrow Color BlueViolet()
        {
            return Color(0x8Au, 0x2Bu, 0xE2u);
        }
        public static nothrow Color Brown()
        {
            return Color(0xA5u, 0x2Au, 0x2Au);
        }
        public static nothrow Color BurlyWood()
        {
            return Color(0xDEu, 0xB8u, 0x87u);
        }
        public static nothrow Color CadetBlue()
        {
            return Color(0x5Fu, 0x9Eu, 0xA0u);
        }
        public static nothrow Color Chartreuse()
        {
            return Color(0x7Fu, 0xFFu, 0x00u);
        }
        public static nothrow Color Chocolate()
        {
            return Color(0xD2u, 0x69u, 0x1Eu);
        }
        public static nothrow Color Coral()
        {
            return Color(0xFFu, 0x7Fu, 0x50u);
        }
        public static nothrow Color CornflowerBlue()
        {
            return Color(0x64u, 0x95u, 0xEDu);
        }
        public static nothrow Color Cornsilk()
        {
            return Color(0xFFu, 0xF8u, 0xDCu);
        }
        public static nothrow Color Crimson()
        {
            return Color(0xDCu, 0x14u, 0x3Cu);
        }
        public static nothrow Color Cyan()
        {
            return Color(0x00u, 0xFFu, 0xFFu);
        }
        public static nothrow Color DarkBlue()
        {
            return Color(0x00u, 0x00u, 0x8Bu);
        }
        public static nothrow Color DarkCyan()
        {
            return Color(0x00u, 0x8Bu, 0x8Bu);
        }
        public static nothrow Color DarkGoldenrod()
        {
            return Color(0xB8u, 0x86u, 0x0Bu);
        }
        public static nothrow Color DarkGray()
        {
            return Color(0xA9u, 0xA9u, 0xA9u);
        }
        public static nothrow Color DarkGreen()
        {
            return Color(0x00u, 0x64u, 0x00u);
        }
        public static nothrow Color DarkKhaki()
        {
            return Color(0xBDu, 0xB7u, 0x6Bu);
        }
        public static nothrow Color DarkMagenta()
        {
            return Color(0x8Bu, 0x00u, 0x8Bu);
        }
        public static nothrow Color DarkOliveGreen()
        {
            return Color(0x55u, 0x6Bu, 0x2Fu);
        }
        public static nothrow Color DarkOrange()
        {
            return Color(0xFFu, 0x8Cu, 0x00u);
        }
        public static nothrow Color DarkOrchid()
        {
            return Color(0x99u, 0x32u, 0xCCu);
        }
        public static nothrow Color DarkRed()
        {
            return Color(0x8Bu, 0x00u, 0x00u);
        }
        public static nothrow Color DarkSalmon()
        {
            return Color(0xE9u, 0x96u, 0x7Au);
        }
        public static nothrow Color DarkSeaGreen()
        {
            return Color(0x8Fu, 0xBCu, 0x8Bu);
        }
        public static nothrow Color DarkSlateBlue()
        {
            return Color(0x48u, 0x3Du, 0x8Bu);
        }
        public static nothrow Color DarkSlateGray()
        {
            return Color(0x2Fu, 0x4Fu, 0x4Fu);
        }
        public static nothrow Color DarkTurquoise()
        {
            return Color(0x00u, 0xCEu, 0xD1u);
        }
        public static nothrow Color DarkViolet()
        {
            return Color(0x94u, 0x00u, 0xD3u);
        }
        public static nothrow Color DeepPink()
        {
            return Color(0xFFu, 0x14u, 0x93u);
        }
        public static nothrow Color DeepSkyBlue()
        {
            return Color(0x00u, 0xBFu, 0xFFu);
        }
        public static nothrow Color DimGray()
        {
            return Color(0x69u, 0x69u, 0x69u);
        }
        public static nothrow Color DodgerBlue()
        {
            return Color(0x1Eu, 0x90u, 0xFFu);
        }
        public static nothrow Color Firebrick()
        {
            return Color(0xB2u, 0x22u, 0x22u);
        }
        public static nothrow Color FloralWhite()
        {
            return Color(0xFFu, 0xFAu, 0xF0u);
        }
        public static nothrow Color ForestGreen()
        {
            return Color(0x22u, 0x8Bu, 0x22u);
        }
        public static nothrow Color Fuchsia()
        {
            return Color(0xFFu, 0x00u, 0xFFu);
        }
        public static nothrow Color Gainsboro()
        {
            return Color(0xDCu, 0xDCu, 0xDCu);
        }
        public static nothrow Color GhostWhite()
        {
            return Color(0xF8u, 0xF8u, 0xFFu);
        }
        public static nothrow Color Gold()
        {
            return Color(0xFFu, 0xD7u, 0x00u);
        }
        public static nothrow Color Goldenrod()
        {
            return Color(0xDAu, 0xA5u, 0x20u);
        }
        public static nothrow Color Gray()
        {
            return Color(0x80u, 0x80u, 0x80u);
        }
        public static nothrow Color Green()
        {
            return Color(0x00u, 0x80u, 0x00u);
        }
        public static nothrow Color GreenYellow()
        {
            return Color(0xADu, 0xFFu, 0x2Fu);
        }
        public static nothrow Color Honeydew()
        {
            return Color(0xF0u, 0xFFu, 0xF0u);
        }
        public static nothrow Color HotPink()
        {
            return Color(0xFFu, 0x69u, 0xB4u);
        }
        public static nothrow Color IndianRed()
        {
            return Color(0xCDu, 0x5Cu, 0x5Cu);
        }
        public static nothrow Color Indigo()
        {
            return Color(0x4Bu, 0x00u, 0x82u);
        }
        public static nothrow Color Ivory()
        {
            return Color(0xFFu, 0xFFu, 0xF0u);
        }
        public static nothrow Color Khaki()
        {
            return Color(0xF0u, 0xE6u, 0x8Cu);
        }
        public static nothrow Color Lavender()
        {
            return Color(0xE6u, 0xE6u, 0xFAu);
        }
        public static nothrow Color LavenderBlush()
        {
            return Color(0xFFu, 0xF0u, 0xF5u);
        }
        public static nothrow Color LawnGreen()
        {
            return Color(0x7Cu, 0xFCu, 0x00u);
        }
        public static nothrow Color LemonChiffon()
        {
            return Color(0xFFu, 0xFAu, 0xCDu);
        }
        public static nothrow Color LightBlue()
        {
            return Color(0xADu, 0xD8u, 0xE6u);
        }
        public static nothrow Color LightCoral()
        {
            return Color(0xF0u, 0x80u, 0x80u);
        }
        public static nothrow Color LightCyan()
        {
            return Color(0xE0u, 0xFFu, 0xFFu);
        }
        public static nothrow Color LightGoldenrodYellow()
        {
            return Color(0xFAu, 0xFAu, 0xD2u);
        }
        public static nothrow Color LightGray()
        {
            return Color(0xD3u, 0xD3u, 0xD3u);
        }
        public static nothrow Color LightGreen()
        {
            return Color(0x90u, 0xEEu, 0x90u);
        }
        public static nothrow Color LightPink()
        {
            return Color(0xFFu, 0xB6u, 0xC1u);
        }
        public static nothrow Color LightSalmon()
        {
            return Color(0xFFu, 0xA0u, 0x7Au);
        }
        public static nothrow Color LightSeaGreen()
        {
            return Color(0x20u, 0xB2u, 0xAAu);
        }
        public static nothrow Color LightSkyBlue()
        {
            return Color(0x87u, 0xCEu, 0xFAu);
        }
        public static nothrow Color LightSlateGray()
        {
            return Color(0x77u, 0x88u, 0x99u);
        }
        public static nothrow Color LightSteelBlue()
        {
            return Color(0xB0u, 0xC4u, 0xDEu);
        }
        public static nothrow Color LightYellow()
        {
            return Color(0xFFu, 0xFFu, 0xE0u);
        }
        public static nothrow Color Lime()
        {
            return Color(0x00u, 0xFFu, 0x00u);
        }
        public static nothrow Color LimeGreen()
        {
            return Color(0x32u, 0xCDu, 0x32u);
        }
        public static nothrow Color Linen()
        {
            return Color(0xFAu, 0xF0u, 0xE6u);
        }
        public static nothrow Color Magenta()
        {
            return Color(0xFFu, 0x00u, 0xFFu);
        }
        public static nothrow Color Maroon()
        {
            return Color(0x80u, 0x00u, 0x00u);
        }
        public static nothrow Color MediumAquamarine()
        {
            return Color(0x66u, 0xCDu, 0xAAu);
        }
        public static nothrow Color MediumBlue()
        {
            return Color(0x00u, 0x00u, 0xCDu);
        }
        public static nothrow Color MediumOrchid()
        {
            return Color(0xBAu, 0x55u, 0xD3u);
        }
        public static nothrow Color MediumPurple()
        {
            return Color(0x93u, 0x70u, 0xDBu);
        }
        public static nothrow Color MediumSeaGreen()
        {
            return Color(0x3Cu, 0xB3u, 0x71u);
        }
        public static nothrow Color MediumSlateBlue()
        {
            return Color(0x7Bu, 0x68u, 0xEEu);
        }
        public static nothrow Color MediumSpringGreen()
        {
            return Color(0x00u, 0xFAu, 0x9Au);
        }
        public static nothrow Color MediumTurquoise()
        {
            return Color(0x48u, 0xD1u, 0xCCu);
        }
        public static nothrow Color MediumVioletRed()
        {
            return Color(0xC7u, 0x15u, 0x85u);
        }
        public static nothrow Color MidnightBlue()
        {
            return Color(0x19u, 0x19u, 0x70u);
        }
        public static nothrow Color MintCream()
        {
            return Color(0xF5u, 0xFFu, 0xFAu);
        }
        public static nothrow Color MistyRose()
        {
            return Color(0xFFu, 0xE4u, 0xE1u);
        }
        public static nothrow Color Moccasin()
        {
            return Color(0xFFu, 0xE4u, 0xB5u);
        }
        public static nothrow Color NavajoWhite()
        {
            return Color(0xFFu, 0xDEu, 0xADu);
        }
        public static nothrow Color Navy()
        {
            return Color(0x00u, 0x00u, 0x80u);
        }
        public static nothrow Color OldLace()
        {
            return Color(0xFDu, 0xF5u, 0xE6u);
        }
        public static nothrow Color Olive()
        {
            return Color(0x80u, 0x80u, 0x00u);
        }
        public static nothrow Color OliveDrab()
        {
            return Color(0x6Bu, 0x8Eu, 0x23u);
        }
        public static nothrow Color Orange()
        {
            return Color(0xFFu, 0xA5u, 0x00u);
        }
        public static nothrow Color OrangeRed()
        {
            return Color(0xFFu, 0x45u, 0x00u);
        }
        public static nothrow Color Orchid()
        {
            return Color(0xDAu, 0x70u, 0xD6u);
        }
        public static nothrow Color PaleGoldenrod()
        {
            return Color(0xEEu, 0xE8u, 0xAAu);
        }
        public static nothrow Color PaleGreen()
        {
            return Color(0x98u, 0xFBu, 0x98u);
        }
        public static nothrow Color PaleTurquoise()
        {
            return Color(0xAFu, 0xEEu, 0xEEu);
        }
        public static nothrow Color PaleVioletRed()
        {
            return Color(0xDBu, 0x70u, 0x93u);
        }
        public static nothrow Color PapayaWhip()
        {
            return Color(0xFFu, 0xEFu, 0xD5u);
        }
        public static nothrow Color PeachPuff()
        {
            return Color(0xFFu, 0xDAu, 0xB9u);
        }
        public static nothrow Color Peru()
        {
            return Color(0xCDu, 0x85u, 0x3Fu);
        }
        public static nothrow Color Pink()
        {
            return Color(0xFFu, 0xC0u, 0xCBu);
        }
        public static nothrow Color Plum()
        {
            return Color(0xDDu, 0xA0u, 0xDDu);
        }
        public static nothrow Color PowderBlue()
        {
            return Color(0xB0u, 0xE0u, 0xE6u);
        }
        public static nothrow Color Purple()
        {
            return Color(0x80u, 0x00u, 0x80u);
        }
        public static nothrow Color Red()
        {
            return Color(0xFFu, 0x00u, 0x00u);
        }
        public static nothrow Color RosyBrown()
        {
            return Color(0xBCu, 0x8Fu, 0x8Fu);
        }
        public static nothrow Color RoyalBlue()
        {
            return Color(0x41u, 0x69u, 0xE1u);
        }
        public static nothrow Color SaddleBrown()
        {
            return Color(0x8Bu, 0x45u, 0x13u);
        }
        public static nothrow Color Salmon()
        {
            return Color(0xFAu, 0x80u, 0x72u);
        }
        public static nothrow Color SandyBrown()
        {
            return Color(0xF4u, 0xA4u, 0x60u);
        }
        public static nothrow Color SeaGreen()
        {
            return Color(0x2Eu, 0x8Bu, 0x57u);
        }
        public static nothrow Color SeaShell()
        {
            return Color(0xFFu, 0xF5u, 0xEEu);
        }
        public static nothrow Color Sienna()
        {
            return Color(0xA0u, 0x52u, 0x2Du);
        }
        public static nothrow Color Silver()
        {
            return Color(0xC0u, 0xC0u, 0xC0u);
        }
        public static nothrow Color SkyBlue()
        {
            return Color(0x87u, 0xCEu, 0xEBu);
        }
        public static nothrow Color SlateBlue()
        {
            return Color(0x6Au, 0x5Au, 0xCDu);
        }
        public static nothrow Color SlateGray()
        {
            return Color(0x70u, 0x80u, 0x90u);
        }
        public static nothrow Color Snow()
        {
            return Color(0xFFu, 0xFAu, 0xFAu);
        }
        public static nothrow Color SpringGreen()
        {
            return Color(0x00u, 0xFFu, 0x7Fu);
        }
        public static nothrow Color SteelBlue()
        {
            return Color(0x46u, 0x82u, 0xB4u);
        }
        public static nothrow Color Tan()
        {
            return Color(0xD2u, 0xB4u, 0x8Cu);
        }
        public static nothrow Color Teal()
        {
            return Color(0x00u, 0x80u, 0x80u);
        }
        public static nothrow Color Thistle()
        {
            return Color(0xD8u, 0xBFu, 0xD8u);
        }
        public static nothrow Color Tomato()
        {
            return Color(0xFFu, 0x63u, 0x47u);
        }
        public static nothrow Color Transparent()
        {
            return Color(0x00u, 0xFFu, 0xFFu, 0xFFu);
        }
        public static nothrow Color Turquoise()
        {
            return Color(0x40u, 0xE0u, 0xD0u);
        }
        public static nothrow Color Violet()
        {
            return Color(0xEEu, 0x82u, 0xEEu);
        }
        public static nothrow Color Wheat()
        {
            return Color(0xF5u, 0xDEu, 0xB3u);
        }
        public static nothrow Color White()
        {
            return Color(0xFFu, 0xFFu, 0xFFu);
        }
        public static nothrow Color WhiteSmoke()
        {
            return Color(0xF5u, 0xF5u, 0xF5u);
        }
        public static nothrow Color Yellow()
        {
            return Color(0xFFu, 0xFFu, 0x00u);
        }
        public static nothrow Color YellowGreen()
        {
            return Color(0x9Au, 0xCDu, 0x32u);
        }
        public byte alpha;
        public byte red;
        public byte green;
        public byte blue;
    }

    public nothrow bool operator==(const Color& left, const Color& right)
    {
        return left.alpha == right.alpha && left.red == right.red && left.green == right.green && left.blue == right.blue;
    }

    public Color GetSystemColor(SystemColor color)
    {
        byte red;
        byte green;
        byte blue;
        WinGetSysColor(cast<int>(color), red, green, blue);
        return Color(red, green, blue);
    }

    public class Point
    {
        public nothrow Point() : x(0), y(0)
        {
        }
        public nothrow Point(int x_, int y_) : x(x_), y(y_)
        {
        }
        public default nothrow Point(const Point&);
        public default nothrow void operator=(const Point&);
        public static nothrow Point Default()
        {
            return Point(CW_USEDEFAULT, CW_USEDEFAULT);
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(x) + ", " + ToString(y) + ")";
        }
        public int x; 
        public int y;
    }
    
    public nothrow inline bool operator==(const Point& left, const Point& right)
    {
        return left.x == right.x && left.y == right.y;
    }
    
    public class Size
    {
        public nothrow Size() : h(0), w(0)
        {
        }
        public nothrow Size(int w_, int h_) : w(w_), h(h_)
        {
        }
        public default nothrow Size(const Size&);
        public default nothrow void operator=(const Size&);
        public static nothrow Size Default()
        {
            return Size(CW_USEDEFAULT, CW_USEDEFAULT);
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(w) + ", " + ToString(h) + ")";
        }
        public int w;
        public int h;
    }
    
    public nothrow inline bool operator==(const Size& left, const Size& right)
    {
        return left.w == right.w && left.h == right.h;
    }

    public class PointF
    {
        public nothrow PointF() : x(0.0f), y(0.0f)
        {
        }
        public nothrow PointF(float x_, float y_) : x(x_), y(y_)
        {
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(x) + ", " + ToString(y) + ")";
        }
        public float x;
        public float y;
    }

    public class SizeF
    {
        public nothrow SizeF() : w(0.0f), h(0.0f)
        {
        }
        public nothrow SizeF(float w_, float h_) : w(w_), h(h_)
        {
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(w) + ", " + ToString(h) + ")";
        }
        public float w;
        public float h;
    }

    public class Rect
    {
        public nothrow Rect() : location(), size()
        {
        }
        public nothrow Rect(const Point& location_, const Size& size_) : location(location_), size(size_)
        {
        }
        public nothrow Rect(const WinRect& winRect) : location(winRect.left, winRect.top), size(winRect.right - winRect.left, winRect.bottom - winRect.top)
        {
        }
        public nothrow WinRect ToWinRect() const
        {
            return WinRect(location.x, location.y, location.x + size.w, location.y + size.h);
        }
        public nothrow inline bool IsEmpty() const
        {
            return size.w == 0 && size.h == 0;
        }
        public nothrow inline int Left() const
        {
            return location.x;
        }
        public nothrow inline int Right() const
        {
            return location.x + size.w;
        }
        public nothrow inline int Top() const
        {
            return location.y;
        }
        public nothrow inline int Bottom() const
        {
            return location.y + size.h;
        }
        public nothrow inline bool Contains(const Point& p)
        {
            return p.x >= location.x && p.x < location.x + size.w && p.y >= location.y && p.y < location.y + size.h;
        }
        public nothrow inline void Inflate(int dx, int dy)
        {
            location.x = location.x - dx;
            location.y = location.y - dy;
            size.w = size.w + 2 * dx;
            size.h = size.h + 2 * dy;
        }
        public nothrow inline void Offset(int dx, int dy)
        {
            location.x = location.x + dx;
            location.y = location.y + dy;
        }
        public static nothrow Rect Union(const Rect& a, const Rect& b)
        {
            int right = Max(a.Right(), b.Right());
            int bottom = Max(a.Bottom(), b.Bottom());
            int left = Min(a.Left(), b.Left());
            int top = Min(a.Top(), b.Top());
            return Rect(Point(left, top), Size(right - left, bottom - top));
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(location.x) + ", " + ToString(location.y) + ", " + ToString(size.w) + ", " + ToString(size.h) + ")";
        }
        public Point location;
        public Size size;
    }

    public nothrow inline bool operator==(const Rect& left, const Rect& right)
    {
        return left.location == right.location && left.size == right.size;
    }

    public class RectF
    {
        public nothrow RectF() : location(), size()
        {
        }
        public nothrow RectF(const PointF& location_, const SizeF& size_) : location(location_), size(size_)
        {
        }
        public nothrow inline float Left() const
        {
            return location.x;
        }
        public nothrow inline float Right() const
        {
            return location.x + size.w;
        }
        public nothrow inline float Top() const
        {
            return location.y;
        }
        public nothrow inline float Bottom() const
        {
            return location.y + size.h;
        }
        public nothrow string ToString() const
        {
            return "(" + ToString(location.x) + ", " + ToString(location.y) + ", " + ToString(size.w) + ", " + ToString(size.h) + ")";
        }
        public nothrow inline bool IsEmpty() const
        {
            return size.w == 0 && size.h == 0;
        }
        public nothrow inline void Inflate(float dx, float dy)
        {
            location.x = location.x - dx;
            location.y = location.y - dy;
            size.w = size.w + 2 * dx;
            size.h = size.h + 2 * dy;
        }
        public static nothrow RectF Union(const RectF& a, const RectF& b)
        {
            float right = Max(a.Right(), b.Right());
            float bottom = Max(a.Bottom(), b.Bottom());
            float left = Min(a.Left(), b.Left());
            float top = Min(a.Top(), b.Top());
            return RectF(PointF(left, top), SizeF(right - left, bottom - top));
        }
        public PointF location;
        public SizeF size;
    }

    public class Pen
    {
        public Pen(const Color& color, float width) : nativePen(WinGraphicsCreatePen(color.alpha, color.red, color.green, color.blue, width))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsPenGetLastStatus(nativePen)));
        }
        public Pen(const Color& color) : this(color, 1.0f)
        {
        }
        public Pen(const Pen& that) : nativePen(WinGraphicsClonePen(that.nativePen))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsPenGetLastStatus(nativePen)));
        }
        public nothrow Pen(Pen&& that) : nativePen(that.nativePen)
        {
            that.nativePen = null;
        }
        public void operator=(const Pen& that)
        {
            if (nativePen != that.nativePen)
            {
                if (nativePen != null)
                {
                    WinGraphicsDeletePen(nativePen);
                }
                nativePen = WinGraphicsClonePen(that.nativePen);
                CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsPenGetLastStatus(nativePen)));
            }
        }
        public default nothrow void operator=(Pen&& that);
        public ~Pen()
        {
            if (nativePen != null)
            {
                WinGraphicsDeletePen(nativePen);
            }
        }
        public nothrow inline void* NativePen() const
        {
            return nativePen;
        }
        private void* nativePen;
    }

    public abstract class Brush
    {
        public virtual ~Brush()
        {
        }
        public abstract nothrow const void* NativeBrush() const;
    }

    public class SolidBrush : Brush
    {
        public SolidBrush(const Color& color) : nativeSolidBrush(WinGraphicsCreateSolidBrush(color.alpha, color.red, color.green, color.blue))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsBrushGetLastStatus(nativeSolidBrush)));
        }
        public SolidBrush(const SolidBrush& that) : nativeSolidBrush(WinGraphicsCloneSolidBrush(that.nativeSolidBrush))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsBrushGetLastStatus(nativeSolidBrush)));
        }
        public nothrow SolidBrush(SolidBrush&& that) : nativeSolidBrush(that.nativeSolidBrush)
        {
            that.nativeSolidBrush = null;
        }
        public void operator=(const SolidBrush& that)
        {
            if (nativeSolidBrush != that.nativeSolidBrush)
            {
                if (nativeSolidBrush != null)
                {
                    WinGraphicsDeleteSolidBrush(nativeSolidBrush);
                }
                nativeSolidBrush = WinGraphicsCloneSolidBrush(that.nativeSolidBrush);
                CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsBrushGetLastStatus(nativeSolidBrush)));
            }
        }
        public default nothrow void operator=(SolidBrush&& that);
        public ~SolidBrush()
        {
            if (nativeSolidBrush != null)
            {
                WinGraphicsDeleteSolidBrush(nativeSolidBrush);
            }
        }
        public override nothrow const void* NativeBrush() const
        {
            return nativeSolidBrush;
        }
        private void* nativeSolidBrush;
    }

    public class NativeHandle
    {
        public explicit nothrow NativeHandle(const void* handle_) : handle(handle_)
        {
        }
        public void* handle;
    }

    public class FontFamily
    {
        public FontFamily(const string& familyName) : nativeFontFamily(WinGraphicsCreateFontFamily(familyName.Chars())), owned(true)
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsFontFamilyGetLastStatus(nativeFontFamily)));
        }
        public explicit nothrow FontFamily(const NativeHandle& nativeHandle_) : nativeFontFamily(nativeHandle_.handle), owned(false) // stock font family not owned
        {
        }
        public FontFamily(const FontFamily& that) : nativeFontFamily(null), owned(that.owned)
        {
            if (owned)
            {
                nativeFontFamily = WinGraphicsCloneFontFamily(that.nativeFontFamily);
                CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsFontFamilyGetLastStatus(nativeFontFamily)));
            }
            else
            {
                nativeFontFamily = that.nativeFontFamily; // stock font family not cloned
            }
        }
        public nothrow FontFamily(FontFamily&& that) : nativeFontFamily(that.nativeFontFamily), owned(that.owned)
        {
            that.nativeFontFamily = null;
            that.owned = false;
        }
        public void operator=(const FontFamily& that)
        {
            if (nativeFontFamily != that.nativeFontFamily)
            {
                if (nativeFontFamily != null && owned)
                {
                    WinGraphicsDeleteFontFamily(nativeFontFamily);
                }
                if (that.owned)
                {
                    nativeFontFamily = WinGraphicsCloneFontFamily(that.nativeFontFamily);
                    CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsFontFamilyGetLastStatus(nativeFontFamily)));
                    owned = true;
                }
                else
                {
                    nativeFontFamily = that.nativeFontFamily; // stock font family not cloned
                    owned = false;
                }
            }
        }
        public default nothrow void operator=(FontFamily&&);
        public ~FontFamily()
        {
            if (nativeFontFamily != null && owned)
            {
                WinGraphicsDeleteFontFamily(nativeFontFamily);
            }
        }
        public static nothrow FontFamily GenericMonospace()
        {
            NativeHandle nativeHandle(WinGraphicsGetGenericMonospaceFontFamily());
            return FontFamily(nativeHandle);
        }
        public static nothrow FontFamily GenericSansSerif()
        {
            NativeHandle nativeHandle(WinGraphicsGetGenericSansSerifFontFamily());
            return FontFamily(nativeHandle);
        }
        public static nothrow FontFamily GenericSerif()
        {
            NativeHandle nativeHandle(WinGraphicsGetGenericSerifFontFamily());
            return FontFamily(nativeHandle);
        }
        public nothrow inline void* NativeFontFamily() const
        {
            return nativeFontFamily;
        }
        private void* nativeFontFamily;
        private bool owned;
    }

    public enum FontStyle : int
    {
        regular = 0,
        bold = 1 << 0,
        italic = 1 << 1,
        boldItalic = bold | italic,
        underline = 1 << 2,
        strikeOut = 1 << 3
    }

    public enum Unit : int
    {
        world = 0,
        display = 1,
        pixel = 2,
        point = 3,
        inch = 4,
        document = 5,
        millimeter = 6
    }

    public class Font
    {
        public Font(const FontFamily& family, float emSize, FontStyle style, Unit unit) : nativeFont(WinGraphicsCreateFont(family.NativeFontFamily(), emSize, style, unit))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsFontGetLastStatus(nativeFont)));
        }
        public Font(const FontFamily& family, float emSize) : this(family, emSize, FontStyle.regular, Unit.point)
        {
        }
        public Font(const Font& that) : nativeFont(WinGraphicsCloneFont(that.nativeFont))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsFontGetLastStatus(nativeFont)));
        }
        public nothrow Font(Font&& that) : nativeFont(that.nativeFont)
        {
            that.nativeFont = null;
        }
        public void operator=(const Font& that)
        {
            if (nativeFont != that.nativeFont)
            {
                if (nativeFont != null)
                {
                    WinGraphicsDeleteFont(nativeFont);
                }
                nativeFont = WinGraphicsCloneFont(that.nativeFont);
            }
        }
        public default nothrow void operator=(Font&&);
        public ~Font()
        {
            if (nativeFont != null)
            {
                WinGraphicsDeleteFont(nativeFont);
            }
        }
        public nothrow float GetHeight(const Graphics& graphics) const
        {
            return WinGraphicsGetFontHeight(nativeFont, graphics.NativeGraphics());
        }
        public nothrow inline void* NativeFont() const
        {
            return nativeFont;
        }
        private void* nativeFont;
    }

    public enum StringAlignment : int
    {
        near, center, far
    }

    public enum HotKeyPrefix : int
    {
        none, show, hide
    }

    public class StringFormat
    {
        public StringFormat() : nativeFormat(WinGraphicsCreateDefaultStringFormat())
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsStringFormatGetLastStatus(nativeFormat)));
        }
        public StringFormat(const StringFormat& that) : nativeFormat(WinGraphicsCloneStringFormat(that.nativeFormat))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsStringFormatGetLastStatus(nativeFormat)));
        }
        public StringFormat(StringAlignment horizontalAlignment, StringAlignment verticalAlignment, HotKeyPrefix hotKeyPrefix) : this()
        {
            SetAlignmentChecked(horizontalAlignment);
            SetLineAlignmentChecked(verticalAlignment);
            SetHotKeyPrefixChecked(hotKeyPrefix);
        }
        public StringFormat(StringAlignment horizontalAlignment, StringAlignment verticalAlignment) : this(horizontalAlignment, verticalAlignment, HotKeyPrefix.none)
        {
        }
        public nothrow StringFormat(StringFormat&& that) : nativeFormat(that.nativeFormat)
        {
            that.nativeFormat = null;
        }
        public void operator=(const StringFormat& that)
        {
            if (nativeFormat != that.nativeFormat)
            {
                if (nativeFormat != null)
                {
                    WinGraphicsDeleteStringFormat(nativeFormat);
                }
                nativeFormat = WinGraphicsCloneStringFormat(that.nativeFormat);
            }
        }
        public default nothrow void operator=(StringFormat&&);
        public ~StringFormat()
        {
            if (nativeFormat != null)
            {
                WinGraphicsDeleteStringFormat(nativeFormat);
            }
        }
        public nothrow GraphicsStatus SetAlignment(StringAlignment alignment)
        {
            return cast<GraphicsStatus>(WinGraphicsStringFormatSetAlignment(nativeFormat, alignment));
        }
        public void SetAlignmentChecked(StringAlignment alignment)
        {
            CheckGraphicsStatus(SetAlignment(alignment));
        }
        public nothrow GraphicsStatus SetLineAlignment(StringAlignment alignment)
        {
            return cast<GraphicsStatus>(WinGraphicsStringFormatSetLineAlignment(nativeFormat, alignment));
        }
        public void SetLineAlignmentChecked(StringAlignment alignment)
        {
            CheckGraphicsStatus(SetLineAlignment(alignment));
        }
        public nothrow GraphicsStatus SetHotKeyPrefix(HotKeyPrefix hotKeyPrefix)
        {
            return cast<GraphicsStatus>(WinGraphicsStringFormatSetHotKeyPrefix(nativeFormat, hotKeyPrefix));
        }
        public void SetHotKeyPrefixChecked(HotKeyPrefix hotKeyPrefix)
        {
            CheckGraphicsStatus(SetHotKeyPrefix(hotKeyPrefix));
        }
        public nothrow inline void* NativeFormat() const
        {
            return nativeFormat;
        }
        private void* nativeFormat;
    }

    internal class PaintGuard
    {
        public nothrow PaintGuard(void* hdc_, void* paintStruct_) : hdc(hdc_), paintStruct(paintStruct_)
        {
        }
        public ~PaintGuard()
        {
            if (hdc != null)
            {
                EndPaint(hdc, paintStruct);
            }
        }
        private void* hdc;
        private void* paintStruct;
    }

    public enum CombineMode : int
    {
        replace, intersect, union, xor, exclude, complement
    }

    public class Region
    {
        public Region() : nativeRegion(WinGraphicsCreateRegion())
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsRegionGetLastStatus(nativeRegion)));
        }
        public Region(const Region& that) : nativeRegion(WinGraphicsCloneRegion(that.nativeRegion))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsRegionGetLastStatus(nativeRegion)));
        }
        public nothrow Region(Region&& that) : nativeRegion(that.nativeRegion)
        {
            that.nativeRegion = null;
        }
        public void operator=(const Region& that)
        {
            if (nativeRegion != null)
            {
                WinGraphicsDeleteRegion(nativeRegion);
            }
            nativeRegion = WinGraphicsCloneRegion(that.nativeRegion);
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsRegionGetLastStatus(nativeRegion)));
        }
        public nothrow default void operator=(Region&&);
        public ~Region()
        {
            if (nativeRegion != null)
            {
                WinGraphicsDeleteRegion(nativeRegion);
            }
        }
        public nothrow inline void* NativeRegion() const
        {
            return nativeRegion;
        }
        private void* nativeRegion;
    }

    public class Image
    {
        public nothrow Image() : nativeImage(null)
        {
        }
        public nothrow Image(void* nativeImage_) : nativeImage(nativeImage_)
        {
        }
        public Image(const string& fileName, bool useEmbeddedColorManagement) : nativeImage(WinGraphicsCreateImage(fileName.Chars(), useEmbeddedColorManagement))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(nativeImage)));
        }
        public Image(const Image& that) : nativeImage(WinGraphicsCloneImage(that.nativeImage))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(nativeImage)));
        }
        public nothrow Image(Image&& that) : nativeImage(that.nativeImage)
        {
            that.nativeImage = null;
        }
        public void operator=(const Image& that)
        {
            if (nativeImage != null)
            {
                WinGraphicsDeleteImage(nativeImage);
            }
            nativeImage = WinGraphicsCloneImage(that.nativeImage);
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(nativeImage)));
        }
        public nothrow default void operator=(Image&&);
        public virtual ~Image()
        {
            if (nativeImage != null)
            {
                WinGraphicsDeleteImage(nativeImage);
            }
        }
        public nothrow void* NativeImage() const
        {
            return nativeImage;
        }
        private void* nativeImage;
    }

    public class Bitmap : Image
    {
        public nothrow Bitmap() : base()
        {
        }
        public nothrow Bitmap(void* nativeHandle_) : base(nativeHandle_)
        {
        }
        public Bitmap(const string& fileName, bool useEmbeddedColorManagement) : base(WinGraphicsCreateBitmap(fileName.Chars(), useEmbeddedColorManagement))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(NativeImage())));
        }
        public Bitmap(int width, int height, const Graphics& graphics) : base(WinGraphicsCreateBitmapWidthHeight(width, height, graphics.NativeGraphics()))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(NativeImage())));
        }
        public Bitmap(const WinBitmap& winBitmap, void* palette) : base(WinGraphicsCreateBitmapWinBitmap(winBitmap.Handle(), palette))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(NativeImage())));
        }
        public Bitmap(const Icon& icon) : base(WinGraphicsCreateBitmapIcon(icon.Handle()))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(NativeImage())));
        }
        public static Bitmap FromResource(const string& resourceName)
        {
            Bitmap bitmap(WinGraphicsCreateBitmapResource(resourceName.Chars()));
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsImageGetLastStatus(bitmap.NativeImage())));
            return bitmap;
        }
        public ~Bitmap()
        {
        }
    }

    public enum MatrixOrder
    {
        prepend, append
    }

    public class Matrix
    {
        public Matrix() : nativeMatrix(WinGraphicsCreateMatrix())
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsMatrixGetLastStatus(nativeMatrix)));
        }
        public Matrix(const Rect& rect, const Point& pt) : nativeMatrix(WinGraphicsCreateMatrixRectPoint(rect.location.x, rect.location.y, rect.size.w, rect.size.h, pt.x, pt.y))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsMatrixGetLastStatus(nativeMatrix)));
        }
        public Matrix(const RectF& rect, const PointF& pt) : nativeMatrix(WinGraphicsCreateMatrixRectFPointF(rect.location.x, rect.location.y, rect.size.w, rect.size.h, pt.x, pt.y))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsMatrixGetLastStatus(nativeMatrix)));
        }
        public Matrix(const Matrix& that) : nativeMatrix(WinGraphicsCloneMatrix(that.nativeMatrix))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsMatrixGetLastStatus(nativeMatrix)));
        }
        public nothrow Matrix(Matrix&& that) : nativeMatrix(that.nativeMatrix)
        {
            that.nativeMatrix = null;
        }
        public void operator=(const Matrix& that)
        {
            if (nativeMatrix != null)
            {
                WinGraphicsDeleteMatrix(nativeMatrix);
            }
            nativeMatrix = WinGraphicsCloneMatrix(that.nativeMatrix);
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsMatrixGetLastStatus(nativeMatrix)));
        }
        public nothrow default void operator=(Matrix&&);
        public ~Matrix()
        {
            if (nativeMatrix != null)
            {
                WinGraphicsDeleteMatrix(nativeMatrix);
            }
        }
        public GraphicsStatus Multiply(const Matrix& that, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMultiplyMatrix(nativeMatrix, that.nativeMatrix, cast<int>(order)));
        }
        public GraphicsStatus Multiply(const Matrix& that)
        {
            return cast<GraphicsStatus>(WinGraphicsMultiplyMatrix(nativeMatrix, that.nativeMatrix, cast<int>(MatrixOrder.prepend)));
        }
        public void MultiplyChecked(const Matrix& that, MatrixOrder order)
        {
            CheckGraphicsStatus(Multiply(that, order));
        }
        public void MultiplyChecked(const Matrix& that)
        {
            CheckGraphicsStatus(Multiply(that, MatrixOrder.prepend));
        }
        public nothrow GraphicsStatus Reset()
        {
            return cast<GraphicsStatus>(WinGraphicsResetMatrix(nativeMatrix));
        }
        public void ResetChecked()
        {
            CheckGraphicsStatus(Reset());
        }
        public nothrow GraphicsStatus Invert()
        {
            return cast<GraphicsStatus>(WinGraphicsInvertMatrix(nativeMatrix));
        }
        public void InvertChecked()
        {
            CheckGraphicsStatus(Invert());
        }
        public nothrow float OffsetX() const
        {
            return WinGraphicsMatrixOffsetX(nativeMatrix);
        }
        public nothrow float OffsetY() const
        {
            return WinGraphicsMatrixOffsetY(nativeMatrix);
        }
        public nothrow GraphicsStatus Rotate(float angle, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixRotate(nativeMatrix, angle, cast<int>(order)));
        }
        public nothrow GraphicsStatus Rotate(float angle)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixRotate(nativeMatrix, angle, cast<int>(MatrixOrder.prepend)));
        }
        public void RotateChecked(float angle, MatrixOrder order)
        {
            CheckGraphicsStatus(Rotate(angle));
        }
        public void RotateChecked(float angle)
        {
            CheckGraphicsStatus(Rotate(angle, MatrixOrder.prepend));
        }
        public nothrow GraphicsStatus RotateAt(float angle, const PointF& center, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixRotateAt(nativeMatrix, angle, center.x, center.y, cast<int>(order)));
        }
        public void RotateAtChecked(float angle, const PointF& center, MatrixOrder order)
        {
            CheckGraphicsStatus(RotateAt(angle, center, order));
        }
        public nothrow GraphicsStatus RotateAt(float angle, const PointF& center)
        {
            return RotateAt(angle, center, MatrixOrder.prepend);
        }
        public void RotateAtChecked(float angle, const PointF& center)
        {
            CheckGraphicsStatus(RotateAt(angle, center, MatrixOrder.prepend));
        }
        public nothrow GraphicsStatus Scale(float scaleX, float scaleY, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixScale(nativeMatrix, scaleX, scaleY, cast<int>(order)));
        }
        public void ScaleChecked(float scaleX, float scaleY, MatrixOrder order)
        {
            CheckGraphicsStatus(Scale(scaleX, scaleY, order));
        }
        public nothrow GraphicsStatus Scale(float scaleX, float scaleY)
        {
            return Scale(scaleX, scaleY, MatrixOrder.prepend);
        }
        public void ScaleChecked(float scaleX, float scaleY)
        {
            CheckGraphicsStatus(Scale(scaleX, scaleY, MatrixOrder.prepend));
        }
        public nothrow GraphicsStatus Shear(float shearX, float shearY, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixShear(nativeMatrix, shearX, shearY, cast<int>(order)));
        }
        public void ShearChecked(float shearX, float shearY, MatrixOrder order)
        {
            CheckGraphicsStatus(Shear(shearX, shearY, order));
        }
        public nothrow GraphicsStatus Shear(float shearX, float shearY)
        {
            return Shear(shearX, shearY, MatrixOrder.prepend);
        }
        public void ShearChecked(float shearX, float shearY)
        {
            ShearChecked(shearX, shearY, MatrixOrder.prepend);
        }
        public nothrow GraphicsStatus Translate(float offsetX, float offsetY, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixTranslate(nativeMatrix, offsetX, offsetY, cast<int>(order)));
        }
        public void TranslateChecked(float offsetX, float offsetY, MatrixOrder order)
        {
            CheckGraphicsStatus(Translate(offsetX, offsetY, order));
        }
        public nothrow GraphicsStatus Translate(float offsetX, float offsetY)
        {
            return Translate(offsetX, offsetY, MatrixOrder.prepend);
        }
        public void TranslateChecked(float offsetX, float offsetY)
        {
            TranslateChecked(offsetX, offsetY, MatrixOrder.prepend);
        }
        public nothrow GraphicsStatus SetElements(float m11, float m12, float m21, float m22, float dx, float dy)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixSetElements(nativeMatrix, m11, m12, m21, m22, dx, dy));
        }
        public void SetElementsChecked(float m11, float m12, float m21, float m22, float dx, float dy)
        {
            CheckGraphicsStatus(SetElements(m11, m12, m21, m22, dx, dy));
        }
        public nothrow GraphicsStatus TransformPoints(List<Point>& points)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixTransformPoints(nativeMatrix, points.Begin().Ptr(), cast<int>(points.Count())));
        }
        public void TransformPointsChecked(List<Point>& points)
        {
            CheckGraphicsStatus(TransformPoints(points));
        }
        public nothrow GraphicsStatus TransformPoints(List<PointF>& points)
        {
            return cast<GraphicsStatus>(WinGraphicsMatrixTransformPointsF(nativeMatrix, points.Begin().Ptr(), cast<int>(points.Count())));
        }
        public void TransformPointsChecked(List<PointF>& points)
        {
            CheckGraphicsStatus(TransformPoints(points));
        }
        public nothrow inline void* NativeMatrix() const
        {
            return nativeMatrix;
        }
        private void* nativeMatrix;
    }

    public Matrix operator*(const Matrix& left, const Matrix& right) // multiply matrix 'right' from left by matrix 'left' and return result
    {
        Matrix product(right);
        product.MultiplyChecked(left);
        return product;
    }

    public Matrix Rotate(const Matrix& m, float angle) // create clockwise rotation matrix from given matrix and angle in degrees and return it
    {
        Matrix rm(m);
        rm.RotateChecked(angle);
        return rm;
    }

    public Matrix RotateAt(const Matrix& m, float angle, const PointF& center) // create clockwise rotation matrix of rotation about point 'center' and return it
    {
        Matrix rm(m);
        rm.RotateAtChecked(angle, center);
        return rm;
    }

    public Matrix Scale(const Matrix& m, float scaleX, float scaleY) // create scaling matrix from given matrix and scale factors in X and Y direction and return it
    {
        Matrix sm(m);
        sm.ScaleChecked(scaleX, scaleY);
        return sm;
    }

    public Matrix Shear(const Matrix& m, float shearX, float shearY) // create shearing matrix from given matrix and horizontal and vertical shearing factors and return it
    {
        Matrix sm(m);
        sm.ShearChecked(shearX, shearY);
        return sm;
    }

    public Matrix Translate(const Matrix& m, float offsetX, float offsetY) // create translation matrix from given matrix and horizontal and vertical offsets and return it
    {
        Matrix tm(m);
        tm.TranslateChecked(offsetX, offsetY);
        return tm;
    }

    public Matrix Invert(const Matrix& m)
    {
        Matrix im(m);
        im.InvertChecked();
        return im;
    }

    public enum GraphicsState : uint
    {
        state = 0u
    }

    public enum SmoothingMode : int
    {
        invalid = -1,
        default_ = 0,
        highSpeed = 1,
        highQuality = 2,
        none = 3,
        antiAlias = 4
    }

    public class Graphics
    {
        public nothrow Graphics() : nativeGraphics(null)
        {
        }
        public Graphics(void* hdc) : nativeGraphics(WinCreateGraphics(hdc))
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
        }
        public Graphics(const NativeHandle& nativeHandle) : nativeGraphics(nativeHandle.handle)
        {
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
        }
        public static Graphics FromWindowHandle(void* windowHandle)
        {
            NativeHandle nativeHandle = WinCreateGraphicsFromWindowHandle(windowHandle);
            return Graphics(nativeHandle);
        }
        public static Graphics FromImage(const Image& image)
        {
            NativeHandle nativeHandle = WinCreateGraphicsFromImage(image.NativeImage());
            return Graphics(nativeHandle);
        }
        suppress Graphics(const Graphics&);
        public nothrow Graphics(Graphics&& that) : nativeGraphics(that.nativeGraphics)
        {
            that.nativeGraphics = null;
        }
        suppress void operator=(const Graphics&);
        public default nothrow void operator=(Graphics&&);
        public ~Graphics()
        {
            if (nativeGraphics != null)
            {
                WinDeleteGraphics(nativeGraphics);
            }
        }
        public nothrow void* GetHDC() const
        {
            return WinGraphicsGetHDC(nativeGraphics);
        }
        public nothrow GraphicsStatus DrawLine(const Pen& pen, const Point& start, const Point& end)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawLine(nativeGraphics, pen.NativePen(), start.x, start.y, end.x, end.y));
        }
        public void DrawLineChecked(const Pen& pen, const Point& start, const Point& end)
        {
            CheckGraphicsStatus(DrawLine(pen, start, end));
        }
        public nothrow GraphicsStatus DrawLines(const Pen& pen, int numPoints, const Point* points)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawLines(nativeGraphics, pen.NativePen(), numPoints, points));
        }
        public void DrawLinesChecked(const Pen& pen, int numPoints, const Point* points)
        {
            CheckGraphicsStatus(DrawLines(pen, numPoints, points));
        }
        public nothrow GraphicsStatus DrawString(const string& str, const Font& font, const PointF& origin, const Brush& brush)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawString(nativeGraphics, str.Chars(), font.NativeFont(), origin.x, origin.y, brush.NativeBrush()));
        }
        public void DrawStringChecked(const string& str, const Font& font, const PointF& origin, const Brush& brush)
        {
            CheckGraphicsStatus(DrawString(str, font, origin, brush));
        }
        public nothrow GraphicsStatus DrawString(const string& str, const Font& font, const PointF& origin, const StringFormat& format, const Brush& brush)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawStringFormatPoint(nativeGraphics, str.Chars(), font.NativeFont(),
                origin.x, origin.y, format.NativeFormat(), brush.NativeBrush()));
        }
        public void DrawStringChecked(const string& str, const Font& font, const PointF& origin, const StringFormat& format, const Brush& brush)
        {
            CheckGraphicsStatus(DrawString(str, font, origin, format, brush));
        }
        public nothrow GraphicsStatus DrawString(const string& str, const Font& font, const RectF& rect, const StringFormat& format, const Brush& brush)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawStringFormatRect(nativeGraphics, str.Chars(), font.NativeFont(),
                rect.location.x, rect.location.y, rect.size.w, rect.size.h,
                format.NativeFormat(), brush.NativeBrush()));
        }
        public void DrawStringChecked(const string& str, const Font& font, const RectF& rect, const StringFormat& format, const Brush& brush)
        {
            CheckGraphicsStatus(DrawString(str, font, rect, format, brush));
        }
        public nothrow GraphicsStatus MeasureString(const string& str, const Font& font, const SizeF& layoutRectSize, const StringFormat& format,
            SizeF& size, int* codePointsFitted, int* linesFilled)
        {
            return cast<GraphicsStatus>(WinGraphicsMeasureStringFormatSize(nativeGraphics, str.Chars(), font.NativeFont(),
                layoutRectSize.w, layoutRectSize.h, format.NativeFormat(), 
                size.w, size.h, codePointsFitted, linesFilled));
        }
        public SizeF MeasureStringChecked(const string& str, const Font& font, const SizeF& layoutRectSize, const StringFormat& format, int* codePointsFitted, int* linesFilled)
        {
            SizeF size;
            CheckGraphicsStatus(MeasureString(str, font, layoutRectSize, format, size, codePointsFitted, linesFilled));
            return size;
        }
        public nothrow GraphicsStatus MeasureString(const string& str, const Font& font, const SizeF& layoutRectSize, const StringFormat& format, SizeF& size)
        {
            return cast<GraphicsStatus>(WinGraphicsMeasureStringFormatSize(nativeGraphics, str.Chars(), font.NativeFont(),
                layoutRectSize.w, layoutRectSize.h, format.NativeFormat(), 
                size.w, size.h, null, null));
        }
        public SizeF MeasureStringChecked(const string& str, const Font& font, const SizeF& layoutRectSize, const StringFormat& format)
        {
            SizeF size;
            CheckGraphicsStatus(MeasureString(str, font, layoutRectSize, format, size));
            return size;
        }
        public nothrow GraphicsStatus MeasureString(const string& str, const Font& font, const RectF& layoutRect, const StringFormat& format,
            RectF& boundingBox, int* codePointsFitted, int* linesFilled)
        {
            return cast<GraphicsStatus>(WinGraphicsMeasureStringFormatRect(nativeGraphics, str.Chars(), font.NativeFont(),
                layoutRect.location.x, layoutRect.location.y, layoutRect.size.w, layoutRect.size.h, format.NativeFormat(), 
                boundingBox.location.x, boundingBox.location.y, boundingBox.size.w, boundingBox.size.h,
                codePointsFitted, linesFilled));
        }
        public RectF MeasureStringChecked(const string& str, const Font& font, const RectF& layoutRect, const StringFormat& format, int* codePointsFitted, int* linesFilled)
        {
            RectF boundingBox;
            CheckGraphicsStatus(MeasureString(str, font, layoutRect, format, boundingBox, codePointsFitted, linesFilled));
            return boundingBox;
        }
        public nothrow GraphicsStatus MeasureString(const string& str, const Font& font, const RectF& layoutRect, const StringFormat& format, RectF& boundingBox)
        {
            return cast<GraphicsStatus>(WinGraphicsMeasureStringFormatRect(nativeGraphics, str.Chars(), font.NativeFont(),
                layoutRect.location.x, layoutRect.location.y, layoutRect.size.w, layoutRect.size.h, format.NativeFormat(), 
                boundingBox.location.x, boundingBox.location.y, boundingBox.size.w, boundingBox.size.h,
                null, null));
        }
        public RectF MeasureStringChecked(const string& str, const Font& font, const RectF& layoutRect, const StringFormat& format)
        {
            RectF boundingBox;
            CheckGraphicsStatus(MeasureString(str, font, layoutRect, format, boundingBox));
            return boundingBox;
        }
        public nothrow GraphicsStatus MeasureString(const string& str, const Font& font, const PointF& origin, const StringFormat& format, RectF& boundingBox)
        {
            return cast<GraphicsStatus>(WinGraphicsMeasureStringFormatPoint(nativeGraphics, str.Chars(), font.NativeFont(), origin.x, origin.y, format.NativeFormat(), 
                boundingBox.location.x, boundingBox.location.y, boundingBox.size.w, boundingBox.size.h));
        }
        public RectF MeasureStringChecked(const string& str, const Font& font, const PointF& origin, const StringFormat& format)
        {
            RectF boundingBox;
            CheckGraphicsStatus(MeasureString(str, font, origin, format, boundingBox));
            return boundingBox;
        }
        public nothrow GraphicsStatus Clear(const Color& color)
        {
            return cast<GraphicsStatus>(WinGraphicsClear(nativeGraphics, color.alpha, color.red, color.green, color.blue));
        }
        public void ClearChecked(const Color& color)
        {
            CheckGraphicsStatus(Clear(color));
        }
        public nothrow GraphicsStatus DrawRectangle(const Pen& pen, const Rect& rect)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawRectangle(nativeGraphics, pen.NativePen(), rect.location.x, rect.location.y, rect.size.w, rect.size.h));
        }
        public void DrawRectangleChecked(const Pen& pen, const Rect& rect)
        {
            CheckGraphicsStatus(DrawRectangle(pen, rect));
        }
        public nothrow GraphicsStatus DrawRectangle(const Pen& pen, const RectF& rect)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawRectangleF(nativeGraphics, pen.NativePen(), rect.location.x, rect.location.y, rect.size.w, rect.size.h));
        }
        public void DrawRectangleChecked(const Pen& pen, const RectF& rect)
        {
            CheckGraphicsStatus(DrawRectangle(pen, rect));
        }
        public nothrow GraphicsStatus FillRectangle(const Brush& brush, const Rect& rect)
        {
            return cast<GraphicsStatus>(WinGraphicsFillRectangle(nativeGraphics, brush.NativeBrush(), rect.location.x, rect.location.y, rect.size.w, rect.size.h));
        }
        public void FillRectangleChecked(const Brush& brush, const Rect& rect)
        {
            CheckGraphicsStatus(FillRectangle(brush, rect));
        }
        public nothrow GraphicsStatus FillPolygon(const Brush& brush, int numPoints, const Point* points)
        {
            return cast<GraphicsStatus>(WinGraphicsFillPolygon(nativeGraphics, brush.NativeBrush(), numPoints, points));
        }
        public void FillPolygonChecked(const Brush& brush, int numPoints, const Point* points)
        {
            CheckGraphicsStatus(FillPolygon(brush, numPoints, points));
        }
        public nothrow GraphicsStatus DrawImage(const Image& image, const PointF& point)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawImagePoint(nativeGraphics, image.NativeImage(), point.x, point.y));
        }
        public void DrawImageChecked(const Image& image, const PointF& point)
        {
            CheckGraphicsStatus(DrawImage(image, point));
        }
        public nothrow GraphicsStatus DrawImage(const Image& image, const RectF& rect)
        {
            return cast<GraphicsStatus>(WinGraphicsDrawImageRect(nativeGraphics, image.NativeImage(), rect.location.x, rect.location.y, rect.size.w, rect.size.h));
        }
        public void DrawImageChecked(const Image& image, const RectF& rect)
        {
            CheckGraphicsStatus(DrawImage(image, rect));
        }
        public nothrow GraphicsStatus GetClip(Region& region)
        {
            return cast<GraphicsStatus>(WinGraphicsGetClip(nativeGraphics, region.NativeRegion()));
        }
        public Region GetClipChecked()
        {
            Region region;
            CheckGraphicsStatus(GetClip(region));
            return region;
        }
        public nothrow GraphicsStatus SetClip(const Rect& rect, CombineMode combineMode)
        {
            return cast<GraphicsStatus>(WinGraphicsSetClipRect(nativeGraphics, rect.location.x, rect.location.y, rect.size.w, rect.size.h, combineMode));
        }
        public nothrow GraphicsStatus SetClip(const Rect& rect)
        {
            return cast<GraphicsStatus>(WinGraphicsSetClipRect(nativeGraphics, rect.location.x, rect.location.y, rect.size.w, rect.size.h, CombineMode.replace));
        }
        public void SetClipChecked(const Rect& rect, CombineMode combineMode)
        {
            CheckGraphicsStatus(SetClip(rect, combineMode));
        }
        public void SetClipChecked(const Rect& rect)
        {
            CheckGraphicsStatus(SetClip(rect, CombineMode.replace));
        }
        public nothrow GraphicsStatus SetClip(const Region& region)
        {
            return cast<GraphicsStatus>(WinGraphicsSetClipRegion(nativeGraphics, region.NativeRegion()));
        }
        public void SetClipChecked(const Region& region)
        {
            CheckGraphicsStatus(SetClip(region));
        }
        public nothrow GraphicsState Save()
        {
            return cast<GraphicsState>(WinGraphicsSave(nativeGraphics));
        }
        public GraphicsState SaveChecked()
        {
            GraphicsState state = Save();
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
            return state;
        }
        public nothrow GraphicsStatus Restore(GraphicsState graphicsState)
        {
            return cast<GraphicsStatus>(WinGraphicsRestore(nativeGraphics, cast<uint>(graphicsState)));
        }
        public void RestoreChecked(GraphicsState graphicsState)
        {
            CheckGraphicsStatus(Restore(graphicsState));
        }
        public nothrow GraphicsStatus GetTransform(Matrix& m)
        {
            return cast<GraphicsStatus>(WinGraphicsGetTransform(nativeGraphics, m.NativeMatrix()));
        }
        public void GetTransformChecked(Matrix& m)
        {
            CheckGraphicsStatus(GetTransform(m));
        }
        public nothrow GraphicsStatus SetTransform(Matrix& m)
        {
            return cast<GraphicsStatus>(WinGraphicsSetTransform(m.NativeMatrix()));
        }
        public nothrow GraphicsStatus MultiplyTransform(const Matrix& matrix, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsMultiplyTransform(nativeGraphics, matrix.NativeMatrix(), cast<int>(order)));
        }
        public void MultiplyTransformChecked(const Matrix& matrix, MatrixOrder order)
        {
            CheckGraphicsStatus(MultiplyTransform(matrix, order));
        }
        public nothrow GraphicsStatus MultiplyTransform(const Matrix& matrix)
        {
            return MultiplyTransform(matrix, MatrixOrder.prepend);
        }
        public void MultiplyTransformChecked(const Matrix& matrix)
        {
            CheckGraphicsStatus(MultiplyTransform(matrix));
        }
        public nothrow GraphicsStatus ResetTransform()
        {
            return cast<GraphicsStatus>(WinGraphicsResetTransform(nativeGraphics));
        }
        public void ResetTransformChecked()
        {
            CheckGraphicsStatus(ResetTransform());
        }
        public nothrow GraphicsStatus RotateTransform(float angle, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsRotateTransform(nativeGraphics, angle, cast<int>(order)));
        }
        public void RotateTransformChecked(float angle, MatrixOrder order)
        {
            CheckGraphicsStatus(RotateTransform(angle, order));
        }
        public nothrow GraphicsStatus RotateTransform(float angle)
        {
            return RotateTransform(angle, MatrixOrder.prepend);
        }
        public void RotateTransformChecked(float angle)
        {
            RotateTransformChecked(angle, MatrixOrder.prepend);
        }
        public nothrow GraphicsStatus ScaleTransform(float scaleX, float scaleY, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsScaleTransform(nativeGraphics, scaleX, scaleY, cast<int>(order)));
        }
        public void ScaleTransformChecked(float scaleX, float scaleY, MatrixOrder order)
        {
            CheckGraphicsStatus(ScaleTransform(scaleX, scaleY, order));
        }
        public nothrow GraphicsStatus ScaleTransform(float scaleX, float scaleY)
        {
            return ScaleTransform(scaleX, scaleY, MatrixOrder.prepend);
        }
        public void ScaleTransformChecked(float scaleX, float scaleY)
        {
            ScaleTransformChecked(scaleX, scaleY, MatrixOrder.prepend);
        }
        public nothrow GraphicsStatus TranslateTransform(float offsetX, float offsetY, MatrixOrder order)
        {
            return cast<GraphicsStatus>(WinGraphicsTranslateTransform(nativeGraphics, offsetX, offsetY, cast<int>(order)));
        }
        public void TranslateTransformChecked(float offsetX, float offsetY, MatrixOrder order)
        {
            CheckGraphicsStatus(TranslateTransform(offsetX, offsetY, order));
        }
        public nothrow GraphicsStatus TranslateTransform(float offsetX, float offsetY)
        {
            return TranslateTransform(offsetX, offsetY, MatrixOrder.prepend);
        }
        public void TranslateTransformChecked(float offsetX, float offsetY)
        {
            TranslateTransformChecked(offsetX, offsetY, MatrixOrder.prepend);
        }
        public nothrow Unit GetPageUnit()
        {
            return cast<Unit>(WinGraphicsGetPageUnit(nativeGraphics));
        }
        public Unit GetPageUnitChecked()
        {
            Unit unit = GetPageUnit();
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
            return unit;
        }
        public nothrow GraphicsStatus SetPageUnit(Unit unit)
        {
            return cast<GraphicsStatus>(WinGraphicsSetPageUnit(nativeGraphics, cast<int>(unit)));
        }
        public void SetPageUnitChecked(Unit unit)
        {
            CheckGraphicsStatus(SetPageUnit(unit));
        }
        public nothrow float GetPageScale()
        {
            return WinGraphicsGetPageScale(nativeGraphics);
        }
        public float GetPageScaleChecked()
        {
            float scale = GetPageScale();
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
            return scale;
        }
        public nothrow GraphicsStatus SetPageScale(float scale)
        {
            return cast<GraphicsStatus>(WinGraphicsSetPageScale(nativeGraphics, scale));
        }
        public void SetPageScaleChecked(float scale)
        {
            CheckGraphicsStatus(SetPageScale(scale));
        }
        public nothrow float GetDpiX()
        {
            return WinGraphicsGetDpiX(nativeGraphics);
        }
        public nothrow float GetDpiY()
        {
            return WinGraphicsGetDpiY(nativeGraphics);
        }
        public nothrow SmoothingMode GetSmoothingMode()
        {
            return cast<SmoothingMode>(WinGraphicsGetSmoothingMode(nativeGraphics));
        }
        public SmoothingMode GetSmoothingModeChecked()
        {
            SmoothingMode smoothingMode = GetSmoothingMode();
            CheckGraphicsStatus(cast<GraphicsStatus>(WinGraphicsGetLastStatus(nativeGraphics)));
            return smoothingMode;
        }
        public nothrow GraphicsStatus SetSmoothingMode(SmoothingMode smoothingMode)
        {
            return cast<GraphicsStatus>(WinGraphicsSetSmoothingMode(nativeGraphics, smoothingMode));
        }
        public void SetSmoothingModeChecked(SmoothingMode smoothingMode)
        {
            CheckGraphicsStatus(SetSmoothingMode(smoothingMode));
        }
        public nothrow inline const void* NativeGraphics() const
        {
            return nativeGraphics;
        }
        private void* nativeGraphics;
    }
}

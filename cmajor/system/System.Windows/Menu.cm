// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows.API;

namespace System.Windows
{
    public nothrow Color DefaultMenuBackgroundColor()
    {
        return GetSystemColor(SystemColor.COLOR_MENU);
    }

    public nothrow Color DefaultMenuTextColor()
    {
        return GetSystemColor(SystemColor.COLOR_MENUTEXT);
    }

    public nothrow Color DefaultDisabledMenuTextColor()
    {
        Color color = GetSystemColor(SystemColor.COLOR_GRAYTEXT);
        if (color == Color.Black())
        {
            return Color(195u, 195u, 198u);
        }
        return color;
    }

    public nothrow Color DefaultMenuMouseOverColor()
    {
        return Color(201u, 222u, 245u);
    }

    public nothrow Color DefaultMenuOpenColor()
    {
        return Color.White();
    }

    public nothrow ControlCreateParams& MenuControlControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowClassBackgroundColor(SystemColor.COLOR_MENU).SetBackgroundColor(DefaultMenuBackgroundColor());
    }

    public class MenuControlCreateParams
    {
        public nothrow MenuControlCreateParams(ControlCreateParams& controlCreateParams_) :
            controlCreateParams(controlCreateParams_),
            fontFamilyName("Segoe UI"),
            fontSize(9.0f),
            textColor(DefaultMenuTextColor()),
            disabledTextColor(DefaultDisabledMenuTextColor()),
            mouseOverColor(DefaultMenuMouseOverColor()),
            menuOpenColor(DefaultMenuOpenColor())
        {
        }
        public nothrow MenuControlCreateParams& Defaults()
        {
            return *this;
        }
        public ControlCreateParams& controlCreateParams;
        public string fontFamilyName;
        public float fontSize;
        public Color textColor;
        public Color disabledTextColor;
        public Color mouseOverColor;
        public Color menuOpenColor;
    }

    public abstract class MenuControl : Control
    {
        public MenuControl(const Font& font_, const string& windowClassName, WindowClassStyle windowClassStyle, WindowStyle style,
            ExtendedWindowStyle exStyle,
            const Color& backgroundColor, const string& text, const Point& location, const Size& size, Dock dock, Anchors anchors) :
            base(windowClassName, windowClassStyle, style, exStyle, backgroundColor, text, location, size, dock, anchors),
            font(font_), textColor(DefaultMenuTextColor()), disabledTextColor(DefaultDisabledMenuTextColor()), mouseOverColor(201u, 222u, 245u),
            menuOpenColor(Color.White()), shadowColor(ShadowColor()), textBrush(textColor), disabledTextBrush(disabledTextColor),
            backgroundBrush(BackgroundColor()), mouseOverBrush(mouseOverColor), menuOpenBrush(menuOpenColor),
            shadowBrush(shadowColor), blackBrush(Color.Black()), blackPen(Color.Black()), darkPen(Color.DarkGray()),
            format(StringAlignment.near, StringAlignment.near, HotKeyPrefix.show)
        {
        }
        public MenuControl(MenuControlCreateParams& createParams) :
            base(createParams.controlCreateParams),
            font(FontFamily(createParams.fontFamilyName), createParams.fontSize),
            textColor(createParams.textColor),
            disabledTextColor(createParams.disabledTextColor),
            mouseOverColor(createParams.mouseOverColor),
            menuOpenColor(createParams.menuOpenColor),
            shadowColor(ShadowColor()),
            textBrush(textColor), disabledTextBrush(disabledTextColor),
            backgroundBrush(BackgroundColor()), mouseOverBrush(mouseOverColor), menuOpenBrush(menuOpenColor),
            shadowBrush(shadowColor), blackBrush(Color.Black()), blackPen(Color.Black()), darkPen(Color.DarkGray()),
            format(StringAlignment.near, StringAlignment.near, HotKeyPrefix.show)
        {
        }
        public override nothrow Padding DefaultPadding() const
        {
            return Padding(6, 2, 6, 2);
        }
        public nothrow inline const Font& GetFont() const
        {
            return font;
        }
        public nothrow inline const Color& TextColor() const
        {
            return textColor;
        }
        public nothrow inline const Color& DisabledTextColor() const
        {
            return disabledTextColor;
        }
        public nothrow inline const Color& MouseOverColor() const
        {
            return mouseOverColor;
        }
        public nothrow inline const Color& MenuOpenColor() const
        {
            return menuOpenColor;
        }
        public nothrow inline const Color& ShadowColor() const
        {
            return shadowColor;
        }
        public nothrow inline const Brush& TextBrush() const
        {
            return textBrush;
        }
        public nothrow inline const Brush& DisabledTextBrush() const
        {
            return disabledTextBrush;
        }
        public nothrow inline const Brush& BackgroundBrush() const
        {
            return backgroundBrush;
        }
        public nothrow inline const Brush& MouseOverBrush() const
        {
            return mouseOverBrush;
        }
        public nothrow inline const Brush& MenuOpenBrush() const
        {
            return menuOpenBrush;
        }
        public nothrow inline const Brush& ShadowBrush() const
        {
            return shadowBrush;
        }
        public nothrow inline const Brush& BlackBrush() const
        {
            return blackBrush;
        }
        public nothrow inline const Pen& BlackPen() const
        {
            return blackPen;
        }
        public nothrow inline const Pen& DarkPen() const
        {
            return darkPen;
        }
        public nothrow inline const StringFormat& Format() const
        {
            return format;
        }
        internal virtual nothrow MenuItem* GetMenuItemByAccessKey(wchar accessKey)
        {
            return null;
        }
        internal virtual nothrow MenuItem* GetOpenedMenuItem() const
        {
            return null;
        }
        internal virtual nothrow MenuItem* GetSelectedMenuItem() const
        {
            return null;
        }
        internal virtual nothrow void SetSelectedMenuItem(MenuItem* selectedMenuItem_)
        {
        }
        internal virtual nothrow bool IsOpen() const
        {
            return false;
        }
        public virtual nothrow void SetOpen()
        {
        }
        internal virtual nothrow void SetClosed()
        {
        }
        internal virtual nothrow void SetMenuInvalidated()
        {
        }
        internal virtual nothrow MenuItem* GetFirstMenuItem() const
        {
            return null;
        }
        internal virtual nothrow MenuItem* GetLastMenuItem() const
        {
            return null;
        }
        internal virtual nothrow MenuItem* LatestOpenedMenuItem() const
        {
            return null;
        }
        internal virtual nothrow void SetLatestOpenedMenuItem(MenuItem* menuItem)
        {
        }
        internal virtual nothrow MenuItem* GetLatestMouseDownMenuItem() const
        {
            return null;
        }
        internal virtual nothrow void SetLatestMouseDownMenuItem(MenuItem* menuItem)
        {
        }
        internal virtual void InvalidateMenu()
        {
        }
        internal virtual nothrow void SetMenuChanged()
        {
        }
        private Font font;
        private Color textColor;
        private Color disabledTextColor;
        private Color mouseOverColor;
        private Color menuOpenColor;
        private Color shadowColor;
        private SolidBrush textBrush;
        private SolidBrush disabledTextBrush;
        private SolidBrush backgroundBrush;
        private SolidBrush mouseOverBrush;
        private SolidBrush menuOpenBrush;
        private SolidBrush shadowBrush;
        private SolidBrush blackBrush;
        private Pen blackPen;
        private Pen darkPen;
        private StringFormat format;
    }

    public const int initialMenuBarHeight = 20;

    public nothrow ControlCreateParams& MenuBarControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowClassBackgroundColor(SystemColor.COLOR_MENU).SetBackgroundColor(DefaultMenuBackgroundColor()).
            SetWindowClassName("System.Windows.MenuBar").SetDock(Dock.top).SetSize(Size(0, initialMenuBarHeight));
    }

    public class MenuBarCreateParams
    {
        public nothrow MenuBarCreateParams(MenuControlCreateParams& menuControlCreateParams_) : menuControlCreateParams(menuControlCreateParams_)
        {
        }
        public nothrow MenuBarCreateParams& Defaults()
        {
            return *this;
        }
        public MenuControlCreateParams& menuControlCreateParams;
    }

    public class MenuBar : MenuControl
    {
        private enum Flags : sbyte
        {
            none, open = 1 << 0, menuChanged = 1 << 1, menuBoxAdded = 1 << 2, menuInvalidated = 1 << 3, menuKeyDisabled = 1 << 4
        }

        internal Color ShadowColor()
        {
            Color shadowColor = GetSystemColor(SystemColor.COLOR_BTNSHADOW);
            shadowColor.alpha = 196u;
            return shadowColor;
        }

        public MenuBar(const Font& font_) : base(font_, "System.Windows.MenuBar", DefaultWindowClassStyle(), DefaultChildWindowStyle(),
            DefaultExtendedWindowStyle(), DefaultMenuBackgroundColor(), "menuBar", Point(), Size(0, initialMenuBarHeight), Dock.top, Anchors.none),
            flags(Flags.none), children(this), latestOpenedMenuItem(null), selectedMenuItem(null), latestMouseDownMenuItem(null)
        {
            SetMenuChanged();
        }
        public MenuBar() : this(Font(FontFamily("Segoe UI"), 9.0f))
        {
        }
        public MenuBar(MenuBarCreateParams& createParams) :
            base(createParams.menuControlCreateParams),
            flags(Flags.none), children(this), latestOpenedMenuItem(null), selectedMenuItem(null), latestMouseDownMenuItem(null)
        {
            SetMenuChanged();
        }
        public void CloseMenu()
        {
            if (!IsOpen()) return;
            SetClosed();
            SetLatestOpenedMenuItem(null);
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    menuItem->SetState(MenuItem.State.closed, this);
                }
                child = child->NextSibling();
            }
            InvalidateMenu();
        }
        public void AddMenuItem(MenuItem* menuItem)
        {
            children.AddChild(menuItem);
            SetMenuChanged();
        }
        public override void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "MenuBar." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                if (Debug.Paint())
                {
                    Rect r(Location(), GetSize());
                    LogView* log = Application.GetLogView();
                    if (log != null)
                    {
                        log->WriteLine("MenuBar.OnPaint: " + r.ToString());
                    }
                }
                if (!MenuBoxAdded())
                {
                    SetMenuBoxAdded();
                    AddMenuBox();
                }
                args.graphics.Clear(BackgroundColor());
                if (MenuChanged())
                {
                    ResetMenuChanged();
                    CollectShortcuts();
                    Size size = GetSize();
                    size.h = cast<int>(GetFont().GetHeight(args.graphics));
                    size.h = size.h + DefaultPadding().Vertical();
                    SetSize(size);
                    LocateMenuItems(args.graphics, size);
                }
                DrawMenuItems(args, false, Location());
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void LocateMenuItems(Graphics& graphics, const Size& size)
        {
            Rect itemRect(Location(), Size(0, size.h));
            Padding padding = DefaultPadding();
            PointF origin(0, 0);
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    Padding menuItemPadding = menuItem->DefaultPadding();
                    RectF r = graphics.MeasureStringChecked(menuItem->Text(), GetFont(), origin, Format());
                    int w = cast<int>(r.size.w) + padding.Horizontal() + menuItemPadding.Horizontal();
                    itemRect.size.w = w;
                    menuItem->SetLocation(itemRect.location);
                    menuItem->SetSize(itemRect.size);
                    menuItem->CalculateChildRect(graphics, GetFont(), Format(), Point(itemRect.location.x, itemRect.location.y + itemRect.size.h));
                    itemRect.location.x = itemRect.location.x + w;
                }
                child = child->NextSibling();
            }
        }
        private nothrow Control* ParentControl() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    return cast<Control*>(parent);
                }
            }
            return null;
        }
        private void InvalidateParentRect(const Rect& parentRect)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->Invalidate(parentRect.ToWinRect());
            }
        }
        internal void DrawMenuItems(PaintEventArgs& args, bool drawSubItems, const Point& origin)
        {
            Padding padding = DefaultPadding();
            Size size = GetSize();
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    menuItem->Draw(
                        args.graphics, padding, TextBrush(), DisabledTextBrush(), BackgroundBrush(), MouseOverBrush(), MenuOpenBrush(), ShadowBrush(), BlackBrush(), BlackPen(), DarkPen(), GetFont(), Format(),
                        MenuOpenColor(), this, drawSubItems, origin);
                }
                child = child->NextSibling();
            }
        }
        internal void DoKeyDown(KeyEventArgs& args)
        {
            OnKeyDown(args);
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            base->OnKeyDown(args);
            if (!args.handled)
            {
                HashMap<Keys, MenuItem*>.ConstIterator it = shortcuts.CFind(args.key);
                if (it != shortcuts.CEnd())
                {
                    MenuItem* menuItem = it->second;
                    if (menuItem->IsEnabled())
                    {
                        menuItem->DoClick();
                        args.handled = true;
                    }
                }
            }
        }
        internal void MouseEnterInternal()
        {
            OnMouseEnter();
        }
        protected override void OnMouseEnter()
        {
            base->OnMouseEnter();
        }
        internal void MouseMoveInternal(MouseEventArgs& args)
        {
            OnMouseMove(args);
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            ResetMenuInvalidated();
            base->OnMouseMove(args);
            bool handled = false;
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (!menuItem->Contains(args.location))
                    {
                        menuItem->ResetSelected(this);
                        if (menuItem->MouseInClient())
                        {
                            menuItem->ResetMouseInClient();
                            menuItem->DoMouseLeave(this);
                        }
                    }
                }
                child = child->NextSibling();
            }
            child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->Contains(args.location))
                    {
                        menuItem->SetSelected(this);
                        if (!menuItem->MouseInClient())
                        {
                            menuItem->SetMouseInClient();
                            menuItem->DoMouseEnter(IsOpen(), this);
                        }
                        else
                        {
                            menuItem->DoMouseMove(args);
                        }
                        handled = true;
                    }
                }
                child = child->NextSibling();
            }
            if (!handled)
            {
                if (IsOpen())
                {
                    if (latestOpenedMenuItem != null)
                    {
                        Component* child = children.FirstChild();
                        while (child != null && !handled)
                        {
                            if (child is MenuItem*)
                            {
                                MenuItem* menuItem = cast<MenuItem*>(child);
                                if (menuItem->IsSameOrParentOf(latestOpenedMenuItem))
                                {
                                    menuItem->DispatchMouseMove(args, handled, this);
                                }
                            }
                            child = child->NextSibling();
                        }
                    }
                }
            }
            if (MenuInvalidated())
            {
                InvalidateMenu();
            }
        }
        internal void MouseLeaveInternal()
        {
            OnMouseLeave();
        }
        protected override void OnMouseLeave()
        {
            ResetMenuInvalidated();
            base->OnMouseLeave();
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->MouseInClient() || menuItem->Children().IsEmpty())
                    {
                        menuItem->ResetSelected(this);
                        menuItem->ResetMouseInClient();
                        Point mousePos;
                        WinGetMessagePos(mousePos.x, mousePos.y);
                        mousePos = ScreenToClient(mousePos);
                        if (menuItem != latestOpenedMenuItem || !menuItem->UnionRectContains(mousePos))
                        {
                            menuItem->DoMouseLeave(this);
                        }
                    }
                    else
                    {
                        menuItem->ResetSelected(this);
                        menuItem->ResetMouseInClient();
                    }
                }
                child = child->NextSibling();
            }
            if (MenuInvalidated())
            {
                InvalidateMenu();
            }
        }
        internal override void InvalidateMenu()
        {
            Invalidate();
            Rect menuRect;
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->GetState() == MenuItem.State.open)
                    {
                        menuItem->GetOpenRect(menuRect);
                    }
                }
                child = child->NextSibling();
            }
            if (IsOpen())
            {
                if (menuBox != null)
                {
                    menuBox->SetPaintThisMenuBox(true);
                    menuBox->SetLocation(Point(Location().x + menuRect.location.x, Location().y + menuRect.location.y));
                    menuBox->SetSize(menuRect.size);
                    Control* parentControl = ParentControl();
                    Control* topControl = null;
                    if (parentControl != null)
                    {
                        topControl = parentControl->TopControl();
                    }
                    menuBox->BringToFront();
                    menuBox->Show();
                    menuBox->Invalidate();
                    menuBox->Update();
                    if (topControl != null)
                    {
                        topControl->BringToFront();
                    }
                }
            }
            else
            {
                if (menuBox != null)
                {
                    menuBox->SetPaintThisMenuBox(false);
                    menuBox->Hide();
                }
                InvalidateParentRect(menuRect);
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    parentControl->Update();
                }
            }
        }
        private void CollectShortcuts()
        {
            shortcuts.Clear();
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    menuItem->CollectShortcuts(shortcuts);
                }
                child = child->NextSibling();
            }
        }
        internal bool HandleAccessKey(wchar accessKey, Keys keyCode, bool& wantsKeys)
        {
            ResetMenuInvalidated();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "MENUBAR: access key = '" + ToString(accessKey) + "' " + ToHexString(cast<ushort>(accessKey)) + ", key code = " + string(keyCodeStr[cast<int>(keyCode)]);
                logView->WriteLine(s);
            }
            if (accessKey == '\0' && keyCode == Keys.none)
            {
                if (!MenuKeyDisabled())
                {
                    if (selectedMenuItem == null)
                    {
                        MenuItem* firstMenuItem = GetFirstMenuItem();
                        if (firstMenuItem != null)
                        {
                            SetOpen();
                            SetSelectedMenuItem(firstMenuItem);
                            wantsKeys = true;
                            InvalidateMenu();
                            return true;
                        }
                    }
                    else
                    {
                        SetClosed();
                        MenuItem* openedMenuItem = GetOpenedMenuItem();
                        if (openedMenuItem != null)
                        {
                            openedMenuItem->SetState(MenuItem.State.closed, this);
                        }
                        selectedMenuItem->ResetSelected(this);
                        SetSelectedMenuItem(null);
                        wantsKeys = false;
                        InvalidateMenu();
                        return true;
                    }
                }
            }
            else if (accessKey != '\0' && keyCode == Keys.none)
            {
                MenuItem* menuItem = GetMenuItemByAccessKey(accessKey);
                if (menuItem != null)
                {
                    MenuItem* firstMenuItem = menuItem->GetFirstMenuItem();
                    if (firstMenuItem != null)
                    {
                        if (selectedMenuItem != null)
                        {
                            MenuItem* openedMenuItem = GetOpenedMenuItem();
                            if (openedMenuItem != null)
                            {
                                openedMenuItem->SetState(MenuItem.State.closed, this);
                            }
                        }
                        SetOpen();
                        menuItem->SetState(MenuItem.State.open, this);
                        SetSelectedMenuItem(firstMenuItem);
                        wantsKeys = true;
                        InvalidateMenu();
                        return true;
                    }
                }
            }
            else if (accessKey == '\0' && keyCode != Keys.none)
            {
                if (keyCode == Keys.menu)
                {
                    wantsKeys = true;
                    return true;
                }
                else
                {
                    if (selectedMenuItem != null)
                    {
                        MenuItem* parentItem = selectedMenuItem->GetParentMenuItem();
                        bool handled = selectedMenuItem->HandleKey(keyCode, wantsKeys, parentItem, this);
                        if (MenuInvalidated())
                        {
                            InvalidateMenu();
                        }
                        return handled;
                    }
                }
            }
            if (MenuInvalidated())
            {
                InvalidateMenu();
            }
            wantsKeys = false;
            return false;
        }
        internal void MouseDownInternal(MouseEventArgs& args)
        {
            OnMouseDown(args);
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            SetLatestMouseDownMenuItem(null);
            bool handled = false;
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    menuItem->DoMouseDown(args, handled, this);
                    if (handled)
                    {
                        InvalidateMenu();
                        return;
                    }
                }
                child = child->NextSibling();
            }
            if (IsOpen())
            {
                SetClosed();
                SetLatestOpenedMenuItem(null);
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is MenuItem*)
                    {
                        MenuItem* menuItem = cast<MenuItem*>(child);
                        menuItem->SetState(MenuItem.State.closed, this);
                    }
                    child = child->NextSibling();
                }
                InvalidateMenu();
            }
        }
        internal void MouseUpInternal(MouseEventArgs& args)
        {
            OnMouseUp(args);
        }
        protected override void OnMouseUp(MouseEventArgs& args)
        {
            base->OnMouseUp(args);
            bool handled = false;
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->IsEnabled())
                    {
                        menuItem->DoMouseUp(args, handled, this);
                        if (handled)
                        {
                            InvalidateMenu();
                            return;
                        }
                    }
                }
                child = child->NextSibling();
            }
        }
        internal nothrow override void SetLatestOpenedMenuItem(MenuItem* menuItem)
        {
            latestOpenedMenuItem = menuItem;
        }
        internal nothrow override MenuItem* LatestOpenedMenuItem() const
        {
            return latestOpenedMenuItem;
        }
        internal nothrow override MenuItem* GetOpenedMenuItem() const
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* childItem = cast<MenuItem*>(child);
                    if (childItem->GetState() == MenuItem.State.open)
                    {
                        return childItem;
                    }
                }
                child = child->NextSibling();
            }
            return null;
        }
        internal nothrow override MenuItem* GetFirstMenuItem() const
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    return menuItem;
                }
                child = child->NextSibling();
            }
            return null;
        }
        internal nothrow override MenuItem* GetLastMenuItem() const
        {
            Component* child = children.LastChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    return menuItem;
                }
                child = child->PrevSibling();
            }
            return null;
        }
        internal nothrow override MenuItem* GetMenuItemByAccessKey(wchar accessKey)
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->AccessKey() == accessKey)
                    {
                        return menuItem;
                    }
                }
                child = child->NextSibling();
            }
            return null;
        }
        internal override nothrow MenuItem* GetSelectedMenuItem() const
        {
            return selectedMenuItem;
        }
        internal override nothrow void SetSelectedMenuItem(MenuItem* selectedMenuItem_)
        {
            selectedMenuItem = selectedMenuItem_;
        }
        internal override nothrow MenuItem* GetLatestMouseDownMenuItem() const
        {
            return latestMouseDownMenuItem;
        }
        internal nothrow override void SetLatestMouseDownMenuItem(MenuItem* menuItem)
        {
            latestMouseDownMenuItem = menuItem;
        }
        public nothrow void DisableMenuKey()
        {
            flags = cast<Flags>(flags | Flags.menuKeyDisabled);
        }
        public nothrow inline bool MenuKeyDisabled() const
        {
            return (flags & Flags.menuKeyDisabled) != Flags.none;
        }
        private nothrow inline bool MenuChanged()
        {
            return (flags & Flags.menuChanged) != Flags.none;
        }
        internal nothrow override void SetMenuChanged()
        {
            flags = cast<Flags>(flags | Flags.menuChanged);
        }
        private nothrow inline void ResetMenuChanged()
        {
            flags = cast<Flags>(flags & ~Flags.menuChanged);
        }
        private nothrow inline bool MenuInvalidated() const
        {
            return (flags & Flags.menuInvalidated) != Flags.none;
        }
        internal nothrow override void SetMenuInvalidated()
        {
            flags = cast<Flags>(flags | Flags.menuInvalidated);
        }
        private nothrow inline void ResetMenuInvalidated()
        {
            flags = cast<Flags>(flags & ~Flags.menuInvalidated);
        }
        internal nothrow override bool IsOpen() const
        {
            return (flags & Flags.open) != Flags.none;
        }
        public nothrow override void SetOpen()
        {
            flags = cast<Flags>(flags | Flags.open);
        }
        public nothrow override void SetClosed()
        {
            if (IsOpen())
            {
                flags = cast<Flags>(flags & ~Flags.open);
                InvalidateMenu();
            }
        }
        private nothrow bool MenuBoxAdded() const
        {
            return (flags & Flags.menuBoxAdded) != Flags.none;
        }
        private nothrow void SetMenuBoxAdded()
        {
            flags = cast<Flags>(flags | Flags.menuBoxAdded);
        }
        private void AddMenuBox()
        {
            Control* parentControl = ParentControl();
            if (parentControl != null && parentControl is ContainerControl*)
            {
                menuBox = new MenuBox(GetFont(), this, null);
                ContainerControl* containerControl = cast<ContainerControl*>(parentControl);
                containerControl->InsertChildAfter(menuBox, this);
            }
        }
        private Flags flags;
        private Container children;
        private MenuItem* latestOpenedMenuItem;
        private MenuItem* selectedMenuItem;
        private MenuItem* latestMouseDownMenuItem;
        private HashMap<Keys, MenuItem*> shortcuts;
        private MenuBox* menuBox;
    }

    public nothrow ControlCreateParams& MenuBoxControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowStyle(HiddenChildWindowStyle()).
            SetWindowClassBackgroundColor(SystemColor.COLOR_MENU).SetBackgroundColor(DefaultMenuBackgroundColor()).
            SetWindowClassName("System.Windows.MenuBox");
    }

    public class MenuBoxCreateParams
    {
        public nothrow MenuBoxCreateParams(MenuControlCreateParams& menuControlCreateParams_) : menuControlCreateParams(menuControlCreateParams_)
        {
        }
        public nothrow MenuBoxCreateParams& Defaults()
        {
            return *this;
        }
        public MenuControlCreateParams& menuControlCreateParams;
    }

    public class MenuBox : MenuControl
    {
        public MenuBox(const Font& font, MenuBar* menuBar_, MenuItem* rootItem_) :
            base(font, "System.Windows.MenuBox", DefaultWindowClassStyle(), HiddenChildWindowStyle(), DefaultExtendedWindowStyle(),
            Color.White(), "menuBox", Point(), Size(), Dock.none, Anchors.none), menuBar(menuBar_), rootItem(rootItem_), paintThisMenuBox(false)
        {
        }
        public MenuBox(MenuBoxCreateParams& createParams, MenuBar* menuBar_, MenuItem* rootItem_) :
            base(createParams.menuControlCreateParams), menuBar(menuBar_), rootItem(rootItem_), paintThisMenuBox(false)
        {
        }
        public nothrow void SetPaintThisMenuBox(bool paintThisMenuBox_)
        {
            paintThisMenuBox = paintThisMenuBox_;
        }
        public nothrow inline bool PaintThisMenuBox() const
        {
            return paintThisMenuBox;
        }
        public override void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "MenuBox." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
        }
        protected virtual Point GetBoxLocation() const
        {
            return Location();
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                if (Debug.Paint())
                {
                    Rect r(Point(), GetSize());
                    LogView* log = Application.GetLogView();
                    if (log != null)
                    {
                        log->WriteLine("MenuBox.OnPaint: " + r.ToString());
                    }
                }
                Point loc = Location();
                if (!paintMenu)
                {
                    if (paintThisMenuBox)
                    {
                        Control* parentControl = ParentControl();
                        if (parentControl != null)
                        {
                            Bitmap menuBoxBitmap(args.clipRect.size.w, args.clipRect.size.h, args.graphics);
                            Graphics menuBoxGraphics = Graphics.FromImage(menuBoxBitmap);
                            Rect menuBoxClipRect(Point(0, 0), Size(args.clipRect.size.w, args.clipRect.size.h));
                            menuBoxGraphics.SetClipChecked(menuBoxClipRect);
                            menuBoxGraphics.TranslateTransformChecked(-loc.x, -loc.y);
                            PaintEventArgs paintMenuBoxArgs(menuBoxGraphics, menuBoxClipRect);
                            bool prevPaintMenu = paintMenu;
                            paintMenu = true;
                            bool skipMenuBar = this is ContextMenu*;
                            parentControl->PaintAll(paintMenuBoxArgs, skipMenuBar);
                            paintMenu = prevPaintMenu;
                            args.graphics.DrawImageChecked(menuBoxBitmap, PointF(0, 0));
                        }
                    }
                }
                else
                {
                    if (menuBar != null)
                    {
                        menuBar->DrawMenuItems(args, true, loc);
                    }
                    else if (rootItem != null)
                    {
                        rootItem->Draw(args.graphics, DefaultPadding(), TextBrush(), DisabledTextBrush(), BackgroundBrush(), MouseOverBrush(), MenuOpenBrush(), ShadowBrush(), BlackBrush(), BlackPen(),
                            DarkPen(), GetFont(), Format(), MenuOpenColor(), this, true, Point());
                    }
                }
            }
            catch (const Exception& ex)
            {
            }
        }
        private nothrow Control* ParentControl() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    return cast<Control*>(parent);
                }
            }
            return null;
        }
        protected override void OnMouseEnter()
        {
            base->OnMouseEnter();
            if (menuBar != null)
            {
                menuBar->MouseEnterInternal();
            }
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            base->OnMouseMove(args);
            if (menuBar != null)
            {
                Point loc = Location();
                args.location.x = args.location.x + loc.x;
                args.location.y = args.location.y + loc.y;
                menuBar->MouseMoveInternal(args);
            }
            else if (rootItem != null)
            {
                bool handled = false;
                rootItem->DispatchMouseMove(args, handled, this);
            }
        }
        protected override void OnMouseLeave()
        {
            base->OnMouseLeave();
            if (menuBar != null)
            {
                menuBar->MouseLeaveInternal();
            }
            else if (rootItem != null)
            {
                rootItem->LeaveChildren(this);
            }
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            if (menuBar != null)
            {
                Point loc = Location();
                args.location.x = args.location.x + loc.x;
                args.location.y = args.location.y + loc.y;
                menuBar->MouseDownInternal(args);
            }
            else if (rootItem != null)
            {
                SetLatestMouseDownMenuItem(null);
                bool handled = false;
                rootItem->DoMouseDown(args, handled, this);
                if (handled)
                {
                    Invalidate();
                }
            }
        }
        protected override void OnMouseUp(MouseEventArgs& args)
        {
            base->OnMouseUp(args);
            if (menuBar != null)
            {
                Point loc = Location();
                args.location.x = args.location.x + loc.x;
                args.location.y = args.location.y + loc.y;
                menuBar->MouseUpInternal(args);
            }
            else if (rootItem != null)
            {
                bool handled = false;
                rootItem->DoMouseUp(args, handled, this);
                if (handled)
                {
                    Invalidate();
                }
            }
        }
        protected nothrow inline MenuItem* GetRootItem() const
        {
            return rootItem;
        }
        private MenuBar* menuBar;
        private MenuItem* rootItem;
        private bool paintThisMenuBox;
        private bool paintMenu;
    }

    public abstract class ClickAction
    {
        public nothrow ClickAction()
        {
            clickEventHandler = Click;
        }
        public default virtual ~ClickAction();
        public nothrow void AddHandlerTo(MenuItem& menuItem)
        {
            menuItem.ClickEvent().AddHandler(clickEventHandler);
        }
        private void Click()
        {
            Execute();
        }
        protected abstract void Execute();
        private ClickEventHandler clickEventHandler;
    }

    public class ClickActions
    {
        public nothrow void Add(ClickAction* action)
        {
            clickActions.Add(UniquePtr<ClickAction>(action));
        }
        private List<UniquePtr<ClickAction>> clickActions;
    }

    public nothrow ControlCreateParams& ContextMenuControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowStyle(HiddenChildWindowStyle()).
            SetWindowClassBackgroundColor(SystemColor.COLOR_MENU).SetBackgroundColor(DefaultMenuBackgroundColor()).
            SetWindowClassName("System.Windows.ContextMenu");
    }

    public nothrow MenuBoxCreateParams& ContextMenuMenuBoxCreateParams(MenuBoxCreateParams& menuBoxCreateParams)
    {
        return menuBoxCreateParams;
    }

    public class ContextMenuCreateParams
    {
        public nothrow ContextMenuCreateParams(MenuBoxCreateParams& menuBoxCreateParams_) : menuBoxCreateParams(menuBoxCreateParams_)
        {
        }
        public nothrow ContextMenuCreateParams& Defaults()
        {
            return *this;
        }
        public MenuBoxCreateParams& menuBoxCreateParams;
    }

    public class ContextMenu : MenuBox
    {
        public ContextMenu(const Font& font) :
            base(font, null, new MenuItem("root")),
            rootItemPtr(GetRootItem()), latestOpenedMenuItem(null), selectedMenuItem(null), latestMouseDownMenuItem(null)
        {
        }
        public ContextMenu() : this(Font(FontFamily("Segoe UI"), 9.0f))
        {
        }
        public ContextMenu(ContextMenuCreateParams& createParams) :
            base(createParams.menuBoxCreateParams, null, new MenuItem("root")),
            rootItemPtr(GetRootItem()), latestOpenedMenuItem(null), selectedMenuItem(null), latestMouseDownMenuItem(null)
        {
        }
        public void AddMenuItem(MenuItemBase* menuItem)
        {
            rootItemPtr->AddMenuItem(menuItem);
        }
        public void AddMenuItemAction(MenuItem* menuItem, ClickAction* action)
        {
            rootItemPtr->AddMenuItem(menuItem);
            action->AddHandlerTo(*menuItem);
            clickActions.Add(action);
        }
        public void CalculateSize()
        {
            rootItemPtr->SetState(MenuItem.State.open, this);
            Graphics graphics = Graphics.FromWindowHandle(Handle());
            rootItemPtr->CalculateChildRect(graphics, GetFont(), Format(), Point(0, 0));
            Rect menuRect;
            rootItemPtr->GetOpenRect(menuRect);
            SetSize(menuRect.size);
        }
        public nothrow bool HasMenuItems()
        {
            return !rootItemPtr->Children().IsEmpty();
        }
        protected override Point GetBoxLocation() const
        {
            return Point(0, 0);
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            SetPaintThisMenuBox(true);
            base->OnPaint(args);
        }
        protected override void OnVisibleChanged()
        {
            base->OnVisibleChanged();
            if (!IsVisible())
            {
                rootItemPtr->SetState(MenuItem.State.closed, this);
                SetPaintThisMenuBox(false);
            }
        }
        internal override nothrow void SetMenuInvalidated()
        {
            Invalidate();
        }
        internal override nothrow bool IsOpen() const
        {
            return rootItemPtr->GetState() == MenuItem.State.open;
        }
        internal override nothrow MenuItem* GetSelectedMenuItem() const
        {
            return selectedMenuItem;
        }
        internal override nothrow void SetSelectedMenuItem(MenuItem* selectedMenuItem_)
        {
            selectedMenuItem = selectedMenuItem_;
        }
        internal override nothrow MenuItem* LatestOpenedMenuItem() const
        {
            return latestOpenedMenuItem;
        }
        internal override nothrow void SetLatestOpenedMenuItem(MenuItem* menuItem)
        {
            latestOpenedMenuItem = menuItem;
        }
        internal override nothrow MenuItem* GetLatestMouseDownMenuItem() const
        {
            return latestMouseDownMenuItem;
        }
        internal nothrow override void SetLatestMouseDownMenuItem(MenuItem* menuItem)
        {
            latestMouseDownMenuItem = menuItem;
        }
        internal nothrow override MenuItem* GetOpenedMenuItem() const
        {
            return rootItemPtr.Get();
        }
        private UniquePtr<MenuItem> rootItemPtr;
        private MenuItem* latestOpenedMenuItem;
        private MenuItem* selectedMenuItem;
        private MenuItem* latestMouseDownMenuItem;
        private ClickActions clickActions;
    }

    public abstract class MenuItemBase : Component
    {
        public nothrow MenuItemBase() : location(), size()
        {
        }
        public abstract void Draw(Graphics& graphics, const Padding& parentPadding, const Brush& textBrush, const Brush& disabledTextBrush, const Brush& backgroundBrush, const Brush& mouseOverBrush,
            const Brush& menuOpenBrush, const Brush& shadowBrush, const Brush& blackBrush, const Pen& blackPen, const Pen& darkPen, const Font& font,
            const StringFormat& format, const Color& menuOpenColor, MenuControl* menuControl, bool drawSubItems, const Point& origin);
        internal nothrow MenuItem* GetParentMenuItem() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is MenuItem*)
                    {
                        MenuItem* parentMenuItem = cast<MenuItem*>(parent);
                        return parentMenuItem;
                    }
                }
            }
            return null;
        }
        public virtual nothrow Padding DefaultPadding() const
        {
            return Padding(0, 0, 0, 0);
        }
        public nothrow int Level() const
        {
            MenuItem* parent = GetParentMenuItem();
            if (parent == null)
            {
                return 0;
            }
            else
            {
                return parent->Level() + 1;
            }
        }
        public nothrow const Point& Location() const
        {
            return location;
        }
        public nothrow void SetLocation(const Point& location_)
        {
            location = location_;
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        public nothrow void SetSize(const Size& size_)
        {
            size = size_;
        }
        public abstract Size MeasureItem(Graphics& graphics, const Font& font, const StringFormat& format, int& maxShortcutWidth, int& childIndicatorWidth);
        private Point location;
        private Size size;
    }

    public class MenuItem : MenuItemBase
    {
        public enum State : sbyte
        {
            closed = 0, open = 1
        }
        private enum Flags : sbyte
        {
            none = 0, disabled = 1 << 0, selected = 1 << 1, mouseInClient = 1 << 2, lbuttonPressed = 1 << 3
        }
        public MenuItem(const string& text_) :
            base(), text(text_), children(this), state(State.closed), childRect(), unionRect(), flags(Flags.none), accessKey('\0'), shortcut(Keys.none), shortcutFieldWidth(0)
        {
            SetAccessKey();
        }
        public void AddMenuItem(MenuItemBase* menuItem)
        {
            children.AddChild(menuItem);
        }
        public nothrow MenuItem* GetFirstMenuItem() const
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* childMenuItem = cast<MenuItem*>(child);
                    return childMenuItem;
                }
                child = child->NextSibling();
            }
            return null;
        }
        public nothrow MenuItem* GetLastMenuItem() const
        {
            Component* child = children.LastChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* childMenuItem = cast<MenuItem*>(child);
                    return childMenuItem;
                }
                child = child->PrevSibling();
            }
            return null;
        }
        public nothrow MenuItem* GetNextMenuItem() const
        {
            Component* next = NextSibling();
            while (next != null)
            {
                if (next is MenuItem*)
                {
                    MenuItem* nextMenuItem = cast<MenuItem*>(next);
                    return nextMenuItem;
                }
                next = next->NextSibling();
            }
            return null;
        }
        public nothrow MenuItem* GetPrevMenuItem() const
        {
            Component* prev = PrevSibling();
            while (prev != null)
            {
                if (prev is MenuItem*)
                {
                    MenuItem* prevMenuItem = cast<MenuItem*>(prev);
                    return prevMenuItem;
                }
                prev = prev->PrevSibling();
            }
            return null;
        }
        public nothrow MenuItem* GetParentMenuItem() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is MenuItem*)
                    {
                        MenuItem* parentItem = cast<MenuItem*>(parent);
                        return parentItem;
                    }
                }
            }
            return null;
        }
        private nothrow MenuControl* GetMenuControl() const
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is MenuItem*)
                    {
                        MenuItem* parentItem = cast<MenuItem*>(parent);
                        return parentItem->GetMenuControl();
                    }
                    else if (parent is MenuControl*)
                    {
                        MenuControl* menuControl = cast<MenuControl*>(parent);
                        return menuControl;
                    }
                }
            }
            return null;
        }
        internal bool HandleKey(Keys key, bool& wantsKeys, MenuItem* parentMenuItem, MenuControl* menuControl)
        {
            if (key >= Keys.a && key <= Keys.z || key >= Keys.d0 && key <= Keys.d9)
            {
                wchar accessKey = cast<wchar>(cast<int>(key));
                MenuItem* childItem = null;
                if (parentMenuItem != null)
                {
                    childItem = parentMenuItem->GetChildItemByAccessKey(accessKey);
                }
                else
                {
                    childItem = menuControl->GetMenuItemByAccessKey(accessKey);
                }
                if (childItem != null && childItem->IsEnabled())
                {
                    childItem->Execute(parentMenuItem, wantsKeys, menuControl);
                    return true;
                }
                else
                {
                    wantsKeys = true;
                    return false;
                }
            }
            else
            {
                switch (key)
                {
                    case Keys.enter:
                    {
                        if (IsEnabled())
                        {
                            Execute(parentMenuItem, wantsKeys, menuControl);
                            return true;
                        }
                        else
                        {
                            wantsKeys = true;
                            return false;
                        }
                    }
                    case Keys.escape:
                    {
                        MenuItem* openedMenuItem = menuControl->GetOpenedMenuItem();
                        if (openedMenuItem != null)
                        {
                            openedMenuItem->SetState(State.closed, menuControl);
                        }
                        wantsKeys = false;
                        menuControl->SetSelectedMenuItem(null);
                        menuControl->SetClosed();
                        menuControl->SetMenuInvalidated();
                        return true;
                    }
                    case Keys.home:
                    {
                        if (Level() == 0)
                        {
                            MenuItem* firstMenuItem = menuControl->GetFirstMenuItem();
                            if (firstMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(firstMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                        }
                        else
                        {
                            MenuItem* parentMenuItem = GetParentMenuItem();
                            if (parentMenuItem != null)
                            {
                                MenuItem* firstMenuItem = parentMenuItem->GetFirstMenuItem();
                                if (firstMenuItem != null)
                                {
                                    menuControl->SetSelectedMenuItem(firstMenuItem);
                                    wantsKeys = true;
                                    menuControl->SetMenuInvalidated();
                                    return true;
                                }
                            }
                        }
                        break;
                    }
                    case Keys.end:
                    {
                        if (Level() == 0)
                        {
                            MenuItem* lastMenuItem = menuControl->GetLastMenuItem();
                            if (lastMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(lastMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                        }
                        else
                        {
                            MenuItem* parentMenuItem = GetParentMenuItem();
                            if (parentMenuItem != null)
                            {
                                MenuItem* lastMenuItem = parentMenuItem->GetLastMenuItem();
                                if (lastMenuItem != null)
                                {
                                    menuControl->SetSelectedMenuItem(lastMenuItem);
                                    wantsKeys = true;
                                    menuControl->SetMenuInvalidated();
                                    return true;
                                }
                            }
                        }
                        break;
                    }
                    case Keys.down:
                    {
                        if (Level() == 0)
                        {
                            SetState(state.open, menuControl);
                            MenuItem* firstChild = GetFirstMenuItem();
                            if (firstChild != null)
                            {
                                menuControl->SetSelectedMenuItem(firstChild);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                        }
                        else
                        {
                            MenuItem* nextMenuItem = GetNextMenuItem();
                            if (nextMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(nextMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                            else
                            {
                                if (parentMenuItem != null)
                                {
                                    MenuItem* firstMenuItem = parentMenuItem->GetFirstMenuItem();
                                    if (firstMenuItem != null)
                                    {
                                        menuControl->SetSelectedMenuItem(firstMenuItem);
                                        wantsKeys = true;
                                        menuControl->SetMenuInvalidated();
                                        return true;
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case Keys.up:
                    {
                        if (Level() == 0)
                        {
                            SetState(state.open, menuControl);
                            MenuItem* lastChild = GetLastMenuItem();
                            if (lastChild != null)
                            {
                                menuControl->SetSelectedMenuItem(lastChild);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                        }
                        else
                        {
                            MenuItem* prevMenuItem = GetPrevMenuItem();
                            if (prevMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(prevMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                            else
                            {
                                if (parentMenuItem != null)
                                {
                                    MenuItem* lastMenuItem = parentMenuItem->GetLastMenuItem();
                                    if (lastMenuItem != null)
                                    {
                                        menuControl->SetSelectedMenuItem(lastMenuItem);
                                        wantsKeys = true;
                                        menuControl->SetMenuInvalidated();
                                        return true;
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case Keys.right:
                    {
                        if (Level() == 0)
                        {
                            MenuItem* nextMenuItem = GetNextMenuItem();
                            if (nextMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(nextMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                            else
                            {
                                MenuItem* firstMenuItem = menuControl->GetFirstMenuItem();
                                if (firstMenuItem != null)
                                {
                                    menuControl->SetSelectedMenuItem(firstMenuItem);
                                    wantsKeys = true;
                                    menuControl->SetMenuInvalidated();
                                    return true;
                                }
                            }
                        }
                        else
                        {
                            MenuItem* firstChild = GetFirstMenuItem();
                            if (firstChild != null)
                            {
                                SetState(State.open, menuControl);
                                menuControl->SetSelectedMenuItem(firstChild);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                            else
                            {
                                while (parentMenuItem != null)
                                {
                                    if (parentMenuItem->Level() == 0)
                                    {
                                        MenuItem* nextMenuItem = parentMenuItem->GetNextMenuItem();
                                        if (nextMenuItem != null)
                                        {
                                            parentMenuItem->SetState(State.closed, menuControl);
                                            nextMenuItem->SetState(State.open, menuControl);
                                            MenuItem* firstChild = nextMenuItem->GetFirstMenuItem();
                                            if (firstChild != null)
                                            {
                                                menuControl->SetSelectedMenuItem(firstChild);
                                                wantsKeys = true;
                                                menuControl->SetMenuInvalidated();
                                                return true;
                                            }
                                        }
                                        else
                                        {
                                            MenuItem* firstMenuItem = menuControl->GetFirstMenuItem();
                                            if (firstMenuItem != null)
                                            {
                                                parentMenuItem->SetState(State.closed, menuControl);
                                                firstMenuItem->SetState(State.open, menuControl);
                                                MenuItem* firstChild = firstMenuItem->GetFirstMenuItem();
                                                if (firstChild != null)
                                                {
                                                    menuControl->SetSelectedMenuItem(firstChild);
                                                    wantsKeys = true;
                                                    menuControl->SetMenuInvalidated();
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        MenuItem* grandParentMenuItem = parentMenuItem->GetParentMenuItem();
                                        MenuItem* nextMenuItem = grandParentMenuItem->GetNextMenuItem();
                                        if (nextMenuItem != null)
                                        {
                                            parentMenuItem->SetState(State.closed, menuControl);
                                            grandParentMenuItem->SetState(State.closed, menuControl);
                                            nextMenuItem->SetState(State.open, menuControl);
                                            MenuItem* firstChild = nextMenuItem->GetFirstMenuItem();
                                            if (firstChild != null)
                                            {
                                                menuControl->SetSelectedMenuItem(firstChild);
                                                wantsKeys = true;
                                                menuControl->SetMenuInvalidated();
                                                return true;
                                            }
                                        }
                                        else
                                        {
                                            parentMenuItem = grandParentMenuItem; // up one level and loop again
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }
                    case Keys.left:
                    {
                        if (Level() == 0)
                        {
                            MenuItem* prevMenuItem = GetPrevMenuItem();
                            if (prevMenuItem != null)
                            {
                                menuControl->SetSelectedMenuItem(prevMenuItem);
                                wantsKeys = true;
                                menuControl->SetMenuInvalidated();
                                return true;
                            }
                            else
                            {
                                MenuItem* lastMenuItem = menuControl->GetLastMenuItem();
                                if (lastMenuItem != null)
                                {
                                    menuControl->SetSelectedMenuItem(lastMenuItem);
                                    wantsKeys = true;
                                    menuControl->SetMenuInvalidated();
                                    return true;
                                }
                            }
                        }
                        else
                        {
                            if (parentMenuItem != null)
                            {
                                MenuItem* prevMenuItem = parentMenuItem->GetPrevMenuItem();
                                if (prevMenuItem != null)
                                {
                                    parentMenuItem->SetState(State.closed, menuControl);
                                    prevMenuItem->SetState(State.open, menuControl);
                                    MenuItem* firstChild = prevMenuItem->GetFirstMenuItem();
                                    if (firstChild != null)
                                    {
                                        menuControl->SetSelectedMenuItem(firstChild);
                                        wantsKeys = true;
                                        menuControl->SetMenuInvalidated();
                                        return true;
                                    }
                                }
                                else
                                {
                                    MenuItem* grandParentMenuItem = parentMenuItem->GetParentMenuItem();
                                    if (grandParentMenuItem != null)
                                    {
                                        grandParentMenuItem->SetState(State.open, menuControl);
                                        MenuItem* firstMenuItem = grandParentMenuItem->GetFirstMenuItem();
                                        if (firstMenuItem != null)
                                        {
                                            firstMenuItem->SetState(State.closed, menuControl);
                                            menuControl->SetSelectedMenuItem(firstMenuItem);
                                        }
                                    }
                                    else
                                    {
                                        MenuItem* lastMenuItem = menuControl->GetLastMenuItem();
                                        if (lastMenuItem != null)
                                        {
                                            parentMenuItem->SetState(State.closed, menuControl);
                                            lastMenuItem->SetState(State.open, menuControl);
                                            MenuItem* firstChild = lastMenuItem->GetFirstMenuItem();
                                            if (firstChild != null)
                                            {
                                                menuControl->SetSelectedMenuItem(firstChild);
                                                wantsKeys = true;
                                                menuControl->SetMenuInvalidated();
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
            }
            wantsKeys = true;
            return false;
        }
        private void Close(MenuControl* menuControl)
        {
            SetState(State.closed, menuControl);
            MenuItem* parentItem = GetParentMenuItem();
            while (parentItem != null)
            {
                parentItem->SetState(State.closed, menuControl);
                parentItem = parentItem->GetParentMenuItem();
            }
            menuControl->SetSelectedMenuItem(null);
            menuControl->SetClosed();
            menuControl->SetMenuInvalidated();
        }
        private void Execute(MenuItem* parentMenuItem, bool& wantsKeys, MenuControl* menuControl)
        {
            if (children.IsEmpty())
            {
                if (IsEnabled())
                {
                    Close(menuControl);
                    wantsKeys = false;
                    DoClick();
                }
            }
            else
            {
                if (IsEnabled())
                {
                    SetState(State.open, menuControl);
                    MenuItem* firstMenuItem = GetFirstMenuItem();
                    if (firstMenuItem != null)
                    {
                        menuControl->SetSelectedMenuItem(firstMenuItem);
                        wantsKeys = true;
                        menuControl->SetMenuInvalidated();
                    }
                }
            }
        }
        internal void DoMouseDown(MouseEventArgs& args, bool& handled, MenuControl* menuControl)
        {
            if (Level() == 0)
            {
                if (Contains(args.location))
                {
                    SetMouseInClient();
                    if (menuControl->IsOpen())
                    {
                        menuControl->SetClosed();
                        menuControl->SetLatestOpenedMenuItem(null);
                        SetState(State.closed, menuControl);
                        DoMouseDown(args, menuControl);
                        handled = true;
                    }
                    else
                    {
                        menuControl->SetOpen();
                        SetState(State.open, menuControl);
                        menuControl->SetLatestOpenedMenuItem(this);
                        DoMouseDown(args, menuControl);
                        handled = true;
                    }
                }
                else
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is MenuItem*)
                        {
                            MenuItem* childItem = cast<MenuItem*>(child);
                            childItem->DoMouseDown(args, handled, menuControl);
                            if (handled) return;
                        }
                        child = child->NextSibling();
                    }
                }
            }
            else
            {
                if (menuControl->IsOpen())
                {
                    MenuItem* parentMenuItem = GetParentMenuItem();
                    if (parentMenuItem != null)
                    {
                        if (parentMenuItem->state == State.open)
                        {
                            if (Contains(args.location))
                            {
                                if (!children.IsEmpty())
                                {
                                    if (state == State.closed)
                                    {
                                        SetState(State.open, menuControl);
                                        menuControl->SetLatestOpenedMenuItem(this);
                                        DoMouseDown(args, menuControl);
                                        handled = true;
                                    }
                                    else if (state == State.open)
                                    {
                                        SetState(State.closed, menuControl);
                                        menuControl->SetLatestOpenedMenuItem(null);
                                        DoMouseDown(args, menuControl);
                                        handled = true;
                                    }
                                }
                                else
                                {
                                    DoMouseDown(args, menuControl);
                                    if ((args.buttons & MouseButtons.lbutton) != 0)
                                    {
                                        SetLButtonPressed();
                                    }
                                    handled = true;
                                }
                            }
                        }
                    }
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is MenuItem*)
                        {
                            MenuItem* childItem = cast<MenuItem*>(child);
                            childItem->DoMouseDown(args, handled, menuControl);
                            if (handled) return;
                        }
                        child = child->NextSibling();
                    }
                }
            }
        }
        internal void DoMouseUp(MouseEventArgs& args, bool& handled, MenuControl* menuControl)
        {
            if (Level() == 0)
            {
                if (Contains(args.location))
                {
                    DoMouseUp(args, menuControl);
                    handled = true;
                }
                else
                {
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is MenuItem*)
                        {
                            MenuItem* childItem = cast<MenuItem*>(child);
                            if (childItem->IsEnabled())
                            {
                                childItem->DoMouseUp(args, handled, menuControl);
                                if (handled) return;
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
            else
            {
                if (menuControl->IsOpen())
                {
                    MenuItem* parentMenuItem = GetParentMenuItem();
                    if (parentMenuItem != null)
                    {
                        if (parentMenuItem->state == State.open)
                        {
                            if (Contains(args.location))
                            {
                                DoMouseUp(args, menuControl);
                                handled = true;
                                return;
                            }
                        }
                    }
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is MenuItem*)
                        {
                            MenuItem* childItem = cast<MenuItem*>(child);
                            if (childItem->IsEnabled())
                            {
                                childItem->DoMouseUp(args, handled, menuControl);
                                if (handled) return;
                            }
                        }
                        child = child->NextSibling();
                    }
                }
            }
        }
        private void DoMouseDown(MouseEventArgs& args, MenuControl* menuControl)
        {
            menuControl->SetLatestMouseDownMenuItem(this);
            ResetLButtonPressed();
            OnMouseDown(args);
        }
        protected virtual void OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
        }
        private void DoMouseUp(MouseEventArgs& args, MenuControl* menuControl)
        {
            if (!IsEnabled()) return;
            OnMouseUp(args);
            bool isMenuBar = menuControl is MenuBar*;
            MenuItem* latestMouseDownMenuItem = menuControl->GetLatestMouseDownMenuItem();
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                if (LButtonPressed())
                {
                    ResetLButtonPressed();
                    if (latestMouseDownMenuItem == this && children.IsEmpty())
                    {
                        ResetSelected(menuControl);
                        ResetMouseInClient();
                        this->DoMouseLeave(menuControl);
                        LeaveChildren(menuControl);
                        Close(menuControl);
                        DoClick();
                    }
                    if (isMenuBar)
                    {
                        MenuItem* openedMenuItem = menuControl->GetOpenedMenuItem();
                        if (openedMenuItem != null)
                        {
                            openedMenuItem->SetState(State.closed, menuControl);
                        }
                        menuControl->SetClosed();
                        menuControl->SetMenuInvalidated();
                    }
                }
            }
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        internal void DoMouseEnter(bool parentIsOpen, MenuControl* menuControl)
        {
            if (parentIsOpen)
            {
                Component* prev = PrevSibling();
                while (prev != null)
                {
                    if (prev is MenuItem*)
                    {
                        MenuItem* prevItem = cast<MenuItem*>(prev);
                        prevItem->DoMouseLeave(menuControl);
                    }
                    prev = prev->PrevSibling();
                }
                Component* next = NextSibling();
                while (next != null)
                {
                    if (next is MenuItem*)
                    {
                        MenuItem* nextItem = cast<MenuItem*>(next);
                        nextItem->DoMouseLeave(menuControl);
                    }
                    next = next->NextSibling();
                }
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is MenuItem*)
                    {
                        MenuItem* childMenuItem = cast<MenuItem*>(child);
                        childMenuItem->ResetSelected(menuControl);
                        if (childMenuItem->MouseInClient())
                        {
                            childMenuItem->ResetMouseInClient();
                            childMenuItem->DoMouseLeave(menuControl);
                        }
                    }
                    child = child->NextSibling();
                }
            }
            if (parentIsOpen)
            {
                SetState(State.open, menuControl);
                menuControl->SetLatestOpenedMenuItem(this);
            }
            OnMouseEnter();
            menuControl->SetMenuInvalidated();
        }
        internal void DoMouseMove(MouseEventArgs& args)
        {
            OnMouseMove(args);
        }
        protected virtual void OnMouseEnter()
        {
            mouseEnterEvent.Fire();
        }
        internal void LeaveChildren(MenuControl* menuControl)
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* childMenuItem = cast<MenuItem*>(child);
                    childMenuItem->ResetSelected(menuControl);
                    childMenuItem->ResetMouseInClient();
                    childMenuItem->DoMouseLeave(menuControl);
                    childMenuItem->LeaveChildren(menuControl);
                }
                child = child->NextSibling();
            }
        }
        internal void DoMouseLeave(MenuControl* menuControl)
        {
            ResetLButtonPressed();
            if (state == State.open)
            {
                SetState(State.closed, menuControl);
                LeaveChildren(menuControl);
                OnMouseLeave();
            }
            else if (Level() == 0)
            {
                OnMouseLeave();
            }
        }
        protected virtual void OnMouseLeave()
        {
            mouseLeaveEvent.Fire();
        }
        internal void DispatchMouseMove(MouseEventArgs& args, bool& handled, MenuControl* menuControl)
        {
            if (unionRect.Contains(args.location))
            {
                if (Contains(args.location))
                {
                    SetSelected(menuControl);
                }
                else
                {
                    ResetSelected(menuControl);
                    ResetMouseInClient();
                }
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is MenuItem*)
                    {
                        MenuItem* childMenuItem = cast<MenuItem*>(child);
                        if (childMenuItem->Contains(args.location))
                        {
                            childMenuItem->SetSelected(menuControl);
                            if (!childMenuItem->MouseInClient())
                            {
                                childMenuItem->SetMouseInClient();
                                childMenuItem->DoMouseEnter(true, menuControl);
                                handled = true;
                            }
                            else
                            {
                                childMenuItem->DoMouseMove(args);
                            }
                        }
                        else
                        {
                            childMenuItem->ResetSelected(menuControl);
                            if (childMenuItem->MouseInClient())
                            {
                                childMenuItem->ResetMouseInClient();
                                if (!childMenuItem->IsSameOrParentOf(menuControl->LatestOpenedMenuItem()))
                                {
                                    childMenuItem->DoMouseLeave(menuControl);
                                }
                            }
                        }
                    }
                    child = child->NextSibling();
                }
            }
            else
            {
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is MenuItem*)
                    {
                        MenuItem* childMenuItem = cast<MenuItem*>(child);
                        if (childMenuItem->IsSameOrParentOf(menuControl->LatestOpenedMenuItem()))
                        {
                            childMenuItem->DispatchMouseMove(args, handled, menuControl);
                            if (handled) return;
                        }
                    }
                    child = child->NextSibling();
                }
            }
        }
        protected virtual void OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
        }
        internal void DoClick()
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                logView->WriteLine("MENUITEM: " + text + " CLICK!");
            }
            OnClick();
        }
        protected virtual void OnClick()
        {
            clickEvent.Fire();
        }
        public void CalculateChildRect(Graphics& graphics, const Font& font, const StringFormat& format, const Point& location)
        {
            childRect = Rect();
            childRect.location = location;
            Component* child = children.FirstChild();
            shortcutFieldWidth = 0;
            childIndicatorFieldWidth = 0;
            while (child != null)
            {
                if (child is MenuItemBase*)
                {
                    MenuItemBase* item = cast<MenuItemBase*>(child);
                    Size size = item->MeasureItem(graphics, font, format, shortcutFieldWidth, childIndicatorFieldWidth);
                    childRect.size.w = Max(childRect.size.w, size.w);
                    childRect.size.h = childRect.size.h + size.h;
                }
                child = child->NextSibling();
            }
            childRect.size.w = childRect.size.w + shortcutFieldWidth + childIndicatorFieldWidth;
            Rect itemRect(childRect.location, Size(childRect.size.w, 0));
            child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItemBase*)
                {
                    MenuItemBase* item = cast<MenuItemBase*>(child);
                    item->SetLocation(itemRect.location);
                    itemRect.size.h = item->GetSize().h;
                    item->SetSize(itemRect.size);
                    itemRect.location.y = itemRect.location.y + itemRect.size.h;
                }
                child = child->NextSibling();
            }
            int shadowWidth = ShadowWidth();
            childRect.size.h = childRect.size.h + shadowWidth;
            childRect.size.w = childRect.size.w + shadowWidth;
            child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* item = cast<MenuItem*>(child);
                    if (!item->Children().IsEmpty())
                    {
                        Point itemLocation = item->Location();
                        Size itemSize = item->GetSize();
                        item->CalculateChildRect(graphics, font, format, Point(itemLocation.x + itemSize.w - shadowWidth, itemLocation.y));
                    }
                }
                child = child->NextSibling();
            }
            Rect r(Location(), GetSize());
            unionRect = Rect.Union(r, childRect);
        }
        public override void Draw(Graphics& graphics, const Padding& parentPadding, const Brush& textBrush, const Brush& disabledTextBrush, const Brush& backgroundBrush, const Brush& mouseOverBrush,
            const Brush& menuOpenBrush, const Brush& shadowBrush, const Brush& blackBrush, const Pen& blackPen, const Pen& darkPen, const Font& font, const StringFormat& format,
            const Color& menuOpenColor, MenuControl* menuControl, bool drawSubItems, const Point& origin)
        {
            switch (state)
            {
                case State.closed:
                {
                    DrawClosed(graphics, parentPadding, textBrush, disabledTextBrush, mouseOverBrush, backgroundBrush, menuOpenBrush, blackBrush, blackPen, font, format, menuOpenColor, menuControl,
                        drawSubItems, origin);
                    break;
                }
                case State.open:
                {
                    DrawOpen(graphics, parentPadding, textBrush, disabledTextBrush, backgroundBrush, mouseOverBrush, menuOpenBrush, shadowBrush, blackBrush, blackPen, darkPen, font, format,
                        menuOpenColor, menuControl, drawSubItems, origin);
                    break;
                }
            }
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public nothrow void SetText(const string& text_, MenuControl* menuControl)
        {
            text = text_;
            SetAccessKey();
            menuControl->InvalidateMenu();
        }
        public nothrow inline wchar AccessKey() const
        {
            return accessKey;
        }
        private nothrow void SetAccessKey()
        {
            wstring s = ToUtf16(text);
            long ampPos = s.Find('&');
            if (ampPos != -1 && ampPos < s.Length() - 1)
            {
                accessKey = cast<wchar>(ToUpper(cast<uchar>(s[ampPos + 1])));
            }
            else
            {
                accessKey = '\0';
            }
        }
        public nothrow void SetShortcut(Keys shortcut_)
        {
            shortcut = shortcut_;
            MenuControl* menuControl = GetMenuControl();
            if (menuControl != null)
            {
                menuControl->SetMenuChanged();
            }
        }
        private nothrow MenuItem* GetChildItemByAccessKey(wchar accessKey)
        {
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->AccessKey() == accessKey)
                    {
                        return menuItem;
                    }
                }
                child = child->NextSibling();
            }
            return null;
        }
        internal nothrow void CollectShortcuts(HashMap<Keys, MenuItem*>& shortcuts)
        {
            if (shortcut != Keys.none)
            {
                shortcuts[shortcut] = this;
            }
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    menuItem->CollectShortcuts(shortcuts);
                }
                child = child->NextSibling();
            }
        }
        public nothrow const Container& Children() const
        {
            return children;
        }
        public override nothrow Padding DefaultPadding() const
        {
            if (Level() == 0)
            {
                return Padding(4, 0, 4, 0);
            }
            else
            {
                return Padding(32, 4, 32, 4);
            }
        }
        public nothrow Padding ShortcutPadding() const
        {
            if (Level() == 0)
            {
                return Padding(0, 0, 0, 0);
            }
            else
            {
                return Padding(4, 0, 4, 0);
            }
        }
        public virtual nothrow int ShadowWidth() const
        {
            return 3;
        }
        public virtual nothrow int ChildIndicatorIndent() const
        {
            return 9;
        }
        public virtual nothrow int ChildIndicatorWidth() const
        {
            return 6;
        }
        public nothrow bool Contains(const Point& p)
        {
            Rect r(Location(), GetSize());
            if (r.Contains(p))
            {
                return true;
            }
            return false;
        }
        public nothrow bool UnionRectContains(const Point& p)
        {
            return unionRect.Contains(p);
        }
        public nothrow inline const Rect& UnionRect() const
        {
            return unionRect;
        }
        public nothrow void GetOpenRect(Rect& parentRect)
        {
            if (!childRect.IsEmpty())
            {
                if (parentRect.IsEmpty())
                {
                    parentRect = childRect;
                }
                else
                {
                    parentRect = Rect.Union(parentRect, childRect);
                }
            }
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is MenuItem*)
                {
                    MenuItem* menuItem = cast<MenuItem*>(child);
                    if (menuItem->GetState() == MenuItem.State.open)
                    {
                        menuItem->GetOpenRect(parentRect);
                    }
                }
                child = child->NextSibling();
            }
        }
        public nothrow inline State GetState() const
        {
            return state;
        }
        internal void SetState(State state_, MenuControl* menuControl)
        {
            if (state != state_)
            {
                state = state_;
                menuControl->SetMenuInvalidated();
            }
        }
        public override Size MeasureItem(Graphics& graphics, const Font& font, const StringFormat& format, int& shortcutFieldWidth, int& childIndicatorFieldWidth)
        {
            Padding padding = DefaultPadding();
            RectF rect = graphics.MeasureStringChecked(text, font, PointF(0, 0), format);
            int w = cast<int>(rect.size.w);
            w = w + padding.Horizontal();
            if (shortcut != Keys.none)
            {
                string shortcutText = ToString(shortcut);
                RectF shortcutRect = graphics.MeasureStringChecked(shortcutText, font, PointF(0, 0), format);
                Padding shortcutPadding = ShortcutPadding();
                int shortcutWidth = cast<int>(shortcutRect.size.w + shortcutPadding.Horizontal());
                shortcutFieldWidth = Max(shortcutFieldWidth, shortcutWidth);
            }
            if (Level() > 0 && !children.IsEmpty())
            {
                childIndicatorFieldWidth = Max(childIndicatorFieldWidth, ChildIndicatorIndent());
            }
            int h = cast<int>(rect.size.h);
            h = h + padding.Vertical();
            Size size(w, h);
            SetSize(size);
            return size;
        }
        private void DrawClosed(Graphics& graphics, const Padding& parentPadding, const Brush& textBrush, const Brush& disabledTextBrush, const Brush& mouseOverBrush, const Brush& backgroundBrush,
            const Brush& menuOpenBrush, const Brush& blackBrush, const Pen& blackPen, const Font& font, const StringFormat& format, const Color& menuOpenColor,
            MenuControl* menuControl, bool drawSubItems, const Point& origin)
        {
            Point loc = Location();
            loc.x = loc.x - origin.x;
            loc.y = loc.y - origin.y;
            Size size = GetSize();
            Rect r(loc, size);
            r.size.w = r.size.w - 1;
            r.size.h = r.size.h - 1;
            MenuItem* selectedMenuItem = menuControl->GetSelectedMenuItem();
            if (Selected() || this == selectedMenuItem)
            {
                graphics.FillRectangleChecked(mouseOverBrush, r);
                graphics.DrawRectangleChecked(blackPen, r);
            }
            if (Level() == 0)
            {
                if (!drawSubItems)
                {
                    if (!Selected() && this != selectedMenuItem)
                    {
                        graphics.FillRectangleChecked(backgroundBrush, r);
                    }
                    StringFormat textFormat(format);
                    textFormat.SetAlignment(StringAlignment.center);
                    RectF rect(PointF(loc.x, loc.y), SizeF(size.w, size.h));
                    if (IsEnabled())
                    {
                        graphics.DrawStringChecked(text, font, rect, textFormat, textBrush);
                    }
                    else
                    {
                        graphics.DrawStringChecked(text, font, rect, textFormat, disabledTextBrush);
                    }
                }
            }
            else
            {
                if (drawSubItems)
                {
                    Padding padding = DefaultPadding();
                    if (IsEnabled())
                    {
                        graphics.DrawStringChecked(text, font, PointF(loc.x + padding.left, loc.y + padding.top), format, textBrush);
                        DrawShortcut(graphics, textBrush, font, format, origin);
                    }
                    else
                    {
                        graphics.DrawStringChecked(text, font, PointF(loc.x + padding.left, loc.y + padding.top), format, disabledTextBrush);
                        DrawShortcut(graphics, disabledTextBrush, font, format, origin);
                    }
                    DrawChildIndicator(graphics, blackBrush, origin);
                }
            }
        }
        private void DrawOpen(Graphics& graphics, const Padding& parentPadding, const Brush& textBrush, const Brush& disabledTextBrush, const Brush& backgroundBrush, const Brush& mouseOverBrush,
            const Brush& menuOpenBrush, const Brush& shadowBrush, const Brush& blackBrush, const Pen& blackPen, const Pen& darkPen, const Font& font, const StringFormat& format,
            const Color& menuOpenColor, MenuControl* menuControl, bool drawSubItems, const Point& origin)
        {
            Point loc = Location();
            loc.x = loc.x - origin.x;
            loc.y = loc.y - origin.y;
            Size size = GetSize();
            Rect r(loc, size);
            r.size.w = r.size.w - 1;
            r.size.h = r.size.h - 1;
            int shadowWidth = ShadowWidth();
            if (Level() == 0)
            {
                if (!drawSubItems)
                {
                    graphics.FillRectangleChecked(menuOpenBrush, r);
                    graphics.DrawLineChecked(blackPen, r.location, Point(r.location.x + r.size.w, r.location.y));
                    //graphics.DrawLineChecked(blackPen, r.location, Point(r.location.x, r.size.h));
                    graphics.DrawLineChecked(blackPen, r.location, Point(r.location.x, r.location.y + r.size.h));
                    graphics.DrawLineChecked(blackPen, Point(r.location.x + r.size.w, r.location.y), Point(r.location.x + r.size.w, r.location.y + r.size.h));
                    if (children.IsEmpty())
                    {
                        graphics.DrawLineChecked(blackPen, Point(r.location.x, r.location.y + r.size.h), Point(r.location.x + r.size.w, r.location.y + r.size.h));
                    }
                    StringFormat textFormat(format);
                    textFormat.SetAlignment(StringAlignment.center);
                    RectF rect(PointF(loc.x, loc.y), SizeF(size.w, size.h));
                    if (IsEnabled())
                    {
                        graphics.DrawStringChecked(text, font, rect, textFormat, textBrush);
                    }
                    else
                    {
                        graphics.DrawStringChecked(text, font, rect, textFormat, disabledTextBrush);
                    }
                }
            }
            else
            {
                if (drawSubItems)
                {
                    MenuItem* selectedMenuItem = menuControl->GetSelectedMenuItem();
                    if (Selected() || this == selectedMenuItem)
                    {
                        graphics.FillRectangleChecked(mouseOverBrush, r);
                        graphics.DrawRectangleChecked(blackPen, r);
                    }
                    else
                    {
                        Rect inside = r;
                        inside.Inflate(-1, -1);
                        graphics.FillRectangleChecked(menuOpenBrush, inside);
                    }
                    Padding padding = DefaultPadding();
                    if (IsEnabled())
                    {
                        graphics.DrawStringChecked(text, font, PointF(loc.x + padding.left, loc.y + padding.top), format, textBrush);
                        DrawShortcut(graphics, textBrush, font, format, origin);
                    }
                    else
                    {
                        graphics.DrawStringChecked(text, font, PointF(loc.x + padding.left, loc.y + padding.top), format, disabledTextBrush);
                        DrawShortcut(graphics, disabledTextBrush, font, format, origin);
                    }
                    DrawChildIndicator(graphics, blackBrush, origin);
                }
            }
            if (!childRect.IsEmpty())
            {
                if (drawSubItems)
                {
                    Region prevClipRegion = graphics.GetClipChecked();
                    Rect menuBox = childRect;
                    menuBox.location.x = menuBox.location.x - origin.x;
                    menuBox.location.y = menuBox.location.y - origin.y;
                    menuBox.size.h = menuBox.size.h - shadowWidth;
                    menuBox.size.w = menuBox.size.w - shadowWidth;
                    graphics.SetClipChecked(menuBox);
                    graphics.Clear(menuOpenColor);
                    Rect cr(childRect);
                    cr.location.x = cr.location.x - origin.x;
                    cr.location.y = cr.location.y - origin.y;
                    graphics.SetClipChecked(cr);
                    Rect bottomShadowRect(
                        Point(cr.location.x + shadowWidth, cr.location.y + cr.size.h - shadowWidth),
                        Size(cr.size.w - shadowWidth, shadowWidth));
                    graphics.FillRectangleChecked(shadowBrush, bottomShadowRect);
                    Rect rightShadowRect(
                        Point(cr.location.x + cr.size.w - shadowWidth, cr.location.y + shadowWidth),
                        Size(shadowWidth, cr.size.h - shadowWidth));
                    graphics.FillRectangleChecked(shadowBrush, rightShadowRect);
                    Rect rect = childRect;
                    rect.location.x = rect.location.x - origin.x;
                    rect.location.y = rect.location.y - origin.y;
                    rect.size.w = rect.size.w - 1;
                    rect.size.h = rect.size.h - 1;
                    if (Level() == 0)
                    {
                        graphics.DrawLineChecked(blackPen, rect.location, Point(rect.location.x, rect.location.y + rect.size.h - shadowWidth));
                        graphics.DrawLineChecked(blackPen, Point(rect.location.x, rect.location.y + rect.size.h - shadowWidth),
                            Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y + rect.size.h - shadowWidth));
                        graphics.DrawLineChecked(blackPen, Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y + rect.size.h - shadowWidth),
                            Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y));
                        graphics.DrawLineChecked(blackPen,
                            Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y), Point(r.location.x + r.size.w, rect.location.y));
                    }
                    else
                    {
                        graphics.DrawLineChecked(blackPen, rect.location, Point(rect.location.x, rect.location.y + rect.size.h - shadowWidth));
                        graphics.DrawLineChecked(blackPen, Point(rect.location.x, r.location.y + rect.size.h - shadowWidth),
                            Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y + rect.size.h - shadowWidth));
                        graphics.DrawLineChecked(blackPen, Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y + rect.size.h - shadowWidth),
                            Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y));
                        graphics.DrawLineChecked(blackPen, Point(rect.location.x + rect.size.w - shadowWidth, rect.location.y),
                            Point(rect.location.x, rect.location.y));
                    }
                    Component* child = children.FirstChild();
                    while (child != null)
                    {
                        if (child is MenuItemBase*)
                        {
                            MenuItemBase* menuItem = cast<MenuItem*>(child);
                            menuItem->Draw(graphics, parentPadding, textBrush, disabledTextBrush, backgroundBrush, mouseOverBrush, menuOpenBrush, shadowBrush, blackBrush, blackPen, darkPen,
                                font, format, menuOpenColor, menuControl, drawSubItems, origin);
                        }
                        child = child->NextSibling();
                    }
                    graphics.SetClipChecked(prevClipRegion);
                }
            }
        }
        private void DrawShortcut(Graphics& graphics, const Brush& textBrush, const Font& font, const StringFormat& format, const Point& origin)
        {
            if (shortcut != Keys.none)
            {
                string shortcutText = ToString(shortcut);
                Padding shortcutPadding = ShortcutPadding();
                int shortcutFieldWidth = 0;
                int childIndicatorFieldWidth = 0;
                MenuItem* parent = GetParentMenuItem();
                if (parent != null)
                {
                    shortcutFieldWidth = parent->shortcutFieldWidth;
                    childIndicatorFieldWidth = parent->childIndicatorFieldWidth;
                }
                Padding padding = DefaultPadding();
                int shadowWidth = ShadowWidth();
                Point loc = Location();
                loc.x = loc.x - origin.x;
                loc.y = loc.y - origin.y;
                Size size = GetSize();
                graphics.DrawStringChecked(shortcutText, font,
                    PointF(loc.x + size.w - shadowWidth - shortcutFieldWidth - childIndicatorFieldWidth + shortcutPadding.left, loc.y + padding.top), format, textBrush);
            }
        }
        private void DrawChildIndicator(Graphics& graphics, const Brush& blackBrush, const Point& origin)
        {
            if (children.IsEmpty()) return;
            Point loc = Location();
            loc.x = loc.x - origin.x;
            loc.y = loc.y - origin.y;
            Size size = GetSize();
            int childIndicatorIndent = ChildIndicatorIndent();
            int childIndicatorWidth = ChildIndicatorWidth();
            int shadowWidth = ShadowWidth();
            Point up(loc.x + size.w - childIndicatorIndent - shadowWidth, loc.y + size.h / 2 - childIndicatorWidth / 2);
            Point down(loc.x + size.w - childIndicatorIndent - shadowWidth, loc.y + size.h / 2 + childIndicatorWidth / 2);
            Point right(loc.x + size.w - childIndicatorIndent + cast<int>((Sqrt(3) / 2.0) * childIndicatorWidth) - shadowWidth, loc.y + size.h / 2);
            List<Point> triangle;
            triangle.Add(up);
            triangle.Add(down);
            triangle.Add(right);
            graphics.FillPolygonChecked(blackBrush, 3, triangle.Begin().Ptr());
        }
        internal nothrow bool IsSameOrParentOf(MenuItem* menuItem) const
        {
            if (this == menuItem) return true;
            MenuItem* parent = menuItem->GetParentMenuItem();
            if (parent != null)
            {
                return IsSameOrParentOf(parent);
            }
            return false;
        }
        internal nothrow inline bool Selected() const
        {
            return (flags & Flags.selected) != 0;
        }
        internal nothrow void SetSelected(MenuControl* menuControl)
        {
            if ((flags & Flags.selected) == 0)
            {
                flags = cast<Flags>(flags | Flags.selected);
                menuControl->SetMenuInvalidated();
            }
        }
        internal nothrow void ResetSelected(MenuControl* menuControl)
        {
            if ((flags & Flags.selected) != 0)
            {
                flags = cast<Flags>(flags & ~Flags.selected);
                menuControl->SetMenuInvalidated();
            }
        }
        public nothrow inline bool IsEnabled() const
        {
            return cast<Flags>(flags & Flags.disabled) == Flags.none;
        }
        public nothrow inline bool IsDisabled() const
        {
            return cast<Flags>(flags & Flags.disabled) != Flags.none;
        }
        public nothrow void Enable()
        {
            if (!IsEnabled())
            {
                flags = cast<Flags>(flags & ~Flags.disabled);
                MenuControl* menuControl = GetMenuControl();
                if (menuControl != null)
                {
                    menuControl->SetMenuInvalidated();
                    menuControl->SetMenuChanged();
                }
            }
        }
        public nothrow void Disable()
        {
            if (IsEnabled())
            {
                flags = cast<Flags>(flags | Flags.disabled);
                MenuControl* menuControl = GetMenuControl();
                if (menuControl != null)
                {
                    menuControl->SetMenuInvalidated();
                    menuControl->SetMenuChanged();
                }
            }
        }
        internal nothrow inline bool MouseInClient() const
        {
            return (flags & Flags.mouseInClient) != 0;
        }
        internal void SetMouseInClient()
        {
            flags = cast<Flags>(flags | Flags.mouseInClient);
        }
        internal void ResetMouseInClient()
        {
            flags = cast<Flags>(flags & ~Flags.mouseInClient);
        }
        private nothrow inline bool LButtonPressed() const
        {
            return (flags & Flags.lbuttonPressed) != 0;
        }
        private nothrow void SetLButtonPressed()
        {
            flags = cast<Flags>(flags | Flags.lbuttonPressed);
        }
        private nothrow void ResetLButtonPressed()
        {
            flags = cast<Flags>(flags & ~Flags.lbuttonPressed);
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent()
        {
            return mouseDownEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent()
        {
            return mouseUpEvent;
        }
        public nothrow Event<MouseEnterEventHandler>& MouseEnterEvent()
        {
            return mouseEnterEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent()
        {
            return mouseMoveEvent;
        }
        public nothrow Event<MouseLeaveEventHandler>& MouseLeaveEvent()
        {
            return mouseLeaveEvent;
        }
        public nothrow Event<ClickEventHandler>& ClickEvent()
        {
            return clickEvent;
        }
        private string text;
        private Container children;
        private Rect childRect;
        private Rect unionRect;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<MouseEnterEventHandler> mouseEnterEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseLeaveEventHandler> mouseLeaveEvent;
        private Event<ClickEventHandler> clickEvent;
        private State state;
        private Flags flags;
        private wchar accessKey;
        private Keys shortcut;
        private int shortcutFieldWidth;
        private int childIndicatorFieldWidth;
    }

    public class MenuItemSeparator : MenuItemBase
    {
        public override void Draw(Graphics& graphics, const Padding& parentPadding, const Brush& textBrush, const Brush& disabledTextBrush, const Brush& backgroundBrush, const Brush& mouseOverBrush,
            const Brush& menuOpenBrush, const Brush& shadowBrush, const Brush& blackBrush, const Pen& blackPen, const Pen& darkPen, const Font& font, const StringFormat& format,
            const Color& menuOpenColor, MenuControl* menuControl, bool drawSubItems, const Point& origin)
        {
            Point loc = Location();
            loc.x = loc.x - origin.x;
            loc.y = loc.y - origin.y;
            Rect rect(loc, GetSize());
            Padding padding = DefaultPadding();
            graphics.DrawLineChecked(darkPen,
                Point(rect.location.x + padding.left, rect.location.y + rect.size.h / 2),
                Point(rect.location.x + rect.size.w - padding.right, rect.location.y + rect.size.h / 2));
        }
        public override nothrow Padding DefaultPadding() const
        {
            return Padding(32, 4, 8, 4);
        }
        public override Size MeasureItem(Graphics& graphics, const Font& font, const StringFormat& format, int& shortcutFieldWidth, int& childIndicatorFieldWidth)
        {
            Padding padding = DefaultPadding();
            RectF rect;
            int w = cast<int>(rect.size.w);
            w = w + padding.Horizontal();
            int h = cast<int>(rect.size.h);
            h = h + padding.Vertical();
            Size size(w, h);
            SetSize(size);
            return size;
        }
    }
}

// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public class delegate void ControlEventHandler(ControlEventArgs& args);

    public class ContainerControl : Control
    {
        public ContainerControl(const char* windowClassName, WindowClassStyle windowClassStyle, WindowStyle style, ExtendedWindowStyle exStyle, 
            const Color& backgroundColor, const string& text, const Point& location, const Size& size, Dock dock, Anchors anchors) : 
            base(windowClassName, windowClassStyle, style, exStyle, backgroundColor, text, location, size, dock, anchors), children(this)
        {
        }
        public void AddChild(Control* child)
        {
            children.AddChild(child);
            ControlEventArgs args(child);
            OnControlAdded(args);
        }
        public UniquePtr<Control> RemoveChild(Control* child)
        {
            UniquePtr<Component> childComponent = children.RemoveChild(child);
            ControlEventArgs args(child);
            OnControlRemoved(args);
            return UniquePtr<Control>(childComponent.Release() as Control*);
        }
        public void InsertChildAfter(Control* child, Control* after)
        {
            children.InsertAfter(child, after);
            ControlEventArgs args(child);
            OnControlAdded(args);
        }
        protected override bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_COMMAND:
                {
                    void* childWindowHandle = message.LParamHandle();
                    ushort notificationCode = message.WParamHiWord();
                    ushort controlId = message.WParamLoWord();
                    Control* child = Application.GetWindowManager().GetWindow(childWindowHandle);
                    if (child != null)
                    {
                        switch (notificationCode)
                        {
                            case BN_CLICKED:
                            {
                                if (child is ButtonBase*)
                                {
                                    ButtonBase* button = cast<ButtonBase*>(child);
                                    button->OnClickInternal();
                                    message.result = 0;
                                    return true;
                                }                            
                                break;
                            }
                        }
                    }
                    break;
                }
                case WM_SIZE:
                {
                    Size newSize = message.LParamSize();
                    Size oldSize = GetSize();
                    if (newSize != oldSize)
                    {
                        Rect parentRect(Point(), newSize);
                        int dx = newSize.w - oldSize.w;
                        int dy = newSize.h - oldSize.h;
                        Component* child = children.FirstChild();
                        while (child != null)
                        {
                            if (child is Control*)
                            {
                                Control* childControl = cast<Control*>(child);
                                if (childControl->GetDock() != Dock.none)
                                {
                                    childControl->DockWindow(parentRect);
                                }
                                else
                                {
                                    childControl->MoveWindow(dx, dy);
                                }
                            }   
                            child = child->NextSibling();
                        }                
                        SetSizeInternal(newSize);
                    }                    
                    message.result = 0;
                    return true;
                }
                case WM_PAINT: case WM_MOUSEMOVE: case WM_MOUSELEAVE: case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_CHAR: case WM_KEYDOWN: case WM_KEYUP: case WM_SYSCOMMAND:
                {
                    return base->ProcessMessage(message);
                }
            }
            return false;
        }
        internal void DockChildren()
        {
            Rect parentRect(Point(), GetSize());
            List<Control*> filledControls;
            List<ContainerControl*> containers;
            Component* child = children.FirstChild();
            while (child != null)
            {
                if (child is Control*)
                {
                    Control* childControl = cast<Control*>(child);
                    switch (childControl->GetDock())
                    {
                        case Dock.none: break;
                        case Dock.fill: filledControls.Add(childControl); break;
                        default:
                        {
                            childControl->DockWindow(parentRect);
                            break;
                        }
                    }
                    if (childControl is ContainerControl*)
                    {
                        ContainerControl* containerChild = cast<ContainerControl*>(childControl);
                        containers.Add(containerChild);
                    }
                }
                child = child->NextSibling();
            }
            for (Control* filledControl : filledControls)
            {
                filledControl->DockWindow(parentRect);
            }
            for (ContainerControl* container : containers)
            {
                container->DockChildren();
            }
        }
        internal override void PaintAll(PaintEventArgs& args)
        {
            try
            {
                base->PaintAll(args);
                Control* topControl = TopControl();
                Component* child = children.FirstChild();
                while (child != null)
                {
                    if (child is Control*)
                    {
                        Control* childControl = cast<Control*>(child);
                        if (childControl != topControl)
                        {
                            GraphicsState state = args.graphics.SaveChecked();
                            Point loc = childControl->Location();
                            args.graphics.SetClipChecked(Rect(childControl->Location(), childControl->GetSize()));
                            args.graphics.TranslateTransformChecked(loc.x, loc.y);
                            childControl->PaintAll(args);
                            args.graphics.RestoreChecked(state);
                        }
                    }
                    child = child->NextSibling();
                }
                if (topControl != null)
                {
                    GraphicsState state = args.graphics.SaveChecked();
                    Point loc = topControl->Location();
                    args.graphics.SetClipChecked(Rect(topControl->Location(), topControl->GetSize()));
                    args.graphics.TranslateTransformChecked(loc.x, loc.y);
                    topControl->PaintAll(args);
                    args.graphics.RestoreChecked(state);
                }
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected virtual void OnControlAdded(ControlEventArgs& args)
        {
            controlAddedEvent.Fire(args);
        }
        public virtual void OnControlRemoved(ControlEventArgs& args)
        {
            controlRemovedEvent.Fire(args);
        }
        private Container children;
        private Event<ControlEventHandler, ControlEventArgs> controlAddedEvent;
        private Event<ControlEventHandler, ControlEventArgs> controlRemovedEvent;
    }
}

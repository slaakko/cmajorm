// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;

namespace System.Windows
{
    public class ContainerControl : Control
    {
        public ContainerControl(const char* windowClassName, WindowClassStyle windowClassStyle, WindowColor windowClassBackgroundColor, WindowStyle style, ExtendedWindowStyle exStyle, 
            const string& text, const Point& location, const Size& size, Dock dock, Anchors anchors) : 
            base(windowClassName, windowClassStyle, windowClassBackgroundColor, style, exStyle, text, location, size, dock, anchors), 
            firstChild(null), lastChild(null)
        {
        }
        public ~ContainerControl()
        {
            Control* child = firstChild;
            while (child != null)
            {
                Control* next = child->NextSibling();
                delete child;
                child = next;
            }
        }
        public void AddChild(Control* child)
        {
            ContainerControl* parent = child->Parent();
            if (parent != null)
            {
                UniquePtr<Control> removedChild = parent->RemoveChild(child);
                child = removedChild.Release();
            }
            if (lastChild != null)
            {
                lastChild->LinkAfter(child);
            }
            if (firstChild == null)
            {
                firstChild = child;
            }
            child->SetParent(this);
            lastChild = child;
            if (child->Handle() == null)
            {
                child->CreateWindowInternal();
            }
            else
            {
                child->SetParentWindow(this);
            }            
            if ((child->GetWindowStyle() & WindowStyle.WS_VISIBLE) != 0)
            {
                child->Show();
            }
        }
        public UniquePtr<Control> RemoveChild(Control* child)
        {
            child->Unlink();
            if (child == firstChild)
            {
                firstChild = child->NextSibling();
            }
            if (child == lastChild)
            {
                lastChild = child->PrevSibling();
            }
            child->SetParent(null);
            return UniquePtr<Control>(child);
        }
        protected override bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_COMMAND:
                {
                    void* childWindowHandle = message.LParamHandle();
                    ushort notificationCode = message.WParamHiWord();
                    ushort controlId = message.WParamLoWord();
                    Control* child = Application.GetWindowManager().GetWindow(childWindowHandle);
                    if (child != null)
                    {
                        switch (notificationCode)
                        {
                            case BN_CLICKED:
                            {
                                if (child is ButtonBase*)
                                {
                                    ButtonBase* button = cast<ButtonBase*>(child);
                                    button->OnClickInternal();
                                    message.result = 0;
                                    return true;
                                }                            
                                break;
                            }
                        }
                    }
                    break;
                }
                case WM_SIZE:
                {
                    uint s = message.LParamLoDWord();
                    ushort sw = cast<ushort>(s);
                    ushort sh = cast<ushort>(s >> 16u);
                    Size newSize(cast<int>(sw), cast<int>(sh));
                    Size oldSize = GetSize();
                    if (newSize != oldSize)
                    {
                        int dx = newSize.w - oldSize.w;
                        int dy = newSize.h - oldSize.h;
                        Control* child = firstChild;
                        while (child != null)
                        {
                            if (child->GetDock() != Dock.none)
                            {
                                child->DockWindow(newSize);
                            }
                            else
                            {
                                child->MoveWindow(dx, dy);
                            }
                            child = child->NextSibling();
                        }                
                        SetSizeInternal(newSize);
                    }                    
                    message.result = 0;
                    return true;
                }
                case WM_PAINT:
                {
                    return base->ProcessMessage(message);
                }
            }
            return false;
        }
        private Control* firstChild;
        private Control* lastChild;
    }
}

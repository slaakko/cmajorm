// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;

namespace System.Windows
{
    public class delegate void WindowClosingEventHandler(bool& cancelClose);
    
    public class delegate void WindowClosedEventHandler();
    
    public class Window : ContainerControl
    {
        public Window(const char* windowClassName, WindowClassStyle classStyle, WindowStyle style, ExtendedWindowStyle exStyle, 
            const Color& backgroundColor, const string& text, const Point& location, const Size& size, Dock dock, Anchors anchors) : 
            base(windowClassName, classStyle, style, exStyle, backgroundColor, text, location, size, dock, anchors), isMainWindow(false), state(WindowState.normal),
            menuBar(null)
        {
        }
        public Window(const char* windowClassName, WindowStyle style, ExtendedWindowStyle exStyle, const string& text, const Point& location, const Size& size, Dock dock, Anchors anchors) : 
            this(windowClassName, cast<WindowClassStyle>(WindowClassStyle.CS_VREDRAW | WindowClassStyle.CS_HREDRAW), style, exStyle, GetSystemColor(SystemColor.COLOR_WINDOW),
            text, location, size, dock, anchors)
        {
        }
        public Window(const string& caption) :
            this("System.Windows.Window", WindowStyle.WS_OVERLAPPEDWINDOW, DefaultExtendedWindowStyle(), caption, Point.Default(), Size.Default(), Dock.none, Anchors.none)
        {
        }
        public override void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "Window." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
            Component* child = Children().FirstChild();
            while (child != null)
            {
                if (child is Control*)
                {
                    Control* childControl = cast<Control*>(child);
                    childControl->PrintWindowTree(level + 1);
                }
                child = child->NextSibling();
            }
        }
        protected override bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_CLOSE:
                {
                    bool cancelClose = false;
                    OnWindowClosing(cancelClose);
                    if (cancelClose)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_DESTROY:
                {
                    bool processed = false;
                    OnWindowClosed(processed);
                    if (processed)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_COMMAND: case WM_SIZE: case WM_PAINT: case WM_MOUSEMOVE: case WM_MOUSELEAVE: case WM_LBUTTONDOWN: case WM_LBUTTONUP: case WM_LBUTTONDBLCLK:
                case WM_CHAR: case WM_KEYDOWN: case WM_KEYUP: case WM_SYSCOMMAND: case WM_HSCROLL: case WM_VSCROLL: case WM_MOUSEWHEEL: case WM_TIMER: case WM_SETFOCUS: case WM_KILLFOCUS:
                {
                    return base->ProcessMessage(message);
                }
            }
            return false;
        }
        public void Close()
        {
            PostMessage(Handle(), WM_CLOSE, 0u, 0);
        }
        protected virtual void OnWindowClosing(bool& cancelClose)
        {
            windowClosingEvent.Fire(cancelClose);
        }
        protected virtual void OnWindowClosed(bool& processed)
        {
            if (windowClosedEvent.Handlers().IsEmpty())
            {
                if (isMainWindow)
                {
                    Application.Exit();
                    processed = true;
                }
            }            
            else
            {
                windowClosedEvent.Fire();
                processed = true;
            }
        }
        protected override void OnControlAdded(ControlEventArgs& args)
        {
            base->OnControlAdded(args);
            Control* control = args.control;
            if (control is MenuBar*)
            {
                menuBar = cast<MenuBar*>(control);
            }
        }
        protected override void OnControlRemoved(ControlEventArgs& args)
        {
            base->OnControlRemoved(args);
            Control* control = args.control;
            if (control == menuBar)
            {
                menuBar = null;
            }
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            base->OnMouseMove(args);
            if (menuBar != null)
            {
                menuBar->MouseMoveInternal(args);
            }
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            if (menuBar != null)
            {
                menuBar->MouseDownInternal(args);
            }
        }
        protected override void OnMouseUp(MouseEventArgs& args)
        {
            base->OnMouseUp(args);
            if (menuBar != null)
            {
                menuBar->MouseUpInternal(args);
            }
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                if (Debug.Paint())
                {
                    Rect r(Point(), GetSize());
                    LogView* log = Application.GetLogView();
                    if (log != null)
                    {
                        log->WriteLine("Window.OnPaint: " + r.ToString());
                    }
                }
                args.graphics.Clear(BackgroundColor());
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected override void OnSetFocus()
        {
        }
        protected override void OnKillFocus()
        {
        }
        public nothrow void SetAsMainWindow()
        {
            isMainWindow = true;
        }
        public nothrow inline bool IsMainWindow() const
        {
            return isMainWindow;
        }
        public WindowState GetWindowState() const
        {
            return state;
        }
        public void SetWindowState(WindowState newState)
        {
            if (state != newState)
            {
                switch (state)
                {
                    case WindowState.normal:
                    {
                        switch (newState)
                        {
                            case WindowState.minimized:
                            {
                                ShowWindow(ShowCommand.SW_MINIMIZE);
                                break;
                            }
                            case WindowState.maximized:
                            {
                                ShowWindow(ShowCommand.SW_MAXIMIZE);
                                break;
                            }
                        }
                        break;
                    }
                    case WindowState.minimized: case WindowState.maximized: 
                    {
                        switch (newState)
                        {
                            case WindowState.normal:
                            {
                                ShowWindow(ShowCommand.SW_RESTORE);
                                break;
                            }
                            case WindowState.minimized:
                            {
                                ShowWindow(ShowCommand.SW_MINIMIZE);
                                break;
                            }
                            case WindowState.maximized:
                            {
                                ShowWindow(ShowCommand.SW_MAXIMIZE);
                                break;
                            }
                        }
                        break;
                    }
                }
                state = newState;
            }
        }
        public nothrow MenuBar* GetMenuBar() const
        {
            return menuBar;
        }
        public nothrow Event<WindowClosingEventHandler, bool>& WindowClosingEvent()
        {
            return windowClosingEvent;
        }
        public nothrow Event<WindowClosedEventHandler>& WindowClosedEvent()
        {
            return windowClosedEvent;
        }
        private bool isMainWindow;
        private WindowState state;
        private MenuBar* menuBar;
        private Event<WindowClosingEventHandler, bool> windowClosingEvent;
        private Event<WindowClosedEventHandler> windowClosedEvent;
    }
}

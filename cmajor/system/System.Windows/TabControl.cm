// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public nothrow Color DefaultTabControlFrameColor()
    {
        return Color(204u, 206u, 219u);
    }

    public nothrow Color DefaultTabTextColor()
    {
        return Color.Black();
    }

    public nothrow Color DefaultTabBackgroundColor()
    {
        return Color.White();
    }

    public nothrow Color DefaultTabCloseBoxSelectedColor()
    {
        return Color(222u, 238u, 245u);
    }

    public nothrow inline int DefaultTabLeadingWidth()
    {
        return 0;
    }

    public nothrow inline int DefaultTabControlTopMarginHeight()
    {
        return 4;
    }

    public nothrow Padding DefaultTabPadding()
    {
        return Padding(8, 2, 8, 2);
    }

    public nothrow Padding DefaultTabCloseBoxPadding()
    {
        return Padding(8, 6, 8, 0);
    }

    public nothrow inline int DefaultTabOverlapWidth()
    {
        return 2;
    }

    public nothrow inline float DefaultTabRoundingRadius()
    {
        return 8;
    }

    public nothrow inline float DefaultTabCloseBoxPenWidth()
    {
        return 1.0f;
    }

    internal class Tab
    {
        public enum State
        {
            normal, closeBoxSelected
        }
        public bool visible;
        public State state;
        public float textHeight;
        public float textWidth;
        public float closeBoxWidth;
        public int height;
        public int width;
        public int left;
        public RectF leftRoundingRect;
        public RectF rightRoundingRect;
        public RectF topRect;
        public RectF bottomRect;
        public RectF textRect;
        public RectF closeBoxRect;
        public Rect selectRect;
        public Rect closeRect;
    }

    public class TabControl : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0
        }
        public TabControl(const Font& font_, const Color& frameColor_, const Point& location, const Size& size, Dock dock, Anchors anchors) :
            base("System.Windows.TabControl", DefaultWindowClassStyle(), DefaultChildWindowStyle(), DefaultExtendedWindowStyle(),
            DefaultControlBackgroundColor(), "tabControl", location, size, dock, anchors), flags(Flags.none), font(font_), frameColor(frameColor_),
            textColor(DefaultTabTextColor()), tabPages(this), selectedTabPage(null), leadingWidth(DefaultTabLeadingWidth()),
            topMarginHeight(DefaultTabControlTopMarginHeight()), headerHeight(0), tabPadding(DefaultTabPadding()), tabCloseBoxPadding(DefaultTabCloseBoxPadding()),
            overlapWidth(DefaultTabOverlapWidth()), roundingRadius(DefaultTabRoundingRadius()), stringFormat(),
            centerFormat(StringAlignment.center, StringAlignment.center), framePen(frameColor), textBrush(textColor), tabBackgroundColor(DefaultTabBackgroundColor()),
            tabBackgroundBrush(tabBackgroundColor), closeBoxPenWidth(DefaultTabCloseBoxPenWidth()), closeBoxPen(textColor, closeBoxPenWidth), closeStateTabPage(null),
            closeBoxSelectedColor(DefaultTabCloseBoxSelectedColor()), closeBoxSelectedBrush(closeBoxSelectedColor)
        {
            SetChanged();
        }
        public TabControl(const Point& location, const Size& size, Dock dock, Anchors anchors) :
            this(Font(FontFamily("Segoe UI"), 9.0f), DefaultTabControlFrameColor(), location, size, dock, anchors)
        {
        }
        public void SetTextColor(const Color& textColor_)
        {
            if (textColor_ != textColor)
            {
                textColor = textColor_;
                textBrush = SolidBrush(textColor);
                Invalidate();
            }
        }
        public void SetTabBackgroundColor(const Color& tabBackgroundColor_)
        {
            if (tabBackgroundColor_ != tabBackgroundColor)
            {
                tabBackgroundColor = tabBackgroundColor_;
                tabBackgroundBrush = SolidBrush(tabBackgroundColor);
                Invalidate();
            }
        }
        public void AddTabPage(TabPage* tabPage)
        {
            AddTabPageToTabPageMap(tabPage);
            tabPages.AddChild(tabPage);
            SetSelectedTabPage(tabPage);
            SetChanged();
        }
        public void AddTabPage(const string& text, const string& key)
        {
            AddTabPage(new TabPage(text, key));
        }
        public void AddTabPage(const string& text)
        {
            AddTabPage(text, string());
        }
        public void CloseTabPage(TabPage* tabPage)
        {
            tabPage->Hide();
            RemoveTabPageFromTabPageMap(tabPage);
            if (tabPage == selectedTabPage)
            {
                if (selectedTabPage->NextSibling() != null)
                {
                    SetSelectedTabPage(cast<TabPage*>(selectedTabPage->NextSibling()));
                }
                else if (selectedTabPage->PrevSibling() != null)
                {
                    SetSelectedTabPage(cast<TabPage*>(selectedTabPage->PrevSibling()));
                }
                else
                {
                    SetSelectedTabPage(null);
                }
            }
            tabPages.RemoveChild(tabPage);
            SetChanged();
            Invalidate();
        }
        public nothrow int IndexOf(TabPage* tabPage) const
        {
            int index = 0;
            Component* component = tabPages.FirstChild();
            while (component != null)
            {
                if (component == tabPage)
                {
                    return index;
                }
                component = component->NextSibling();
                ++index;
            }
            return -1;
        }
        public nothrow TabPage* GetTabPageByKey(const string& key) const
        {
            HashMap<string, TabPage*>.ConstIterator it = tabPageMap.CFind(key);
            if (it != tabPageMap.CEnd())
            {
                return it->second;
            }
            else
            {
                return null;
            }
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                if (Debug.Paint())
                {
                    Rect r(Point(), GetSize());
                    LogView* log = Application.GetLogView();
                    if (log != null)
                    {
                        log->WriteLine("TabControl.OnPaint: " + r.ToString());
                    }
                }
                SmoothingMode prevSmoothingMode = args.graphics.GetSmoothingModeChecked();
                args.graphics.SetSmoothingModeChecked(SmoothingMode.highQuality);
                if (Changed())
                {
                    ResetChanged();
                    Measure(args.graphics);
                }
                args.graphics.Clear(BackgroundColor());
                DrawTabs(args.graphics);
                DrawSelectedTabPage();
                DrawFrame(args.graphics);
                args.graphics.SetSmoothingModeChecked(prevSmoothingMode);
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected override void OnMouseEnter()
        {
            base->OnMouseEnter();
            closeStateTabPage = null;
        }
        protected override void OnMouseLeave()
        {
            base->OnMouseLeave();
            if (closeStateTabPage != null)
            {
                closeStateTabPage->tab.state = Tab.State.normal;
                Invalidate(closeStateTabPage->tab.closeRect.ToWinRect());
                closeStateTabPage = null;
            }
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            base->OnMouseMove(args);
            Component* component = tabPages.FirstChild();
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                if (tabPage->tab.closeRect.Contains(args.location))
                {
                    if (tabPage->tab.state == Tab.State.normal)
                    {
                        tabPage->tab.state = Tab.State.closeBoxSelected;
                        closeStateTabPage = tabPage;
                        Invalidate(tabPage->tab.closeRect.ToWinRect());
                        return;
                    }
                }
                else if (closeStateTabPage != null)
                {
                    if (tabPage->tab.state == Tab.State.closeBoxSelected)
                    {
                        closeStateTabPage->tab.state = Tab.State.normal;
                        Invalidate(closeStateTabPage->tab.closeRect.ToWinRect());
                        closeStateTabPage = null;
                        return;
                    }
                }
                component = component->NextSibling();
            }
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            Component* component = tabPages.FirstChild();
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                if (tabPage->tab.selectRect.Contains(args.location))
                {
                    tabPage->Select();
                    return;
                }
                else if (tabPage->tab.closeRect.Contains(args.location))
                {
                    tabPage->Close();
                    return;
                }
                component = component->NextSibling();
            }
        }
        public nothrow inline TabPage* SelectedTabPage() const
        {
            return selectedTabPage;
        }
        public void SetSelectedTabPage(TabPage* tabPage)
        {
            if (selectedTabPage != tabPage)
            {
                if (selectedTabPage != null)
                {
                    selectedTabPage->Hide();
                }
                selectedTabPage = tabPage;
                if (selectedTabPage != null)
                {
                    selectedTabPage->Show();
                }
                Invalidate();
            }
        }
        private void DrawTabs(Graphics& graphics)
        {
            Component* component = tabPages.FirstChild();
            int left = leadingWidth;
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                if (tabPage != selectedTabPage)
                {
                    tabPage->DrawTab(graphics, this);
                }
                component = component->NextSibling();
            }
            if (selectedTabPage != null)
            {
                selectedTabPage->DrawTab(graphics, this);
            }
        }
        private void DrawSelectedTabPage()
        {
            if (selectedTabPage == null) return;
            selectedTabPage->SetLocation(Point(1, headerHeight + 1));
            Size size = GetSize();
            size.w = size.w - 2;
            size.h = size.h - headerHeight - 2;
            selectedTabPage->SetSize(size);
            selectedTabPage->Invalidate();
        }
        private void DrawFrame(Graphics& graphics)
        {
            if (selectedTabPage == null) return;
            Size size = GetSize();
            graphics.DrawLineChecked(framePen,
                PointF(0, headerHeight),
                PointF(selectedTabPage->tab.left, headerHeight));
            graphics.DrawLineChecked(framePen,
                PointF(selectedTabPage->tab.left + selectedTabPage->tab.width, headerHeight),
                PointF(size.w - 1, headerHeight));
            graphics.DrawLineChecked(framePen,
                PointF(size.w - 1, headerHeight),
                PointF(size.w - 1, size.h - 1));
            graphics.DrawLineChecked(framePen,
                PointF(size.w - 1, size.h - 1),
                PointF(0, size.h - 1));
            graphics.DrawLineChecked(framePen,
                PointF(0, size.h - 1),
                PointF(0, headerHeight));
        }
        internal nothrow void AddTabPageToTabPageMap(TabPage* tabPage)
        {
            if (!tabPage->Key().IsEmpty())
            {
                tabPageMap[tabPage->Key()] = tabPage;
            }
        }
        internal nothrow void RemoveTabPageFromTabPageMap(TabPage* tabPage)
        {
            if (!tabPage->Key().IsEmpty())
            {
                tabPageMap.Remove(tabPage->Key());
            }
        }
        private void Measure(Graphics& graphics)
        {
            headerHeight = 0;
            MeasureWidthsAndHeight(graphics);
            SetVisibility(graphics);
            CalculateMetrics(graphics);
        }
        private void MeasureWidthsAndHeight(Graphics& graphics)
        {
            Component* component = tabPages.FirstChild();
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                tabPage->MeasureWidthAndHeight(graphics, this);
                component = component->NextSibling();
            }
        }
        private void SetVisibility(Graphics& graphics)
        {
            Component* component = tabPages.FirstChild();
            TabPage* firstVisibleTabPage = cast<TabPage*>(component);
            int width = GetSize().w;
            int sum = leadingWidth;
            bool selectedPassed = false;
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                int w = tabPage->tab.width;
                sum = sum + w;
                if (tabPage == selectedTabPage)
                {
                    if (sum < width)
                    {
                        firstVisibleTabPage->tab.visible = true;
                        while (firstVisibleTabPage != selectedTabPage)
                        {
                            firstVisibleTabPage = cast<TabPage*>(firstVisibleTabPage->NextSibling());
                            firstVisibleTabPage->tab.visible = true;
                        }
                        selectedPassed = true;
                    }
                    else
                    {
                        sum = sum - firstVisibleTabPage->tab.width;
                        firstVisibleTabPage->tab.visible = false;
                        component = firstVisibleTabPage;
                    }
                }
                else if (selectedPassed)
                {
                    if (sum < width)
                    {
                        tabPage->tab.visible = true;
                    }
                    else
                    {
                        tabPage->tab.visible = false;
                    }
                }
                sum = sum - overlapWidth;
                component = component->NextSibling();
            }
        }
        private void CalculateMetrics(Graphics& graphics)
        {
            Component* component = tabPages.FirstChild();
            int left = leadingWidth;
            while (component != null)
            {
                TabPage* tabPage = cast<TabPage*>(component);
                tabPage->CalculateMetrics(graphics, this, left);
                component = component->NextSibling();
            }
        }
        internal nothrow inline const Font& GetFont() const
        {
            return font;
        }
        internal nothrow inline const Pen& FramePen() const
        {
            return framePen;
        }
        internal nothrow inline const Pen& CloseBoxPen() const
        {
            return closeBoxPen;
        }
        internal nothrow inline const SolidBrush& TextBrush() const
        {
            return textBrush;
        }
        internal nothrow inline const SolidBrush& TabBackgroundBrush() const
        {
            return tabBackgroundBrush;
        }
        internal nothrow inline const SolidBrush& CloseBoxSelectedBrush() const
        {
            return closeBoxSelectedBrush;
        }
        internal nothrow inline int LeadingWidth() const
        {
            return leadingWidth;
        }
        internal nothrow inline int TopMarginHeight() const
        {
            return topMarginHeight;
        }
        internal nothrow inline int HeaderHeight() const
        {
            return headerHeight;
        }
        internal nothrow void SetHeaderHeight(int headerHeight_)
        {
            headerHeight = headerHeight_;
        }
        internal nothrow inline const Padding& TabPadding() const
        {
            return tabPadding;
        }
        internal nothrow inline const Padding& TabCloseBoxPadding() const
        {
            return tabCloseBoxPadding;
        }
        internal nothrow inline int OverlapWidth() const
        {
            return overlapWidth;
        }
        internal nothrow inline float RoundingRadius() const
        {
            return roundingRadius;
        }
        internal nothrow inline const StringFormat& GetStringFormat() const
        {
            return stringFormat;
        }
        internal nothrow inline const StringFormat& CenterFormat() const
        {
            return centerFormat;
        }
        private nothrow inline bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        internal nothrow inline void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed);
        }
        private nothrow inline void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed); 
        }
        private Flags flags;
        private Font font;
        private Color frameColor;
        private Color textColor;
        private Container tabPages;
        private HashMap<string, TabPage*> tabPageMap;
        private TabPage* selectedTabPage;
        private int leadingWidth;
        private int topMarginHeight;
        private int headerHeight;
        private Padding tabPadding;
        private Padding tabCloseBoxPadding;
        private int overlapWidth;
        private float roundingRadius;
        private StringFormat stringFormat;
        private StringFormat centerFormat;
        private Color tabBackgroundColor;
        private Pen framePen;
        private float closeBoxPenWidth;
        private Pen closeBoxPen;
        private SolidBrush textBrush;
        private SolidBrush tabBackgroundBrush;
        private Color closeBoxSelectedColor;
        private SolidBrush closeBoxSelectedBrush;
        private TabPage* closeStateTabPage;
    }

    public class TabPage : Panel
    {
        public TabPage(const string& text, const string& key_) :
            base("System.Windows.TabPage", text, Point(), Size(), Dock.none, Anchors.none, Color.White()), key(key_), tab()
        {
        }
        public nothrow inline const string& Key() const
        {
            return key;
        }
        public void SetKey(const string& key_)
        {
            TabControl* tabControl = GetTabControl();
            if (tabControl != null)
            {
                tabControl->RemoveTabPageFromTabPageMap(this);
            }
            key = key_;
            if (tabControl != null)
            {
                tabControl->AddTabPageToTabPageMap(this);
            }
        }
        public void Select()
        {
            TabControl* tabControl = GetTabControl();
            if (tabControl != null)
            {
                tabControl->SetSelectedTabPage(this);
            }
        }
        public void Close()
        {
            TabControl* tabControl = GetTabControl();
            if (tabControl != null)
            {
                tabControl->CloseTabPage(this);
            }
        }
        public nothrow TabControl* GetTabControl() const
        {
            Control* parentControl = ParentControl();
            if (parentControl != null && parentControl is TabControl*)
            {
                return cast<TabControl*>(parentControl);
            }
            return null;
        }
        protected override void OnTextChanged()
        {
            base->OnTextChanged();
            tab.width = 0;
            TabControl* tabControl = GetTabControl();
            if (tabControl != null)
            {
                tabControl->SetChanged();
                tabControl->Invalidate();
            }
        }
        internal void MeasureWidthAndHeight(Graphics& graphics, TabControl* tabControl)
        {
            if (tab.width == 0)
            {
                RectF textRect = graphics.MeasureStringChecked(Text(), tabControl->GetFont(), PointF(), tabControl->GetStringFormat());
                RectF closeRect = graphics.MeasureStringChecked("x", tabControl->GetFont(), PointF(), tabControl->GetStringFormat());
                tab.textHeight = textRect.size.h;
                tab.textWidth = textRect.size.w;
                tab.closeBoxWidth = closeRect.size.w;
                tab.height = cast<int>(tabControl->TabPadding().Vertical() + tabControl->TabCloseBoxPadding().Vertical() + tab.textHeight);
                tab.width = cast<int>(tabControl->TabPadding().Horizontal() + tab.textWidth + tabControl->OverlapWidth() +
                    tabControl->TabCloseBoxPadding().Horizontal() + tab.closeBoxWidth);
            }
            tabControl->SetHeaderHeight(Max(tabControl->HeaderHeight(), tab.height + tabControl->TopMarginHeight()));
        }
        internal void CalculateMetrics(Graphics& graphics, TabControl* tabControl, int& left)
        {
            if (!tab.visible) return;
            float roundingRadius = tabControl->RoundingRadius();
            int topMarginHeight = tabControl->TopMarginHeight();
            tab.left = left;
            tab.leftRoundingRect = RectF(PointF(), SizeF(2 * roundingRadius, 2 * roundingRadius));
            tab.leftRoundingRect.Offset(left, topMarginHeight);
            tab.rightRoundingRect = RectF(PointF(), SizeF(2 * roundingRadius, 2 * roundingRadius));
            tab.rightRoundingRect.Offset(left + tab.width - 2 * roundingRadius, topMarginHeight);
            tab.topRect = RectF(PointF(), SizeF(tab.width - 2 * roundingRadius, roundingRadius));
            tab.topRect.Offset(left + roundingRadius, topMarginHeight);
            tab.bottomRect = RectF(PointF(), SizeF(tab.width, tab.height - roundingRadius + 1));
            tab.bottomRect.Offset(left, topMarginHeight + roundingRadius);
            tab.textRect = RectF(PointF(), SizeF(tab.width - (tabControl->TabCloseBoxPadding().Horizontal() + tab.closeBoxWidth), tab.height));
            tab.textRect.Offset(left, topMarginHeight);
            tab.selectRect = Rect(Point(tab.left, topMarginHeight),
                Size(cast<int>(tab.width - (tab.closeBoxWidth + tabControl->TabCloseBoxPadding().right)), tab.height));
            tab.closeBoxRect = RectF(
                PointF(tab.left + tab.selectRect.size.w,
                    topMarginHeight + tabControl->TabPadding().top + tabControl->TabCloseBoxPadding().top),
                SizeF(tab.closeBoxWidth, tab.closeBoxWidth));
            tab.closeRect = Rect(Point(cast<int>(tab.closeBoxRect.location.x), cast<int>(tab.closeBoxRect.location.y)),
                Size(cast<int>(tab.closeBoxRect.size.w), cast<int>(tab.closeBoxRect.size.h)));
            tab.closeRect.Inflate(3, 3);
            tab.closeBoxRect.Inflate(-1, -1);
            left = left + tab.width - tabControl->OverlapWidth();
        }
        internal void DrawTab(Graphics& graphics, TabControl* tabControl)
        {
            if (!tab.visible) return;
            const Brush& backgroundBrush = tabControl->TabBackgroundBrush();
            const Pen& framePen = tabControl->FramePen();
            const Pen& closeBoxPen = tabControl->CloseBoxPen();
            int topMarginHeight = tabControl->TopMarginHeight();
            float roundingRadius = tabControl->RoundingRadius();
            graphics.FillEllipseChecked(backgroundBrush, tab.leftRoundingRect);
            graphics.FillEllipseChecked(backgroundBrush, tab.rightRoundingRect);
            graphics.FillRectangleChecked(backgroundBrush, tab.topRect);
            graphics.FillRectangleChecked(backgroundBrush, tab.bottomRect);
            graphics.DrawLineChecked(framePen, PointF(tab.left, tab.bottomRect.location.y + tab.bottomRect.size.h), PointF(tab.left, tab.bottomRect.location.y));
            graphics.DrawArcChecked(framePen, tab.leftRoundingRect, -180.0f, 90.0f);
            graphics.DrawStringChecked(Text(), tabControl->GetFont(), tab.textRect, tabControl->CenterFormat(), tabControl->TextBrush());
            graphics.DrawLineChecked(framePen,
                PointF(tab.leftRoundingRect.location.x + roundingRadius, topMarginHeight),
                PointF(tab.rightRoundingRect.location.x + roundingRadius, topMarginHeight));
                graphics.DrawArcChecked(framePen, tab.rightRoundingRect, -90.0f, 90.0f);
            graphics.DrawLineChecked(framePen,
                PointF(tab.left + tab.width, tab.bottomRect.location.y),
                PointF(tab.left + tab.width, tab.bottomRect.location.y + tab.bottomRect.size.h - 1));
            if (tab.state == Tab.State.normal)
            {
                RectF r = tab.closeBoxRect;
                r.Inflate(3, 3);
                graphics.FillRectangleChecked(backgroundBrush, r);
            }
            else if (tab.state == Tab.State.closeBoxSelected)
            {
                RectF r = tab.closeBoxRect;
                r.Inflate(3, 3);
                const Brush& selectedBrush = tabControl->CloseBoxSelectedBrush();
                graphics.FillRectangleChecked(selectedBrush, r);
            }
            graphics.DrawLineChecked(closeBoxPen,
                tab.closeBoxRect.location, PointF(tab.closeBoxRect.location.x + tab.closeBoxRect.size.w, tab.closeBoxRect.location.y + tab.closeBoxRect.size.h));
            graphics.DrawLineChecked(closeBoxPen,
                PointF(tab.closeBoxRect.location.x, tab.closeBoxRect.location.y + tab.closeBoxRect.size.h),
                PointF(tab.closeBoxRect.location.x + tab.closeBoxRect.size.w, tab.closeBoxRect.location.y));
        }
        private string key;
        internal Tab tab;
    }
}

// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public const uint defaultCaretTimerPeriod = 5000u; // 5 seconds

    public class LineEventArgs
    {
        public nothrow LineEventArgs(int lineIndex_) : lineIndex(lineIndex_)
        {
        }
        public int lineIndex;
    }

    public class delegate void CaretPosChangedEventHandler();
    public class delegate void LinesChangedEventHandler();
    public class delegate void LineChangedEventHandler(LineEventArgs& args);
    public class delegate void LineDeletedEventHandler(LineEventArgs& args);
    public class delegate void LineInsertedEventHandler(LineEventArgs& args);
    public class delegate void GotoCaretLineEventHandler(ControlEventArgs& args);

    public class TextView : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, painting = 1 << 1, readOnly = 1 << 2, fixed = 1 << 3, dirty = 1 << 4
        }
        
        public TextView(const FontFamily& fontFamily_, float fontSize_, const Color& backgroundColor, const Color& textColor, const Point& location, const Size& size,
            Dock dock, Anchors anchors) :
            base("System.Windows.TextView", DefaultWindowClassStyle(), cast<WindowStyle>(DefaultChildWindowStyle() | WindowStyle.WS_TABSTOP), DefaultExtendedWindowStyle(), backgroundColor,
            "textView", location, size, dock, anchors), flags(Flags.none), drawFormat(StringAlignment.near, StringAlignment.near), fontFamily(fontFamily_), fontSize(fontSize_),
            charWidth(0), charHeight(0), textWidth(0), textHeight(0), maxLineLength(0), cursor(LoadStandardCursor(StandardCursorId.IDC_IBEAM)), caretLine(1), caretColumn(1),
            caretTimerPeriod(defaultCaretTimerPeriod), brush(textColor), update(false), topLine(1), topLineDiff(0.0f), leftCol(1), leftColDiff(0.0f),
            padding()
        {
            uint caretTimeOut = 0u;
            bool succeeded = ReadCaretTimeoutFromRegistry(caretTimeOut);
            if (succeeded)
            {
                caretTimerPeriod = caretTimeOut;
            }
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
            SetChanged();
            measureString = "// this file has been semiautomatically generated from 'D:/work/soulng-project/sngcm/ast/AstReader.hpp' using cpp2cm version 1.0.0";
        }
        public TextView(const Point& location, const Size& size, Dock dock, Anchors anchors) : this(FontFamily("Consolas"), 10.0f, Color.White(), Color.Black(),
            location, size, dock, anchors)
        {
        }
        public nothrow inline List<ustring>& Lines()
        {
            return lines;
        }
        public nothrow inline const List<ustring>& Lines() const
        {
            return lines;
        }
        public void AddLine(const ustring& line)
        {
            lines.Add(line);
            SetMaxLineLength();
        }
        public void SetFont(const FontFamily& fontFamily_, float fontSize_)
        {
            fontFamily = fontFamily_;
            fontSize = fontSize_;
            fonts.Clear();
            OnFontChanged();
            SetChanged();
        }
        protected virtual void OnFontChanged()
        {
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
        }
        public nothrow inline float CharWidth() const
        {
            return charWidth;
        }
        public nothrow inline float CharHeight() const
        {
            return charHeight;
        }
        public nothrow inline int TextWidth() const
        {
            return textWidth;
        }
        public nothrow inline int TextHeight() const
        {
            return textHeight;
        }
        public nothrow inline FontFamily& GetFontFamily() const
        {
            return fontFamily;
        }
        public nothrow inline float FontSize() const
        {
            return fontSize;
        }
        public nothrow inline const List<UniquePtr<Font>>& Fonts() const
        {
            return fonts;
        }
        public nothrow inline List<UniquePtr<Font>>& Fonts()
        {
            return fonts;
        }
        public void SetCaretLineCol(int line, int column)
        {
            if (caretLine != line || caretColumn != column)
            {
                caretLine = line;
                caretColumn = column;
                SetCaretLocation();
            }
        }
        public nothrow inline int TopLine() const
        {
            return topLine;
        }
        public nothrow inline float TopLineDiff() const
        {
            return topLineDiff;
        }
        public nothrow inline int LeftColumn() const
        {
            return leftCol;
        }
        public nothrow inline float LeftColumnDiff() const
        {
            return leftColDiff;
        }
        public nothrow inline int CaretLine() const
        {
            return caretLine;
        }
        public nothrow inline int CaretColumn() const
        {
            return caretColumn - LineNumberFieldLength();
        }
        public void SetTopLineCol(int line, int column)
        {
            Point newOrigin(cast<int>((column - 1) * charWidth), cast<int>((line - 1) * charHeight));
            topLine = cast<int>(newOrigin.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - newOrigin.y;
            leftCol = cast<int>(newOrigin.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - newOrigin.x;
            SetContentLocation(newOrigin);
            Invalidate();
        }
        public nothrow inline int GetVisibleLineCount() const
        {
            Size size = GetSize();
            return cast<int>(size.h / charHeight);
        }
        public nothrow inline int GetVisibleColumnCount() const
        {
            Size size = GetSize();
            return cast<int>(size.w / charWidth);
        }
        public nothrow inline bool IsLinePartiallyVisible(int line) const
        {
            return line >= (topLine - 1) && line < (topLine + GetVisibleLineCount() + 1);
        }
        public nothrow inline bool IsLineVisible(int line) const
        {
            return line >= topLine && line < topLine + GetVisibleLineCount();
        }
        public virtual nothrow void GetLineColumn(const Point& contentLocation, int& line, short& column) const
        {
            line = cast<int>(contentLocation.y / charHeight + 1);
            column = cast<short>(contentLocation.x / charWidth + 1);
        }
        public void EnsureLineVisible(int line)
        {
            Invalidate();
            Application.ProcessMessages();
            if (IsLineVisible(line))
            {
                return;
            }
            int tl = Max(cast<int>(1), line - GetVisibleLineCount() / 2);
            SetTopLineCol(tl, 1);
        }
        public virtual void Clear()
        {
            ustring emptyContent;
            SetTextContent(emptyContent);
        }
        public void SetTextContent(const ustring& textContent)
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            lines = SplitTextIntoLines(textContent);
            lineStartIndeces = CalculateLineStartIndeces(textContent);
            SetMaxLineLength();
            OnLinesChanged();
            SetContentChanged();
            SetChanged();
            SetCaretLineCol(1, 1 + LineNumberFieldLength());
            Invalidate();
            update = true;
        }
        public nothrow int GetLineLength(int lineNumber)
        {
            int lineLength = 0;
            if (lineNumber >= 1 && lineNumber <= lines.Count())
            {
                lineLength = cast<int>(lines[lineNumber - 1].Length());
            }
            return lineLength;
        }
        public nothrow bool Prev(int& line, int& col)
        {
            if (col > 1)
            {
                --col;
                return true;
            }
            else
            {
                if (line > 1)
                {
                    --line;
                    int lineLength = GetLineLength(line);
                    if (lineLength > 0)
                    {
                        col = lineLength;
                    }
                    else
                    {
                        col = 1;
                    }
                    return true;
                }
            }
            return false;
        }
        public nothrow bool Next(int& line, int& col)
        {
            int lineLength = GetLineLength(line);
            if (col < lineLength)
            {
                ++col;
                return true;
            }
            else
            {
                if (line < lines.Count())
                {
                    ++line;
                    col = 1;
                    return true;
                }
            }
            return false;
        }
        public nothrow void PrevWord(int& line, int& col)
        {
            LogView* log = Application.GetLogView();
            if (Prev(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                if (IsWhiteSpace(c))
                {
                    Next(line, col);
                }
            }
        }
        public nothrow void NextWord(int& line, int& col)
        {
            if (Next(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
            }
        }
        private nothrow void GotoCaretLine()
        {
            ControlEventArgs args(this);
            OnGotoCaretLine(args);
        }
        protected virtual void OnGotoCaretLine(ControlEventArgs& args)
        {
            gotoCaretLineEvent.Fire(args);
        }
        public nothrow uchar GetCharAt(int line, int column) const
        {
            if (line < 1)
            {
                line = 1;
            }
            else if (line > lines.Count())
            {
                line = cast<int>(lines.Count());
            }
            int lineLength = GetLineLength(line);
            if (column < 1)
            {
                column = 1;
            }
            else
            {
                if (lineLength > 0 && column > lineLength)
                {
                    column = lineLength;
                }
            }
            if (line >= 1 && line <= lines.Count() && column >= 1 && column <= lineLength)
            {
                return lines[line - 1][column - 1];
            }
            return '\0';
        }
        public void SetCaretPosByCharIndex(int charIndex)
        {
            List<int>.ConstIterator it = LowerBound(lineStartIndeces.CBegin(), lineStartIndeces.CEnd(), charIndex);
            if (it != lineStartIndeces.CBegin() && it == lineStartIndeces.CEnd())
            {
                --it;
            }
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                if (*it > charIndex)
                {
                    --it;
                }
            }
            int lineNumber = cast<int>(it - lineStartIndeces.CBegin() + 1);
            int columnNumber = 1 + LineNumberFieldLength();
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                int lineStartCharIndex = *it;
                columnNumber = charIndex - lineStartCharIndex + 1 + LineNumberFieldLength();
            }
            SetCaretLineCol(lineNumber, columnNumber);
            ScrollToCaret();
        }
        public int GetCharIndex(int line, int column) const
        {
            if (line >= 1 && line <= lineStartIndeces.Count())
            {
                int lineStartIndex = lineStartIndeces[line - 1];
                int lineLength = GetLineLength(line);
                if (column >= 1 && column <= lineLength)
                {
                    return lineStartIndex + column - 1;
                }
            }
            return -1;
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                PaintContent(args.graphics);
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected virtual void PaintContent(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                Measure(graphics);
                if (Focused())
                {
                    SetCaretLocation();
                    ShowCaret();
                }
            }
            TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
            graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
            graphics.ClearChecked(BackgroundColor());
            int n = cast<int>(lines.Count());
            SetLineNumberFieldLength(n);
            PointF origin(0, 0);
            for (int i = 0; i < n; ++i)
            {
                if (IsLinePartiallyVisible(i + 1))
                {
                    DrawLine(graphics, i, origin);
                }
                origin.y = origin.y + charHeight;
            }
            graphics.SetTextRenderingHintChecked(prevRenderingHint);
        }
        protected virtual void DrawLine(Graphics& graphics, int lineIndex, const PointF& origin)
        {
            if (!fonts.IsEmpty())
            {
                PointF pt(origin);
                const ustring& line = lines[lineIndex];
                string s(ToUtf8(line));
                graphics.DrawStringChecked(s, *fonts[0], pt, brush);
            }
        }
        protected virtual void Measure(Graphics& graphics)
        {
            charWidth = 0;
            charHeight = 0;
            string ms;
            bool measure = false;
            if (IsFixed())
            {
                ms = measureString;
                maxLineLength = cast<int>(ToUtf32(measureString).Length());
                measure = true;
            }
            else
            {
                if (!lines.IsEmpty() && maxLineLength > 0)
                {
                    ms = ToUtf8(lines[maxLineIndex]);
                    measure = true;
                }
            }
            if (measure)
            {
                for (const UniquePtr<Font>& font : fonts)
                {
                    TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
                    graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
                    RectF charRect = graphics.MeasureStringChecked(ms, *font, PointF(0, 0), drawFormat);
                    graphics.SetTextRenderingHintChecked(prevRenderingHint);
                    charWidth = Max(charWidth, charRect.size.w / maxLineLength);
                    charHeight = Max(charHeight, charRect.size.h);
                }
            }
            SetScrollUnits(cast<int>(charHeight), cast<int>(2 * charWidth));
            SetTextExtent();
        }
        private void SetTextExtent()
        {
            textWidth = cast<int>(maxLineLength * charWidth);
            textHeight = cast<int>(lines.Count() * charHeight);
            SetContentSize(Size(textWidth, textHeight));
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            SetFocus(this);
            if (charHeight != 0 && charWidth != 0)
            {
                if ((args.buttons == MouseButtons.lbutton || args.buttons == MouseButtons.rbutton) && args.clicks == 1)
                {
                    Point loc = args.location;
                    int lineNumber = cast<int>(loc.y / charHeight + 1.5);
                    lineNumber = Max(1, Min(lineNumber, cast<int>(lines.Count())));
                    int columnNumber = cast<int>(loc.x / charWidth + 1.5);
                    columnNumber = Max(columnNumber, 1 + LineNumberFieldLength());
                    int lineLength = GetLineLength(lineNumber);
                    columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                    if (update)
                    {
                        update = false;
                        Invalidate();
                    }
                    SetCaretLineCol(lineNumber, columnNumber);
                    if (args.buttons == MouseButtons.rbutton)
                    {
                        RightClickEventArgs rightClickArgs(this, loc);
                        OnRightClick(rightClickArgs);
                    }
                }
            }
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            base->OnKeyDown(args);
            if (!args.handled)
            {
                bool scrolled = false;
                int lineNumber = caretLine;
                int columnNumber = caretColumn;
                switch (args.keyData)
                {
                    case Keys.home:
                    {
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case Keys.end:
                    {
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case Keys.left:
                    {
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            --columnNumber;
                        }
                        else if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.right:
                    {
                        if (lineNumber <= lines.Count())
                        {
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                            }
                            else
                            {
                                ++lineNumber;
                                columnNumber = 1 + LineNumberFieldLength();
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.down:
                    {
                        if (lineNumber < lines.Count())
                        {
                            ++lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        else
                        {
                            lineNumber = cast<int>(lines.Count()) + 1;
                            columnNumber = 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.up:
                    {
                        if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.pageDown:
                    {
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber + windowLines;
                        lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        args.handled = true;
                        break;
                    }
                    case Keys.pageUp:
                    {
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber - windowLines;
                        lineNumber = Max(lineNumber, 1);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.home):
                    {
                        lineNumber = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.end):
                    {
                        lineNumber = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.left):
                    {
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.right):
                    {
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.down):
                    {
                        ScrollLineDown();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.up):
                    {
                        ScrollLineUp();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.k):
                    {
                        GotoCaretLine();
                        args.handled = true;
                        break;
                    }
                    case Keys.delete_:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            DeleteChar(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.back:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            Backspace(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.enter:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            NewLine(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.r):
                    {
                        StreamWriter writer = File.AppendText(@"C:\temp\text.txt");
                        writer << lines[maxLineIndex] << "\n" << lines[maxLineIndex].Length() << "\n" << charWidth << "\n" << charHeight << "\n" << endl();
                        break;
                    }
                }
                if (args.handled && !scrolled)
                {
                    SetCaretLineCol(lineNumber, columnNumber);
                    ScrollToCaret();
                }
            }
        }
        protected override void OnKeyPress(KeyPressEventArgs& args)
        {
            base->OnKeyPress(args);
            if (IsReadOnly()) return;
            if (!args.handled)
            {
                uchar c(args.keyChar);
                int lineIndex = caretLine - 1;
                int columnIndex = CaretColumn() - 1;
                InsertChar(lineIndex, columnIndex, c);
                KeyEventArgs rightArgs(Keys.right, Keys.none);
                OnKeyDown(rightArgs);
                args.handled = true;
            }
        }
        private void InsertChar(int lineIndex, int columnIndex, uchar c)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex, c);
            if (line.Length() > maxLineLength)
            {
                maxLineLength = cast<int>(line.Length());
                maxLineIndex = lineIndex;
                SetTextExtent();
            }
            LineEventArgs args(lineIndex);
            OnLineChanged(args);
            SetDirty();
        }
        private void DeleteChar(int lineIndex, int columnIndex)
        {
            ustring& line = lines[lineIndex];
            if (columnIndex < line.Length())
            {
                line.Remove(columnIndex, 1);
                LineEventArgs args(lineIndex);
                OnLineChanged(args);
            }
            else
            {
                if (lines.Count() > lineIndex + 1)
                {
                    line.Append(lines[lineIndex + 1]);
                    LineEventArgs changedArgs(lineIndex);
                    OnLineChanged(changedArgs);
                    lines.Remove(lines.Begin() + lineIndex + 1);
                    LineEventArgs deletedArgs(lineIndex + 1);
                    OnLineDeleted(deletedArgs);
                }
            }
            SetDirty();
        }
        private void Backspace(int lineIndex, int columnIndex)
        {
            if (lineIndex != 0 || columnIndex != 0)
            {
                KeyEventArgs leftArgs(Keys.left, Keys.none);
                OnKeyDown(leftArgs);
                KeyEventArgs deleteArgs(Keys.delete_, Keys.none);
                OnKeyDown(deleteArgs);
            }
        }
        private void NewLine(int lineIndex, int columnIndex)
        {
            ustring& line = lines[lineIndex];
            ustring toInsert = line.Substring(columnIndex);
            if (!toInsert.IsEmpty())
            {
                line.Remove(columnIndex, line.Length() - columnIndex);
                LineEventArgs changedArgs(lineIndex);
                OnLineChanged(changedArgs);
            }
            lines.Insert(lines.Begin() + lineIndex + 1, toInsert);
            SetLineNumberFieldLength(cast<int>(lines.Count()));
            LineEventArgs insertedArgs(lineIndex + 1);
            OnLineInserted(insertedArgs);
            SetCaretLineCol(lineIndex + 1 + 1, 1 + LineNumberFieldLength());
            ScrollToCaret();
            Invalidate();
        }
        protected override nothrow void SetContentLocationInternal(const Point& contentLocation)
        {
            topLine = cast<int>(contentLocation.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - contentLocation.y;
            leftCol = cast<int>(contentLocation.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - contentLocation.x;
            base->SetContentLocationInternal(contentLocation);
        }
        public void ScrollToCaret()
        {
            if (lines.IsEmpty() || charHeight == 0) return;
            Size size = GetSize();
            int windowLines = cast<int>(size.h / charHeight);
            int windowCols = cast<int>(size.w / charWidth);
            Point currentOrigin = ContentLocation();
            int topLineNumber = cast<int>(currentOrigin.y / charHeight + 1);
            int leftColNumber = cast<int>(currentOrigin.x / charWidth + 1);
            int oldTopLineNumber = topLineNumber;
            if (caretLine > topLineNumber)
            {
                while (caretLine - topLineNumber + 1 >= windowLines)
                {
                    ++topLineNumber;
                }
            }
            else if (caretLine < topLineNumber)
            {
                topLineNumber = caretLine;
            }
            else
            {
                topLineNumber = Max(cast<int>(1), caretLine - 1);
            }
            int oldLeftColNumber = leftColNumber;
            if (caretColumn >= leftColNumber)
            {
                while (caretColumn - leftColNumber + 2 >= windowCols)
                {
                    ++leftColNumber;
                }
            }
            else
            {
                if (caretColumn == 1 + LineNumberFieldLength())
                {
                    leftColNumber = 1;
                }
                else
                {
                    leftColNumber = caretColumn;
                }
            }
            if (update || caretLine == 1 || topLineNumber != oldTopLineNumber || leftColNumber != oldLeftColNumber)
            {
                update = false;
                Point newOrigin(cast<int>((leftColNumber - 1) * charWidth), cast<int>((topLineNumber - 1) * charHeight));
                topLine = topLineNumber;
                topLineDiff = 0.0f;
                leftCol = leftColNumber;
                leftColDiff = 0.0f;
                SetContentLocation(newOrigin);
                SetCaretLocation();
                Invalidate();
            }
        }
        protected virtual nothrow int LineNumberFieldLength() const
        {
            return 0;
        }
        protected virtual nothrow void SetLineNumberFieldLength(int lineCount)
        {
        }
        protected override void CreateCaret()
        {
            if (charHeight != 0)
            {
                System.Windows.API.CreateCaret(Handle(), null, 1, cast<int>(charHeight));
            }
            else
            {
                base->CreateCaret();
            }
            SetTimer(1u, caretTimerPeriod);
        }
        protected override void OnTimer(TimerEventArgs& args)
        {
            base->OnTimer(args);
            if (Focused())
            {
                HideCaret();
                ShowCaret();
            }
        }
        protected override void OnClick()
        {
            base->OnClick();
            SetFocus();
        }
        protected override void SetCursor()
        {
            SetCursor(cursor);
        }
        protected override void SetCaretLocation()
        {
            int x = cast<int>(padding.left + (caretColumn - 1) * charWidth);
            int y = cast<int>(padding.top + (caretLine - 1) * charHeight);
            Point caretPos(x, y);
            TranslateContentLocation(caretPos);
            if (CaretCreated())
            {
                SetCaretPos(caretPos);
                OnCaretPosChanged();
            }
        }
        protected virtual void OnCaretPosChanged()
        {
            caretPosChangedEvent.Fire();
        }
        protected virtual void OnLinesChanged()
        {
            linesChangedEvent.Fire();
        }
        protected virtual void OnLineChanged(LineEventArgs& args)
        {
            lineChangedEvent.Fire(args);
        }
        protected virtual void OnLineDeleted(LineEventArgs& args)
        {
            lineDeletedEvent.Fire(args);
        }
        protected virtual void OnLineInserted(LineEventArgs& args)
        {
            lineInsertedEvent.Fire(args);
        }
        public nothrow inline int MaxLineLength() const
        {
            return maxLineLength;
        }
        public nothrow inline int MaxLineIndex() const
        {
            return maxLineIndex;
        }
        protected nothrow void SetMaxLineLength()
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const ustring& line = lines[i];
                if (line.Length() > maxLineLength)
                {
                    maxLineLength = cast<int>(line.Length());
                    maxLineIndex = i;
                }
            }
        }
        protected inline nothrow bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        protected inline nothrow void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed); 
        }
        protected inline nothrow void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public inline nothrow bool Painting() const
        {
            return (flags &  Flags.painting) != Flags.none;
        }
        private inline nothrow void SetPainting()
        {
            flags = cast<Flags>(flags | Flags.painting);
        }
        private inline nothrow void ResetPainting()
        {
            flags = cast<Flags>(flags & ~Flags.painting);
        }
        public nothrow inline bool IsReadOnly() const
        {
            return (flags & Flags.readOnly) != Flags.none;
        }
        public nothrow void SetReadOnly()
        {
            flags = cast<Flags>(flags | Flags.readOnly);
        }
        public nothrow void ResetReadOnly()
        {
            flags = cast<Flags>(flags & ~Flags.readOnly);
        }
        public nothrow inline bool IsFixed() const
        {
            return (flags & Flags.fixed) != Flags.none;
        }
        public nothrow void SetFixed()
        {
            flags = cast<Flags>(flags | Flags.fixed);
        }
        public nothrow void ResetFixed()
        {
            flags = cast<Flags>(flags & ~Flags.fixed);
        }
        public nothrow inline bool IsDirty() const
        {
            return (flags & Flags.dirty) != Flags.none;
        }
        public nothrow void SetDirty()
        {
            flags = cast<Flags>(flags | Flags.dirty);
        }
        public nothrow void ResetDirty()
        {
            flags = cast<Flags>(flags & ~Flags.dirty);
        }
        public nothrow Event<CaretPosChangedEventHandler>& CaretPosChangedEvent() const
        {
            return caretPosChangedEvent;
        }
        public nothrow Event<LinesChangedEventHandler>& LinesChangedEvent() const
        {
            return linesChangedEvent;
        }
        public nothrow Event<LineChangedEventHandler, LineEventArgs>& LineChangedEvent() const
        {
            return lineChangedEvent;
        }
        public nothrow Event<LineDeletedEventHandler, LineEventArgs>& LineDeletedEvent() const
        {
            return lineDeletedEvent;
        }
        public nothrow Event<LineInsertedEventHandler, LineEventArgs>& LineInsertedEvent() const
        {
            return lineInsertedEvent;
        }
        public nothrow Event<GotoCaretLineEventHandler, ControlEventArgs>& GotoCaretLineEvent() const
        {
            return gotoCaretLineEvent;
        }
        public nothrow inline const Padding& GetPadding() const
        {
            return padding;
        }
        public nothrow void SetPadding(const Padding& padding_)
        {
            if (padding != padding_)
            {
                padding = padding_;
                Invalidate();
            }
        }
        private Flags flags;
        private List<ustring> lines;
        private List<int> lineStartIndeces;
        private StringFormat drawFormat;
        private FontFamily fontFamily;
        private List<UniquePtr<Font>> fonts;
        private SolidBrush brush;
        private float fontSize;
        private float charWidth;
        private float charHeight;
        private int textWidth;
        private int textHeight;
        private int maxLineLength;
        private int maxLineIndex;
        private Cursor cursor;
        private int caretLine;
        private int caretColumn;
        private int topLine;
        private int leftCol;
        private float topLineDiff;
        private float leftColDiff;
        private uint caretTimerPeriod;
        private bool update;
        private Padding padding;
        private Event<CaretPosChangedEventHandler> caretPosChangedEvent;
        private Event<LinesChangedEventHandler> linesChangedEvent;
        private Event<LineChangedEventHandler, LineEventArgs> lineChangedEvent;
        private Event<LineDeletedEventHandler, LineEventArgs> lineDeletedEvent;
        private Event<LineInsertedEventHandler, LineEventArgs> lineInsertedEvent;
        private Event<GotoCaretLineEventHandler, ControlEventArgs> gotoCaretLineEvent;
        private string measureString;
    }

    public nothrow ustring TrimEnd(const ustring& line)
    {
        long i = line.Length();
        while (i > 0 && IsWhiteSpace(line[i - 1]))
        {
            --i;
        }
        return line.Substring(0, i);
    }

    public List<ustring> SplitTextIntoLines(const ustring& text)
    {
        List<ustring> lines;
        ustring line;
        int state = 0;
        for (uchar c : text)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            lines.Add(TrimEnd(line));
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        lines.Add(TrimEnd(line));
                        line.Clear();
                        state = 0;
                        break;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            lines.Add(TrimEnd(line));
        }
        return lines;
    }

    public List<int> CalculateLineStartIndeces(const ustring& text)
    {
        List<int> indeces;
        int state = 0;
        int n = cast<int>(text.Length());
        for (int i = 0; i < n; ++i)
        {
            uchar c = text[i];
            switch (state)
            {
                case 0:
                {
                    indeces.Add(i);
                    if (c != '\n')
                    {
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        return indeces;
    }

    internal bool ReadCaretTimeoutFromRegistry(uint& caretTimeout)
    {
        void* currentUserKey = null;
        bool openSucceeded = WinRegOpenCurrentUser(&currentUserKey);
        if (openSucceeded)
        {
            uint value = 0u;
            bool getValueSucceeded = WinRegGetDWordValue(currentUserKey, @"Control Panel\Desktop", "CaretTimeout", value);
            if (getValueSucceeded)
            {
                caretTimeout = value;
            }
            WinRegCloseKey(currentUserKey);
            return getValueSucceeded;
        }
        return false;
    }
}

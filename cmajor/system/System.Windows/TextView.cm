// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public const uint defaultCaretTimerPeriod = 5000u; // 5 seconds

    public class delegate void CaretPosChangedEventHandler();
    public class delegate void LinesChangedEventHandler();

    public class TextView : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, painting = 1 << 1
        }
        
        public TextView(const FontFamily& fontFamily_, float fontSize_, const Color& backgroundColor, const Point& location, const Size& size, Dock dock, Anchors anchors) :
            base("System.Windows.TextView", DefaultWindowClassStyle(), cast<WindowStyle>(DefaultChildWindowStyle() | WindowStyle.WS_TABSTOP), DefaultExtendedWindowStyle(), backgroundColor,
            "textView", location, size, dock, anchors), flags(Flags.none), drawFormat(StringAlignment.near, StringAlignment.near), fontFamily(fontFamily_), fontSize(fontSize_),
            charWidth(0), charHeight(0), textWidth(0), textHeight(0), maxLineLength(0), cursor(LoadStandardCursor(StandardCursorId.IDC_IBEAM)), caretLine(0), caretColumn(0),
            caretTimerPeriod(defaultCaretTimerPeriod), brush(Color.Black()), update(false), topLine(1), topLineDiff(0.0f), leftCol(1), leftColDiff(0.0f)
        {
            uint caretTimeOut = 0u;
            bool succeeded = ReadCaretTimeoutFromRegistry(caretTimeOut);
            if (succeeded)
            {
                caretTimerPeriod = caretTimeOut;
            }
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
            SetChanged();
        }
        public TextView(const Point& location, const Size& size, Dock dock, Anchors anchors) : this(FontFamily("Consolas"), 10.0f, Color.White(), location, size, dock, anchors)
        {
        }
        public nothrow inline const List<ustring>& Lines() const
        {
            return lines;
        }
        public void AddLine(const ustring& line)
        {
            lines.Add(line);
            SetMaxLineLength();
        }
        public void SetFont(const FontFamily& fontFamily_, float fontSize_)
        {
            fontFamily = fontFamily_;
            fontSize = fontSize_;
            fonts.Clear();
            OnFontChanged();
        }
        protected virtual void OnFontChanged()
        {
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
        }
        public nothrow inline float CharWidth() const
        {
            return charWidth;
        }
        public nothrow inline float CharHeight() const
        {
            return charHeight;
        }
        public nothrow inline float TextWidth() const
        {
            return textWidth;
        }
        public nothrow inline float TextHeight() const
        {
            return textHeight;
        }
        public nothrow inline FontFamily& GetFontFamily() const
        {
            return fontFamily;
        }
        public nothrow inline float FontSize() const
        {
            return fontSize;
        }
        public nothrow inline const List<UniquePtr<Font>>& Fonts() const
        {
            return fonts;
        }
        public nothrow inline List<UniquePtr<Font>>& Fonts()
        {
            return fonts;
        }
        public void SetCaretLineCol(int line, int column)
        {
            if (caretLine != line || caretColumn != column)
            {
                caretLine = line;
                caretColumn = column;
                SetCaretLocation();
            }
        }
        public nothrow inline int TopLine() const
        {
            return topLine;
        }
        public nothrow inline float TopLineDiff() const
        {
            return topLineDiff;
        }
        public nothrow inline int LeftColumn() const
        {
            return leftCol;
        }
        public nothrow inline float LeftColumnDiff() const
        {
            return leftColDiff;
        }
        public nothrow inline int CaretLine() const
        {
            return caretLine;
        }
        public nothrow inline int CaretColumn() const
        {
            return caretColumn - LineNumberFieldLength();
        }
        public void SetTopLineCol(int line, int column)
        {
            Point newOrigin(cast<int>((column - 1) * charWidth), cast<int>((line - 1) * charHeight));
            SetContentLocation(newOrigin);
            Invalidate();
        }
        public nothrow inline int GetVisibleLineCount() const
        {
            Size size = GetSize();
            return cast<int>(size.h / charHeight);
        }
        public nothrow inline int GetVisibleColumnCount() const
        {
            Size size = GetSize();
            return cast<int>(size.w / charWidth);
        }
        public nothrow inline bool IsLinePartiallyVisible(int line) const
        {
            return line >= (topLine - 1) && line < (topLine + GetVisibleLineCount() + 1);
        }
        public nothrow inline bool IsLineVisible(int line) const
        {
            return line >= topLine && line < topLine + GetVisibleLineCount();
        }
        public virtual nothrow void GetLineColumn(const Point& contentLocation, int& line, short& column) const
        {
            line = cast<int>(contentLocation.y / charHeight + 1);
            column = cast<short>(contentLocation.x / charWidth + 1);
        }
        public void SetTextContent(const ustring& textContent)
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            lines = SplitTextIntoLines(textContent);
            lineStartIndeces = CalculateLineStartIndeces(textContent);
            SetMaxLineLength();
            OnLinesChanged();
            SetContentChanged();
            SetChanged();
            SetCaretLineCol(1, 1 + LineNumberFieldLength());
            Invalidate();
            update = true;
        }
        public nothrow int GetLineLength(int lineNumber)
        {
            int lineLength = 0;
            if (lineNumber >= 1 && lineNumber <= lines.Count())
            {
                lineLength = cast<int>(lines[lineNumber - 1].Length());
            }
            return lineLength;
        }
        public nothrow bool Prev(int& line, int& col)
        {
            if (col > 1)
            {
                --col;
                return true;
            }
            else
            {
                if (line > 1)
                {
                    --line;
                    int lineLength = GetLineLength(line);
                    if (lineLength > 0)
                    {
                        col = lineLength;
                    }
                    else
                    {
                        col = 1;
                    }
                    return true;
                }
            }
            return false;
        }
        public nothrow bool Next(int& line, int& col)
        {
            int lineLength = GetLineLength(line);
            if (col < lineLength)
            {
                ++col;
                return true;
            }
            else
            {
                if (line < lines.Count())
                {
                    ++line;
                    col = 1;
                    return true;
                }
            }
            return false;
        }
        public nothrow void PrevWord(int& line, int& col)
        {
            LogView* log = Application.GetLogView();
            if (Prev(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                if (IsWhiteSpace(c))
                {
                    Next(line, col);
                }
            }
        }
        public nothrow void NextWord(int& line, int& col)
        {
            if (Next(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
            }
        }
        public nothrow uchar GetCharAt(int line, int column) const
        {
            if (line < 1)
            {
                line = 1;
            }
            else if (line > lines.Count())
            {
                line = cast<int>(lines.Count());
            }
            int lineLength = GetLineLength(line);
            if (column < 1)
            {
                column = 1;
            }
            else
            {
                if (lineLength > 0 && column > lineLength)
                {
                    column = lineLength;
                }
            }
            if (line >= 1 && line <= lines.Count() && column >= 1 && column <= lineLength)
            {
                return lines[line - 1][column - 1];
            }
            return '\0';
        }
        public void SetCaretPosByCharIndex(int charIndex)
        {
            List<int>.ConstIterator it = LowerBound(lineStartIndeces.CBegin(), lineStartIndeces.CEnd(), charIndex);
            if (it != lineStartIndeces.CBegin() && it == lineStartIndeces.CEnd())
            {
                --it;
            }
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                if (*it > charIndex)
                {
                    --it;
                }
            }
            int lineNumber = cast<int>(it - lineStartIndeces.CBegin() + 1);
            int columnNumber = 1 + LineNumberFieldLength();
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                int lineStartCharIndex = *it;
                columnNumber = charIndex - lineStartCharIndex + 1 + LineNumberFieldLength();
            }
            SetCaretLineCol(lineNumber, columnNumber);
            ScrollToCaret();
        }
        public int GetCharIndex(int line, int column) const
        {
            if (line >= 1 && line <= lineStartIndeces.Count())
            {
                int lineStartIndex = lineStartIndeces[line - 1];
                int lineLength = GetLineLength(line);
                if (column >= 1 && column <= lineLength)
                {
                    return lineStartIndex + column - 1;
                }
            }
            return -1;
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            bool prevPainting = Painting();
            SetPainting();
            try
            {
                if (Changed())
                {
                    ResetChanged();
                    Measure(args.graphics);
                    if (Focused())
                    {
                        SetCaretLocation();
                        ShowCaret();
                    }
                }
                TextRenderingHint prevRenderingHint = args.graphics.GetTextRenderingHint();
                args.graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
                args.graphics.ClearChecked(BackgroundColor());
                int n = cast<int>(lines.Count());
                SetLineNumberFieldLength(n);
                PointF origin(0, 0);
                for (int i = 0; i < n; ++i)
                {
                    if (IsLinePartiallyVisible(i + 1))
                    {
                        DrawLine(args.graphics, i, origin);
                    }
                    origin.y = origin.y + charHeight;
                }
                args.graphics.SetTextRenderingHintChecked(prevRenderingHint);
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
            if (!prevPainting)
            {
                ResetPainting();
            }
        }
        protected virtual void DrawLine(Graphics& graphics, int lineIndex, const PointF& origin)
        {
            if (!fonts.IsEmpty())
            {
                PointF pt(origin);
                const ustring& line = lines[lineIndex];
                string s(ToUtf8(line));
                graphics.DrawStringChecked(s, *fonts[0], pt, brush);
            }
        }
        protected virtual void Measure(Graphics& graphics)
        {
            charWidth = 0;
            charHeight = 0;
            if (!lines.IsEmpty() && maxLineLength > 0)
            {
                for (const UniquePtr<Font>& font : fonts)
                {
                    TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
                    graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
                    RectF charRect = graphics.MeasureStringChecked(ToUtf8(lines[maxLineIndex]), *font, PointF(0, 0), drawFormat);
                    graphics.SetTextRenderingHintChecked(prevRenderingHint);
                    charWidth = Max(charWidth, charRect.size.w / maxLineLength);
                    charHeight = Max(charHeight, charRect.size.h);
                }
            }
            SetScrollUnits(cast<int>(charHeight), cast<int>(2 * charWidth));
            textWidth = cast<int>(maxLineLength * charWidth);
            textHeight = cast<int>(lines.Count() * charHeight);
            SetContentSize(Size(textWidth, textHeight));
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            SetFocus(this);
            if (charHeight != 0 && charWidth != 0)
            {
                if (args.buttons == MouseButtons.lbutton && args.clicks == 1)
                {
                    Point loc = args.location;
                    int lineNumber = cast<int>(loc.y / charHeight + 1.5);
                    lineNumber = Min(lineNumber, cast<int>(lines.Count()));
                    int columnNumber = cast<int>(loc.x / charWidth + 1.5);
                    columnNumber = Max(columnNumber, 1 + LineNumberFieldLength());
                    int lineLength = GetLineLength(lineNumber);
                    columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                    if (update)
                    {
                        update = false;
                        Invalidate();
                    }
                    SetCaretLineCol(lineNumber, columnNumber);
                }
            }
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            base->OnKeyDown(args);
            if (!args.handled)
            {
                bool scrolled = false;
                int lineNumber = caretLine;
                int columnNumber = caretColumn;
                switch (args.keyData)
                {
                    case Keys.home:
                    {
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case Keys.end:
                    {
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case Keys.left:
                    {
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            --columnNumber;
                        }
                        else if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.right:
                    {
                        if (lineNumber <= lines.Count())
                        {
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                            }
                            else
                            {
                                ++lineNumber;
                                columnNumber = 1 + LineNumberFieldLength();
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.down:
                    {
                        if (lineNumber < lines.Count())
                        {
                            ++lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        else
                        {
                            lineNumber = cast<int>(lines.Count()) + 1;
                            columnNumber = 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.up:
                    {
                        if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.pageDown:
                    {
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber + windowLines;
                        lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        args.handled = true;
                        break;
                    }
                    case Keys.pageUp:
                    {
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber - windowLines;
                        lineNumber = Max(lineNumber, 1);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.home):
                    {
                        lineNumber = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.end):
                    {
                        lineNumber = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.left):
                    {
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.right):
                    {
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.down):
                    {
                        ScrollLineDown();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.up):
                    {
                        ScrollLineUp();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                }
                if (args.handled && !scrolled)
                {
                    SetCaretLineCol(lineNumber, columnNumber);
                    ScrollToCaret();
                }
            }
        }
        protected override nothrow void SetContentLocationInternal(const Point& contentLocation)
        {
            topLine = cast<int>(contentLocation.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - contentLocation.y;
            leftCol = cast<int>(contentLocation.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - contentLocation.x;
            base->SetContentLocationInternal(contentLocation);
        }
        public void ScrollToCaret()
        {
            if (lines.IsEmpty() || charHeight == 0) return;
            Size size = GetSize();
            int windowLines = cast<int>(size.h / charHeight);
            int windowCols = cast<int>(size.w / charWidth);
            Point currentOrigin = ContentLocation();
            int topLineNumber = cast<int>(currentOrigin.y / charHeight + 1);
            int leftColNumber = cast<int>(currentOrigin.x / charWidth + 1);
            int oldTopLineNumber = topLineNumber;
            if (caretLine > topLineNumber)
            {
                while (caretLine - topLineNumber + 1 >= windowLines)
                {
                    ++topLineNumber;
                }
            }
            else if (caretLine < topLineNumber)
            {
                topLineNumber = caretLine;
            }
            else
            {
                topLineNumber = Max(cast<int>(1), caretLine - 1);
            }
            int oldLeftColNumber = leftColNumber;
            if (caretColumn >= leftColNumber)
            {
                while (caretColumn - leftColNumber + 2 >= windowCols)
                {
                    ++leftColNumber;
                }
            }
            else
            {
                if (caretColumn == 1 + LineNumberFieldLength())
                {
                    leftColNumber = 1;
                }
                else
                {
                    leftColNumber = caretColumn;
                }
            }
            if (update || caretLine == 1 || topLineNumber != oldTopLineNumber || leftColNumber != oldLeftColNumber)
            {
                update = false;
                Point newOrigin(cast<int>((leftColNumber - 1) * charWidth), cast<int>((topLineNumber - 1) * charHeight));
                topLine = topLineNumber;
                topLineDiff = 0.0f;
                leftCol = leftColNumber;
                leftColDiff = 0.0f;
                SetContentLocation(newOrigin);
                SetCaretLocation();
                Invalidate();
            }
        }
        protected virtual nothrow int LineNumberFieldLength() const
        {
            return 0;
        }
        protected virtual nothrow void SetLineNumberFieldLength(int lineCount)
        {
        }
        protected override void CreateCaret()
        {
            if (charHeight != 0)
            {
                System.Windows.API.CreateCaret(Handle(), null, 1, cast<int>(charHeight));
            }
            else
            {
                base->CreateCaret();
            }
            SetTimer(1u, caretTimerPeriod);
        }
        protected override void OnTimer(TimerEventArgs& args)
        {
            if (Focused())
            {
                HideCaret();
                ShowCaret();
            }
        }
        protected override void OnClick()
        {
            base->OnClick();
            SetFocus();
        }
        protected override void SetCursor()
        {
            SetCursor(cursor);
        }
        protected override void SetCaretLocation()
        {
            Point caretPos(cast<int>((caretColumn - 1) * charWidth), cast<int>((caretLine - 1) * charHeight));
            TranslateContentLocation(caretPos);
            if (CaretCreated())
            {
                SetCaretPos(caretPos);
                OnCaretPosChanged();
            }
        }
        protected virtual void OnCaretPosChanged()
        {
            caretPosChangedEvent.Fire();
        }
        protected virtual void OnLinesChanged()
        {
            linesChangedEvent.Fire();
        }
        private void SetMaxLineLength()
        {
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const ustring& line = lines[i];
                if (line.Length() > maxLineLength)
                {
                    maxLineLength = cast<int>(line.Length());
                    maxLineIndex = i;
                }
            }
        }
        private inline nothrow bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        protected inline nothrow void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed); 
        }
        private inline nothrow void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public inline nothrow bool Painting() const
        {
            return (flags &  Flags.painting) != Flags.none;
        }
        private inline nothrow void SetPainting()
        {
            flags = cast<Flags>(flags | Flags.painting);
        }
        private inline nothrow void ResetPainting()
        {
            flags = cast<Flags>(flags & ~Flags.painting);
        }
        public nothrow Event<CaretPosChangedEventHandler>& CaretPosChangedEvent() const
        {
            return caretPosChangedEvent;
        }
        public nothrow Event<LinesChangedEventHandler>& LinesChangedEvent() const
        {
            return linesChangedEvent;
        }
        private Flags flags;
        private List<ustring> lines;
        private List<int> lineStartIndeces;
        private StringFormat drawFormat;
        private FontFamily fontFamily;
        private List<UniquePtr<Font>> fonts;
        private SolidBrush brush;
        private float fontSize;
        private float charWidth;
        private float charHeight;
        private int textWidth;
        private int textHeight;
        private int maxLineLength;
        private int maxLineIndex;
        private Cursor cursor;
        private int caretLine;
        private int caretColumn;
        private int topLine;
        private int leftCol;
        private float topLineDiff;
        private float leftColDiff;
        private uint caretTimerPeriod;
        private bool update;
        private Event<CaretPosChangedEventHandler> caretPosChangedEvent;
        private Event<LinesChangedEventHandler> linesChangedEvent;
    }

    public nothrow ustring TrimEnd(const ustring& line)
    {
        long i = line.Length();
        while (i > 0 && IsWhiteSpace(line[i - 1]))
        {
            --i;
        }
        return line.Substring(0, i);
    }

    public List<ustring> SplitTextIntoLines(const ustring& text)
    {
        List<ustring> lines;
        ustring line;
        int state = 0;
        for (uchar c : text)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            lines.Add(TrimEnd(line));
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        lines.Add(TrimEnd(line));
                        line.Clear();
                        state = 0;
                        break;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            lines.Add(TrimEnd(line));
        }
        return lines;
    }

    public List<int> CalculateLineStartIndeces(const ustring& text)
    {
        List<int> indeces;
        int state = 0;
        int n = cast<int>(text.Length());
        for (int i = 0; i < n; ++i)
        {
            uchar c = text[i];
            switch (state)
            {
                case 0:
                {
                    indeces.Add(i);
                    if (c != '\n')
                    {
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        return indeces;
    }

    internal bool ReadCaretTimeoutFromRegistry(uint& caretTimeout)
    {
        void* currentUserKey = null;
        bool openSucceeded = WinRegOpenCurrentUser(&currentUserKey);
        if (openSucceeded)
        {
            uint value = 0u;
            bool getValueSucceeded = WinRegGetDWordValue(currentUserKey, @"Control Panel\Desktop", "CaretTimeout", value);
            if (getValueSucceeded)
            {
                caretTimeout = value;
            }
            WinRegCloseKey(currentUserKey);
            return getValueSucceeded;
        }
        return false;
    }
}

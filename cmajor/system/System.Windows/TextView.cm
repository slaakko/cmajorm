// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;

namespace System.Windows
{
    public static class WordSeparators
    {
        static WordSeparators()
        {
            wordSeparators = u"`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
        }
        public static nothrow bool IsWordSeparatorChar(uchar c)
        {
            return wordSeparators.Find(c) != -1;
        }
        private static ustring wordSeparators;
    }

    public nothrow bool IsWordSeparator(uchar c)
    {
        return WordSeparators.IsWordSeparatorChar(c);
    }

    public static class CCStopChars
    {
        static CCStopChars()
        {
            ccStopChars = u" ,()[]{};\"'<=|&^!+/%~:";
        }
        public static nothrow bool IsCCStopChar(uchar c)
        {
            return ccStopChars.Find(c) != -1;
        }
        private static ustring ccStopChars;
    }

    public nothrow bool IsCCStopChar(uchar c)
    {
        return CCStopChars.IsCCStopChar(c);
    }
    public nothrow bool IsEmptyOrSpaceLine(const ustring& line)
    {
        if (line.IsEmpty()) return true;
        for (uchar c : line)
        {
            if (c != ' ') return false;
        }
        return true;
    }

    public nothrow System.Windows.Color DefaultTextViewSelectionBackgroundColor()
    {
        return System.Windows.Color(153u, 201u, 239u);
    }

    public class SourcePos
    {
        public nothrow SourcePos() : line(0), column(0)
        {
        }
        public nothrow SourcePos(int line_, int column_) : line(line_), column(column_)
        {
        }
        public nothrow bool IsValid() const
        {
            return line != 0 && column != 0;
        }
        public int line;
        public int column;
    }

    public nothrow bool operator==(const SourcePos& left, const SourcePos& right)
    {
        return left.line == right.line && left.column == right.column;
    }

    public nothrow bool operator<(const SourcePos& left, const SourcePos& right)
    {
        if (left.line < right.line) return true;
        if (left.line > right.line) return false;
        return left.column < right.column;
    }

    public class Selection
    {
        public enum Fix : sbyte
        {
            none, start, end
        }
        public nothrow Selection() : fixed(Fix.none), start(), end()
        {
        }
        public nothrow bool IsEmpty() const
        {
            return !start.IsValid() && !end.IsValid();
        }
        public Fix fixed;
        public SourcePos start;
        public SourcePos end;
    }

    public class SelectionData
    {
        public nothrow SelectionData() : selectedText(), indent(0), numTrailingSpaces(0)
        {
        }
        public nothrow SelectionData(const ustring& selectedText_, int indent_, int numTrailingSpaces_) : selectedText(selectedText_), indent(indent_), numTrailingSpaces(numTrailingSpaces_)
        {
        }
        public ustring selectedText;
        public int indent;
        public int numTrailingSpaces;
    }

    public const uint defaultCaretTimerPeriod = 5000u; // 5 seconds

    public class LineEventArgs
    {
        public nothrow LineEventArgs(int lineIndex_, int indentLineIndex_) : lineIndex(lineIndex_), indentLineIndex(indentLineIndex_)
        {
        }
        public int lineIndex;
        public int indentLineIndex;
    }

    public class delegate void CaretPosChangedEventHandler();
    public class delegate void LinesChangedEventHandler();
    public class delegate void LineChangedEventHandler(LineEventArgs& args);
    public class delegate void LineDeletedEventHandler(LineEventArgs& args);
    public class delegate void LineInsertedEventHandler(LineEventArgs& args);
    public class delegate void GotoCaretLineEventHandler(ControlEventArgs& args);
    public class delegate void SelectionChangedEventHandler();
    public class delegate void DirtyChangedEventHandler();
    public class delegate void CCDirtyChangedEventHandler();
    public class delegate void CCTextChangedEventHandler();
    public class delegate void CCEventHandler();
    public class delegate void CCNextEventHandler();
    public class delegate void CCPrevEventHandler();
    public class delegate void CCNextPageEventHandler();
    public class delegate void CCPrevPageEventHandler();
    public class delegate void CCSelectEventHandler();
    public class delegate void EscapePressedHandler();
    public class delegate void CopyEventHandler();
    public class delegate void CutEventHandler();
    public class delegate void PasteEventHandler();

    public nothrow ControlCreateParams& TextViewControlCreateParams(ControlCreateParams& controlCreateParams)
    {
        return controlCreateParams.SetWindowClassName("System.Windows.TextView").SetWindowClassStyle(DoubleClickWindowClassStyle()).
            SetWindowStyle(cast<WindowStyle>(DefaultChildWindowStyle() | WindowStyle.WS_TABSTOP)).
            SetWindowClassBackgroundColor(SystemColor.COLOR_WINDOW).SetBackgroundColor(Color.White());
    }

    public class TextViewCreateParams
    {
        public nothrow TextViewCreateParams(ControlCreateParams& controlCreateParams_) :
            controlCreateParams(controlCreateParams_),
            fontFamilyName("Consolas"),
            fontSize(10.0f),
            padding(),
            textColor(Color.Black()),
            selectionBackgroundColor(DefaultTextViewSelectionBackgroundColor()),
            indentSize(1)
        {
        }
        public nothrow TextViewCreateParams& Defaults()
        {
            return *this;
        }
        public nothrow TextViewCreateParams& SetFontFamilyName(const string& fontFamilyName_)
        {
            fontFamilyName = fontFamilyName_;
            return *this;
        }
        public nothrow TextViewCreateParams& SetFontSize(float fontSize_)
        {
            fontSize = fontSize_;
            return *this;
        }
        public nothrow TextViewCreateParams& SetPadding(const Padding& padding_)
        {
            padding = padding_;
            return *this;
        }
        public nothrow TextViewCreateParams& SetTextColor(const Color& textColor_)
        {
            textColor = textColor_;
            return *this;
        }
        public nothrow TextViewCreateParams& SetSelectionBackgroundColor(const Color& selectionBackgroundColor_)
        {
            selectionBackgroundColor = selectionBackgroundColor_;
            return *this;
        }
        public nothrow TextViewCreateParams& SetIndentSize(int indentSize_)
        {
            indentSize = indentSize_;
            return *this;
        }
        public ControlCreateParams& controlCreateParams;
        public string fontFamilyName;
        public float fontSize;
        public Padding padding;
        public Color textColor;
        public Color selectionBackgroundColor;
        public int indentSize;
    }

    public class TextView : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, painting = 1 << 1, readOnly = 1 << 2, fixed = 1 << 3, dirty = 1 << 4, ccdirty = 1 << 5,
            mouseExtendSelection = 1 << 6, ccOpen = 1 << 7
        }

        public TextView(const FontFamily& fontFamily_, float fontSize_, const Color& backgroundColor, const Color& textColor_, const Point& location,
            const Size& size, Dock dock, Anchors anchors) :
            base("System.Windows.TextView", DoubleClickWindowClassStyle(),
                cast<WindowStyle>(DefaultChildWindowStyle() | WindowStyle.WS_TABSTOP), DefaultExtendedWindowStyle(), backgroundColor,
            "textView", location, size, dock, anchors), flags(Flags.none), drawFormat(StringAlignment.near, StringAlignment.near),
            fontFamily(fontFamily_), fontSize(fontSize_),
            charWidth(0), charHeight(0), textWidth(0), textHeight(0), maxLineLength(0), cursor(LoadStandardCursor(StandardCursorId.IDC_IBEAM)),
            caretLine(1), caretColumn(1),
            caretTimerPeriod(defaultCaretTimerPeriod), update(false), topLine(1), topLineDiff(0.0f), leftCol(1), leftColDiff(0.0f),
            padding(), selectionBackgroundColor(DefaultTextViewSelectionBackgroundColor()), textColor(textColor_), editCommandList(this), selection(),
            indentSize(1)
        {
            Init();
        }
        public TextView(const Point& location, const Size& size, Dock dock, Anchors anchors) :
            this(FontFamily("Consolas"), 10.0f, Color.White(), Color.Black(), location, size, dock, anchors)
        {
        }
        public TextView(TextViewCreateParams& createParams) :
            base(createParams.controlCreateParams),
            flags(Flags.none),
            drawFormat(StringAlignment.near, StringAlignment.near),
            fontFamily(createParams.fontFamilyName),
            fontSize(createParams.fontSize),
            charWidth(0), charHeight(0), textWidth(0), textHeight(0), maxLineLength(0), cursor(LoadStandardCursor(StandardCursorId.IDC_IBEAM)),
            caretLine(1), caretColumn(1),
            caretTimerPeriod(defaultCaretTimerPeriod), update(false), topLine(1), topLineDiff(0.0f), leftCol(1), leftColDiff(0.0f),
            padding(createParams.padding), selectionBackgroundColor(createParams.selectionBackgroundColor), textColor(createParams.textColor),
            editCommandList(this), selection(), indentSize(createParams.indentSize)
        {
            Init();
        }
        private void Init()
        {
            uint caretTimeOut = 0u;
            bool succeeded = ReadCaretTimeoutFromRegistry(caretTimeOut);
            if (succeeded)
            {
                caretTimerPeriod = caretTimeOut;
            }
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
            SetChanged();
            measureString = "// this file has been semiautomatically generated from 'D:/work/soulng-project/sngcm/ast/AstReader.hpp' using cpp2cm version 1.0.0";
        }
        public nothrow const System.Windows.Color& GetTextColor() const
        {
            return textColor;
        }
        public nothrow void SetTextColor(const System.Windows.Color& textColor_)
        {
            textColor = textColor_;
        }
        public nothrow const System.Windows.Color& GetSelectionBackgroundColor() const
        {
            return selectionBackgroundColor;
        }
        public nothrow void SetSelectionBackgroundColor(const System.Windows.Color& selectionBackgroundColor_)
        {
            selectionBackgroundColor = selectionBackgroundColor_;
        }
        public nothrow inline List<ustring>& Lines()
        {
            return lines;
        }
        public nothrow inline const List<ustring>& Lines() const
        {
            return lines;
        }
        public void AddLine(const ustring& line)
        {
            lines.Add(line);
            SetMaxLineLength();
        }
        public void SetFont(const FontFamily& fontFamily_, float fontSize_)
        {
            fontFamily = fontFamily_;
            fontSize = fontSize_;
            fonts.Clear();
            OnFontChanged();
            SetChanged();
        }
        protected virtual void OnFontChanged()
        {
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
        }
        public nothrow void SetUndoRedoMenuItems(MenuItem* undoMenuItem, MenuItem* redoMenuItem)
        {
            editCommandList.SetMenuItems(undoMenuItem, redoMenuItem);
        }
        public nothrow void Select()
        {
            editCommandList.UpdateMenuItems();
        }
        public nothrow void Undo()
        {
            editCommandList.Undo();
        }
        public nothrow void Redo()
        {
            editCommandList.Redo();
        }
        public nothrow inline float CharWidth() const
        {
            return charWidth;
        }
        public nothrow inline float CharHeight() const
        {
            return charHeight;
        }
        public nothrow inline int TextWidth() const
        {
            return textWidth;
        }
        public nothrow inline int TextHeight() const
        {
            return textHeight;
        }
        public nothrow inline FontFamily& GetFontFamily() const
        {
            return fontFamily;
        }
        public nothrow inline float FontSize() const
        {
            return fontSize;
        }
        public nothrow inline const List<UniquePtr<Font>>& Fonts() const
        {
            return fonts;
        }
        public nothrow inline List<UniquePtr<Font>>& Fonts()
        {
            return fonts;
        }
        public void SetCaretLineCol(int line, int column)
        {
            if (caretLine != line || caretColumn != column)
            {
                caretLine = line;
                caretColumn = column;
                SetCaretLocation();
            }
        }
        public nothrow Point CaretPos() const
        {
            int x = cast<int>(padding.left + (caretColumn - 1) * charWidth);
            int y = cast<int>(padding.top + (caretLine - 1) * charHeight);
            Point loc(x, y);
            TranslateContentLocation(loc);
            return loc;
        }
        public nothrow Point CCPos() const
        {
            Point ccPos = CaretPos();
            ccPos.Offset(0, cast<int>(charHeight + 0.5));
            return ccPos;
        }
        public nothrow inline int TopLine() const
        {
            return topLine;
        }
        public nothrow inline float TopLineDiff() const
        {
            return topLineDiff;
        }
        public nothrow inline int LeftColumn() const
        {
            return leftCol;
        }
        public nothrow inline float LeftColumnDiff() const
        {
            return leftColDiff;
        }
        public nothrow inline int CaretLine() const
        {
            return caretLine;
        }
        public nothrow inline int CaretColumn() const
        {
            return caretColumn - LineNumberFieldLength();
        }
        public void SetTopLineCol(int line, int column)
        {
            Point newOrigin(cast<int>((column - 1) * charWidth), cast<int>((line - 1) * charHeight));
            topLine = cast<int>(newOrigin.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - newOrigin.y;
            leftCol = cast<int>(newOrigin.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - newOrigin.x;
            SetContentLocation(newOrigin);
            Invalidate();
        }
        public nothrow inline int GetVisibleLineCount() const
        {
            Size size = GetSize();
            return cast<int>(size.h / charHeight);
        }
        public nothrow inline int GetVisibleColumnCount() const
        {
            Size size = GetSize();
            return cast<int>(size.w / charWidth);
        }
        public nothrow inline bool IsLinePartiallyVisible(int line) const
        {
            return line >= (topLine - 1) && line < (topLine + GetVisibleLineCount() + 1);
        }
        public nothrow inline bool IsLineVisible(int line) const
        {
            return line >= topLine && line < topLine + GetVisibleLineCount();
        }
        public nothrow void GetLineColumn(const Point& contentLocation, int& line, int& column) const
        {
            line = cast<int>(contentLocation.y / charHeight + 1);
            column = cast<int>(contentLocation.x / charWidth + 1) - LineNumberFieldLength();
        }
        public void EnsureLineVisible(int line)
        {
            Invalidate();
            Application.ProcessMessages();
            if (IsLineVisible(line))
            {
                return;
            }
            int tl = Max(cast<int>(1), line - GetVisibleLineCount() / 2);
            SetTopLineCol(tl, 1);
        }
        public virtual void Clear()
        {
            ustring emptyContent;
            SetTextContent(emptyContent);
        }
        public void SetTextContent(const ustring& textContent)
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            lines = SplitTextIntoLines(textContent);
            lineStartIndeces = CalculateLineStartIndeces(textContent);
            SetMaxLineLength();
            OnLinesChanged();
            SetContentChanged();
            SetChanged();
            SetCaretLineCol(1, 1 + LineNumberFieldLength());
            OnContentLocationChanged();
            Invalidate();
            update = true;
        }
        public nothrow int GetLineLength(int lineNumber)
        {
            int lineLength = 0;
            if (lineNumber >= 1 && lineNumber <= lines.Count())
            {
                lineLength = cast<int>(lines[lineNumber - 1].Length());
            }
            return lineLength;
        }
        public nothrow bool Prev(int& line, int& col)
        {
            if (col > 1)
            {
                --col;
                return true;
            }
            else
            {
                if (line > 1)
                {
                    --line;
                    int lineLength = GetLineLength(line);
                    if (lineLength > 0)
                    {
                        col = lineLength;
                    }
                    else
                    {
                        col = 1;
                    }
                    return true;
                }
            }
            return false;
        }
        public nothrow bool Next(int& line, int& col)
        {
            int lineLength = GetLineLength(line);
            if (col < lineLength)
            {
                ++col;
                return true;
            }
            else
            {
                if (line < lines.Count())
                {
                    ++line;
                    col = 1;
                    return true;
                }
            }
            return false;
        }
        public nothrow void PrevWord(int& line, int& col)
        {
            if (Prev(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (IsWhiteSpace(c) || IsWordSeparator(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (!IsWhiteSpace(c) && !IsWordSeparator(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                if (IsWhiteSpace(c) || IsWordSeparator(c))
                {
                    Next(line, col);
                }
            }
        }
        public nothrow void NextWord(int& line, int& col)
        {
            if (Next(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (!IsWhiteSpace(c) && !IsWordSeparator(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
            }
        }
        private nothrow void GotoCaretLine()
        {
            ControlEventArgs args(this);
            OnGotoCaretLine(args);
        }
        protected virtual void OnGotoCaretLine(ControlEventArgs& args)
        {
            gotoCaretLineEvent.Fire(args);
        }
        public nothrow uchar GetCharAt(int line, int column) const
        {
            if (line < 1)
            {
                line = 1;
            }
            else if (line > lines.Count())
            {
                line = cast<int>(lines.Count());
            }
            int lineLength = GetLineLength(line);
            if (column < 1)
            {
                column = 1;
            }
            else
            {
                if (lineLength > 0 && column > lineLength)
                {
                    column = lineLength;
                }
            }
            if (line >= 1 && line <= lines.Count() && column >= 1 && column <= lineLength)
            {
                return lines[line - 1][column - 1];
            }
            return '\0';
        }
        public void SetCaretPosByCharIndex(int charIndex)
        {
            List<int>.ConstIterator it = LowerBound(lineStartIndeces.CBegin(), lineStartIndeces.CEnd(), charIndex);
            if (it != lineStartIndeces.CBegin() && it == lineStartIndeces.CEnd())
            {
                --it;
            }
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                if (*it > charIndex)
                {
                    --it;
                }
            }
            int lineNumber = cast<int>(it - lineStartIndeces.CBegin() + 1);
            int columnNumber = 1 + LineNumberFieldLength();
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                int lineStartCharIndex = *it;
                columnNumber = charIndex - lineStartCharIndex + 1 + LineNumberFieldLength();
            }
            SetCaretLineCol(lineNumber, columnNumber);
            ScrollToCaret();
        }
        public int GetCharIndex(int line, int column) const
        {
            if (line >= 1 && line <= lineStartIndeces.Count())
            {
                int lineStartIndex = lineStartIndeces[line - 1];
                int lineLength = GetLineLength(line);
                if (column >= 1 && column <= lineLength)
                {
                    return lineStartIndex + column - 1;
                }
            }
            return -1;
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                PaintContent(args.graphics, args.clipRect);
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected virtual void PaintContent(Graphics& graphics, const Rect& clipRect)
        {
            if (Changed())
            {
                ResetChanged();
                Measure(graphics);
                if (Focused())
                {
                    SetCaretLocation();
                    ShowCaret();
                }
                OnContentLocationChanged();
            }
            TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
            graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
            graphics.ClearChecked(BackgroundColor());
            int n = cast<int>(lines.Count());
            SetLineNumberFieldLength(n);
            int lineNumberFieldLength = LineNumberFieldLength();
            PointF origin(0, 0);
            Size size = GetSize();
            for (int i = 0; i < n; ++i)
            {
                if (IsLinePartiallyVisible(i + 1))
                {
                    DrawSelectionBackground(graphics, i + 1, origin, lineNumberFieldLength);
                    DrawLine(graphics, i, origin);
                }
                origin.y = origin.y + charHeight;
            }
            graphics.SetTextRenderingHintChecked(prevRenderingHint);
        }
        private void DrawSelectionBackground(Graphics& graphics, int line, const PointF& origin, int lineNumberFieldLength)
        {
            if (selection.IsEmpty()) return;
            if (line < selection.start.line) return;
            if (line > selection.end.line) return;
            PointF pt(origin);
            pt.x = pt.x + charWidth * lineNumberFieldLength;
            RectF rect;
            if (line > selection.start.line && line < selection.end.line)
            {
                int lineLength = Max(1, GetLineLength(line));
                rect = RectF(pt, SizeF(charWidth * lineLength, charHeight));
            }
            else if (selection.start.line == selection.end.line)
            {
                pt.x = pt.x + charWidth * (selection.start.column - 1);
                int selectionLength = selection.end.column - selection.start.column;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            else if (line == selection.start.line)
            {
                pt.x = pt.x + charWidth * (selection.start.column - 1);
                int lineLength = GetLineLength(line);
                int selectionLength = lineLength - selection.start.column + 1;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            else if (line == selection.end.line)
            {
                int selectionLength = selection.end.column - 1;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            Brush* brush = GetOrInsertBrush(selectionBackgroundColor);
            graphics.FillRectangleChecked(*brush, rect);
        }
        protected virtual void DrawLine(Graphics& graphics, int lineIndex, const PointF& origin)
        {
            if (!fonts.IsEmpty())
            {
                PointF pt(origin);
                const ustring& line = lines[lineIndex];
                string s(ToUtf8(line));
                Brush* brush = GetOrInsertBrush(textColor);
                graphics.DrawStringChecked(s, *fonts[0], pt, *brush);
            }
        }
        protected virtual void Measure(Graphics& graphics)
        {
            charWidth = 0;
            charHeight = 0;
            string ms;
            bool measure = false;
            if (IsFixed())
            {
                ms = measureString;
                maxLineLength = cast<int>(ToUtf32(measureString).Length());
                measure = true;
            }
            else
            {
                if (!lines.IsEmpty() && maxLineLength > 0)
                {
                    ms = ToUtf8(lines[maxLineIndex]);
                    measure = true;
                }
            }
            if (measure)
            {
                for (const UniquePtr<Font>& font : fonts)
                {
                    TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
                    graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
                    RectF charRect = graphics.MeasureStringChecked(ms, *font, PointF(0, 0), drawFormat);
                    graphics.SetTextRenderingHintChecked(prevRenderingHint);
                    charWidth = Max(charWidth, charRect.size.w / maxLineLength);
                    charHeight = Max(charHeight, charRect.size.h);
                }
            }
            SetScrollUnits(cast<int>(charHeight + 0.5), cast<int>(2 * (charWidth + 0.5)));
            SetTextExtent();
        }
        public void SetTextExtent()
        {
            textWidth = cast<int>(maxLineLength * charWidth);
            textHeight = cast<int>(lines.Count() * charHeight);
            SetContentSize(Size(textWidth, textHeight));
        }
        private nothrow void FixColumn(int& column, int line)
        {
            if (column < 1) column = 1;
            int n = GetLineLength(line);
            if (column > n + 1)
            {
                column = n + 1;
            }
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            SetFocus(this);
            ResetSelection();
            if (args.buttons == MouseButtons.lbutton && !lines.IsEmpty())
            {
                int line = 0;
                int column = 0;
                GetLineColumn(args.location, line, column);
                if (line >= 1 && line <= lines.Count())
                {
                    FixColumn(column, line);
                    mouseSelectionStart = SourcePos(line, column);
                    SetMouseExtendSelection();
                }
            }
            if (charHeight != 0 && charWidth != 0)
            {
                if ((args.buttons == MouseButtons.lbutton || args.buttons == MouseButtons.rbutton) && args.clicks == 1)
                {
                    Point loc = args.location;
                    int lineNumber = cast<int>(loc.y / charHeight) + 1;
                    lineNumber = Max(1, Min(lineNumber, cast<int>(lines.Count())));
                    int columnNumber = cast<int>(loc.x / charWidth) + 1;
                    columnNumber = Max(columnNumber, 1 + LineNumberFieldLength());
                    int lineLength = GetLineLength(lineNumber);
                    columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                    if (update)
                    {
                        update = false;
                        Invalidate();
                    }
                    SetCaretLineCol(lineNumber, columnNumber);
                    if (args.buttons == MouseButtons.rbutton)
                    {
                        RightClickEventArgs rightClickArgs(this, loc);
                        OnRightClick(rightClickArgs);
                    }
                }
            }
        }
        protected override void OnMouseMove(MouseEventArgs& args)
        {
            base->OnMouseMove(args);
            if (MouseExtendSelection())
            {
                int line = 0;
                int column = 0;
                GetLineColumn(args.location, line, column);
                if (line >= 1 && line <= lines.Count())
                {
                    FixColumn(column, line);
                    mouseSelectionEnd = SourcePos(line, column);
                    if (mouseSelectionStart != mouseSelectionEnd)
                    {
                        ExtendSelection(mouseSelectionStart, mouseSelectionEnd);
                        InvalidateLines(selection.start.line, selection.end.line);
                    }
                }
            }
        }
        protected override void OnMouseUp(MouseEventArgs& args)
        {
            base->OnMouseUp(args);
            if (MouseExtendSelection())
            {
                ResetMouseExtendSelection();
                int line = 0;
                int column = 0;
                GetLineColumn(args.location, line, column);
                if (line >= 1 && line <= lines.Count())
                {
                    FixColumn(column, line);
                    mouseSelectionEnd = SourcePos(line, column);
                    if (mouseSelectionStart != mouseSelectionEnd)
                    {
                        ExtendSelection(mouseSelectionStart, mouseSelectionEnd);
                        InvalidateLines(selection.start.line, selection.end.line);
                    }
                }
            }
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            base->OnKeyDown(args);
            if (!args.handled)
            {
                bool scrolled = false;
                int lineNumber = caretLine;
                int columnNumber = caretColumn;
                switch (args.key)
                {
                    case Keys.escape:
                    {
                        OnEscape();
                        args.handled = true;
                        break;
                    }
                    case Keys.home:
                    {
                        ResetSelection();
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.home):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(CaretLine(), 1);
                        ExtendSelection(start, end);
                        columnNumber = 1 + LineNumberFieldLength();
                        InvalidateLineCol(CaretLine(), columnNumber);
                        args.handled = true;
                        break;
                    }
                    case Keys.end:
                    {
                        ResetSelection();
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.end):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(CaretLine(), GetLineLength(lineNumber) + 1);
                        ExtendSelection(start, end);
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        InvalidateLineCol(CaretLine(), 1 + LineNumberFieldLength());
                        args.handled = true;
                        break;
                    }
                    case Keys.left:
                    {
                        ResetSelection();
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            --columnNumber;
                        }
                        else if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.left):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            SourcePos end(start);
                            --columnNumber;
                            --end.column;
                            ExtendSelection(start, end);
                            InvalidateLines(selection.start.line, selection.end.line);
                        }
                        else if (lineNumber > 1)
                        {
                            SourcePos end(start);
                            --lineNumber;
                            --end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                            end.column = lineLength + 1;
                            ExtendSelection(start, end);
                            InvalidateLines(selection.start.line, selection.end.line);
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.right:
                    {
                        ResetSelection();
                        if (lineNumber <= lines.Count())
                        {
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                            }
                            else
                            {
                                ++lineNumber;
                                columnNumber = 1 + LineNumberFieldLength();
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.right):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        if (lineNumber <= lines.Count())
                        {
                            SourcePos end(start);
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                                ++end.column;
                                ExtendSelection(start, end);
                            }
                            else
                            {
                                ++lineNumber;
                                ++end.line;
                                columnNumber = 1 + LineNumberFieldLength();
                                end.column = 1;
                                ExtendSelection(start, end);
                            }
                            InvalidateLines(selection.start.line, selection.end.line);
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.down:
                    {
                        if (CCOpen())
                        {
                            OnCCNext();
                        }
                        else
                        {
                            ResetSelection();
                            if (lineNumber < lines.Count())
                            {
                                ++lineNumber;
                                int lineLength = GetLineLength(lineNumber);
                                columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            }
                            else
                            {
                                lineNumber = cast<int>(lines.Count()) + 1;
                                columnNumber = 1 + LineNumberFieldLength();
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.down):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        if (lineNumber < lines.Count())
                        {
                            ++lineNumber;
                            ++end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            end.column = Min(end.column, lineLength + 1);
                        }
                        else
                        {
                            lineNumber = cast<int>(lines.Count()) + 1;
                            end.line = cast<int>(lines.Count()) + 1;
                            columnNumber = 1 + LineNumberFieldLength();
                            end.column = 1;
                        }
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case Keys.up:
                    {
                        if (CCOpen())
                        {
                            OnCCPrev();
                        }
                        else
                        {
                            ResetSelection();
                            if (lineNumber > 1)
                            {
                                --lineNumber;
                                int lineLength = GetLineLength(lineNumber);
                                columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.up):
                    {
                        if (lineNumber > 1)
                        {
                            SourcePos start(CaretLine(), CaretColumn());
                            SourcePos end(start);
                            --lineNumber;
                            --end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            end.column = Min(end.column, lineLength + 1);
                            ExtendSelection(start, end);
                            InvalidateLines(selection.start.line, selection.end.line);
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.pageDown:
                    {
                        if (CCOpen())
                        {
                            OnCCNextPage();
                        }
                        else
                        {
                            ResetSelection();
                            Size size = GetSize();
                            int windowLines = cast<int>(size.h / charHeight);
                            lineNumber = lineNumber + windowLines;
                            lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.pageDown):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber + windowLines;
                        end.line = end.line + windowLines;
                        lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        end.line = Min(end.line, cast<int>(lines.Count()) + 1);
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case Keys.pageUp:
                    {
                        if (CCOpen())
                        {
                            OnCCPrevPage();
                        }
                        else
                        {
                            ResetSelection();
                            Size size = GetSize();
                            int windowLines = cast<int>(size.h / charHeight);
                            lineNumber = lineNumber - windowLines;
                            lineNumber = Max(lineNumber, 1);
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.pageUp):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber - windowLines;
                        end.line = end.line - windowLines;
                        lineNumber = Max(lineNumber, 1);
                        end.line = Max(end.line, 1);
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.a):
                    {
                        ResetSelection();
                        SourcePos start(1, 1);
                        SourcePos end(cast<int>(lines.Count() + 1), 1);
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.home):
                    {
                        ResetSelection();
                        lineNumber = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.home):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        lineNumber = 1;
                        end.line = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        end.column = 1;
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.end):
                    {
                        ResetSelection();
                        lineNumber = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.end):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        lineNumber = cast<int>(lines.Count() + 1);
                        end.line = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        end.column = 1;
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.left):
                    {
                        ResetSelection();
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.left):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        end.line = line;
                        columnNumber = col + LineNumberFieldLength();
                        end.column = col;
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.right):
                    {
                        ResetSelection();
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.right):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        end.line = line;
                        columnNumber = col + LineNumberFieldLength();
                        end.column = col;
                        ExtendSelection(start, end);
                        InvalidateLines(selection.start.line, selection.end.line);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.down):
                    {
                        if (lines.Count() < GetVisibleLineCount())
                        {
                            args.handled = true;
                            return;
                        }
                        ResetSelection();
                        ScrollLineDown();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.up):
                    {
                        if (lines.Count() < GetVisibleLineCount())
                        {
                            args.handled = true;
                            return;
                        }
                        ResetSelection();
                        ScrollLineUp();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.k):
                    {
                        ResetSelection();
                        GotoCaretLine();
                        args.handled = true;
                        break;
                    }
                    case Keys.delete_:
                    {
                        if (!IsReadOnly())
                        {
                            if (selection.IsEmpty())
                            {
                                int lineIndex = caretLine - 1;
                                int columnIndex = CaretColumn() - 1;
                                AddDeleteCharCommand(lineIndex, columnIndex);
                                DeleteChar(lineIndex, columnIndex, 0, 0, false);
                            }
                            else
                            {
                                AddRemoveSelectionCommand();
                                RemoveSelection();
                            }
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.back:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            Backspace(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.enter:
                    {
                        if (CCOpen())
                        {
                            OnCCSelect();
                            args.handled = true;
                            return;
                        }
                        else
                        {
                            if (!IsReadOnly())
                            {
                                ResetSelection();
                                int lineIndex = caretLine - 1;
                                int columnIndex = CaretColumn() - 1;
                                AddNewLineCommand(lineIndex, columnIndex);
                                NewLine(lineIndex, columnIndex);
                                args.handled = true;
                                return;
                            }
                        }
                        break;
                    }
                    case Keys.tab:
                    {
                        if (!IsReadOnly())
                        {
                            if (selection.IsEmpty())
                            {
                                int lineIndex = caretLine - 1;
                                int columnIndex = CaretColumn() - 1;
                                AddTabCommand(lineIndex, columnIndex);
                                Tab(lineIndex, columnIndex);
                            }
                            else
                            {
                                AddIndentSelectionCommand();
                                IndentSelection();
                            }
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.tab):
                    {
                        if (!IsReadOnly())
                        {
                            if (selection.IsEmpty())
                            {
                                int lineIndex = caretLine - 1;
                                int columnIndex = CaretColumn() - 1;
                                AddBacktabCommand(lineIndex, columnIndex);
                                Backtab(lineIndex, columnIndex);
                            }
                            else
                            {
                                AddUnindentSelectionCommand();
                                UnindentSelection();
                            }
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.insert):
                    {
                        if (!selection.IsEmpty())
                        {
                            OnCopy();
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.insert):
                    {
                        OnPaste();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.delete_):
                    {
                        if (!selection.IsEmpty())
                        {
                            OnCut();
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.altModifier | Keys.back):
                    {
                        Undo();
                        break;
                    }
                    case Keys.f4:
                    {
                        Redo();
                        break;
                    }
                }
                if (args.handled && !scrolled)
                {
                    SetCaretLineCol(lineNumber, columnNumber);
                    ScrollToCaret();
                }
            }
        }
        protected override void OnKeyPress(KeyPressEventArgs& args)
        {
            base->OnKeyPress(args);
            if (IsReadOnly()) return;
            if (!args.handled && WinKeyPressed(VK_CONTROL) && args.keyChar == ' ')
            {
                OnCC();
                args.handled = true;
                return;
            }
            if (!WinKeyPressed(VK_MENU) && WinKeyPressed(VK_CONTROL))
            {
                return;
            }
            if (!args.handled)
            {
                editCommandList.BeginGroup();
                if (!selection.IsEmpty())
                {
                    AddRemoveSelectionCommand();
                    RemoveSelection();
                }
                uchar c(args.keyChar);
                int lineIndex = caretLine - 1;
                int columnIndex = CaretColumn() - 1;
                AddInsertCharCommand(lineIndex, columnIndex, c);
                InsertChar(lineIndex, columnIndex, c);
                editCommandList.EndGroup();
                args.handled = true;
            }
        }
        protected virtual void OnEscape()
        {
            escapePressedEvent.Fire();
        }
        protected virtual void OnCCNext()
        {
            ccNextEvent.Fire();
        }
        protected virtual void OnCCPrev()
        {
            ccPrevEvent.Fire();
        }
        protected virtual void OnCCNextPage()
        {
            ccNextPageEvent.Fire();
        }
        protected virtual void OnCCPrevPage()
        {
            ccPrevPageEvent.Fire();
        }
        protected virtual void OnCCSelect()
        {
            ccSelectEvent.Fire();
        }
        private nothrow void AddInsertCharCommand(int lineIndex, int columnIndex, uchar c)
        {
            bool removeIndent = false;
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            if (c == '}' && line.StartsWith(ustring(' ', IndentSize())))
            {
                removeIndent = true;
            }
            editCommandList.AddCommand(new InsertCharCommand(lineIndex, columnIndex, c, removeIndent));
        }
        public void InsertChar(int lineIndex, int columnIndex, uchar c)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex, c);
            if (c == '}' && line.StartsWith(ustring(' ', IndentSize())))
            {
                line.Remove(0, IndentSize());
                columnIndex = columnIndex - IndentSize();
            }
            if (line.Length() > maxLineLength)
            {
                maxLineLength = cast<int>(line.Length());
                maxLineIndex = lineIndex;
                SetTextExtent();
            }
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength());
            KeyEventArgs rightArgs(Keys.right);
            OnKeyDown(rightArgs);
            SetCCText(line, columnIndex);
            SetDirty();
            SetCCDirty();
        }
        public void InsertText(int lineIndex, int columnIndex, const ustring& text)
        {
            if (text.IsEmpty()) return;
            editCommandList.BeginGroup();
            if (!selection.IsEmpty())
            {
                lineIndex = selection.start.line - 1;
                columnIndex = selection.start.column - 1;
                AddRemoveSelectionCommand();
                RemoveSelection();
            }
            List<ustring> linesToInsert = SplitTextIntoLines(text);
            if (linesToInsert.Count() == 1 && !IsEmptyOrSpaceLine(lines[lineIndex]))
            {
                AddInsertIntoLineCommand(lineIndex, columnIndex, linesToInsert.Front());
                InsertIntoLine(lineIndex, columnIndex, linesToInsert.Front());
            }
            else
            {
                AddInsertLinesCommand(lineIndex, columnIndex, linesToInsert);
                InsertLines(lineIndex, columnIndex, linesToInsert);
            }
            editCommandList.EndGroup();
        }
        public nothrow void AddInsertIntoLineCommand(int lineIndex, int columnIndex, const ustring& text)
        {
            editCommandList.AddCommand(new InsertIntoLineCommand(lineIndex, columnIndex, text));
        }
        public nothrow void InsertIntoLine(int lineIndex, int columnIndex, const ustring& text)
        {
            lines[lineIndex].Insert(columnIndex, text);
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetTextExtent();
            SetCaretLineCol(lineIndex + 1, 1 + LineNumberFieldLength() + columnIndex + cast<int>(text.Length()));
            ScrollToCaret();
            Invalidate();
            InvalidateLines(lineIndex + 1, lineIndex + 1);
            SetDirty();
            SetCCDirty();
        }
        public nothrow void RemoveFromLine(int lineIndex, int columnIndex, long count)
        {
            lines[lineIndex].Remove(columnIndex, count);
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetTextExtent();
            SetCaretLineCol(lineIndex + 1, 1 + LineNumberFieldLength() + columnIndex);
            ScrollToCaret();
            Invalidate();
            InvalidateLines(lineIndex + 1, lineIndex + 1);
            SetDirty();
            SetCCDirty();
        }
        public nothrow void AddInsertLinesCommand(int lineIndex, int columnIndex, const List<ustring>& linesToInsert)
        {
            editCommandList.AddCommand(new InsertLinesCommand(lineIndex, columnIndex, linesToInsert));
        }
        public nothrow void InsertLines(int lineIndex, int columnIndex, const List<ustring>& linesToInsert)
        {
            int indent = 0;
            if (lineIndex > 0 && lineIndex < lines.Count())
            {
                indent = GetIndent(lines[lineIndex - 1], lineIndex - 1);
            }
            int indentLineIndex = lineIndex - 1;
            for (const ustring& lineToInsert : linesToInsert)
            {
                lines.Insert(lines.Begin() + lineIndex, lineToInsert);
                SetLineNumberFieldLength(cast<int>(lines.Count()));
                LineEventArgs insertedArgs(lineIndex, indentLineIndex);
                OnLineInserted(insertedArgs);
                ++lineIndex;
            }
            bool lineDeleted = false;
            if (lineIndex < lines.Count())
            {
                if (IsEmptyOrSpaceLine(lines[lineIndex]))
                {
                    lines.Remove(lines.Begin() + lineIndex);
                    LineEventArgs args(lineIndex, -1);
                    OnLineDeleted(args);
                    lineDeleted = true;
                }
            }
            SetTextExtent();
            if (lineDeleted)
            {
                SetCaretLineCol(lineIndex, 1 + LineNumberFieldLength() + cast<int>(lines[lineIndex - 1].Length()));
            }
            else
            {
                SetCaretLineCol(lineIndex, 1 + LineNumberFieldLength() + indent);
            }
            ScrollToCaret();
            Invalidate();
            InvalidateLines(lineIndex + 1, cast<int>(lineIndex + linesToInsert.Count() + 1));
            SetDirty();
            SetCCDirty();
        }
        public nothrow void DeleteLines(int lineIndex, int columnIndex, const List<ustring>& linesToDelete)
        {
            if (linesToDelete.Count() == 1)
            {
                ustring& line = lines[lineIndex];
                line.Remove(columnIndex, linesToDelete.Front().Length());
                LineEventArgs args(lineIndex, -1);
                OnLineChanged(args);
            }
            else
            {
                for (int i = 0; i < linesToDelete.Count(); ++i)
                {
                    lines.Remove(lines.Begin() + lineIndex);
                    LineEventArgs deleteArgs(lineIndex, -1);
                    OnLineDeleted(deleteArgs);
                }
            }
            SetTextExtent();
            SetLineNumberFieldLength(cast<int>(lines.Count()));
            SetCaretLineCol(lineIndex, 1 + LineNumberFieldLength());
            ScrollToCaret();
            Invalidate();
            SetDirty();
            SetCCDirty();
        }
        private nothrow void AddDeleteCharCommand(int lineIndex, int columnIndex)
        {
            if (lineIndex >= lines.Count()) return;
            ustring& line = lines[lineIndex];
            if (columnIndex < line.Length())
            {
                uchar c = line[columnIndex];
                editCommandList.AddCommand(new DeleteCharCommand(lineIndex, columnIndex, c));
            }
            else
            {
                if (lines.Count() > lineIndex + 1)
                {
                    editCommandList.AddCommand(new DeleteCharCommand(lineIndex, columnIndex, '\0'));
                }
            }
        }
        public void DeleteChar(int lineIndex, int columnIndex, int indent, int numSpaces, bool removeIndent)
        {
            if (lineIndex >= lines.Count()) return;
            ustring& line = lines[lineIndex];
            if (removeIndent)
            {
                line.Insert(0, ustring(' ', IndentSize()));
            }
            if (columnIndex < line.Length())
            {
                line.Remove(columnIndex, 1);
                LineEventArgs args(lineIndex, -1);
                OnLineChanged(args);
                SetCCText(line, columnIndex);
            }
            else
            {
                if (lines.Count() > lineIndex + 1)
                {
                    if (numSpaces > 0)
                    {
                        line.Append(ustring(' ', numSpaces));
                    }
                    ustring nextLine = lines[lineIndex + 1];
                    line.Append(nextLine.Substring(indent));
                    LineEventArgs changedArgs(lineIndex, -1);
                    OnLineChanged(changedArgs);
                    lines.Remove(lines.Begin() + lineIndex + 1);
                    LineEventArgs deletedArgs(lineIndex + 1, -1);
                    OnLineDeleted(deletedArgs);
                    SetTextExtent();
                    ResetCCText();
                }
            }
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength());
            SetDirty();
            SetCCDirty();
        }
        private void Backspace(int lineIndex, int columnIndex)
        {
            if (lineIndex != 0 || columnIndex != 0)
            {
                KeyEventArgs leftArgs(Keys.left);
                OnKeyDown(leftArgs);
                KeyEventArgs deleteArgs(Keys.delete_);
                OnKeyDown(deleteArgs);
            }
        }
        protected virtual nothrow int GetIndent(const ustring& line, int lineIndex)
        {
            for (int i = 0; i < line.Length(); ++i)
            {
                if (line[i] != ' ')
                {
                    return i;
                }
            }
            return 0;
        }
        protected virtual nothrow int RemoveIndent(int lineIndex) const
        {
            return 0;
        }
        public nothrow void AddNewLineCommand(int lineIndex, int columnIndex)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            int indent = 0;
            bool countIndent = false;
            int i = columnIndex - 1;
            while (i >= 0)
            {
                if (line[i] != ' ')
                {
                    countIndent = true;
                    break;
                }
                --i;
            }
            if (countIndent)
            {
                for (int i = 0; i < columnIndex - 1; ++i)
                {
                    if (line[i] == ' ') ++indent; else break;
                }
            }
            int numSpaces = 0;
            i = columnIndex - 1;
            while (i >= 0 && line[i] == ' ')
            {
                ++numSpaces;
                --i;
            }
            editCommandList.AddCommand(new NewLineCommand(lineIndex, columnIndex, indent, numSpaces));
        }
        public void NewLine(int lineIndex, int columnIndex)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            if (columnIndex > line.Length())
            {
                columnIndex = cast<int>(line.Length());
            }
            ustring toInsert = TrimEnd(line.Substring(columnIndex));
            bool lineChanged = false;
            if (!toInsert.IsEmpty())
            {
                line.Remove(columnIndex, line.Length() - columnIndex);
                lineChanged = true;
            }
            ustring trimmedLine = TrimEnd(line);
            if (trimmedLine.Length() != line.Length())
            {
                Swap(line, trimmedLine);
                lineChanged = true;
            }
            if (lineChanged)
            {
                LineEventArgs changedArgs(lineIndex, -1);
                OnLineChanged(changedArgs);
            }
            lines.Insert(lines.Begin() + lineIndex + 1, toInsert);
            SetLineNumberFieldLength(cast<int>(lines.Count()));
            int indentLineIndex = lineIndex;
            while (indentLineIndex >= 0 && IsEmptyOrSpaceLine(lines[indentLineIndex]))
            {
                --indentLineIndex;
            }
            if (indentLineIndex < 0)
            {
                indentLineIndex = 0;
            }
            LineEventArgs insertedArgs(lineIndex + 1, indentLineIndex);
            OnLineInserted(insertedArgs);
            SetTextExtent();
            SetCaretLineCol(lineIndex + 1 + 1, 1 + LineNumberFieldLength() + GetIndent(lines[indentLineIndex], indentLineIndex));
            ScrollToCaret();
            Invalidate();
            SetDirty();
            SetCCDirty();
        }
        public nothrow inline int IndentSize() const
        {
            return indentSize;
        }
        public void SetIndentSize(int indentSize_)
        {
            indentSize = indentSize_;
        }
        private void AddTabCommand(int lineIndex, int columnIndex)
        {
            editCommandList.AddCommand(new TabCommand(lineIndex, columnIndex));
        }
        public void Tab(int lineIndex, int columnIndex)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex, ustring(' ', IndentSize()));
            if (line.Length() > maxLineLength)
            {
                maxLineLength = cast<int>(line.Length());
                maxLineIndex = lineIndex;
                SetTextExtent();
            }
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() + IndentSize());
            ScrollToCaret();
            InvalidateLineCol(lineIndex + 1, columnIndex + 1);
            SetDirty();
            SetCCDirty();
        }
        private void AddBacktabCommand(int lineIndex, int columnIndex)
        {
            ustring& line = lines[lineIndex];
            int targetCol = Max(cast<int>(1), columnIndex - IndentSize() + 1);
            int numSpaces = 0;
            for (int i = columnIndex; i >= targetCol; --i)
            {
                if (line[i - 1] == ' ')
                {
                    ++numSpaces;
                }
                else
                {
                    break;
                }
            }
            editCommandList.AddCommand(new BacktabCommand(lineIndex, columnIndex, numSpaces));
        }
        public void Backtab(int lineIndex, int columnIndex)
        {
            if (lineIndex >= lines.Count()) return;
            ustring& line = lines[lineIndex];
            int targetCol = Max(cast<int>(1), columnIndex - IndentSize() + 1);
            int numSpaces = 0;
            int col = 0;
            for (int i = columnIndex; i >= targetCol; --i)
            {
                if (line[i - 1] == ' ')
                {
                    col = i - 1;
                    ++numSpaces;
                }
                else
                {
                    break;
                }
            }
            if (numSpaces > 0)
            {
                line.Remove(col, numSpaces);
                LineEventArgs args(lineIndex, -1);
                OnLineChanged(args);
                SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() - numSpaces);
                ScrollToCaret();
                InvalidateLineCol(lineIndex + 1, 1 + col + LineNumberFieldLength());
                SetDirty();
                SetCCDirty();
            }
        }
        public nothrow void AddSpaces(int lineIndex, int columnIndex, int numSpaces)
        {
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex - numSpaces, ustring(' ', numSpaces));
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() - numSpaces);
            ScrollToCaret();
            InvalidateLineCol(lineIndex + 1, 1 + LineNumberFieldLength());
            SetDirty();
            SetCCDirty();
        }
        public nothrow void RemoveSpaces(int lineIndex, int columnIndex, int numSpaces)
        {
            ustring& line = lines[lineIndex];
            line.Remove(columnIndex - numSpaces, numSpaces);
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() - numSpaces);
            ScrollToCaret();
            InvalidateLineCol(lineIndex + 1, 1 + LineNumberFieldLength());
            SetDirty();
            SetCCDirty();
        }
        protected virtual void OnCopy()
        {
            copyEvent.Fire();
        }
        protected virtual void OnPaste()
        {
            pasteEvent.Fire();
        }
        protected virtual void OnCut()
        {
            cutEvent.Fire();
        }
        protected override nothrow void SetContentLocationInternal(const Point& contentLocation)
        {
            topLine = cast<int>(contentLocation.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - contentLocation.y;
            leftCol = cast<int>(contentLocation.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - contentLocation.x;
            base->SetContentLocationInternal(contentLocation);
        }
        public void ScrollToCaret()
        {
            if (lines.IsEmpty() || charHeight == 0) return;
            Size size = GetSize();
            int windowLines = cast<int>(size.h / charHeight);
            int windowCols = cast<int>(size.w / charWidth);
            Point currentOrigin = ContentLocation();
            int topLineNumber = cast<int>(currentOrigin.y / charHeight + 1);
            int leftColNumber = cast<int>(currentOrigin.x / charWidth + 1);
            int oldTopLineNumber = topLineNumber;
            if (caretLine > topLineNumber)
            {
                while (caretLine - topLineNumber + 1 >= windowLines)
                {
                    ++topLineNumber;
                }
            }
            else if (caretLine < topLineNumber)
            {
                topLineNumber = caretLine;
            }
            else
            {
                topLineNumber = Max(cast<int>(1), caretLine - 1);
            }
            int oldLeftColNumber = leftColNumber;
            if (caretColumn >= leftColNumber)
            {
                while (caretColumn - leftColNumber + 2 >= windowCols)
                {
                    ++leftColNumber;
                }
            }
            else
            {
                if (caretColumn == 1 + LineNumberFieldLength())
                {
                    leftColNumber = 1;
                }
                else
                {
                    leftColNumber = caretColumn;
                }
            }
            if (update || caretLine == 1 || topLineNumber != oldTopLineNumber || leftColNumber != oldLeftColNumber)
            {
                update = false;
                Point newOrigin(cast<int>((leftColNumber - 1) * charWidth), cast<int>((topLineNumber - 1) * charHeight));
                topLine = topLineNumber;
                topLineDiff = 0.0f;
                leftCol = leftColNumber;
                leftColDiff = 0.0f;
                SetContentLocation(newOrigin);
                SetCaretLocation();
                Invalidate();
            }
        }
        public virtual nothrow int LineNumberFieldLength() const
        {
            return 0;
        }
        protected virtual nothrow void SetLineNumberFieldLength(int lineCount)
        {
        }
        protected override void CreateCaret()
        {
            if (charHeight != 0)
            {
                System.Windows.API.CreateCaret(Handle(), null, 1, cast<int>(charHeight));
            }
            else
            {
                base->CreateCaret();
            }
            SetTimer(1u, caretTimerPeriod);
        }
        protected override void OnTimer(TimerEventArgs& args)
        {
            base->OnTimer(args);
            if (Focused())
            {
                HideCaret();
                ShowCaret();
            }
        }
        protected override void OnLostFocus()
        {
            base->OnLostFocus();
            KillTimer(1u);
        }
        protected override void OnClick()
        {
            base->OnClick();
            SetFocus();
            ResetSelection();
        }
        protected override void OnMouseDoubleClick(MouseEventArgs& args)
        {
            base->OnMouseDoubleClick(args);
            ResetMouseExtendSelection();
            mouseSelectionStart = SourcePos();
            mouseSelectionEnd = SourcePos();
            SetFocus();
            ResetSelection();
            int line = 0;
            int column = 0;
            GetLineColumn(args.location, line, column);
            uchar c = GetCharAt(line, column);
            while (!IsWhiteSpace(c) && !IsWordSeparator(c))
            {
                if (column == 1 || !Prev(line, column))
                {
                    break;
                }
                c = GetCharAt(line, column);
            }
            c = GetCharAt(line, column);
            if (IsWhiteSpace(c) || IsWordSeparator(c))
            {
                Next(line, column);
            }
            SourcePos start(line, column);
            c = GetCharAt(line, column);
            while (!IsWhiteSpace(c) && !IsWordSeparator(c))
            {
                if (!Next(line, column))
                {
                    break;
                }
                c = GetCharAt(line, column);
            }
            if (!IsWhiteSpace(c) && !IsWordSeparator(c))
            {
                column = column + 1;
            }
            SourcePos end(line, column);
            ExtendSelection(start, end);
            SetCaretLineCol(start.line, start.column + LineNumberFieldLength());
            ScrollToCaret();
            InvalidateLineCol(start.line, start.column);
        }
        protected override void SetCursor()
        {
            SetCursor(cursor);
        }
        protected override void SetCaretLocation()
        {
            int x = cast<int>(padding.left + (caretColumn - 1) * charWidth);
            int y = cast<int>(padding.top + (caretLine - 1) * charHeight);
            Point caretPos(x, y);
            TranslateContentLocation(caretPos);
            if (CaretCreated())
            {
                SetCaretPos(caretPos);
                OnCaretPosChanged();
            }
        }
        protected virtual void OnCaretPosChanged()
        {
            caretPosChangedEvent.Fire();
        }
        protected virtual void OnLinesChanged()
        {
            linesChangedEvent.Fire();
        }
        protected virtual void OnLineChanged(LineEventArgs& args)
        {
            lineChangedEvent.Fire(args);
            InvalidateLineCol(args.lineIndex + 1, 1 + LineNumberFieldLength());
        }
        protected virtual void OnLineDeleted(LineEventArgs& args)
        {
            lineDeletedEvent.Fire(args);
            Invalidate();
        }
        protected virtual void OnLineInserted(LineEventArgs& args)
        {
            lineInsertedEvent.Fire(args);
            int lineIndex = args.lineIndex;
            ustring& line = Lines()[lineIndex];
            int indent = 0;
            if (args.indentLineIndex >= 0 && args.indentLineIndex < Lines().Count())
            {
                indent = GetIndent(Lines()[args.indentLineIndex], args.indentLineIndex);
            }
            if (indent != 0)
            {
                line.Insert(0, ustring(' ', indent));
            }
            Invalidate();
        }
        public nothrow inline int MaxLineLength() const
        {
            return maxLineLength;
        }
        public nothrow inline int MaxLineIndex() const
        {
            return maxLineIndex;
        }
        protected nothrow void SetMaxLineLength()
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const ustring& line = lines[i];
                if (line.Length() > maxLineLength)
                {
                    maxLineLength = cast<int>(line.Length());
                    maxLineIndex = i;
                }
            }
        }
        public nothrow inline const Padding& GetPadding() const
        {
            return padding;
        }
        public nothrow void SetPadding(const Padding& padding_)
        {
            if (padding != padding_)
            {
                padding = padding_;
                Invalidate();
            }
        }
        protected virtual void OnSelectionChanged()
        {
            selectionChangedEvent.Fire();
        }
        protected virtual void OnDirtyChanged()
        {
            dirtyChangedEvent.Fire();
        }
        protected virtual void OnCCDirtyChanged()
        {
            ccdirtyChangedEvent.Fire();
        }
        protected virtual void OnCC()
        {
            ccEvent.Fire();
        }
        public void SaveText(const string& filePath)
        {
            StreamWriter writer = File.CreateText(filePath);
            for (const ustring& line : lines)
            {
                writer.WriteLine(line);
            }
        }
        public nothrow void SetCCText(const ustring& line, int columnIndex)
        {
            cctext.Clear();
            while (columnIndex >= line.Length())
            {
                --columnIndex;
            }
            while (columnIndex >= 0)
            {
                if (IsCCStopChar(line[columnIndex]))
                {
                    break;
                }
                cctext.Append(line[columnIndex]);
                --columnIndex;
            }
            Reverse(cctext.Begin(), cctext.End());
            OnCCTextChanged();
        }
        public nothrow void ResetCCText()
        {
            cctext.Clear();
            OnCCTextChanged();
        }
        protected virtual nothrow void OnCCTextChanged()
        {
            cctextChangedEvent.Fire();
        }
        public nothrow inline const ustring& GetCCText() const
        {
            return cctext;
        }
        public nothrow void ReplaceCCText(const ustring& replacement)
        {
            int caretLineIndex = Max(0, caretLine - 1);
            int caretColumnIndex = Max(0, caretColumn - 1);
            if (caretLineIndex < lines.Count())
            {
                ustring& line = lines[caretLineIndex];
                while (caretColumnIndex > line.Length())
                {
                    --caretColumnIndex;
                }
                int endColumnIndex = Max(0, caretColumnIndex);
                while (caretColumnIndex > 0)
                {
                    if (caretColumnIndex < line.Length())
                    {
                        if (IsCCStopChar(line[caretColumnIndex]))
                        {
                            ++caretColumnIndex;
                            break;
                        }
                    }
                    --caretColumnIndex;
                }
                int startColumndIndex = Max(0, caretColumnIndex);
                line = line.Substring(0, startColumndIndex) + replacement + line.Substring(endColumnIndex);
                int newEndColumnIndex = startColumndIndex + cast<int>(replacement.Length());
                LineEventArgs args(caretLineIndex, -1);
                OnLineChanged(args);
                SetCaretLineCol(caretLineIndex + 1, newEndColumnIndex + 1 + LineNumberFieldLength());
                ScrollToCaret();
                Invalidate();
                SetDirty();
                SetCCDirty();
            }
        }
        public nothrow ustring GetCursorText() const
        {
            ustring cursorText;
            int caretIndex = Max(0, caretColumn - 1);
            long n = lines.Count();
            for (long i = 0; i < n; ++i)
            {
                const ustring& line = lines[i];
                int lineNumber = cast<int>(i + 1);
                if (lineNumber == caretLine)
                {
                    int startIndex = caretIndex;
                    while (startIndex > 0)
                    {
                        if (startIndex < line.Length())
                        {
                            bool exit = false;
                            switch (line[startIndex])
                            {
                                case ';':
                                case '{':
                                case '}':
                                {
                                    ++startIndex;
                                    exit = true;
                                    break;
                                }
                            }
                            if (exit)
                            {
                                break;
                            }
                        }
                        --startIndex;
                    }
                    cursorText.Append(line.Substring(0, startIndex)).Append('$').Append(line.Substring(caretIndex)).Append('\n');
                }
                else
                {
                    cursorText.Append(line).Append('\n');
                }
            }
            return cursorText;
        }
        public nothrow void SetSelection(const Selection& selection_)
        {
            selection = selection_;
            Invalidate();
        }
        public nothrow void ResetSelection()
        {
            if (!selection.IsEmpty())
            {
                selection = Selection();
                OnSelectionChanged();
                Invalidate();
            }
        }
        public nothrow bool IsSelectionEmpty() const
        {
            return selection.IsEmpty();
        }
        public nothrow SelectionData GetSelection() const
        {
            if (selection.IsEmpty()) return SelectionData();
            if (selection.start.line == selection.end.line)
            {
                ustring s = lines[selection.start.line - 1].Substring(selection.start.column - 1, selection.end.column - selection.start.column);
                int indent = MinIndent(s);
                SelectionData selectionData(Unindent(s, indent), indent, 0);
                return selectionData;
            }
            else
            {
                int numTrailingSpaces = 0;
                ustring s = lines[selection.start.line - 1].Substring(selection.start.column - 1).Append(u"\n");
                for (int i = selection.start.line; i < selection.end.line - 1; ++i)
                {
                    s.Append(lines[i]).Append(u"\n");
                }
                if (selection.end.line - 1 < lines.Count())
                {
                    if (!lines[selection.end.line - 1].Substring(0, selection.end.column - 1).IsEmpty())
                    {
                        ustring lastLine = lines[selection.end.line - 1].Substring(0, selection.end.column - 1);
                        numTrailingSpaces = GetNumTrailingSpaces(lastLine);
                        s.Append(lastLine).Append(u"\n");
                    }
                }
                else
                {
                    int i = selection.end.line - 1;
                    while (i >= lines.Count())
                    {
                        s.Append(u"\n");
                        --i;
                    }
                }
                int indent = MinIndent(s);
                SelectionData selectionData(Unindent(s, indent), indent, numTrailingSpaces);
                return selectionData;
            }
        }
        public nothrow void InsertSelection(const Selection& selectionToInsert, const SelectionData& selectionData, bool wholeLine)
        {
            if (selectionToInsert.IsEmpty()) return;
            if (selectionToInsert.start.line == selectionToInsert.end.line)
            {
                if (wholeLine)
                {
                    int lineIndex = selectionToInsert.start.line - 1;
                    ustring selectedText = selectionData.selectedText;
                    if (selectionData.indent > 0)
                    {
                        selectedText.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lines.Insert(lines.Begin() + lineIndex, selectedText);
                    LineEventArgs insertArgs(lineIndex, -1);
                    OnLineInserted(insertArgs);
                    SetCaretLineCol(lineIndex + 1, 1 + LineNumberFieldLength());
                }
                else
                {
                    int lineIndex = selectionToInsert.start.line - 1;
                    ustring selectedText = selectionData.selectedText;
                    if (selectionData.indent > 0)
                    {
                        selectedText.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lines[lineIndex].Insert(selectionToInsert.start.column - 1, selectedText);
                    LineEventArgs changeArgs(lineIndex, -1);
                    OnLineChanged(changeArgs);
                    SetCaretLineCol(lineIndex + 1, selectionToInsert.start.column + LineNumberFieldLength());
                }
            }
            else
            {
                List<ustring> selectionLines = SplitTextIntoLines(selectionData.selectedText);
                int startLineIndex = selectionToInsert.start.line - 1;
                int endLineIndex = selectionToInsert.end.line - 1;
                int lineCount  = endLineIndex - startLineIndex + 1;
                if (selectionToInsert.start.column > 1)
                {
                    ustring firstSelectionLine = selectionLines[0];
                    if (selectionData.indent > 0)
                    {
                        firstSelectionLine.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lines[startLineIndex].Insert(selectionToInsert.start.column - 1, firstSelectionLine);
                    LineEventArgs changeArgs(startLineIndex, -1);
                    OnLineChanged(changeArgs);
                    ++startLineIndex;
                }
                else
                {
                    ustring firstSelectionLine = selectionLines[0];
                    if (selectionData.indent > 0)
                    {
                        firstSelectionLine.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lines.Insert(lines.Begin() + startLineIndex, firstSelectionLine);
                    LineEventArgs insertArgs(startLineIndex, -1);
                    OnLineInserted(insertArgs);
                    ++startLineIndex;
                }
                int n = endLineIndex;
                for (int i = startLineIndex; i < n; ++i)
                {
                    ustring selectionLine = selectionLines[i - startLineIndex + 1];
                    if (selectionData.indent > 0)
                    {
                        selectionLine.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lines.Insert(lines.Begin() + i, selectionLine);
                    LineEventArgs insertArgs(i, -1);
                    OnLineInserted(insertArgs);
                }
                ustring lastLine;
                if (selectionLines.Count() >= lineCount)
                {
                    lastLine = selectionLines.Back();
                    if (selectionData.indent > 0)
                    {
                        lastLine.Insert(0, ustring(' ', selectionData.indent));
                    }
                    lastLine.Append(' ', selectionData.numTrailingSpaces);
                }
                if (wholeLine)
                {
                    lines.Insert(lines.Begin() + endLineIndex, lastLine);
                    LineEventArgs insertArgs(endLineIndex, -1);
                    OnLineInserted(insertArgs);
                }
                else
                {
                    lines[endLineIndex].Insert(0, lastLine);
                    LineEventArgs changeArgs(endLineIndex, -1);
                    OnLineChanged(changeArgs);
                }
            }
            selection = selectionToInsert;
            SetCaretLineCol(selection.end.line, selection.end.column + LineNumberFieldLength());
            Invalidate();
            SetDirty();
            SetCCDirty();
        }
        public nothrow void AddRemoveSelectionCommand()
        {
            if (selection.IsEmpty()) return;
            bool wholeLine = false;
            SelectionData selectionData = GetSelection();
            if (selection.start.line == selection.end.line)
            {
                if (selection.end.column - selection.start.column >= GetLineLength(selection.start.line))
                {
                    wholeLine = true;
                }
            }
            else
            {
                int endLineIndex = selection.end.line - 1;
                if (selection.end.column > GetLineLength(endLineIndex + 1))
                {
                    wholeLine = true;
                }
            }
            editCommandList.AddCommand(new RemoveSelectionCommand(selection, selectionData, wholeLine));
        }
        public nothrow void RemoveSelection()
        {
            if (selection.IsEmpty()) return;
            if (selection.start.line == selection.end.line)
            {
                if (selection.end.column - selection.start.column >= GetLineLength(selection.start.line))
                {
                    int lineIndex = selection.start.line - 1;
                    lines.Remove(lines.Begin() + lineIndex);
                    LineEventArgs deleteArgs(lineIndex, -1);
                    OnLineDeleted(deleteArgs);
                    SetCaretLineCol(selection.start.line, 1 + LineNumberFieldLength());
                }
                else
                {
                    int lineIndex = selection.start.line - 1;
                    lines[lineIndex].Remove(selection.start.column - 1, selection.end.column - selection.start.column);
                    LineEventArgs changeArgs(lineIndex, -1);
                    OnLineChanged(changeArgs);
                    SetCaretLineCol(lineIndex + 1, selection.start.column + LineNumberFieldLength());
                }
            }
            else
            {
                int startLineIndex = selection.start.line - 1;
                int endLineIndex = selection.end.line - 1;
                if (selection.start.column > 1)
                {
                    lines[startLineIndex].Remove(selection.start.column - 1, GetLineLength(startLineIndex + 1) - selection.start.column + 1);
                    LineEventArgs changeArgs(startLineIndex, -1);
                    OnLineChanged(changeArgs);
                    ++startLineIndex;
                }
                else
                {
                    lines.Remove(lines.Begin() + startLineIndex);
                    --endLineIndex;
                    LineEventArgs deleteArgs(startLineIndex, -1);
                    OnLineDeleted(deleteArgs);
                }
                int n = endLineIndex;
                for (int i = startLineIndex; i < n; ++i)
                {
                    lines.Remove(lines.Begin() + startLineIndex);
                    --endLineIndex;
                    LineEventArgs deleteArgs(startLineIndex, -1);
                    OnLineDeleted(deleteArgs);
                }
                if (endLineIndex >= 0 && endLineIndex < lines.Count())
                {
                    if (selection.end.column > GetLineLength(endLineIndex + 1))
                    {
                        lines.Remove(lines.Begin() + endLineIndex);
                        LineEventArgs deleteArgs(endLineIndex, -1);
                        OnLineDeleted(deleteArgs);
                    }
                    else
                    {
                        lines[endLineIndex].Remove(0, selection.end.column - 1);
                        LineEventArgs changeArgs(endLineIndex, -1);
                        OnLineChanged(changeArgs);
                    }
                }
                SetCaretLineCol(selection.start.line, selection.start.column + LineNumberFieldLength());
            }
            ResetSelection();
            Invalidate();
            SetDirty();
            SetCCDirty();
            SetFocus();
        }
        private nothrow void AddIndentSelectionCommand()
        {
            editCommandList.AddCommand(new IndentSelectionCommand(selection));
        }
        public nothrow void IndentSelection()
        {
            if (selection.IsEmpty()) return;
            int startLineIndex = selection.start.line - 1;
            int endLineIndex = selection.end.line - 1;
            ustring indentString(' ', IndentSize());
            for (int i = startLineIndex; i <= endLineIndex; ++i)
            {
                if (lines[i].IsEmpty()) continue;
                if (i == selection.end.line - 1 && lines[i].Substring(0, selection.end.column - 1).IsEmpty()) continue;
                lines[i].Insert(0, indentString);
                LineEventArgs changeArgs(i, -1);
                OnLineChanged(changeArgs);
            }
            InvalidateLines(selection.start.line, selection.end.line);
            SetDirty();
            SetCCDirty();
        }
        public nothrow void AddUnindentSelectionCommand()
        {
            editCommandList.AddCommand(new UnindentSelectionCommand(selection));
        }
        public nothrow void UnindentSelection()
        {
            if (selection.IsEmpty()) return;
            int startLineIndex = selection.start.line - 1;
            int endLineIndex = selection.end.line - 1;
            ustring indentString(' ', IndentSize());
            for (int i = startLineIndex; i <= endLineIndex; ++i)
            {
                ustring line = lines[i];
                if (i == endLineIndex)
                {
                    line = line.Substring(0, selection.end.column - 1);
                }
                if (line.StartsWith(indentString))
                {
                    lines[i].Remove(0, IndentSize());
                    LineEventArgs changeArgs(i, -1);
                    OnLineChanged(changeArgs);
                }
            }
            InvalidateLines(selection.start.line, selection.end.line);
            SetDirty();
            SetCCDirty();
        }
        public nothrow void ExtendSelection(const SourcePos& start, const SourcePos& end)
        {
            switch (selection.fixed)
            {
                case Selection.Fix.none:
                {
                    if (start < end)
                    {
                        selection.fixed = Selection.Fix.start;
                        selection.start = start;
                        selection.end = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.end;
                        selection.end = start;
                        selection.start = end;
                    }
                    break;
                }
                case Selection.Fix.start:
                {
                    if (end == selection.start)
                    {
                        ResetSelection();
                    }
                    else if (end > selection.start)
                    {
                        selection.end = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.end;
                        selection.end = start;
                        selection.start = end;
                    }
                    break;
                }
                case Selection.Fix.end:
                {
                    if (end == selection.end)
                    {
                        ResetSelection();
                    }
                    else if (end < selection.end)
                    {
                        selection.start = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.start;
                        selection.start = start;
                        selection.end = end;
                    }
                    break;
                }
            }
            OnSelectionChanged();
        }
        public Brush* GetOrInsertBrush(const Color& color)
        {
            HashMap<Color, Brush*>.ConstIterator it = colorBrushMap.CFind(color);
            if (it != colorBrushMap.CEnd())
            {
                return it->second;
            }
            Brush* brush = new SolidBrush(color);
            brushes.Add(UniquePtr<Brush>(brush));
            colorBrushMap[color] = brush;
            return brush;
        }
        protected inline nothrow bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        protected inline nothrow void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed);
        }
        protected inline nothrow void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public inline nothrow bool Painting() const
        {
            return (flags &  Flags.painting) != Flags.none;
        }
        private inline nothrow void SetPainting()
        {
            flags = cast<Flags>(flags | Flags.painting);
        }
        private inline nothrow void ResetPainting()
        {
            flags = cast<Flags>(flags & ~Flags.painting);
        }
        public nothrow inline bool IsReadOnly() const
        {
            return (flags & Flags.readOnly) != Flags.none;
        }
        public nothrow void SetReadOnly()
        {
            flags = cast<Flags>(flags | Flags.readOnly);
        }
        public nothrow void ResetReadOnly()
        {
            flags = cast<Flags>(flags & ~Flags.readOnly);
        }
        public nothrow inline bool IsFixed() const
        {
            return (flags & Flags.fixed) != Flags.none;
        }
        public nothrow void SetFixed()
        {
            flags = cast<Flags>(flags | Flags.fixed);
        }
        public nothrow void ResetFixed()
        {
            flags = cast<Flags>(flags & ~Flags.fixed);
        }
        public nothrow inline bool IsDirty() const
        {
            return (flags & Flags.dirty) != Flags.none;
        }
        public nothrow void SetDirty()
        {
            if (!IsDirty())
            {
                flags = cast<Flags>(flags | Flags.dirty);
                OnDirtyChanged();
            }
        }
        public nothrow void ResetDirty()
        {
            if (IsDirty())
            {
                flags = cast<Flags>(flags & ~Flags.dirty);
                OnDirtyChanged();
            }
        }
        public nothrow inline bool IsCCDirty() const
        {
            return (flags & Flags.ccdirty) != Flags.none;
        }
        public nothrow void SetCCDirty()
        {
            if (!IsCCDirty())
            {
                flags = cast<Flags>(flags | Flags.ccdirty);
                OnCCDirtyChanged();
            }
        }
        public nothrow void ResetCCDirty()
        {
            if (IsCCDirty())
            {
                flags = cast<Flags>(flags & ~Flags.ccdirty);
                OnCCDirtyChanged();
            }
        }
        private nothrow inline bool MouseExtendSelection() const
        {
            return (flags & Flags.mouseExtendSelection) != Flags.none;
        }
        private nothrow void SetMouseExtendSelection()
        {
            flags = cast<Flags>(flags | Flags.mouseExtendSelection);
        }
        private nothrow void ResetMouseExtendSelection()
        {
            flags = cast<Flags>(flags & ~Flags.mouseExtendSelection);
        }
        public nothrow inline bool CCOpen() const
        {
            return (flags & Flags.ccOpen) != Flags.none;
        }
        public nothrow void SetCCOpen()
        {
            flags = cast<Flags>(flags | Flags.ccOpen);
        }
        public nothrow void ResetCCOpen()
        {
            flags = cast<Flags>(flags & ~Flags.ccOpen);
        }
        public nothrow Event<CaretPosChangedEventHandler>& CaretPosChangedEvent() const
        {
            return caretPosChangedEvent;
        }
        public nothrow Event<LinesChangedEventHandler>& LinesChangedEvent() const
        {
            return linesChangedEvent;
        }
        public nothrow Event<LineChangedEventHandler, LineEventArgs>& LineChangedEvent() const
        {
            return lineChangedEvent;
        }
        public nothrow Event<LineDeletedEventHandler, LineEventArgs>& LineDeletedEvent() const
        {
            return lineDeletedEvent;
        }
        public nothrow Event<LineInsertedEventHandler, LineEventArgs>& LineInsertedEvent() const
        {
            return lineInsertedEvent;
        }
        public nothrow Event<GotoCaretLineEventHandler, ControlEventArgs>& GotoCaretLineEvent() const
        {
            return gotoCaretLineEvent;
        }
        public nothrow Event<SelectionChangedEventHandler>& SelectionChangedEvent() const
        {
            return selectionChangedEvent;
        }
        public nothrow Event<DirtyChangedEventHandler>& DirtyChangedEvent() const
        {
            return dirtyChangedEvent;
        }
        public nothrow Event<CCDirtyChangedEventHandler>& CCDirtyChangedEvent() const
        {
            return ccdirtyChangedEvent;
        }
        public nothrow Event<CCTextChangedEventHandler>& CCTextChangedEvent() const
        {
            return cctextChangedEvent;
        }
        public nothrow Event<CCEventHandler>& CCEvent() const
        {
            return ccEvent;
        }
        public nothrow Event<EscapePressedHandler>& EscapePressedEvent() const
        {
            return escapePressedEvent;
        }
        public nothrow Event<CCNextEventHandler>& CCNextEvent() const
        {
            return ccNextEvent;
        }
        public nothrow Event<CCPrevEventHandler>& CCPrevEvent() const
        {
            return ccPrevEvent;
        }
        public nothrow Event<CCNextPageEventHandler>& CCNextPageEvent() const
        {
            return ccNextPageEvent;
        }
        public nothrow Event<CCPrevPageEventHandler>& CCPrevPageEvent() const
        {
            return ccPrevPageEvent;
        }
        public nothrow Event<CCSelectEventHandler>& CCSelectEvent() const
        {
            return ccSelectEvent;
        }
        public nothrow Event<CopyEventHandler>& CopyEvent() const
        {
            return copyEvent;
        }
        public nothrow Event<CutEventHandler>& CutEvent() const
        {
            return cutEvent;
        }
        public nothrow Event<PasteEventHandler>& PasteEvent() const
        {
            return pasteEvent;
        }
        public void InvalidateLineCol(int lineNumber, int columnNumber)
        {
            if (charHeight != 0 && charWidth != 0)
            {
                Point pt(cast<int>(charWidth * (columnNumber - 1)), cast<int>(charHeight * (lineNumber - 1)));
                TranslateContentLocation(pt);
                Size size = GetSize();
                Size sz(size.w - pt.x, cast<int>(charHeight + 1.5f));
                Rect rect(pt, sz);
                Invalidate(rect);
            }
            else
            {
                Invalidate();
            }
        }
        public void InvalidateLines(int startLineNumber, int endLineNumber)
        {
            if (charHeight != 0 && charWidth != 0)
            {
                Point pt(0, cast<int>(charHeight * (startLineNumber - 1) - charHeight));
                TranslateContentLocation(pt);
                Size size = GetSize();
                Size sz(size.w, cast<int>(charHeight * (endLineNumber - startLineNumber + 1) + 2 * charHeight + 1.5f));
                Rect rect(pt, sz);
                Invalidate(rect);
            }
            else
            {
                Invalidate();
            }
        }
        public nothrow void SetFilePath(const string& filePath_)
        {
            filePath = filePath_;
        }
        public nothrow const string& FilePath() const
        {
            return filePath;
        }
        private Flags flags;
        private List<ustring> lines;
        private List<int> lineStartIndeces;
        private StringFormat drawFormat;
        private FontFamily fontFamily;
        private Color textColor;
        private List<UniquePtr<Font>> fonts;
        private List<UniquePtr<Brush>> brushes;
        private HashMap<Color, Brush*> colorBrushMap;
        private float fontSize;
        private float charWidth;
        private float charHeight;
        private int textWidth;
        private int textHeight;
        private int maxLineLength;
        private int maxLineIndex;
        private Cursor cursor;
        private int caretLine;
        private int caretColumn;
        private int topLine;
        private int leftCol;
        private float topLineDiff;
        private float leftColDiff;
        private uint caretTimerPeriod;
        private bool update;
        private Padding padding;
        private Event<CaretPosChangedEventHandler> caretPosChangedEvent;
        private Event<LinesChangedEventHandler> linesChangedEvent;
        private Event<LineChangedEventHandler, LineEventArgs> lineChangedEvent;
        private Event<LineDeletedEventHandler, LineEventArgs> lineDeletedEvent;
        private Event<LineInsertedEventHandler, LineEventArgs> lineInsertedEvent;
        private Event<GotoCaretLineEventHandler, ControlEventArgs> gotoCaretLineEvent;
        private Event<SelectionChangedEventHandler> selectionChangedEvent;
        private Event<DirtyChangedEventHandler> dirtyChangedEvent;
        private Event<CCDirtyChangedEventHandler> ccdirtyChangedEvent;
        private Event<CCTextChangedEventHandler> cctextChangedEvent;
        private Event<CCEventHandler> ccEvent;
        private Event<CCNextEventHandler> ccNextEvent;
        private Event<CCPrevEventHandler> ccPrevEvent;
        private Event<CCNextPageEventHandler> ccNextPageEvent;
        private Event<CCPrevPageEventHandler> ccPrevPageEvent;
        private Event<CCSelectEventHandler> ccSelectEvent;
        private Event<EscapePressedHandler> escapePressedEvent;
        private Event<CopyEventHandler> copyEvent;
        private Event<CutEventHandler> cutEvent;
        private Event<PasteEventHandler> pasteEvent;
        private string measureString;
        private Selection selection;
        private SourcePos mouseSelectionStart;
        private SourcePos mouseSelectionEnd;
        private System.Windows.Color selectionBackgroundColor;
        private EditCommandList editCommandList;
        private int indentSize;
        private string filePath;
        private ustring cctext;
    }

    public nothrow ustring TrimEnd(const ustring& line)
    {
        long i = line.Length();
        while (i > 0 && IsWhiteSpace(line[i - 1]))
        {
            --i;
        }
        return line.Substring(0, i);
    }

    public nothrow int GetNumTrailingSpaces(const ustring& line)
    {
        int numTrailingSpaces = 0;
        long i = line.Length();
        while (i > 0 && IsWhiteSpace(line[i - 1]))
        {
            --i;
            ++numTrailingSpaces;
        }
        return numTrailingSpaces;
    }

    public List<ustring> SplitTextIntoLines(const ustring& text)
    {
        List<ustring> lines;
        ustring line;
        int state = 0;
        for (uchar c : text)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            lines.Add(TrimEnd(line));
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        lines.Add(TrimEnd(line));
                        line.Clear();
                        state = 0;
                        break;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            lines.Add(TrimEnd(line));
        }
        return lines;
    }

    public nothrow int MinIndent(const ustring& s)
    {
        if (s.IsEmpty()) return 0;
        int state = 0;
        int indent = 0;
        int minIndent = MaxValue<int>();
        for (uchar c : s)
        {
            switch (state)
            {
                case 0:
                {
                    if (c == ' ')
                    {
                        ++indent;
                    }
                    else if (c == '\n')
                    {
                        if (indent < minIndent)
                        {
                            minIndent = indent;
                        }
                        indent = 0;
                    }
                    else
                    {
                        if (indent < minIndent)
                        {
                            minIndent = indent;
                        }
                        indent = 0;
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        if (indent > 0 && indent < minIndent)
        {
            minIndent = indent;
        }
        if (minIndent == MaxValue<int>())
        {
            minIndent = 0;
        }
        return minIndent;
    }

    public nothrow ustring Unindent(const ustring& s, int indent)
    {
        if (indent == 0) return s;
        ustring line;
        ustring result;
        int state = 0;
        for (uchar c : s)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            result.Append(line.Substring(indent)).Append('\n');
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        result.Append(line.Substring(indent)).Append('\n');
                        line.Clear();
                        state = 0;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            result.Append(line.Substring(indent));
        }
        return result;
    }

    public List<int> CalculateLineStartIndeces(const ustring& text)
    {
        List<int> indeces;
        int state = 0;
        int n = cast<int>(text.Length());
        for (int i = 0; i < n; ++i)
        {
            uchar c = text[i];
            switch (state)
            {
                case 0:
                {
                    indeces.Add(i);
                    if (c != '\n')
                    {
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        return indeces;
    }

    internal bool ReadCaretTimeoutFromRegistry(uint& caretTimeout)
    {
        void* currentUserKey = null;
        bool openSucceeded = WinRegOpenCurrentUser(&currentUserKey);
        if (openSucceeded)
        {
            uint value = 0u;
            bool getValueSucceeded = WinRegGetDWordValue(currentUserKey, @"Control Panel\Desktop", "CaretTimeout", value);
            if (getValueSucceeded)
            {
                caretTimeout = value;
            }
            WinRegCloseKey(currentUserKey);
            return getValueSucceeded;
        }
        return false;
    }

}

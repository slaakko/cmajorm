// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Windows
{
    public nothrow System.Windows.Color DefaultSelectionBackgroundColor()
    {
        return System.Windows.Color(153u, 201u, 239u);
    }

    public class SourcePos
    {
        public nothrow SourcePos() : line(0), column(0)
        {
        }
        public nothrow SourcePos(int line_, int column_) : line(line_), column(column_)
        {
        }
        public nothrow bool IsValid() const
        {
            return line != 0 && column != 0;
        }
        public int line;
        public int column;
    }

    public nothrow bool operator==(const SourcePos& left, const SourcePos& right)
    {
        return left.line == right.line && left.column == right.column;
    }

    public nothrow bool operator<(const SourcePos& left, const SourcePos& right)
    {
        if (left.line < right.line) return true;
        if (left.line > right.line) return false;
        return left.column < right.column;
    }

    public class Selection
    {
        public enum Fix : sbyte
        {
            none, start, end
        }
        public nothrow Selection() : fixed(Fix.none), start(), end()
        {
        }
        public nothrow bool IsEmpty() const
        {
            return !start.IsValid() && !end.IsValid();
        }
        public Fix fixed;
        public SourcePos start;
        public SourcePos end;
    }

    public const uint defaultCaretTimerPeriod = 5000u; // 5 seconds

    public class LineEventArgs
    {
        public nothrow LineEventArgs(int lineIndex_, int indentLineIndex_) : lineIndex(lineIndex_), indentLineIndex(indentLineIndex_)
        {
        }
        public int lineIndex;
        public int indentLineIndex;
    }

    public class delegate void CaretPosChangedEventHandler();
    public class delegate void LinesChangedEventHandler();
    public class delegate void LineChangedEventHandler(LineEventArgs& args);
    public class delegate void LineDeletedEventHandler(LineEventArgs& args);
    public class delegate void LineInsertedEventHandler(LineEventArgs& args);
    public class delegate void GotoCaretLineEventHandler(ControlEventArgs& args);
    public class delegate void SelectionChangedEventHandler();
    public class delegate void CopyEventHandler();
    public class delegate void CutEventHandler();
    public class delegate void PasteEventHandler();

    public class TextView : Control
    {
        private enum Flags : sbyte
        {
            none = 0, changed = 1 << 0, painting = 1 << 1, readOnly = 1 << 2, fixed = 1 << 3, dirty = 1 << 4
        }
        
        public TextView(const FontFamily& fontFamily_, float fontSize_, const Color& backgroundColor, const Color& textColor_, const Point& location, const Size& size,
            Dock dock, Anchors anchors) :
            base("System.Windows.TextView", DefaultWindowClassStyle(), cast<WindowStyle>(DefaultChildWindowStyle() | WindowStyle.WS_TABSTOP), DefaultExtendedWindowStyle(), backgroundColor,
            "textView", location, size, dock, anchors), flags(Flags.none), drawFormat(StringAlignment.near, StringAlignment.near), fontFamily(fontFamily_), fontSize(fontSize_),
            charWidth(0), charHeight(0), textWidth(0), textHeight(0), maxLineLength(0), cursor(LoadStandardCursor(StandardCursorId.IDC_IBEAM)), caretLine(1), caretColumn(1),
            caretTimerPeriod(defaultCaretTimerPeriod), update(false), topLine(1), topLineDiff(0.0f), leftCol(1), leftColDiff(0.0f),
            padding(), selectionBackgroundColor(DefaultSelectionBackgroundColor()), textColor(textColor_)
        {
            uint caretTimeOut = 0u;
            bool succeeded = ReadCaretTimeoutFromRegistry(caretTimeOut);
            if (succeeded)
            {
                caretTimerPeriod = caretTimeOut;
            }
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
            SetChanged();
            measureString = "// this file has been semiautomatically generated from 'D:/work/soulng-project/sngcm/ast/AstReader.hpp' using cpp2cm version 1.0.0";
        }
        public TextView(const Point& location, const Size& size, Dock dock, Anchors anchors) : this(FontFamily("Consolas"), 10.0f, Color.White(), Color.Black(),
            location, size, dock, anchors)
        {
        }
        public nothrow const System.Windows.Color& GetTextColor() const
        {
            return textColor;
        }
        public nothrow void SetTextColor(const System.Windows.Color& textColor_)
        {
            textColor = textColor_;
        }
        public nothrow const System.Windows.Color& GetSelectionBackgroundColor() const
        {
            return selectionBackgroundColor;
        }
        public nothrow void SetSelectionBackgroundColor(const System.Windows.Color& selectionBackgroundColor_)
        {
            selectionBackgroundColor = selectionBackgroundColor_;
        }
        public nothrow inline List<ustring>& Lines()
        {
            return lines;
        }
        public nothrow inline const List<ustring>& Lines() const
        {
            return lines;
        }
        public void AddLine(const ustring& line)
        {
            lines.Add(line);
            SetMaxLineLength();
        }
        public void SetFont(const FontFamily& fontFamily_, float fontSize_)
        {
            fontFamily = fontFamily_;
            fontSize = fontSize_;
            fonts.Clear();
            OnFontChanged();
            SetChanged();
        }
        protected virtual void OnFontChanged()
        {
            Font* font = new Font(fontFamily, fontSize, FontStyle.regular, Unit.point);
            fonts.Add(UniquePtr<Font>(font));
        }
        public nothrow inline float CharWidth() const
        {
            return charWidth;
        }
        public nothrow inline float CharHeight() const
        {
            return charHeight;
        }
        public nothrow inline int TextWidth() const
        {
            return textWidth;
        }
        public nothrow inline int TextHeight() const
        {
            return textHeight;
        }
        public nothrow inline FontFamily& GetFontFamily() const
        {
            return fontFamily;
        }
        public nothrow inline float FontSize() const
        {
            return fontSize;
        }
        public nothrow inline const List<UniquePtr<Font>>& Fonts() const
        {
            return fonts;
        }
        public nothrow inline List<UniquePtr<Font>>& Fonts()
        {
            return fonts;
        }
        public void SetCaretLineCol(int line, int column)
        {
            if (caretLine != line || caretColumn != column)
            {
                caretLine = line;
                caretColumn = column;
                SetCaretLocation();
            }
        }
        public nothrow inline int TopLine() const
        {
            return topLine;
        }
        public nothrow inline float TopLineDiff() const
        {
            return topLineDiff;
        }
        public nothrow inline int LeftColumn() const
        {
            return leftCol;
        }
        public nothrow inline float LeftColumnDiff() const
        {
            return leftColDiff;
        }
        public nothrow inline int CaretLine() const
        {
            return caretLine;
        }
        public nothrow inline int CaretColumn() const
        {
            return caretColumn - LineNumberFieldLength();
        }
        public void SetTopLineCol(int line, int column)
        {
            Point newOrigin(cast<int>((column - 1) * charWidth), cast<int>((line - 1) * charHeight));
            topLine = cast<int>(newOrigin.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - newOrigin.y;
            leftCol = cast<int>(newOrigin.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - newOrigin.x;
            SetContentLocation(newOrigin);
            Invalidate();
        }
        public nothrow inline int GetVisibleLineCount() const
        {
            Size size = GetSize();
            return cast<int>(size.h / charHeight);
        }
        public nothrow inline int GetVisibleColumnCount() const
        {
            Size size = GetSize();
            return cast<int>(size.w / charWidth);
        }
        public nothrow inline bool IsLinePartiallyVisible(int line) const
        {
            return line >= (topLine - 1) && line < (topLine + GetVisibleLineCount() + 1);
        }
        public nothrow inline bool IsLineVisible(int line) const
        {
            return line >= topLine && line < topLine + GetVisibleLineCount();
        }
        public virtual nothrow void GetLineColumn(const Point& contentLocation, int& line, short& column) const
        {
            line = cast<int>(contentLocation.y / charHeight + 1);
            column = cast<short>(contentLocation.x / charWidth + 1);
        }
        public void EnsureLineVisible(int line)
        {
            Invalidate();
            Application.ProcessMessages();
            if (IsLineVisible(line))
            {
                return;
            }
            int tl = Max(cast<int>(1), line - GetVisibleLineCount() / 2);
            SetTopLineCol(tl, 1);
        }
        public virtual void Clear()
        {
            ustring emptyContent;
            SetTextContent(emptyContent);
        }
        public void SetTextContent(const ustring& textContent)
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            lines = SplitTextIntoLines(textContent);
            lineStartIndeces = CalculateLineStartIndeces(textContent);
            SetMaxLineLength();
            OnLinesChanged();
            SetContentChanged();
            SetChanged();
            SetCaretLineCol(1, 1 + LineNumberFieldLength());
            Invalidate();
            update = true;
        }
        public nothrow int GetLineLength(int lineNumber)
        {
            int lineLength = 0;
            if (lineNumber >= 1 && lineNumber <= lines.Count())
            {
                lineLength = cast<int>(lines[lineNumber - 1].Length());
            }
            return lineLength;
        }
        public nothrow bool Prev(int& line, int& col)
        {
            if (col > 1)
            {
                --col;
                return true;
            }
            else
            {
                if (line > 1)
                {
                    --line;
                    int lineLength = GetLineLength(line);
                    if (lineLength > 0)
                    {
                        col = lineLength;
                    }
                    else
                    {
                        col = 1;
                    }
                    return true;
                }
            }
            return false;
        }
        public nothrow bool Next(int& line, int& col)
        {
            int lineLength = GetLineLength(line);
            if (col < lineLength)
            {
                ++col;
                return true;
            }
            else
            {
                if (line < lines.Count())
                {
                    ++line;
                    col = 1;
                    return true;
                }
            }
            return false;
        }
        public nothrow void PrevWord(int& line, int& col)
        {
            LogView* log = Application.GetLogView();
            if (Prev(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Prev(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                if (IsWhiteSpace(c))
                {
                    Next(line, col);
                }
            }
        }
        public nothrow void NextWord(int& line, int& col)
        {
            if (Next(line, col))
            {
                uchar c = GetCharAt(line, col);
                while (!IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
                c = GetCharAt(line, col);
                while (IsWhiteSpace(c))
                {
                    if (col == 1 || !Next(line, col))
                    {
                        return;
                    }
                    c = GetCharAt(line, col);
                }
            }
        }
        private nothrow void GotoCaretLine()
        {
            ControlEventArgs args(this);
            OnGotoCaretLine(args);
        }
        protected virtual void OnGotoCaretLine(ControlEventArgs& args)
        {
            gotoCaretLineEvent.Fire(args);
        }
        public nothrow uchar GetCharAt(int line, int column) const
        {
            if (line < 1)
            {
                line = 1;
            }
            else if (line > lines.Count())
            {
                line = cast<int>(lines.Count());
            }
            int lineLength = GetLineLength(line);
            if (column < 1)
            {
                column = 1;
            }
            else
            {
                if (lineLength > 0 && column > lineLength)
                {
                    column = lineLength;
                }
            }
            if (line >= 1 && line <= lines.Count() && column >= 1 && column <= lineLength)
            {
                return lines[line - 1][column - 1];
            }
            return '\0';
        }
        public void SetCaretPosByCharIndex(int charIndex)
        {
            List<int>.ConstIterator it = LowerBound(lineStartIndeces.CBegin(), lineStartIndeces.CEnd(), charIndex);
            if (it != lineStartIndeces.CBegin() && it == lineStartIndeces.CEnd())
            {
                --it;
            }
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                if (*it > charIndex)
                {
                    --it;
                }
            }
            int lineNumber = cast<int>(it - lineStartIndeces.CBegin() + 1);
            int columnNumber = 1 + LineNumberFieldLength();
            if (it >= lineStartIndeces.CBegin() && it != lineStartIndeces.CEnd())
            {
                int lineStartCharIndex = *it;
                columnNumber = charIndex - lineStartCharIndex + 1 + LineNumberFieldLength();
            }
            SetCaretLineCol(lineNumber, columnNumber);
            ScrollToCaret();
        }
        public int GetCharIndex(int line, int column) const
        {
            if (line >= 1 && line <= lineStartIndeces.Count())
            {
                int lineStartIndex = lineStartIndeces[line - 1];
                int lineLength = GetLineLength(line);
                if (column >= 1 && column <= lineLength)
                {
                    return lineStartIndex + column - 1;
                }
            }
            return -1;
        }
        protected override void OnPaint(PaintEventArgs& args)
        {
            try
            {
                PaintContent(args.graphics);
                base->OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected virtual void PaintContent(Graphics& graphics)
        {
            if (Changed())
            {
                ResetChanged();
                Measure(graphics);
                if (Focused())
                {
                    SetCaretLocation();
                    ShowCaret();
                }
            }
            TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
            graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
            graphics.ClearChecked(BackgroundColor());
            int n = cast<int>(lines.Count());
            SetLineNumberFieldLength(n);
            int lineNumberFieldLength = LineNumberFieldLength();
            PointF origin(0, 0);
            for (int i = 0; i < n; ++i)
            {
                if (IsLinePartiallyVisible(i + 1))
                {
                    DrawSelectionBackground(graphics, i + 1, origin, lineNumberFieldLength);
                    DrawLine(graphics, i, origin);
                }
                origin.y = origin.y + charHeight;
            }
            graphics.SetTextRenderingHintChecked(prevRenderingHint);
        }
        private void DrawSelectionBackground(Graphics& graphics, int line, const PointF& origin, int lineNumberFieldLength)
        {
            if (selection.IsEmpty()) return;
            if (line < selection.start.line) return;
            if (line > selection.end.line) return;
            PointF pt(origin);
            pt.x = pt.x + charWidth * lineNumberFieldLength;
            RectF rect;
            if (line > selection.start.line && line < selection.end.line)
            {
                int lineLength = Max(1, GetLineLength(line));
                rect = RectF(pt, SizeF(charWidth * lineLength, charHeight));
            }
            else if (selection.start.line == selection.end.line)
            {
                pt.x = pt.x + charWidth * (selection.start.column - 1);
                int selectionLength = selection.end.column - selection.start.column;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            else if (line == selection.start.line)
            {
                pt.x = pt.x + charWidth * (selection.start.column - 1);
                int lineLength = GetLineLength(line);
                int selectionLength = lineLength - selection.start.column + 1;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            else if (line == selection.end.line)
            {
                int selectionLength = selection.end.column - 1;
                rect = RectF(pt, SizeF(charWidth * selectionLength, charHeight));
            }
            Brush* brush = GetOrInsertBrush(selectionBackgroundColor);
            graphics.FillRectangleChecked(*brush, rect);
        }
        protected virtual void DrawLine(Graphics& graphics, int lineIndex, const PointF& origin)
        {
            if (!fonts.IsEmpty())
            {
                PointF pt(origin);
                const ustring& line = lines[lineIndex];
                string s(ToUtf8(line));
                Brush* brush = GetOrInsertBrush(textColor);
                graphics.DrawStringChecked(s, *fonts[0], pt, *brush);
            }
        }
        protected virtual void Measure(Graphics& graphics)
        {
            charWidth = 0;
            charHeight = 0;
            string ms;
            bool measure = false;
            if (IsFixed())
            {
                ms = measureString;
                maxLineLength = cast<int>(ToUtf32(measureString).Length());
                measure = true;
            }
            else
            {
                if (!lines.IsEmpty() && maxLineLength > 0)
                {
                    ms = ToUtf8(lines[maxLineIndex]);
                    measure = true;
                }
            }
            if (measure)
            {
                for (const UniquePtr<Font>& font : fonts)
                {
                    TextRenderingHint prevRenderingHint = graphics.GetTextRenderingHint();
                    graphics.SetTextRenderingHintChecked(TextRenderingHint.clearTypeGridFit);
                    RectF charRect = graphics.MeasureStringChecked(ms, *font, PointF(0, 0), drawFormat);
                    graphics.SetTextRenderingHintChecked(prevRenderingHint);
                    charWidth = Max(charWidth, charRect.size.w / maxLineLength);
                    charHeight = Max(charHeight, charRect.size.h);
                }
            }
            SetScrollUnits(cast<int>(charHeight), cast<int>(2 * charWidth));
            SetTextExtent();
        }
        private void SetTextExtent()
        {
            textWidth = cast<int>(maxLineLength * charWidth);
            textHeight = cast<int>(lines.Count() * charHeight);
            SetContentSize(Size(textWidth, textHeight));
        }
        protected override void OnMouseDown(MouseEventArgs& args)
        {
            base->OnMouseDown(args);
            SetFocus(this);
            ResetSelection();
            if (charHeight != 0 && charWidth != 0)
            {
                if ((args.buttons == MouseButtons.lbutton || args.buttons == MouseButtons.rbutton) && args.clicks == 1)
                {
                    Point loc = args.location;
                    int lineNumber = cast<int>(loc.y / charHeight + 1.5);
                    lineNumber = Max(1, Min(lineNumber, cast<int>(lines.Count())));
                    int columnNumber = cast<int>(loc.x / charWidth + 1.5);
                    columnNumber = Max(columnNumber, 1 + LineNumberFieldLength());
                    int lineLength = GetLineLength(lineNumber);
                    columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                    if (update)
                    {
                        update = false;
                        Invalidate();
                    }
                    SetCaretLineCol(lineNumber, columnNumber);
                    if (args.buttons == MouseButtons.rbutton)
                    {
                        RightClickEventArgs rightClickArgs(this, loc);
                        OnRightClick(rightClickArgs);
                    }
                }
            }
        }
        protected override void OnKeyDown(KeyEventArgs& args)
        {
            base->OnKeyDown(args);
            if (!args.handled)
            {
                bool scrolled = false;
                int lineNumber = caretLine;
                int columnNumber = caretColumn;
                switch (args.keyData)
                {
                    case Keys.home:
                    {
                        ResetSelection();
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.home):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(CaretLine(), 1);
                        ExtendSelection(start, end);
                        columnNumber = 1 + LineNumberFieldLength();
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case Keys.end:
                    {
                        ResetSelection();
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.end):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(CaretLine(), GetLineLength(lineNumber) + 1);
                        ExtendSelection(start, end);
                        columnNumber = GetLineLength(lineNumber) + 1 + LineNumberFieldLength();
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case Keys.left:
                    {
                        ResetSelection();
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            --columnNumber;
                        }
                        else if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.left):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        if (columnNumber > 1 + LineNumberFieldLength())
                        {
                            SourcePos end(start);
                            --columnNumber;
                            --end.column;
                            ExtendSelection(start, end);
                            Invalidate();
                        }
                        else if (lineNumber > 1)
                        {
                            SourcePos end(start);
                            --lineNumber;
                            --end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = lineLength + 1 + LineNumberFieldLength();
                            end.column = lineLength + 1;
                            ExtendSelection(start, end);
                            Invalidate();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.right:
                    {
                        ResetSelection();
                        if (lineNumber <= lines.Count())
                        {
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                            }
                            else
                            {
                                ++lineNumber;
                                columnNumber = 1 + LineNumberFieldLength();
                            }
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.right):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        if (lineNumber <= lines.Count())
                        {
                            SourcePos end(start);
                            int lineLength = GetLineLength(lineNumber);
                            if (columnNumber < lineLength + 1 + LineNumberFieldLength())
                            {
                                ++columnNumber;
                                ++end.column;
                                ExtendSelection(start, end);
                            }
                            else
                            {
                                ++lineNumber;
                                ++end.line;
                                columnNumber = 1 + LineNumberFieldLength();
                                end.column = 1;
                                ExtendSelection(start, end);
                            }
                            Invalidate();
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.down:
                    {
                        ResetSelection();
                        if (lineNumber < lines.Count())
                        {
                            ++lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        else
                        {
                            lineNumber = cast<int>(lines.Count()) + 1;
                            columnNumber = 1 + LineNumberFieldLength();
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.down):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        if (lineNumber < lines.Count())
                        {
                            ++lineNumber;
                            ++end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            end.column = Min(end.column, lineLength + 1);
                        }
                        else
                        {
                            lineNumber = cast<int>(lines.Count()) + 1;
                            end.line = cast<int>(lines.Count()) + 1;
                            columnNumber = 1 + LineNumberFieldLength();
                            end.column = 1;
                        }
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case Keys.up:
                    {
                        ResetSelection();
                        if (lineNumber > 1)
                        {
                            --lineNumber;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                        }
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.up):
                    {
                        if (lineNumber > 1)
                        {
                            SourcePos start(CaretLine(), CaretColumn());
                            SourcePos end(start);
                            --lineNumber;
                            --end.line;
                            int lineLength = GetLineLength(lineNumber);
                            columnNumber = Min(columnNumber, lineLength + 1 + LineNumberFieldLength());
                            end.column = Min(end.column, lineLength + 1);
                            Invalidate();
                            ExtendSelection(start, end);
                        }
                        args.handled = true;
                        break;
                    }
                    case Keys.pageDown:
                    {
                        ResetSelection();
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber + windowLines;
                        lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.pageDown):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber + windowLines;
                        end.line = end.line + windowLines;
                        lineNumber = Min(lineNumber, cast<int>(lines.Count()) + 1);
                        end.line = Min(end.line, cast<int>(lines.Count()) + 1);
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case Keys.pageUp:
                    {
                        ResetSelection();
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber - windowLines;
                        lineNumber = Max(lineNumber, 1);
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.pageUp):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        Size size = GetSize();
                        int windowLines = cast<int>(size.h / charHeight);
                        lineNumber = lineNumber - windowLines;
                        end.line = end.line - windowLines;
                        lineNumber = Max(lineNumber, 1);
                        end.line = Max(end.line, 1);
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.home):
                    {
                        ResetSelection();
                        lineNumber = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.home):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        lineNumber = 1;
                        end.line = 1;
                        columnNumber = 1 + LineNumberFieldLength();
                        end.column = 1;
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.end):
                    {
                        ResetSelection();
                        lineNumber = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.end):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        lineNumber = cast<int>(lines.Count() + 1);
                        end.line = cast<int>(lines.Count() + 1);
                        columnNumber = 1 + LineNumberFieldLength();
                        end.column = 1;
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.left):
                    {
                        ResetSelection();
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.left):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        PrevWord(line, col);
                        lineNumber = line;
                        end.line = line;
                        columnNumber = col + LineNumberFieldLength();
                        end.column = col;
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.right):
                    {
                        ResetSelection();
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        columnNumber = col + LineNumberFieldLength();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.controlModifier | Keys.right):
                    {
                        SourcePos start(CaretLine(), CaretColumn());
                        SourcePos end(start);
                        int line = lineNumber;
                        int col = columnNumber - LineNumberFieldLength();
                        NextWord(line, col);
                        lineNumber = line;
                        end.line = line;
                        columnNumber = col + LineNumberFieldLength();
                        end.column = col;
                        ExtendSelection(start, end);
                        Invalidate();
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.down):
                    {
                        ResetSelection();
                        ScrollLineDown();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.up):
                    {
                        ResetSelection();
                        ScrollLineUp();
                        scrolled = true;
                        args.handled = true;
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.k):
                    {
                        ResetSelection();
                        GotoCaretLine();
                        args.handled = true;
                        break;
                    }
                    case Keys.delete_:
                    {
                        if (!IsReadOnly())
                        {
                            if (selection.IsEmpty())
                            {
                                int lineIndex = caretLine - 1;
                                int columnIndex = CaretColumn() - 1;
                                DeleteChar(lineIndex, columnIndex);
                            }
                            else
                            {
                                RemoveSelection();
                            }
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.back:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            Backspace(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.enter:
                    {
                        if (!IsReadOnly())
                        {
                            ResetSelection();
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            NewLine(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case Keys.tab:
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            Tab(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.tab):
                    {
                        if (!IsReadOnly())
                        {
                            int lineIndex = caretLine - 1;
                            int columnIndex = CaretColumn() - 1;
                            Backtab(lineIndex, columnIndex);
                            args.handled = true;
                            return;
                        }
                        break;
                    }
                    case cast<Keys>(Keys.controlModifier | Keys.insert):
                    {
                        if (selection.IsEmpty()) return;
                        OnCopy();
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.insert):
                    {
                        OnPaste();
                        break;
                    }
                    case cast<Keys>(Keys.shiftModifier | Keys.delete_):
                    {
                        if (selection.IsEmpty()) return;
                        OnCut();
                        break;
                    }
                }
                if (args.handled && !scrolled)
                {
                    SetCaretLineCol(lineNumber, columnNumber);
                    ScrollToCaret();
                }
            }
        }
        protected override void OnKeyPress(KeyPressEventArgs& args)
        {
            base->OnKeyPress(args);
            if (IsReadOnly()) return;
            if (!args.handled)
            {
                ResetSelection();
                uchar c(args.keyChar);
                int lineIndex = caretLine - 1;
                int columnIndex = CaretColumn() - 1;
                InsertChar(lineIndex, columnIndex, c);
                KeyEventArgs rightArgs(Keys.right, Keys.none);
                OnKeyDown(rightArgs);
                args.handled = true;
            }
        }
        private void InsertChar(int lineIndex, int columnIndex, uchar c)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex, c);
            if (line.Length() > maxLineLength)
            {
                maxLineLength = cast<int>(line.Length());
                maxLineIndex = lineIndex;
                SetTextExtent();
            }
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetDirty();
        }
        public void InsertText(int lineIndex, int columnIndex, const ustring& text)
        {
            if (text.IsEmpty()) return;
            int indent = 0;
            if (lineIndex > 0 && lineIndex < lines.Count())
            {
                indent = GetIndent(lines[lineIndex - 1], lineIndex - 1);
            }
            List<ustring> linesToInsert = SplitTextIntoLines(text);
            int indentLineIndex = lineIndex - 1;
            for (const ustring& lineToInsert : linesToInsert)
            {
                lines.Insert(lines.Begin() + lineIndex, lineToInsert);
                SetLineNumberFieldLength(cast<int>(lines.Count()));
                LineEventArgs insertedArgs(lineIndex, indentLineIndex);
                OnLineInserted(insertedArgs);
                ++lineIndex;
            }
            SetCaretLineCol(lineIndex, 1 + LineNumberFieldLength() + indent);
            ScrollToCaret();
            Invalidate();
            SetDirty();
        }
        private void DeleteChar(int lineIndex, int columnIndex)
        {
            ustring& line = lines[lineIndex];
            if (columnIndex < line.Length())
            {
                line.Remove(columnIndex, 1);
                LineEventArgs args(lineIndex, -1);
                OnLineChanged(args);
            }
            else
            {
                if (lines.Count() > lineIndex + 1)
                {
                    line.Append(lines[lineIndex + 1]);
                    LineEventArgs changedArgs(lineIndex, -1);
                    OnLineChanged(changedArgs);
                    lines.Remove(lines.Begin() + lineIndex + 1);
                    LineEventArgs deletedArgs(lineIndex + 1, -1);
                    OnLineDeleted(deletedArgs);
                }
            }
            SetDirty();
        }
        private void Backspace(int lineIndex, int columnIndex)
        {
            if (lineIndex != 0 || columnIndex != 0)
            {
                KeyEventArgs leftArgs(Keys.left, Keys.none);
                OnKeyDown(leftArgs);
                KeyEventArgs deleteArgs(Keys.delete_, Keys.none);
                OnKeyDown(deleteArgs);
            }
        }
        protected virtual nothrow int GetIndent(const ustring& line, int lineIndex) const
        {
            return 0;
        }
        protected virtual nothrow int RemoveIndent(int lineIndex) const
        {
            return 0;
        }
        private void NewLine(int lineIndex, int columnIndex)
        {
            ustring& line = lines[lineIndex];
            ustring toInsert = TrimEnd(line.Substring(columnIndex));
            bool lineChanged = false;
            if (!toInsert.IsEmpty())
            {
                line.Remove(columnIndex, line.Length() - columnIndex);
                lineChanged = true;
            }
            int removeIndent = RemoveIndent(lineIndex);
            if (removeIndent > 0 && line.Length() >= removeIndent)
            {
                line.Remove(0, removeIndent);
                lineChanged = true;
            }
            ustring trimmedLine = TrimEnd(line);
            if (trimmedLine.Length() != line.Length())
            {
                Swap(line, trimmedLine);
                lineChanged = true;
            }
            if (lineChanged)
            {
                LineEventArgs changedArgs(lineIndex, -1);
                OnLineChanged(changedArgs);
            }
            lines.Insert(lines.Begin() + lineIndex + 1, toInsert);
            SetLineNumberFieldLength(cast<int>(lines.Count()));
            LineEventArgs insertedArgs(lineIndex + 1, lineIndex);
            OnLineInserted(insertedArgs);
            SetCaretLineCol(lineIndex + 1 + 1, 1 + LineNumberFieldLength() + GetIndent(line, lineIndex));
            ScrollToCaret();
            Invalidate();
            SetDirty();
        }
        protected virtual nothrow int IndentSize() const
        {
            return 0;
        }
        private void Tab(int lineIndex, int columnIndex)
        {
            while (lineIndex >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[lineIndex];
            line.Insert(columnIndex, ustring(' ', IndentSize()));
            if (line.Length() > maxLineLength)
            {
                maxLineLength = cast<int>(line.Length());
                maxLineIndex = lineIndex;
                SetTextExtent();
            }
            LineEventArgs args(lineIndex, -1);
            OnLineChanged(args);
            SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() + IndentSize());
            ScrollToCaret();
            Invalidate();
            SetDirty();
        }
        private void Backtab(int lineIndex, int columnIndex)
        {
            if (lineIndex >= lines.Count()) return;
            ustring& line = lines[lineIndex];
            int targetCol = Max(cast<int>(1), columnIndex - IndentSize() + 1);
            int numSpaces = 0;
            int col = 0;
            for (int i = columnIndex; i >= targetCol; --i)
            {
                if (line[i - 1] == ' ')
                {
                    col = i - 1;
                    ++numSpaces;
                }
                else
                {
                    break;
                }
            }
            if (numSpaces > 0)
            {
                line.Remove(col, numSpaces);
                LineEventArgs args(lineIndex, -1);
                OnLineChanged(args);
                SetCaretLineCol(lineIndex + 1, columnIndex + 1 + LineNumberFieldLength() - numSpaces);
                ScrollToCaret();
                Invalidate();
                SetDirty();
            }
        }
        protected virtual void OnCopy()
        {
            copyEvent.Fire();
        }
        protected virtual void OnPaste()
        {
            pasteEvent.Fire();
        }
        protected virtual void OnCut()
        {
            cutEvent.Fire();
        }
        protected override nothrow void SetContentLocationInternal(const Point& contentLocation)
        {
            topLine = cast<int>(contentLocation.y / charHeight + 1.5f);
            topLineDiff = (topLine - 1) * charHeight - contentLocation.y;
            leftCol = cast<int>(contentLocation.x / charWidth + 1.5f);
            leftColDiff = (leftCol - 1) * charWidth - contentLocation.x;
            base->SetContentLocationInternal(contentLocation);
        }
        public void ScrollToCaret()
        {
            if (lines.IsEmpty() || charHeight == 0) return;
            Size size = GetSize();
            int windowLines = cast<int>(size.h / charHeight);
            int windowCols = cast<int>(size.w / charWidth);
            Point currentOrigin = ContentLocation();
            int topLineNumber = cast<int>(currentOrigin.y / charHeight + 1);
            int leftColNumber = cast<int>(currentOrigin.x / charWidth + 1);
            int oldTopLineNumber = topLineNumber;
            if (caretLine > topLineNumber)
            {
                while (caretLine - topLineNumber + 1 >= windowLines)
                {
                    ++topLineNumber;
                }
            }
            else if (caretLine < topLineNumber)
            {
                topLineNumber = caretLine;
            }
            else
            {
                topLineNumber = Max(cast<int>(1), caretLine - 1);
            }
            int oldLeftColNumber = leftColNumber;
            if (caretColumn >= leftColNumber)
            {
                while (caretColumn - leftColNumber + 2 >= windowCols)
                {
                    ++leftColNumber;
                }
            }
            else
            {
                if (caretColumn == 1 + LineNumberFieldLength())
                {
                    leftColNumber = 1;
                }
                else
                {
                    leftColNumber = caretColumn;
                }
            }
            if (update || caretLine == 1 || topLineNumber != oldTopLineNumber || leftColNumber != oldLeftColNumber)
            {
                update = false;
                Point newOrigin(cast<int>((leftColNumber - 1) * charWidth), cast<int>((topLineNumber - 1) * charHeight));
                topLine = topLineNumber;
                topLineDiff = 0.0f;
                leftCol = leftColNumber;
                leftColDiff = 0.0f;
                SetContentLocation(newOrigin);
                SetCaretLocation();
                Invalidate();
            }
        }
        protected virtual nothrow int LineNumberFieldLength() const
        {
            return 0;
        }
        protected virtual nothrow void SetLineNumberFieldLength(int lineCount)
        {
        }
        protected override void CreateCaret()
        {
            if (charHeight != 0)
            {
                System.Windows.API.CreateCaret(Handle(), null, 1, cast<int>(charHeight));
            }
            else
            {
                base->CreateCaret();
            }
            SetTimer(1u, caretTimerPeriod);
        }
        protected override void OnTimer(TimerEventArgs& args)
        {
            base->OnTimer(args);
            if (Focused())
            {
                HideCaret();
                ShowCaret();
            }
        }
        protected override void OnClick()
        {
            base->OnClick();
            SetFocus();
            ResetSelection();
        }
        protected override void SetCursor()
        {
            SetCursor(cursor);
        }
        protected override void SetCaretLocation()
        {
            int x = cast<int>(padding.left + (caretColumn - 1) * charWidth);
            int y = cast<int>(padding.top + (caretLine - 1) * charHeight);
            Point caretPos(x, y);
            TranslateContentLocation(caretPos);
            if (CaretCreated())
            {
                SetCaretPos(caretPos);
                OnCaretPosChanged();
            }
        }
        protected virtual void OnCaretPosChanged()
        {
            caretPosChangedEvent.Fire();
        }
        protected virtual void OnLinesChanged()
        {
            linesChangedEvent.Fire();
        }
        protected virtual void OnLineChanged(LineEventArgs& args)
        {
            lineChangedEvent.Fire(args);
        }
        protected virtual void OnLineDeleted(LineEventArgs& args)
        {
            lineDeletedEvent.Fire(args);
        }
        protected virtual void OnLineInserted(LineEventArgs& args)
        {
            lineInsertedEvent.Fire(args);
        }
        public nothrow inline int MaxLineLength() const
        {
            return maxLineLength;
        }
        public nothrow inline int MaxLineIndex() const
        {
            return maxLineIndex;
        }
        protected nothrow void SetMaxLineLength()
        {
            maxLineLength = 0;
            maxLineIndex = 0;
            int n = cast<int>(lines.Count());
            for (int i = 0; i < n; ++i)
            {
                const ustring& line = lines[i];
                if (line.Length() > maxLineLength)
                {
                    maxLineLength = cast<int>(line.Length());
                    maxLineIndex = i;
                }
            }
        }
        public nothrow inline const Padding& GetPadding() const
        {
            return padding;
        }
        public nothrow void SetPadding(const Padding& padding_)
        {
            if (padding != padding_)
            {
                padding = padding_;
                Invalidate();
            }
        }
        protected virtual void OnSelectionChanged()
        {
            selectionChangedEvent.Fire();
        }
        public nothrow void ResetSelection()
        {
            if (!selection.IsEmpty())
            {
                selection = Selection();
                OnSelectionChanged();
                Invalidate();
            }
        }
        public nothrow bool IsSelectionEmpty() const
        {
            return selection.IsEmpty();
        }
        public nothrow ustring GetSelection() const
        {
            if (selection.IsEmpty()) return ustring();
            if (selection.start.line == selection.end.line)
            {
                ustring s = lines[selection.start.line - 1].Substring(selection.start.column - 1, selection.end.column - selection.start.column);
                return Unindent(s, MinIndent(s));
            }
            else
            {
                ustring s = lines[selection.start.line - 1].Substring(selection.start.column - 1).Append(u"\n");
                for (int i = selection.start.line; i < selection.end.line - 1; ++i)
                {
                    s.Append(lines[i]).Append(u"\n");
                }
                if (!lines[selection.end.line - 1].Substring(0, selection.end.column - 1).IsEmpty())
                {
                    s.Append(lines[selection.end.line - 1].Substring(0, selection.end.column - 1)).Append(u"\n");
                }
                return Unindent(s, MinIndent(s));
            }
        }
        public nothrow void RemoveSelection()
        {
            if (selection.IsEmpty()) return;
            if (selection.start.line == selection.end.line)
            {
                if (selection.end.column - selection.start.column >= GetLineLength(selection.start.line))
                {
                    int lineIndex = selection.start.line - 1;
                    lines.Remove(lines.Begin() + lineIndex);
                    LineEventArgs deleteArgs(lineIndex, -1);
                    OnLineDeleted(deleteArgs);
                    SetCaretLineCol(lineIndex, 1 + LineNumberFieldLength());
                }
                else
                {
                    int lineIndex = selection.start.line - 1;
                    lines[lineIndex].Remove(selection.start.column - 1, selection.end.column - selection.start.column);
                    LineEventArgs changeArgs(lineIndex, -1);
                    OnLineChanged(changeArgs);
                    SetCaretLineCol(lineIndex + 1, selection.start.column + LineNumberFieldLength());
                }
            }
            else
            {
                int startLineIndex = selection.start.line - 1;
                int endLineIndex = selection.end.line - 1;
                if (selection.start.column > 1)
                {
                    lines[startLineIndex].Remove(selection.start.column - 1, GetLineLength(startLineIndex + 1) - selection.start.column + 1);
                    LineEventArgs changeArgs(startLineIndex, -1);
                    OnLineChanged(changeArgs);
                    ++startLineIndex;
                }
                else
                {
                    lines.Remove(lines.Begin() + startLineIndex);
                    --endLineIndex;
                    LineEventArgs deleteArgs(startLineIndex, -1);
                    OnLineDeleted(deleteArgs);
                }
                int n = endLineIndex;
                for (int i = startLineIndex; i < n; ++i)
                {
                    lines.Remove(lines.Begin() + startLineIndex);
                    --endLineIndex;
                    LineEventArgs deleteArgs(startLineIndex, -1);
                    OnLineDeleted(deleteArgs);
                }
                if (endLineIndex >= 0 && endLineIndex < lines.Count())
                {
                    if (selection.end.column > GetLineLength(endLineIndex + 1))
                    {
                        lines.Remove(lines.Begin() + endLineIndex);
                        LineEventArgs deleteArgs(endLineIndex, -1);
                        OnLineDeleted(deleteArgs);
                    }
                    else
                    {
                        lines[endLineIndex].Remove(0, selection.end.column - 1);
                        LineEventArgs changeArgs(endLineIndex, -1);
                        OnLineChanged(changeArgs);
                    }
                }
                SetCaretLineCol(selection.start.line, selection.start.column + LineNumberFieldLength());
            }
            ResetSelection();
            Invalidate();
            SetDirty();
        }
        public nothrow void ExtendSelection(const SourcePos& start, const SourcePos& end)
        {
            switch (selection.fixed)
            {
                case Selection.Fix.none:
                {
                    if (start < end)
                    {
                        selection.fixed = Selection.Fix.start;
                        selection.start = start;
                        selection.end = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.end;
                        selection.end = start;
                        selection.start = end;
                    }
                    break;
                }
                case Selection.Fix.start:
                {
                    if (end == selection.start)
                    {
                        ResetSelection();
                    }
                    else if (end > selection.start)
                    {
                        selection.end = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.end;
                        selection.end = start;
                        selection.start = end;
                    }
                    break;
                }
                case Selection.Fix.end:
                {
                    if (end == selection.end)
                    {
                        ResetSelection();
                    }
                    else if (end < selection.end)
                    {
                        selection.start = end;
                    }
                    else
                    {
                        selection.fixed = Selection.Fix.start;
                        selection.start = start;
                        selection.end = end;
                    }
                    break;
                }
            }
            OnSelectionChanged();
        }
        public Brush* GetOrInsertBrush(const Color& color)
        {
            HashMap<Color, Brush*>.ConstIterator it = colorBrushMap.CFind(color);
            if (it != colorBrushMap.CEnd())
            {
                return it->second;
            }
            Brush* brush = new SolidBrush(color);
            brushes.Add(UniquePtr<Brush>(brush));
            colorBrushMap[color] = brush;
            return brush;
        }
        protected inline nothrow bool Changed() const
        {
            return (flags & Flags.changed) != Flags.none;
        }
        protected inline nothrow void SetChanged()
        {
            flags = cast<Flags>(flags | Flags.changed); 
        }
        protected inline nothrow void ResetChanged()
        {
            flags = cast<Flags>(flags & ~Flags.changed);
        }
        public inline nothrow bool Painting() const
        {
            return (flags &  Flags.painting) != Flags.none;
        }
        private inline nothrow void SetPainting()
        {
            flags = cast<Flags>(flags | Flags.painting);
        }
        private inline nothrow void ResetPainting()
        {
            flags = cast<Flags>(flags & ~Flags.painting);
        }
        public nothrow inline bool IsReadOnly() const
        {
            return (flags & Flags.readOnly) != Flags.none;
        }
        public nothrow void SetReadOnly()
        {
            flags = cast<Flags>(flags | Flags.readOnly);
        }
        public nothrow void ResetReadOnly()
        {
            flags = cast<Flags>(flags & ~Flags.readOnly);
        }
        public nothrow inline bool IsFixed() const
        {
            return (flags & Flags.fixed) != Flags.none;
        }
        public nothrow void SetFixed()
        {
            flags = cast<Flags>(flags | Flags.fixed);
        }
        public nothrow void ResetFixed()
        {
            flags = cast<Flags>(flags & ~Flags.fixed);
        }
        public nothrow inline bool IsDirty() const
        {
            return (flags & Flags.dirty) != Flags.none;
        }
        public nothrow void SetDirty()
        {
            flags = cast<Flags>(flags | Flags.dirty);
        }
        public nothrow void ResetDirty()
        {
            flags = cast<Flags>(flags & ~Flags.dirty);
        }
        public nothrow Event<CaretPosChangedEventHandler>& CaretPosChangedEvent() const
        {
            return caretPosChangedEvent;
        }
        public nothrow Event<LinesChangedEventHandler>& LinesChangedEvent() const
        {
            return linesChangedEvent;
        }
        public nothrow Event<LineChangedEventHandler, LineEventArgs>& LineChangedEvent() const
        {
            return lineChangedEvent;
        }
        public nothrow Event<LineDeletedEventHandler, LineEventArgs>& LineDeletedEvent() const
        {
            return lineDeletedEvent;
        }
        public nothrow Event<LineInsertedEventHandler, LineEventArgs>& LineInsertedEvent() const
        {
            return lineInsertedEvent;
        }
        public nothrow Event<GotoCaretLineEventHandler, ControlEventArgs>& GotoCaretLineEvent() const
        {
            return gotoCaretLineEvent;
        }
        public nothrow Event<SelectionChangedEventHandler>& SelectionChangedEvent() const
        {
            return selectionChangedEvent;
        }
        public nothrow Event<CopyEventHandler>& CopyEvent() const
        {
            return copyEvent;
        }
        public nothrow Event<CutEventHandler>& CutEvent() const
        {
            return cutEvent;
        }
        public nothrow Event<PasteEventHandler>& PasteEvent() const
        {
            return pasteEvent;
        }
        private Flags flags;
        private List<ustring> lines;
        private List<int> lineStartIndeces;
        private StringFormat drawFormat;
        private FontFamily fontFamily;
        private Color textColor;
        private List<UniquePtr<Font>> fonts;
        private List<UniquePtr<Brush>> brushes;
        private HashMap<Color, Brush*> colorBrushMap;
        private float fontSize;
        private float charWidth;
        private float charHeight;
        private int textWidth;
        private int textHeight;
        private int maxLineLength;
        private int maxLineIndex;
        private Cursor cursor;
        private int caretLine;
        private int caretColumn;
        private int topLine;
        private int leftCol;
        private float topLineDiff;
        private float leftColDiff;
        private uint caretTimerPeriod;
        private bool update;
        private Padding padding;
        private Event<CaretPosChangedEventHandler> caretPosChangedEvent;
        private Event<LinesChangedEventHandler> linesChangedEvent;
        private Event<LineChangedEventHandler, LineEventArgs> lineChangedEvent;
        private Event<LineDeletedEventHandler, LineEventArgs> lineDeletedEvent;
        private Event<LineInsertedEventHandler, LineEventArgs> lineInsertedEvent;
        private Event<GotoCaretLineEventHandler, ControlEventArgs> gotoCaretLineEvent;
        private Event<SelectionChangedEventHandler> selectionChangedEvent;
        private Event<CopyEventHandler> copyEvent;
        private Event<CutEventHandler> cutEvent;
        private Event<PasteEventHandler> pasteEvent;
        private string measureString;
        private Selection selection;
        private System.Windows.Color selectionBackgroundColor;
    }

    public nothrow ustring TrimEnd(const ustring& line)
    {
        long i = line.Length();
        while (i > 0 && IsWhiteSpace(line[i - 1]))
        {
            --i;
        }
        return line.Substring(0, i);
    }

    public List<ustring> SplitTextIntoLines(const ustring& text)
    {
        List<ustring> lines;
        ustring line;
        int state = 0;
        for (uchar c : text)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            lines.Add(TrimEnd(line));
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        lines.Add(TrimEnd(line));
                        line.Clear();
                        state = 0;
                        break;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            lines.Add(TrimEnd(line));
        }
        return lines;
    }

    public nothrow int MinIndent(const ustring& s)
    {
        if (s.IsEmpty()) return 0;
        int state = 0;
        int indent = 0;
        int minIndent = MaxValue<int>();
        for (uchar c : s)
        {
            switch (state)
            {
                case 0:
                {
                    if (c == ' ')
                    {
                        ++indent;
                    }
                    else if (c == '\n')
                    {
                        if (indent < minIndent)
                        {
                            minIndent = indent;
                        }
                        indent = 0;
                    }
                    else
                    {
                        if (indent < minIndent)
                        {
                            minIndent = indent;
                        }
                        indent = 0;
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        if (indent > 0 && indent < minIndent)
        {
            minIndent = indent;
        }
        return minIndent;
    }

    public nothrow ustring Unindent(const ustring& s, int indent)
    {
        if (indent == 0) return s;
        ustring line;
        ustring result;
        int state = 0;
        for (uchar c : s)
        {
            switch (state)
            {
                case 0:
                {
                    switch (c)
                    {
                        case '\n':
                        {
                            result.Append(line.Substring(indent)).Append('\n');
                            line.Clear();
                            break;
                        }
                        case '\r':
                        {
                            state = 1;
                            break;
                        }
                        default:
                        {
                            line.Append(c);
                            break;
                        }
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        result.Append(line.Substring(indent)).Append('\n');
                        line.Clear();
                        state = 0;
                    }
                    break;
                }
            }
        }
        if (!line.IsEmpty())
        {
            result.Append(line.Substring(indent));
        }
        return result;
    }

    public List<int> CalculateLineStartIndeces(const ustring& text)
    {
        List<int> indeces;
        int state = 0;
        int n = cast<int>(text.Length());
        for (int i = 0; i < n; ++i)
        {
            uchar c = text[i];
            switch (state)
            {
                case 0:
                {
                    indeces.Add(i);
                    if (c != '\n')
                    {
                        state = 1;
                    }
                    break;
                }
                case 1:
                {
                    if (c == '\n')
                    {
                        state = 0;
                    }
                    break;
                }
            }
        }
        return indeces;
    }

    internal bool ReadCaretTimeoutFromRegistry(uint& caretTimeout)
    {
        void* currentUserKey = null;
        bool openSucceeded = WinRegOpenCurrentUser(&currentUserKey);
        if (openSucceeded)
        {
            uint value = 0u;
            bool getValueSucceeded = WinRegGetDWordValue(currentUserKey, @"Control Panel\Desktop", "CaretTimeout", value);
            if (getValueSucceeded)
            {
                caretTimeout = value;
            }
            WinRegCloseKey(currentUserKey);
            return getValueSucceeded;
        }
        return false;
    }

}

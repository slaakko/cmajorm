// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows.API;

namespace System.Windows
{
    public class delegate void PaintEventHandler(PaintEventArgs& paintEventArgs);
    public class delegate void MouseEnterEventHandler();
    public class delegate void MouseEventHandler(MouseEventArgs& mouseEventargs);
    public class delegate void MouseLeaveEventHandler();
    public class delegate void MouseWheelEventHandler(MouseWheelEventArgs& mouseWheelEventArgs);
    public class delegate void KeyPressEventHandler(KeyPressEventArgs& keyPressEventArgs);
    public class delegate void KeyEventHandler(KeyEventArgs& keyEventArgs);
    public class delegate void ClickEventHandler();
    public class delegate void SizeChangedEventHandler();
    public class delegate void LocationChangedEventHandler();
    public class delegate void ContentSizeChangedEventHandler();
    public class delegate void ChildContentSizeChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void HScrollEventHandler(ScrollEventArgs& scrollEventArgs);
    public class delegate void VScrollEventHandler(ScrollEventArgs& scrollEventArgs);

    public inline nothrow WindowClassStyle DefaultWindowClassStyle()
    {
        return WindowClassStyle.CS_DBLCLKS;
    }

    public inline nothrow WindowStyle DefaultChildWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CHILD | WindowStyle.WS_VISIBLE | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow ExtendedWindowStyle DefaultExtendedWindowStyle()
    {
        return ExtendedWindowStyle.WS_EX_DEFAULT;
    }
    
    public abstract class Control : Component
    {
        private enum Flags : sbyte
        {
            none = 0, mouseInClient = 1 << 0, lbuttonPressed = 1 << 1, menuWantsKeys = 1 << 2, keyDownHandled = 1 << 3
        }
        public Control(const char* windowClassName_, WindowClassStyle windowClassStyle_, WindowStyle style_, ExtendedWindowStyle exStyle_, 
            const Color& backgroundColor_, const string& text_, const Point& location_, const Size& size_, Dock dock_, Anchors anchors_) : 
            windowClassName(windowClassName_), windowClassStyle(windowClassStyle_), style(style_), exStyle(exStyle_),
            backgroundColor(backgroundColor_), handle(null), text(text_), location(location_), size(size_), contentSize(), dock(dock_), anchors(anchors_), flags(Flags.none),
            arrowCursor(LoadStandardCursor(StandardCursorId.IDC_ARROW))
        {
            Application.Init();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                CreateWindow();
            }
        }
        public ~Control()
        {
            if (handle != null)
            {
                Application.GetWindowManager().RemoveWindow(this);
            } 
        }
        protected void CreateWindow()
        {
            CreateWindowInternal();
        }
        public nothrow Control* ParentControl() const
        {
            Control* parentControl = null;
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    parentControl = cast<Control*>(parent);
                }
            }
            return parentControl;
        }
        public nothrow string ParentText() const
        {
            string parentText;
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentText = "parent:" + string(typename(*parentControl)) + "." + parentControl->Text() + ".parentHandle=" + ToHexString(cast<ulong>(parentControl->Handle()));
            }
            return parentText;
        }
        internal void CreateWindowInternal()
        {
            if (handle != null) return;
            Control* parentControl = ParentControl();
            if (Application.GetWindowManager().IsSystemClassName(windowClassName))
            {
                handle = CreateWindowByClassName(windowClassName, text.Chars(), style, exStyle, location, size, parentControl);
            }
            else
            {
                ushort windowClass = Application.GetWindowManager().RegisterWindowClass(windowClassName, windowClassStyle, 0);
                handle = CreateWindowByClassAtom(windowClass, text.Chars(), style, exStyle, location, size, parentControl);
            }
            if (!createList.IsEmpty())
            {
                for (Control* childControl : createList)
                {
                    childControl->CreateWindowInternal();
                }
                createList.Clear();
            }
            Application.GetWindowManager().AddWindow(this);
            WinRect clientRect = GetClientRect();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            size.w = clientRect.right - clientRect.left;
            size.h = clientRect.bottom - clientRect.top;
            if (parentControl != null && parentControl->createList.IsEmpty())
            {
                DockWindow();
            }
            if ((style & WindowStyle.WS_VISIBLE) != 0)
            {
                Show();
                Update();
            }
        }
        internal void AddChildVisual(Control* child)
        {
            if (handle != null)
            {
                if (child->Handle() == null)
                {
                    child->CreateWindowInternal();
                }
                else
                {
                    child->SetParentWindow(this);
                }
                if ((child->GetWindowStyle() & WindowStyle.WS_VISIBLE) != 0)
                {
                    child->Show();
                    child->Update();
                }
            }
            else
            {
                createList.Add(child);
            }
        }
        public nothrow virtual ContainerControl* GetContainerControl() const
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                return parentControl->GetContainerControl();
            }
            return null;
        }
        public Window* GetWindow() const
        {
            Control* thisControl = this;
            if (thisControl is Window*)
            {
                return cast<Window*>(this);
            }
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is Window*)
                    {
                        return cast<Window*>(parent);
                    }
                    else if (parent is Control*)
                    {
                        Control* control = cast<Control*>(parent);
                        return control->GetWindow();
                    }
                }
            }
            return null;
        }
        internal void SetParentWindow(Control* parentWindow)
        {
            SetParentWindow(handle, parentWindow->handle);
            DockWindow();
        }
        public void BringToFront()
        {
            BringWindowToTop(handle);
        }
        public Control* TopControl() const
        {
            void* topWindowHandle = GetTopWindow(handle);
            if (topWindowHandle != null)
            {
                return Application.GetWindowManager().GetWindow(topWindowHandle);
            }
            else
            {
                return null;
            }
        }
        public void Show()
        {
            ShowWindow(ShowCommand.SW_SHOW);
        }
        public void Hide()
        {
            ShowWindow(ShowCommand.SW_HIDE);
        }
        public void ShowWindow(ShowCommand showCommand)
        {
            WinShowWindow(handle, showCommand);
        }
        public void Update()
        {
            WinUpdateWindow(handle);
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                SetWindowText(handle, text);
            }
        }
        public const Point& Location()
        {
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            return location;
        }
        public void SetLocation(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
                OnLocationChanged();
            }
        }
        protected virtual void OnLocationChanged()
        {
            locationChangedEvent.Fire();
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        internal nothrow void SetSizeInternal(const Size& sz)
        {
            if (size != sz)
            {
                size = sz;
                OnSizeChanged();
            }
        }
        public void SetSize(const Size& sz)
        {
            if (size != sz)
            {
                SetSizeInternal(sz);
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
            }
        }
        protected virtual void OnSizeChanged()
        {
            sizeChangedEvent.Fire();
        }
        public nothrow inline const Size& ContentSize() const
        {
            return contentSize;
        }
        public void SetContentSize(const Size& contentSize_)
        {
            if (contentSize != contentSize_)
            {
                contentSize = contentSize_;
                OnContentSizeChanged();
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    ControlEventArgs args(this);
                    parentControl->OnChildContentSizeChanged(args);
                }
            }
        }
        protected virtual void OnContentSizeChanged()
        {
            contentSizeChangedEvent.Fire();
        }
        protected virtual void OnChildContentSizeChanged(ControlEventArgs& args)
        {
            childContentSizeChangedEvent.Fire(args);
        }
        public nothrow void SetScrollUnits(int verticalScrollUnit_, int horizontalScrollUnit_)
        {
            verticalScrollUnit = verticalScrollUnit_;
            horizontalScrollUnit = horizontalScrollUnit_;
        }
        public nothrow Pair<int, int> GetScrollUnits() const
        {
            return MakePair(verticalScrollUnit, horizontalScrollUnit);
        }
        public inline nothrow Dock GetDock() const
        {
            return dock;
        }
        public void SetDock(Dock dock_)
        {
            dock = dock_;
            if (dock != Dock.none)
            {
                DockWindow();
            }
        }
        internal void DockWindow()
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                if (parentControl is ContainerControl*)
                {
                    ContainerControl* containerParent = cast<ContainerControl*>(parentControl);
                    containerParent->DockChildren();
                }
            }
        }
        internal void DockWindow(Rect& parentRect)
        {
            if (dock == Dock.none) return;
            if (handle == null) return;
            LogView* logView = Application.GetLogView();
            Point parentLoc = parentRect.location;
            Size parentSize = parentRect.size;
            Point newLocation = location;
            Size newSize = size;
            switch (dock)
            {
                case Dock.left:
                {
                    newLocation = parentLoc;
                    newSize.h = parentSize.h;
                    parentRect.location = Point(parentLoc.x + size.w, parentLoc.y);
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.left " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.top:
                {
                    newLocation = parentLoc;
                    newSize.w = parentSize.w;
                    parentRect.location = Point(parentLoc.x, parentLoc.y + size.h);
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.top " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.right:
                {
                    newLocation = Point(parentLoc.x + parentSize.w - size.w, parentLoc.y);
                    newSize.h = parentSize.h;
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.right " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.bottom:
                {
                    newLocation = Point(parentLoc.x, parentLoc.y + parentSize.h - size.h);
                    newSize.w = parentSize.w;
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.bottom " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.fill:
                {
                    newLocation = parentLoc;
                    newSize = parentSize;
                    parentRect.location = Point();
                    parentRect.size = Size();
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.fill " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        internal void MoveWindow(int dx, int dy)
        {
            Point newLocation = location;
            Size newSize = size;
            bool leftAnchored = cast<Anchors>(anchors & Anchors.left) != Anchors.none;
            bool rightAnchored = cast<Anchors>(anchors & Anchors.right) != Anchors.none;
            if (!leftAnchored)
            {
                newLocation.x = newLocation.x + dx;
            }
            else if (rightAnchored)
            {
                newSize.w = newSize.w + dx;
            }
            bool topAnchored = cast<Anchors>(anchors & Anchors.top) != Anchors.none;
            bool bottomAnchored = cast<Anchors>(anchors & Anchors.bottom) != Anchors.none;
            if (!topAnchored)
            {
                newLocation.y = newLocation.y + dy;
            }
            else if (bottomAnchored)
            {
                newSize.h = newSize.h + dy;
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Anchors GetAnchors() const
        {
            return anchors;
        }
        public inline nothrow void SetAnchors(Anchors anchors_) 
        {
            anchors = anchors_;
        }
        public virtual nothrow Padding DefaultPadding() const
        {
            return Padding();
        }
        public WinRect GetClientRect() const
        {
            return GetClientRect(handle);
        }
        public WinRect GetWindowRect() const
        {
            return GetWindowRect(handle);
        }
        public Point ClientToScreen(const Point& point) const
        {
            return ClientToScreen(handle, point);
        }
        public Point ScreenToClient(const Point& point) const
        {
            return ScreenToClient(handle, point);
        }
        internal bool ProcessMessageInternal(Message& message)
        {
            return ProcessMessage(message);
        }
        public virtual void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "Control." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
        }
        protected virtual bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_PAINT:
                {
                    DoPaint();
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEMOVE:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam), 0);
                    DoMouseMove(args);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSELEAVE:
                {
                    DoMouseLeave();
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDBLCLK:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 2);
                    DoMouseDoubleClick(args);
                    message.result = 0;
                    return true;
                }
                case WM_CHAR:
                {
                    wchar ch = cast<wchar>(message.wparam);
                    KeyPressEventArgs args(ch);
                    DoKeyPress(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYDOWN:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyDown(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYUP:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyUp(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SYSCOMMAND:
                {
                    if (DoSysCommand(message.wparam, message.lparam))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_HSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoHScroll(request);
                    message.result = 0;
                    return true;
                    break;
                }
                case WM_VSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoVScroll(request);
                    message.result = 0;
                    return true;
                    break;
                }
                case WM_MOUSEWHEEL:
                {
                    MouseWheelEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(cast<uint>(cast<ushort>(message.wparam))), cast<short>(message.wparam >> 16u));
                    DoMouseWheel(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
            }
            return false;
        }
        private bool DoSysCommand(uint wparam, long lparam)
        {
            switch (wparam)
            {
                case SC_KEYMENU:
                {
                    wchar accessKey = cast<wchar>(ToUpper(cast<uchar>(cast<wchar>(lparam))));
                    if (DoMenu(accessKey, Keys.none))
                    {
                        return true;
                    }
                    else
                    {
                        currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.altModifier);
                        if (DoKeyDown(cast<int>(accessKey)))
                        {
                            currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                            return true;
                        }
                        currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                    }
                    break;
                }
                case SC_CLOSE:
                {
                    KeyEventArgs args(Keys.f4, Keys.altModifier);
                    DoMenu(args);
                    if (args.handled)
                    {
                        return true;
                    }
                    break;
                }
            }
            return false;
        }
        private bool DoKeyDown(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyDown: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            ResetKeyDownHandled();
            if (MenuWantsKeys())
            {
                if (DoMenu('\0', cast<Keys>(virtualKeyCode)))
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            Keys keyCode = cast<Keys>(virtualKeyCode);
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.altModifier);
                    break;
                }
            }
            KeyEventArgs args(keyCode, currentModifierKeys);
            DoMenu(args);
            if (args.handled)
            {
                SetKeyDownHandled();
                return true;
            }
            else
            {
                OnKeyDown(args);
                if (args.handled)
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            return false;
        }
        private bool DoKeyUp(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyUp: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            if (KeyDownHandled() || MenuWantsKeys())
            {
                return KeyDownHandled();
            }
            Keys keyCode = cast<Keys>(virtualKeyCode);
            Keys modifierKeys;
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.altModifier);
                    break;
                }
            }
            KeyEventArgs args(keyCode, modifierKeys);
            OnKeyUp(args);
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                    break;
                }
            }
            if (args.handled)
            {
                return true;
            }
            return false;
        }
        private void DoKeyPress(KeyPressEventArgs& args)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyPress: " + ToString(args.keyChar) + " " + ToHexString(cast<uint>(args.keyChar));
                logView->WriteLine(s);
            }
            if (KeyDownHandled() || MenuWantsKeys())
            {
                args.handled = KeyDownHandled();
                return;
            }
            OnKeyPress(args);
        }
        private bool DoMenu(wchar accessKey, Keys keyCode)
        {
            ResetKeyDownHandled();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "MENU: " + ToString(accessKey) + " " + ToHexString(cast<ushort>(accessKey));
                logView->WriteLine(s);
            }
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    bool menuWantsKeys = false;
                    bool handled = menuBar->HandleAccessKey(accessKey, keyCode, menuWantsKeys);
                    if (handled)
                    {
                        SetKeyDownHandled();
                    }
                    if (menuWantsKeys)
                    {
                        SetMenuWantsKeys();
                    }
                    else
                    {
                        ResetMenuWantsKeys();
                    }
                    return handled;
                }
            }
            return false;
        }
        private void DoMenu(KeyEventArgs& args)
        {
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    menuBar->DoKeyDown(args);
                }
            }
        }
        private void DoVScroll(ushort request)
        {
            OnVScroll(request);
        }
        private void DoHScroll(ushort request)
        {
            OnHScroll(request);
        }
        private void DoMouseWheel(MouseWheelEventArgs& args)
        {
            OnMouseWheel(args);
        }
        protected nothrow virtual bool IsDecoratorControl() const
        {
            return false;
        }
        protected virtual void TranslateChildGraphics(Graphics& graphics)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateChildGraphics(graphics);
            }
        }
        protected virtual void TranslateMousePos(Point& location)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateMousePos(location);
            }
        }
        private void DoPaint()
        {
            void* paintStruct = null;
            void* hdc = BeginPaint(handle, paintStruct);
            Rect clipRect;
            WinGetClipRect(paintStruct, clipRect.location.x, clipRect.location.y, clipRect.size.w, clipRect.size.h);
            PaintGuard paintGuard(hdc, paintStruct);
            Graphics graphics(hdc);
            PaintEventArgs args(graphics, clipRect);
            if (!IsDecoratorControl())
            {
                TranslateChildGraphics(graphics);
            }
            OnPaint(args);
        }
        protected virtual void OnPaint(PaintEventArgs& args)
        {
            paintEvent.Fire(args);
        }
        internal virtual void PaintAll(PaintEventArgs& args)
        {
            try
            {
                OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void DoMouseMove(MouseEventArgs& args)
        {
            if (!MouseInClient())
            {
                SetMouseInClient();
                SetCursor();
                OnMouseEnter();
                WinTrackMouseEvent(handle, TME_LEAVE, HOVER_DEFAULT);
            }
            else 
            {
                if (!IsDecoratorControl())
                {
                    TranslateMousePos(args.location);
                }
                OnMouseMove(args);
            }
        }
        private void DoMouseLeave()
        {
            ResetMouseInClient();
            ResetLButtonPressed();
            OnMouseLeave();
        }
        private void DoMouseDown(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDown(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                SetLButtonPressed();
            }
        }
        private void DoMouseUp(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseUp(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                if (LButtonPressed())
                {
                    ResetLButtonPressed();
                    OnClick();
                }
            }
        }
        private void DoMouseDoubleClick(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDoubleClick(args);
        }
        protected virtual void SetCursor()
        {
            SetCursor(arrowCursor);
        }
        protected virtual void OnMouseEnter()
        {
            mouseEnterEvent.Fire();
        }
        protected virtual void OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
        }
        protected virtual void OnMouseLeave()
        {
            mouseLeaveEvent.Fire();
        }
        protected virtual void OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        protected virtual void OnMouseDoubleClick(MouseEventArgs& args)
        {
            mouseDoubleClickEvent.Fire(args);
        }
        protected virtual void OnKeyPress(KeyPressEventArgs& args)
        {
            keyPressEvent.Fire(args);
        }
        protected virtual void OnKeyDown(KeyEventArgs& args)
        {
            keyDownEvent.Fire(args);
        }
        protected virtual void OnKeyUp(KeyEventArgs& args)
        {
            keyUpEvent.Fire(args);
        }
        protected virtual void OnClick()
        {
            clickEvent.Fire();
        }
        protected virtual void OnHScroll(ScrollEventArgs& args)
        {
            hscrollEvent.Fire(args);
        }
        protected virtual void OnVScroll(ScrollEventArgs& args)
        {
            vscrollEvent.Fire(args);
        }
        protected virtual void OnMouseWheel(MouseWheelEventArgs& args)
        {
            mouseWheelEvent.Fire(args);
        }
        public void* GetDC()
        {
            return GetDC(handle);
        }
        public void Invalidate()
        {
            InvalidateRect(handle, null, true);
        }
        public void Invalidate(const WinRect& rect)
        {
            InvalidateRect(handle, &rect, false);
        }
        public void Invalidate(const WinRect& rect, bool eraseBackground)
        {
            InvalidateRect(handle, &rect, eraseBackground);
        }
        public nothrow inline const Color& BackgroundColor() const
        {
            return backgroundColor;
        }
        public void SetBackgroundColor(const Color& backgroundColor_)
        {
            backgroundColor = backgroundColor_;
            Invalidate();
        }
        public nothrow inline void* Handle() const
        {
            return handle;
        }
        public inline nothrow WindowStyle GetWindowStyle() const
        {
            return style;
        }
        public inline nothrow ExtendedWindowStyle GetExtendedWindowStyle() const
        {
            return exStyle;
        }
        public nothrow Event<PaintEventHandler, PaintEventArgs>& PaintEvent()
        {
            return paintEvent;
        }
        public nothrow Event<MouseEnterEventHandler>& MouseEnterEvent() const
        {
            return mouseEnterEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent() const
        {
            return mouseMoveEvent;
        }
        public nothrow Event<MouseLeaveEventHandler>& MouseLeaveEvent() const
        {
            return mouseLeaveEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent() const
        {
            return mouseDownEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent() const
        {
            return mouseUpEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDoubleClickEvent() const
        {
            return mouseDoubleClickEvent;
        }
        public nothrow Event<KeyPressEventHandler, KeyPressEventArgs>& KeyPressEvent() const
        {
            return keyPressEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyDownEvent() const
        {
            return keyDownEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyUpEvent() const
        {
            return keyUpEvent;
        }
        public nothrow Event<ClickEventHandler>& ClickEvent() const
        {
            return clickEvent;
        }
        public nothrow Event<SizeChangedEventHandler>& SizeChangedEvent() const
        {
            return sizeChangedEvent;
        }
        public nothrow Event<LocationChangedEventHandler>& LocationChangedEvent() const
        {
            return locationChangedEvent;
        }
        public nothrow Event<ContentSizeChangedEventHandler>& ContentSizeChangedEvent() const
        {
            return contentSizeChangedEvent;
        }
        public nothrow Event<ChildContentSizeChangedEventHandler, ControlEventArgs>& ChildContentSizeChangedEvent() const
        {
            return childContentSizeChangedEvent;
        }
        public nothrow Event<HScrollEventHandler, ScrollEventArgs>& HScrollEvent() const
        {
            return hscrollEvent;
        }
        public nothrow Event<VScrollEventHandler, ScrollEventArgs>& VScrollEvent() const
        {
            return vscrollEvent;
        }
        public nothrow Event<MouseWheelEventHandler, MouseWheelEventArgs>& MouseWheelEvent() const
        {
            return mouseWheelEvent;
        }
        private nothrow inline bool MouseInClient() const
        {
            return (flags & Flags.mouseInClient) != 0;
        }
        private nothrow inline void SetMouseInClient()
        {
            flags = cast<Flags>(flags | Flags.mouseInClient);
        }
        private nothrow inline void ResetMouseInClient()
        {
            flags = cast<Flags>(flags & ~Flags.mouseInClient);
        }
        private nothrow inline bool LButtonPressed() const
        {
            return (flags & flags.lbuttonPressed) != 0;
        }
        private nothrow inline void SetLButtonPressed()
        {
            flags = cast<Flags>(flags | Flags.lbuttonPressed);
        }
        private nothrow inline void ResetLButtonPressed()
        {
            flags = cast<Flags>(flags & ~Flags.lbuttonPressed);
        }
        private nothrow inline bool MenuWantsKeys() const
        {
            return (flags & flags.menuWantsKeys) != 0;
        }
        private nothrow inline void SetMenuWantsKeys()
        {
            flags = cast<Flags>(flags | Flags.menuWantsKeys);
        }
        private nothrow inline void ResetMenuWantsKeys()
        {
            flags = cast<Flags>(flags & ~Flags.menuWantsKeys);
        }
        private nothrow inline bool KeyDownHandled() const
        {
            return (flags & flags.keyDownHandled) != 0;
        }
        private nothrow inline void SetKeyDownHandled()
        {
            flags = cast<Flags>(flags | Flags.keyDownHandled);
        }
        private nothrow inline void ResetKeyDownHandled()
        {
            flags = cast<Flags>(flags & ~Flags.keyDownHandled);
        }
        private const char* windowClassName;
        private WindowClassStyle windowClassStyle;
        private Color backgroundColor;
        private WindowStyle style;
        private ExtendedWindowStyle exStyle;
        private void* handle;
        private string text;
        private Point location;
        private Size size;
        private Size contentSize;
        private int verticalScrollUnit;
        private int horizontalScrollUnit;
        private Dock dock;
        private Anchors anchors;
        private Flags flags;
        private Keys currentModifierKeys;
        private List<Control*> createList;
        private Cursor arrowCursor;
        private Event<PaintEventHandler, PaintEventArgs> paintEvent;
        private Event<MouseEnterEventHandler> mouseEnterEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseLeaveEventHandler> mouseLeaveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDoubleClickEvent;
        private Event<KeyPressEventHandler, KeyPressEventArgs> keyPressEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyDownEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyUpEvent;
        private Event<ClickEventHandler> clickEvent;
        private Event<SizeChangedEventHandler> sizeChangedEvent;
        private Event<LocationChangedEventHandler> locationChangedEvent;
        private Event<ContentSizeChangedEventHandler> contentSizeChangedEvent;
        private Event<ChildContentSizeChangedEventHandler, ControlEventArgs> childContentSizeChangedEvent;
        private Event<HScrollEventHandler, ScrollEventArgs> hscrollEvent;
        private Event<VScrollEventHandler, ScrollEventArgs> vscrollEvent;
        private Event<MouseWheelEventHandler, MouseWheelEventArgs> mouseWheelEvent;
    }
}

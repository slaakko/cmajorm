// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Windows.API;

namespace System.Windows
{
    public class delegate void PaintEventHandler(PaintEventArgs& paintEventArgs);

    public class Control
    {
        public Control(const char* windowClassName_, WindowClassStyle windowClassStyle_, WindowColor windowClassBackgroundColor_, WindowStyle style_, ExtendedWindowStyle exStyle_, 
            const string& text_, const Point& location_, const Size& size_, Dock dock_, Anchors anchors_) : 
            windowClassName(windowClassName_), windowClassStyle(windowClassStyle_), windowClassBackgroundColor(windowClassBackgroundColor_), style(style_), exStyle(exStyle_), 
            handle(null), parent(null), nextSibling(null), prevSibling(null), 
            name(), text(text_), location(location_), size(size_), dock(dock_), anchors(anchors_)
        {
            Application.Init();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                CreateWindow();
            }
        }
        public virtual ~Control()
        {
            if (handle != null)
            {
                Application.GetWindowManager().RemoveWindow(this);
            } 
        }
        protected void CreateWindow()
        {
            CreateWindowInternal();
        }
        internal void CreateWindowInternal()
        {
            if (handle != null) return;
            if (Application.GetWindowManager().IsSystemClassName(windowClassName))
            {
                handle = CreateWindowByClassName(windowClassName, text.Chars(), style, exStyle, location, size, parent);
            }
            else
            {
                ushort windowClass = Application.GetWindowManager().RegisterWindowClass(windowClassName, windowClassStyle, windowClassBackgroundColor);
                handle = CreateWindowByClassAtom(windowClass, text.Chars(), style, exStyle, location, size, parent);
            }            
            Application.GetWindowManager().AddWindow(this);
            WinRect clientRect = GetClientRect();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            size.w = clientRect.right - clientRect.left;
            size.h = clientRect.bottom - clientRect.top;
            DockWindow();
        }
        internal void SetParentWindow(ContainerControl* parentWindow)
        {
            SetParentWindow(handle, parentWindow->handle);
            DockWindow();
        }
        public void Show()
        {
            ShowWindow(ShowCommand.SW_SHOW);
        }
        public void Hide()
        {
            ShowWindow(ShowCommand.SW_HIDE);
        }
        public void ShowWindow(ShowCommand showCommand)
        {
            WinShowWindow(handle, showCommand);
        }
        public void Update()
        {
            WinUpdateWindow(handle);
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                SetWindowText(handle, text);
            }
        }
        public const Point& Location()
        {
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            return location;
        }
        public void SetLocation(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                MoveWindow(handle, location, size, true);
            }
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        internal nothrow void SetSizeInternal(const Size& sz)
        {
            size = sz;
        }
        public void SetSize(const Size& sz)
        {
            if (size != sz)
            {
                size = sz;
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Dock GetDock() const
        {
            return dock;
        }
        public void SetDock(Dock dock_)
        {
            dock = dock_;
            if (dock != Dock.none)
            {
                DockWindow();
            }
        }
        internal void DockWindow()
        {
            if (parent != null)
            {
                DockWindow(parent->GetSize());
            }
        }
        internal void DockWindow(const Size& parentSize)
        {
            if (dock == Dock.none) return;
            Point newLocation = location;
            Size newSize = size;
            switch (dock)
            {
                case Dock.left:
                {
                    newLocation = Point(0, 0);
                    newSize.h = parentSize.h;
                    break;
                }
                case Dock.top:
                {
                    newLocation = Point(0, 0);
                    newSize.w = parentSize.w;
                    break;
                }
                case Dock.right:
                {
                    newLocation = Point(parentSize.w - size.w, 0);
                    newSize.h = parentSize.h;
                    break;
                }
                case Dock.bottom:
                {
                    newLocation = Point(0, parentSize.h - size.h);
                    newSize.w = parentSize.w;
                    break;
                }
                case Dock.fill:
                {
                    newLocation = Point(0, 0);
                    newSize = parentSize;
                    break;
                }
            }
            if (location != newLocation || size != newSize)
            {
                location = newLocation;
                size = newSize;
                MoveWindow(handle, location, size, true);
            }
        }
        internal void MoveWindow(int dx, int dy)
        {
            Point newLocation = location;
            Size newSize = size;
            bool leftAnchored = cast<Anchors>(anchors & Anchors.left) != Anchors.none;
            bool rightAnchored = cast<Anchors>(anchors & Anchors.right) != Anchors.none;
            if (!leftAnchored)
            {
                newLocation.x = newLocation.x + dx;
            }
            else if (rightAnchored)
            {
                newSize.w = newSize.w + dx;
            }
            bool topAnchored = cast<Anchors>(anchors & Anchors.top) != Anchors.none;
            bool bottomAnchored = cast<Anchors>(anchors & Anchors.bottom) != Anchors.none;
            if (!topAnchored)
            {
                newLocation.y = newLocation.y + dy;
            }
            else if (bottomAnchored)
            {
                newSize.h = newSize.h + dy;
            }
            if (location != newLocation || size != newSize)
            {
                location = newLocation;
                size = newSize;
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Anchors GetAnchors() const
        {
            return anchors;
        }
        public inline nothrow void SetAnchors(Anchors anchors_) 
        {
            anchors = anchors_;
        }
        public WinRect GetClientRect() const
        {
            return GetClientRect(handle);
        }
        public WinRect GetWindowRect() const
        {
            return GetWindowRect(handle);
        }
        public Point ClientToScreen(const Point& point) const
        {
            return ClientToScreen(handle, point);
        }
        public Point ScreenToClient(const Point& point) const
        {
            return ScreenToClient(handle, point);
        }
        internal bool ProcessMessageInternal(Message& message)
        {
            return ProcessMessage(message);
        }
        protected virtual bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_PAINT:
                {
                    if (!paintEvent.Handlers().IsEmpty())
                    {
                        OnPaint();
                        message.result = 0;
                        return true;
                    }
                    break;
                }
            }
            return false;
        }
        protected virtual void OnPaint()
        {
            void* paintStruct = null;
            void* hdc = BeginPaint(handle, paintStruct);
            Rect clipRect;
            WinGetClipRect(paintStruct, clipRect.location.x, clipRect.location.y, clipRect.size.w, clipRect.size.h);
            PaintGuard paintGuard(hdc, paintStruct);
            Graphics graphics(hdc);
            PaintEventArgs args(graphics, clipRect);
            paintEvent.Fire(args);
        }
        public void Invalidate()
        {
            InvalidateRect(handle, null, true);
        }
        public void Invalidate(const WinRect& rect)
        {
            InvalidateRect(handle, &rect, false);
        }
        public void Invalidate(const WinRect& rect, bool eraseBackground)
        {
            InvalidateRect(handle, &rect, eraseBackground);
        }
        public nothrow inline void* Handle() const
        {
            return handle;
        }
        public nothrow inline ContainerControl* Parent() const
        {
            return parent;
        }
        internal nothrow void SetParent(ContainerControl* parent_)
        {
            parent = parent_;
        }    
        public nothrow inline Control* NextSibling() const
        {
            return nextSibling;
        }
        public nothrow inline Control* PrevSibling() const
        {
            return prevSibling;
        }
        internal nothrow void LinkAfter(Control* control)
        {
            control->prevSibling = this;
            control->nextSibling = nextSibling;
            nextSibling = control;
        }    
        internal nothrow void Unlink()
        {
            if (prevSibling != null)
            {
                prevSibling->nextSibling = nextSibling;
            }
            if (nextSibling != null)
            {
                nextSibling->prevSibling = prevSibling;
            }
        }
        public inline nothrow WindowStyle GetWindowStyle() const
        {
            return style;
        }
        public inline nothrow ExtendedWindowStyle GetExtendedWindowStyle() const
        {
            return exStyle;
        }
        public nothrow Event<PaintEventHandler, PaintEventArgs>& PaintEvent()
        {
            return paintEvent;
        }
        private const char* windowClassName;
        private WindowClassStyle windowClassStyle;
        private WindowColor windowClassBackgroundColor;
        private WindowStyle style;
        private ExtendedWindowStyle exStyle;
        private void* handle;
        private ContainerControl* parent;
        private Control* nextSibling;
        private Control* prevSibling;
        private string name;
        private string text;
        private Point location;
        private Size size;
        private Dock dock;
        private Anchors anchors;
        private Event<PaintEventHandler, PaintEventArgs> paintEvent;
    }
}

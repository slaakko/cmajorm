// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows.API;

namespace System.Windows
{
    public class delegate void PaintEventHandler(PaintEventArgs& paintEventArgs);
    public class delegate void MouseEnterEventHandler();
    public class delegate void MouseEventHandler(MouseEventArgs& mouseEventargs);
    public class delegate void MouseLeaveEventHandler();
    public class delegate void MouseWheelEventHandler(MouseWheelEventArgs& mouseWheelEventArgs);
    public class delegate void KeyPressEventHandler(KeyPressEventArgs& keyPressEventArgs);
    public class delegate void KeyEventHandler(KeyEventArgs& keyEventArgs);
    public class delegate void ClickEventHandler();
    public class delegate void CreatedEventHandler();
    public class delegate void DestroyedEventHandler();
    public class delegate void ShownEventHandler();
    public class delegate void EnabledChangedEventHandler();
    public class delegate void VisibleChangedEventHandler();
    public class delegate void SizeChangedEventHandler(uint windowState);
    public class delegate void SizeChangingEventHandler(SizeChangingEventArgs& args);
    public class delegate void ChildSizeChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void LocationChangedEventHandler();
    public class delegate void ContentChangedEventHandler();
    public class delegate void ChildContentChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ContentLocationChangedEventHandler();
    public class delegate void ChildContentLocationChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ContentSizeChangedEventHandler();
    public class delegate void ChildContentSizeChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void TextChangedEventHandler();
    public class delegate void HScrollEventHandler(ScrollEventArgs& scrollEventArgs);
    public class delegate void VScrollEventHandler(ScrollEventArgs& scrollEventArgs);
    public class delegate void TimerEventHandler(TimerEventArgs& timerEventArgs);
    public class delegate void GotFocusEventHandler();
    public class delegate void LostFocusEventHandler();
    public class delegate void ChildGotFocusEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ChildLostFocusEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ControlEventHandler(ControlEventArgs& args);
    public class delegate void RightClickEventHandler(RightClickEventArgs& args);
    public class delegate void ClipboardUpdateEventHandler();

    public inline nothrow WindowClassStyle DefaultWindowClassStyle()
    {
        return WindowClassStyle.CS_DEFAULT;
    }

    public inline nothrow WindowClassStyle DoubleClickWindowClassStyle()
    {
        return WindowClassStyle.CS_DBLCLKS;
    }

    public inline nothrow WindowStyle DefaultChildWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CHILD | WindowStyle.WS_VISIBLE | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow WindowStyle HiddenChildWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CHILD | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow WindowStyle DialogWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CAPTION | WindowStyle.WS_DLGFRAME | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow ExtendedWindowStyle DefaultExtendedWindowStyle()
    {
        return ExtendedWindowStyle.WS_EX_DEFAULT;
    }

    public inline nothrow SystemColor DefaultWindowClassBackgroundColor()
    {
        return SystemColor.COLOR_WINDOW;
    }

    public nothrow Color DefaultControlBackgroundColor()
    {
        return GetSystemColor(SystemColor.COLOR_MENU);
    }

    public const uint mouseHoverTimerId = 2u;

    public nothrow uint DefaultMouseHoverMs()
    {
        return 300u;
    }

    public nothrow Size DefaultMouseHoverRectSize()
    {
        return Size(8, 8);
    }

    public class ControlCreateParams
    {
        public nothrow ControlCreateParams() :
            windowClassName(),
            windowClassStyle(DefaultWindowClassStyle()),
            windowStyle(DefaultChildWindowStyle()),
            extendedWindowStyle(DefaultExtendedWindowStyle()),
            windowClassBackgroundColor(DefaultWindowClassBackgroundColor()),
            backgroundColor(DefaultControlBackgroundColor()),
            text(),
            location(),
            size(),
            anchors(cast<Anchors>(Anchors.left | Anchors.top)),
            dock(Dock.none)
        {
        }
        public nothrow ControlCreateParams& Defaults()
        {
            return *this;
        }
        public nothrow ControlCreateParams& SetWindowClassName(const string& windowClassName_)
        {
            windowClassName = windowClassName_;
            return *this;
        }
        public nothrow ControlCreateParams& SetWindowClassStyle(WindowClassStyle windowClassStyle_)
        {
            windowClassStyle = windowClassStyle_;
            return *this;
        }
        public nothrow ControlCreateParams& SetWindowStyle(WindowStyle windowStyle_)
        {
            windowStyle = windowStyle_;
            return *this;
        }
        public nothrow ControlCreateParams& SetExtendedWindowStyle(ExtendedWindowStyle extendedWindowStyle_)
        {
            extendedWindowStyle = extendedWindowStyle_;
            return *this;
        }
        public nothrow ControlCreateParams& SetWindowClassBackgroundColor(SystemColor systemColor)
        {
            windowClassBackgroundColor = systemColor;
            return *this;
        }
        public nothrow ControlCreateParams& SetBackgroundColor(const Color& backgroundColor_)
        {
            backgroundColor = backgroundColor_;
            return *this;
        }
        public nothrow ControlCreateParams& SetText(const string& text_)
        {
            text = text_;
            return *this;
        }
        public nothrow ControlCreateParams& SetLocation(const Point& location_)
        {
            location = location_;
            return *this;
        }
        public nothrow ControlCreateParams& SetSize(const Size& size_)
        {
            size = size_;
            return *this;
        }
        public nothrow ControlCreateParams& SetDock(Dock dock_)
        {
            dock = dock_;
            return *this;
        }
        public nothrow ControlCreateParams& SetAnchors(Anchors anchors_)
        {
            anchors = anchors_;
            return *this;
        }
        public string windowClassName;
        public WindowClassStyle windowClassStyle;
        public WindowStyle windowStyle;
        public ExtendedWindowStyle extendedWindowStyle;
        public SystemColor windowClassBackgroundColor;
        public Color backgroundColor;
        public string text;
        public Point location;
        public Size size;
        public Dock dock;
        public Anchors anchors;
    }

    public abstract class Control : Component
    {
        private enum Flags : short
        {
            none = 0, mouseInClient = 1 << 0, lbuttonPressed = 1 << 1, menuWantsKeys = 1 << 2, keyDownHandled = 1 << 3, focused = 1 << 4,
            caretCreated = 1 << 5, caretShown = 1 << 6, disabled = 1 << 7, hidden = 1 << 8, tabStop = 1 << 9, baseOnCreatedCalled = 1 << 10,
            mouseHoverTimerStarted = 1 << 11, doubleBuffered = 1 << 12, scrollSubject = 1 << 13
        }
        public Control(const string& windowClassName_, WindowClassStyle windowClassStyle_, WindowStyle style_, ExtendedWindowStyle exStyle_,
            const Color& backgroundColor_, const string& text_, const Point& location_, const Size& size_, Dock dock_, Anchors anchors_) :
            windowClassName(windowClassName_), windowClassStyle(windowClassStyle_), style(style_), exStyle(exStyle_),
            windowClassBackgroundColor(DefaultWindowClassBackgroundColor()), backgroundColor(backgroundColor_), handle(null), text(text_),
            location(location_), size(size_), contentLocation(0, 0), contentSize(), dock(dock_), anchors(anchors_), flags(Flags.none),
            arrowCursor(LoadStandardCursor(StandardCursorId.IDC_ARROW)), caretShowCount(0), font(null), fontHandle(null), originalWndProc(null),
            mouseHoverMs(0u), mouseHoverRectSize(DefaultMouseHoverRectSize())
        {
            Init();
        }
        public Control(ControlCreateParams& createParams) :
            windowClassName(createParams.windowClassName), windowClassStyle(createParams.windowClassStyle), style(createParams.windowStyle),
            exStyle(createParams.extendedWindowStyle), windowClassBackgroundColor(createParams.windowClassBackgroundColor),
            backgroundColor(createParams.backgroundColor), handle(null), text(createParams.text), location(createParams.location),
            size(createParams.size), contentLocation(0, 0), contentSize(), dock(createParams.dock), anchors(createParams.anchors), flags(Flags.none),
            arrowCursor(LoadStandardCursor(StandardCursorId.IDC_ARROW)), caretShowCount(0), font(null), fontHandle(null), originalWndProc(null),
            mouseHoverMs(0u), mouseHoverRectSize(DefaultMouseHoverRectSize())
        {
            Init();
        }
        private void Init()
        {
            if ((style & WindowStyle.WS_DISABLED) != 0)
            {
                SetDisabled();
            }
            if ((style & WindowStyle.WS_VISIBLE) == 0)
            {
                SetHidden();
            }
            if ((style & WindowStyle.WS_TABSTOP) != 0)
            {
                SetTabStop();
            }
            Application.Init();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                CreateWindow();
            }
            SetScrollUnits(10, 10);
        }
        public ~Control()
        {
            if (handle != null)
            {
                Application.GetWindowManager().RemoveWindow(this);
                WinDestroyWindow(handle);
            }
        }
        protected void CreateWindow()
        {
            CreateWindowInternal();
        }
        public nothrow Control* ParentControl() const
        {
            Control* parentControl = null;
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    parentControl = cast<Control*>(parent);
                }
            }
            return parentControl;
        }
        public nothrow string ParentText() const
        {
            string parentText;
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentText = "parent:" + string(typename(*parentControl)) + "." + parentControl->Text() + ".parentHandle=" +
                    ToHexString(cast<ulong>(parentControl->Handle()));
            }
            return parentText;
        }
        internal nothrow void SetWindowCreateStyleFromFlags()
        {
            if (IsDisabled())
            {
                style = cast<WindowStyle>(style | WindowStyle.WS_DISABLED);
            }
            else
            {
                style = cast<WindowStyle>(style & ~WindowStyle.WS_DISABLED);
            }
            if (Hidden())
            {
                style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
            }
            else
            {
                style = cast<WindowStyle>(style | WindowStyle.WS_VISIBLE);
            }
        }
        internal void CreateWindowInternal()
        {
            if (handle != null) return;
            Control* parentControl = ParentControl();
            SetWindowCreateStyleFromFlags();
            if (Application.GetWindowManager().IsSystemClassName(windowClassName.Chars()))
            {
                handle = CreateWindowByClassName(windowClassName.Chars(), text.Chars(), style, exStyle, location, size, parentControl);
            }
            else
            {
                ushort windowClass = Application.GetWindowManager().RegisterWindowClass(
                    windowClassName.Chars(), windowClassStyle, windowClassBackgroundColor);
                handle = CreateWindowByClassAtom(windowClass, text.Chars(), style, exStyle, location, size, parentControl);
            }
            if (!createList.IsEmpty())
            {
                for (Control* childControl : createList)
                {
                    childControl->CreateWindowInternal();
                }
                createList.Clear();
            }
            Application.GetWindowManager().AddWindow(this);
            OnCreated();
            WinRect clientRect = GetClientRect();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            size.w = clientRect.right - clientRect.left;
            size.h = clientRect.bottom - clientRect.top;
            if (parentControl != null && parentControl->createList.IsEmpty())
            {
                DockWindow();
            }
        }
        internal void AddChildVisual(Control* child)
        {
            if (handle != null)
            {
                if (child->Handle() == null)
                {
                    child->CreateWindowInternal();
                }
                else
                {
                    child->SetParentWindow(this);
                }
                if ((child->GetWindowStyle() & WindowStyle.WS_VISIBLE) != 0)
                {
                    child->Show();
                    child->Update();
                }
            }
            else
            {
                createList.Add(child);
            }
        }
        public nothrow virtual ContainerControl* GetContainerControl() const
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                return parentControl->GetContainerControl();
            }
            return null;
        }
        public Window* GetWindow() const
        {
            Control* thisControl = this;
            if (thisControl is Window*)
            {
                return cast<Window*>(this);
            }
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is Window*)
                    {
                        return cast<Window*>(parent);
                    }
                    else if (parent is Control*)
                    {
                        Control* control = cast<Control*>(parent);
                        return control->GetWindow();
                    }
                }
            }
            return null;
        }
        internal void SetParentWindow(Control* parentWindow)
        {
            SetParentWindow(handle, parentWindow->handle);
            DockWindow();
        }
        public nothrow inline bool IsEnabled() const
        {
            return !IsDisabled();
        }
        public void Enable()
        {
            if (IsDisabled())
            {
                ResetDisabled();
                style = cast<WindowStyle>(style & ~WindowStyle.WS_DISABLED);
                if (handle != null)
                {
                    EnableWindow(true);
                }
                OnEnabledChanged();
            }
        }
        public void Disable()
        {
            if (!IsDisabled())
            {
                SetDisabled();
                style = cast<WindowStyle>(style | WindowStyle.WS_DISABLED);
                if (handle != null)
                {
                    EnableWindow(false);
                }
                OnEnabledChanged();
            }
        }
        protected virtual void OnEnabledChanged()
        {
            enabledChangedEvent.Fire();
        }
        internal void EnableWindow(bool enable)
        {
            WinEnableWindow(handle, enable);
        }
        public void BringToFront()
        {
            BringWindowToTop(handle);
        }
        public Control* TopControl() const
        {
            void* topWindowHandle = GetTopWindow(handle);
            if (topWindowHandle != null)
            {
                return Application.GetWindowManager().GetWindow(topWindowHandle);
            }
            else
            {
                return null;
            }
        }
        public nothrow inline bool IsVisible() const
        {
            return !Hidden();
        }
        public void Show()
        {
            if (Hidden())
            {
                ResetHidden();
                style = cast<WindowStyle>(style | WindowStyle.WS_VISIBLE);
                OnVisibleChanged();
            }
            if (handle != null)
            {
                ShowWindow(ShowCommand.SW_SHOW);
            }
        }
        public void Hide()
        {
            if (handle != null)
            {
                ShowWindow(ShowCommand.SW_HIDE);
            }
            if (!Hidden())
            {
                SetHidden();
                style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
                OnVisibleChanged();
            }
        }
        public void ShowWindow(ShowCommand showCommand)
        {
            WinShowWindow(handle, showCommand);
            if (showCommand == ShowCommand.SW_HIDE)
            {
                if (!Hidden())
                {
                    SetHidden();
                    style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
                    OnVisibleChanged();
                }
            }
        }
        protected virtual void OnVisibleChanged()
        {
            visibleChangedEvent.Fire();
        }
        public void Update()
        {
            WinUpdateWindow(handle);
        }
        internal nothrow virtual Control* GetFirstEnabledTabStopControl() const
        {
            if (IsTabStop() && IsEnabled())
            {
                return this;
            }
            else
            {
                return null;
            }
        }
        internal nothrow virtual Control* GetLastEnabledTabStopControl() const
        {
            if (IsTabStop() && IsEnabled())
            {
                return this;
            }
            else
            {
                return null;
            }
        }
        public void SetFocus()
        {
            Control* focusedControl = Application.GetFocusedControl();
            if (focusedControl != null)
            {
                currentModifierKeys = focusedControl->currentModifierKeys;
                Keys emptyModifierKeys;
                focusedControl->currentModifierKeys = emptyModifierKeys;
            }
            WinSetFocus(Handle());
            Window* window = GetWindow();
            if (window != null)
            {
                window->SetFocusedControl(this);
            }
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                SetWindowText(handle, text);
                OnTextChanged();
            }
        }
        internal void SetTextInternal(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                OnTextChanged();
            }
        }
        public int GetWindowTextLength() const
        {
            return GetWindowTextLength(handle);
        }
        public string GetWindowText()
        {
            return GetWindowText(handle);
        }
        protected virtual void OnTextChanged()
        {
            textChangedEvent.Fire();
        }
        public const Point& Location()
        {
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            return location;
        }
        public void SetLocation(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
                OnLocationChanged();
            }
        }
        internal  void SetLocationInternal(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                OnLocationChanged();
            }
        }
        protected virtual void OnLocationChanged()
        {
            locationChangedEvent.Fire();
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        internal nothrow void SetSizeInternal(const Size& sz, uint windowState)
        {
            if (size != sz)
            {
                size = sz;
                OnSizeChanged(windowState);
            }
        }
        public void SetSize(const Size& sz)
        {
            if (size != sz)
            {
                SizeChangingEventArgs sizeChangingArgs(size, sz);
                OnSizeChanging(sizeChangingArgs);
                SetSizeInternal(sz, SIZE_RESTORED);
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
                if (IsScrollSubject())
                {
                    Control* parentControl = ParentControl();
                    if (parentControl != null)
                    {
                        ControlEventArgs args(this);
                        parentControl->OnChildSizeChanged(args);
                    }
                }
            }
        }
        public void SendSetFontMessage(const FontHandle& fontHandle)
        {
            if (Handle() != null)
            {
                WinSendMessage(Handle(), WM_SETFONT, cast<uint>(cast<ulong>(fontHandle.HFont())), 0);
            }
        }
        protected virtual void OnSizeChanged(uint windowState)
        {
            sizeChangedEvent.Fire(windowState);
        }
        protected virtual void OnSizeChanging(SizeChangingEventArgs& args)
        {
            sizeChangingEvent.Fire(args);
        }
        public void FireChildSizeChanged(ControlEventArgs& args)
        {
            OnChildSizeChanged(args);
        }
        protected virtual void OnChildSizeChanged(ControlEventArgs& args)
        {
            childSizeChangedEvent.Fire(args);
        }
        public void SetContentChanged()
        {
            OnContentChanged();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildContentChanged(args);
            }
        }
        protected virtual void OnContentChanged()
        {
            contentChangedEvent.Fire();
        }
        protected virtual void OnChildContentChanged(ControlEventArgs& args)
        {
            childContentChangedEvent.Fire(args);
        }
        public nothrow inline const Point& ContentLocation() const
        {
            return contentLocation;
        }
        internal virtual nothrow void SetContentLocationInternal(const Point& contentLocation_)
        {
            contentLocation = contentLocation_;
            OnContentLocationChanged();
        }
        public void SetContentLocation(const Point& contentLocation_)
        {
            if (contentLocation != contentLocation_)
            {
                contentLocation = contentLocation_;
                OnContentLocationChanged();
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    ControlEventArgs args(this);
                    parentControl->OnChildContentLocationChanged(args);
                }
            }
        }
        protected virtual void OnContentLocationChanged()
        {
            contentLocationChangedEvent.Fire();
        }
        protected virtual void OnChildContentLocationChanged(ControlEventArgs& args)
        {
            childContentLocationChangedEvent.Fire(args);
        }
        public nothrow inline const Size& ContentSize() const
        {
            return contentSize;
        }
        public void SetContentSize(const Size& contentSize_)
        {
            if (contentSize != contentSize_)
            {
                contentSize = contentSize_;
                OnContentSizeChanged();
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    ControlEventArgs args(this);
                    parentControl->OnChildContentSizeChanged(args);
                }
            }
        }
        protected virtual void OnContentSizeChanged()
        {
            contentSizeChangedEvent.Fire();
        }
        protected virtual void OnChildContentSizeChanged(ControlEventArgs& args)
        {
            childContentSizeChangedEvent.Fire(args);
        }
        public nothrow void SetScrollUnits(int verticalScrollUnit_, int horizontalScrollUnit_)
        {
            verticalScrollUnit = verticalScrollUnit_;
            horizontalScrollUnit = horizontalScrollUnit_;
        }
        public nothrow Pair<int, int> GetScrollUnits() const
        {
            return MakePair(verticalScrollUnit, horizontalScrollUnit);
        }
        protected virtual void SetCaretLocation()
        {
            SetCaretPos(Point(0, 0));
        }
        public inline nothrow Dock GetDock() const
        {
            return dock;
        }
        public void SetDock(Dock dock_)
        {
            dock = dock_;
            if (dock != Dock.none)
            {
                DockWindow();
            }
        }
        public void DockWindow()
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                if (parentControl is ContainerControl*)
                {
                    ContainerControl* containerParent = cast<ContainerControl*>(parentControl);
                    containerParent->DockChildren();
                }
            }
        }
        internal void DockWindow(Rect& parentRect)
        {
            if (dock == Dock.none) return;
            if (handle == null) return;
            LogView* logView = Application.GetLogView();
            Point parentLoc = parentRect.location;
            Size parentSize = parentRect.size;
            Point newLocation = location;
            Size newSize = size;
            switch (dock)
            {
                case Dock.left:
                {
                    newLocation = parentLoc;
                    newSize.h = parentSize.h;
                    parentRect.location = Point(parentLoc.x + size.w, parentLoc.y);
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.left " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.top:
                {
                    newLocation = parentLoc;
                    newSize.w = parentSize.w;
                    parentRect.location = Point(parentLoc.x, parentLoc.y + size.h);
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.top " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.right:
                {
                    newLocation = Point(parentLoc.x + parentSize.w - size.w, parentLoc.y);
                    newSize.h = parentSize.h;
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.right " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.bottom:
                {
                    newLocation = Point(parentLoc.x, parentLoc.y + parentSize.h - size.h);
                    newSize.w = parentSize.w;
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.bottom " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.fill:
                {
                    newLocation = parentLoc;
                    newSize = parentSize;
                    parentRect.location = Point();
                    parentRect.size = Size();
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.fill " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        internal void MoveWindow(int dx, int dy)
        {
            Point newLocation = location;
            Size newSize = size;
            bool leftAnchored = cast<Anchors>(anchors & Anchors.left) != Anchors.none;
            bool rightAnchored = cast<Anchors>(anchors & Anchors.right) != Anchors.none;
            if (!leftAnchored)
            {
                newLocation.x = newLocation.x + dx;
            }
            else if (rightAnchored)
            {
                newSize.w = newSize.w + dx;
            }
            bool topAnchored = cast<Anchors>(anchors & Anchors.top) != Anchors.none;
            bool bottomAnchored = cast<Anchors>(anchors & Anchors.bottom) != Anchors.none;
            if (!topAnchored)
            {
                newLocation.y = newLocation.y + dy;
            }
            else if (bottomAnchored)
            {
                newSize.h = newSize.h + dy;
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Anchors GetAnchors() const
        {
            return anchors;
        }
        public inline nothrow void SetAnchors(Anchors anchors_)
        {
            anchors = anchors_;
        }
        public virtual nothrow Padding DefaultPadding() const
        {
            return Padding();
        }
        public WinRect GetClientRect() const
        {
            return GetClientRect(handle);
        }
        public WinRect GetWindowRect() const
        {
            return GetWindowRect(handle);
        }
        public Point ClientToScreen(const Point& point) const
        {
            return ClientToScreen(handle, point);
        }
        public Point ScreenToClient(const Point& point) const
        {
            return ScreenToClient(handle, point);
        }
        internal bool ProcessMessageInternal(Message& message)
        {
            return ProcessMessage(message);
        }
        public virtual void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "Control." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
        }
        public virtual void ScrollLineDown()
        {
            Control* parent = ParentControl();
            if (parent != null)
            {
                parent->ScrollLineDown();
            }
        }
        public virtual void ScrollLineUp()
        {
            Control* parent = ParentControl();
            if (parent != null)
            {
                parent->ScrollLineUp();
            }
        }
        protected void SubClassCommandWndProc()
        {
            if (originalWndProc == null && handle != null)
            {
                originalWndProc = WinSubClassCommandWndProc(handle);
            }
        }
        protected virtual bool ProcessMessage(Message& message)
        {
            if (originalWndProc != null)
            {
                // If this control has subclassed a standard Windows control for receiving WM_COMMAND notifications, first set address of original window procedure in the message:
                // Currently only GroupBox does this.
                if (message.originalWndProc == null)
                {
                    message.originalWndProc = originalWndProc;
                }
                // If this message is not a WM_COMMAND and not a WM_DESTROY message, return without processing the message.
                // Original window procedure will be called in all cases after returning from Application.ProcessMessage.
                if (message.msg != WM_COMMAND && message.msg != WM_DESTROY)
                {
                    return false;
                }
                // otherwise proceed to process the WM_COMMAND notification or WM_DESTROY message...
            }
            switch (message.msg)
            {
                case WM_PAINT:
                {
                    DoPaint();
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEMOVE:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam), 0);
                    DoMouseMove(args);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSELEAVE:
                {
                    DoMouseLeave();
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDBLCLK:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 2);
                    DoMouseDoubleClick(args);
                    message.result = 0;
                    return true;
                }
                case WM_RBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.rbutton), 1);
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_RBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.rbutton), 1);
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_CHAR:
                {
                    wchar ch = cast<wchar>(message.wparam);
                    KeyPressEventArgs args(ch);
                    DoKeyPress(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYDOWN:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyDown(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYUP:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyUp(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SYSCOMMAND:
                {
                    if (DoSysCommand(message.wparam, message.lparam))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_HSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoHScroll(request);
                    message.result = 0;
                    return true;
                }
                case WM_VSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoVScroll(request);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEWHEEL:
                {
                    MouseWheelEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(cast<uint>(cast<ushort>(message.wparam))), cast<short>(message.wparam >> 16u));
                    DoMouseWheel(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SETFOCUS:
                {
                    DoSetFocus();
                    message.result = 0;
                    return true;
                }
                case WM_KILLFOCUS:
                {
                    DoKillFocus();
                    message.result = 0;
                    return true;
                }
                case WM_SHOWWINDOW:
                {
                    if (message.wparam == 1)
                    {
                        OnShown();
                    }
                    message.result = 0;
                    return true;
                }
                case WM_TIMER:
                {
                    DoTimer(message.wparam);
                    message.result = 0;
                    return true;
                }
                case WM_DESTROY:
                {
                    DoDestroy();
                    message.result = 0;
                    return true;
                }
                case WM_CLIPBOARDUPDATE:
                {
                    DoClipboardUpdate();
                    message.result = 0;
                    return true;
                }
                case WM_MOVE:
                {
                    Point newLocation = message.LParamLocation();
                    Point oldLocation = Location();
                    if (newLocation != oldLocation)
                    {
                        SetLocationInternal(newLocation);
                    }
                    message.result = 0;
                    return true;
                }
                case WM_SIZE:
                {
                    Size newSize = message.LParamSize();
                    Size oldSize = GetSize();
                    uint windowState = message.wparam;
                    if (newSize != oldSize)
                    {
                        SetSizeInternal(newSize, windowState);
                    }
                    message.result = 0;
                    return true;
                }
                case WM_COMMAND:
                {
                    void* childWindowHandle = message.LParamHandle();
                    ushort notificationCode = message.WParamHiWord();
                    ushort controlId = message.WParamLoWord();
                    Control* child = Application.GetWindowManager().GetWindow(childWindowHandle);
                    if (child != null)
                    {
                        switch (notificationCode)
                        {
                            case BN_CLICKED:
                            {
                                child->OnClick();
                                message.result = 0;
                                return true;
                            }
                            case BN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case BN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case EN_CHANGE:
                            {
                                child->SetTextInternal(child->GetWindowText());
                                message.result = 0;
                                return true;
                            }
                            case EN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case EN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_SELCHANGE:
                            {
                                if (child is ListBox*)
                                {
                                    ListBox* listBox = cast<ListBox*>(child);
                                    listBox->SelectedIndexChangedInternal();
                                }
                                message.result = 0;
                                return true;
                            }
                        }
                    }
                    break;
                }
            }
            return false;
        }
        private void DoDestroy()
        {
            OnDestroyed();
            if (originalWndProc != null)
            {
                WinRestoreOriginalWndProc(handle, originalWndProc);
            }
        }
        private void DoClipboardUpdate()
        {
            OnClipboardUpdate();
        }
        protected virtual void OnClipboardUpdate()
        {
            clipboardUpdateEvent.Fire();
        }
        private bool DoSysCommand(uint wparam, long lparam)
        {
            switch (wparam)
            {
                case SC_KEYMENU:
                {
                    wchar accessKey = cast<wchar>(ToUpper(cast<uchar>(cast<wchar>(lparam))));
                    if (DoMenu(accessKey, Keys.none))
                    {
                        return true;
                    }
                    else
                    {
                        if (lparam == VK_F10)
                        {
                            if (DoKeyDown(cast<int>(lparam)))
                            {
                                return true;
                            }
                        }
                        else
                        {
                            currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.altModifier);
                        }
                        if (DoKeyDown(cast<int>(accessKey)))
                        {
                            currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                            return true;
                        }
                        currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                    }
                    break;
                }
                case SC_CLOSE:
                {
                    KeyEventArgs args(cast<Keys>(Keys.f4 | Keys.altModifier));
                    DoMenu(args);
                    if (args.handled)
                    {
                        return true;
                    }
                    break;
                }
            }
            return false;
        }
        public nothrow void ResetModifierKeys()
        {
            currentModifierKeys = Keys.none;
        }
        private bool DoKeyDown(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyDown: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            ResetKeyDownHandled();
            if (MenuWantsKeys())
            {
                if (DoMenu('\0', cast<Keys>(virtualKeyCode)))
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            Keys key = cast<Keys>(virtualKeyCode);
            if (WinKeyPressed(VK_SHIFT))
            {
                key = cast<Keys>(key | Keys.shiftModifier);
            }
            if (WinKeyPressed(VK_CONTROL))
            {
                key = cast<Keys>(key | Keys.controlModifier);
            }
            if (WinKeyPressed(VK_MENU))
            {
                key = cast<Keys>(key | Keys.altModifier);
            }
            KeyEventArgs args(key);
            DoMenu(args);
            if (args.handled)
            {
                SetKeyDownHandled();
                return true;
            }
            else
            {
                DispatchKeyDown(args);
                if (args.handled)
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            return false;
        }
        private bool DoKeyUp(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyUp: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            Keys key = cast<Keys>(virtualKeyCode);
            if (KeyDownHandled() || MenuWantsKeys())
            {
                return KeyDownHandled();
            }
            KeyEventArgs args(key);
            DispatchKeyUp(args);
            if (args.handled)
            {
                return true;
            }
            return false;
        }
        private void DoKeyPress(KeyPressEventArgs& args)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyPress: " + ToString(args.keyChar) + " " + ToHexString(cast<uint>(args.keyChar));
                logView->WriteLine(s);
            }
            if (KeyDownHandled() || MenuWantsKeys())
            {
                args.handled = KeyDownHandled();
                return;
            }
            ResetModifierKeys();
            DispatchKeyPress(args);
        }
        private void DispatchKeyPress(KeyPressEventArgs& args)
        {
            OnKeyPress(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyPress(args);
                }
            }
        }
        private void DispatchKeyDown(KeyEventArgs& args)
        {
            OnKeyDown(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyDown(args);
                }
            }
        }
        private void DispatchKeyUp(KeyEventArgs& args)
        {
            OnKeyUp(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyUp(args);
                }
            }
        }
        private bool DoMenu(wchar accessKey, Keys keyCode)
        {
            ResetKeyDownHandled();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "MENU: " + ToString(accessKey) + " " + ToHexString(cast<ushort>(accessKey));
                logView->WriteLine(s);
            }
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    bool menuWantsKeys = false;
                    bool handled = menuBar->HandleAccessKey(accessKey, keyCode, menuWantsKeys);
                    if (handled)
                    {
                        SetKeyDownHandled();
                    }
                    if (menuWantsKeys)
                    {
                        SetMenuWantsKeys();
                    }
                    else
                    {
                        ResetMenuWantsKeys();
                    }
                    return handled;
                }
            }
            return false;
        }
        private void DoMenu(KeyEventArgs& args)
        {
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    menuBar->DoKeyDown(args);
                }
            }
        }
        private void DoVScroll(ushort request)
        {
            OnVScroll(request);
        }
        private void DoHScroll(ushort request)
        {
            OnHScroll(request);
        }
        private void DoMouseWheel(MouseWheelEventArgs& args)
        {
            OnMouseWheel(args);
        }
        private void DoSetFocus()
        {
            if (this is Window*)
            {
                Window* thisWindow = cast<Window*>(this);
                if (thisWindow->IsMainWindow())
                {
                    OnGotFocus();
                    return;
                }
            }
            SetFocused();
            DoGotFocus();
            DoCreateAndShowCaret();
        }
        private void DoGotFocus()
        {
            OnGotFocus();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildGotFocus(args);
            }
        }
        protected virtual void OnGotFocus()
        {
            gotFocusEvent.Fire();
        }
        protected virtual void OnChildGotFocus(ControlEventArgs& args)
        {
            childGotFocusEvent.Fire(args);
        }
        private void DoKillFocus()
        {
            ResetFocused();
            DoLostFocus();
            DoDestroyCaret();
        }
        private void DoLostFocus()
        {
            OnLostFocus();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildLostFocus(args);
            }
        }
        protected virtual void OnLostFocus()
        {
            lostFocusEvent.Fire();
        }
        protected virtual void OnChildLostFocus(ControlEventArgs& args)
        {
            childLostFocusEvent.Fire(args);
        }
        protected nothrow virtual bool IsDecoratorControl() const
        {
            return false;
        }
        protected virtual void TranslateChildGraphics(Graphics& graphics)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateChildGraphics(graphics);
            }
        }
        protected virtual void TranslateMousePos(Point& location)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateMousePos(location);
            }
        }
        protected virtual void TranslateContentLocation(Point& location)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateContentLocation(location);
            }
        }
        private void DoPaint()
        {
            try
            {
                void* paintStruct = null;
                void* hdc = BeginPaint(handle, paintStruct);
                Rect clipRect;
                WinGetClipRect(paintStruct, clipRect.location.x, clipRect.location.y, clipRect.size.w, clipRect.size.h);
                PaintGuard paintGuard(hdc, paintStruct);
                Graphics graphics(hdc);
                PaintEventArgs args(graphics, clipRect);
                PaintEventArgs* argsPtr = &args;
                if (!IsDecoratorControl())
                {
                    TranslateChildGraphics(graphics);
                }
                if (Focused())
                {
                    --caretShowCount;
                }
                UniquePtr<PaintEventArgs> bufferPaintArgs;
                if (IsDoubleBuffered())
                {
                    if (buffer.IsNull() || buffer->GetSize() != GetSize())
                    {
                        buffer.Reset(new Buffer(GetSize(), graphics));
                    }
                    buffer->BitmapGraphics().Clear(BackgroundColor());
                    bufferPaintArgs.Reset(new PaintEventArgs(buffer->BitmapGraphics(), clipRect));
                    argsPtr = bufferPaintArgs.Get();
                    Matrix matrix;
                    graphics.GetTransformChecked(matrix);
                    buffer->BitmapGraphics().SetTransformChecked(matrix);
                }
                OnPaint(*argsPtr);
                if (IsDoubleBuffered())
                {
                    Graphics windowGraphics(hdc);
                    buffer->Draw(windowGraphics);
                }
                if (Focused() && CaretCreated())
                {
                    ShowCaret();
                }
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        protected virtual void OnPaint(PaintEventArgs& args)
        {
            paintEvent.Fire(args);
        }
        internal virtual void PaintAll(PaintEventArgs& args, bool skipMenuBar)
        {
            try
            {
                OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void DoCreateAndShowCaret()
        {
            if (Focused())
            {
                CreateCaret();
                SetCaretCreated();
                SetCaretLocation();
                ShowCaret();
            }
        }
        public virtual void CreateCaret()
        {
            System.Windows.API.CreateCaret(Handle(), null, 1, 15);
        }
        private void DoDestroyCaret()
        {
            if (CaretCreated())
            {
                HideCaret();
                ResetCaretCreated();
                DestroyCaret();
            }
        }
        public virtual void DestroyCaret()
        {
            System.Windows.API.DestroyCaret();
            caretShowCount = 0;
        }
        public void ShowCaret()
        {
            System.Windows.API.ShowCaret(Handle());
            ++caretShowCount;
        }
        public void HideCaret()
        {
            System.Windows.API.HideCaret(Handle());
            --caretShowCount;
        }
        public nothrow inline int CaretShowCount() const
        {
            return caretShowCount;
        }
        public Point GetCaretPos() const
        {
            return System.Windows.API.GetCaretPos();
        }
        public void SetCaretPos(const Point& caretPos)
        {
            if (CaretCreated())
            {
                System.Windows.API.SetCaretPos(caretPos);
            }
        }
        private void DoMouseMove(MouseEventArgs& args)
        {
            if (!MouseInClient())
            {
                SetMouseInClient();
                SetCursor();
                OnMouseEnter();
                WinTrackMouseEvent(handle, TME_LEAVE, HOVER_DEFAULT);
            }
            else
            {
                if (!IsDecoratorControl())
                {
                    TranslateMousePos(args.location);
                }
                SetCursor();
                OnMouseMove(args);
            }
            if (mouseHoverMs != 0u && !MouseHoverTimerStarted())
            {
                Point pt = args.location;
                int dx = Abs(mouseHoverLocation.x - pt.x);
                int dy = Abs(mouseHoverLocation.y - pt.y);
                if (dx > mouseHoverRectSize.w || dy > mouseHoverRectSize.h)
                {
                    SetMouseHoverTimerStarted();
                    mouseHoverLocation = pt;
                    SetTimer(mouseHoverTimerId, mouseHoverMs);
                }
            }
        }
        public nothrow void SetMouseHoverMs(uint mouseHoverMs_)
        {
            mouseHoverMs = mouseHoverMs_;
        }
        public nothrow uint MouseHoverMs() const
        {
            return mouseHoverMs;
        }
        public nothrow void SetMouseHoverRectSize(const Size& mouseHoverRectSize_)
        {
            mouseHoverRectSize = mouseHoverRectSize_;
        }
        public nothrow const Size& MouseHoverRectSize() const
        {
            return mouseHoverRectSize;
        }
        private void DoMouseHover()
        {
            ResetMouseHoverTimerStarted();
            KillTimer(mouseHoverTimerId);
            Point pt;
            GetCursorPos(pt.x, pt.y);
            pt = ScreenToClient(pt);
            if (!IsDecoratorControl())
            {
                TranslateMousePos(pt);
            }
            int dx = Abs(mouseHoverLocation.x - pt.x);
            int dy = Abs(mouseHoverLocation.y - pt.y);
            if (dx <= mouseHoverRectSize.w && dy <= mouseHoverRectSize.h)
            {
                MouseEventArgs args;
                args.location = pt;
                OnMouseHover(args);
            }
        }
        private void DoMouseLeave()
        {
            ResetMouseInClient();
            ResetLButtonPressed();
            OnMouseLeave();
        }
        private void DoMouseDown(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDown(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                SetLButtonPressed();
            }
        }
        private void DoMouseUp(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseUp(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                if (LButtonPressed())
                {
                    ResetLButtonPressed();
                    this->OnClick();
                }
            }
            Window* mainWindow = Application.MainWindow();
            if (mainWindow != null)
            {
                mainWindow->MouseUpNotificationInternal(args);
            }
        }
        private void DoMouseDoubleClick(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDoubleClick(args);
        }
        public void SetTimer(uint timerId, uint elapseMs)
        {
            SetTimer(Handle(), timerId, elapseMs);
        }
        public void KillTimer(uint timerId)
        {
            KillTimer(Handle(), timerId);
        }
        private void DoTimer(uint timerId)
        {
            TimerEventArgs timerEventArgs(timerId);
            OnTimer(timerEventArgs);
        }
        protected virtual void OnTimer(TimerEventArgs& args)
        {
            if (args.timerId == mouseHoverTimerId)
            {
                DoMouseHover();
            }
            else
            {
                timerEvent.Fire(args);
            }
        }
        protected virtual void SetCursor()
        {
            SetCursor(arrowCursor);
        }
        protected virtual void OnMouseEnter()
        {
            mouseEnterEvent.Fire();
        }
        protected virtual void OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
        }
        protected virtual void OnMouseHover(MouseEventArgs& args)
        {
            mouseHoverEvent.Fire(args);
        }
        protected virtual void OnMouseLeave()
        {
            mouseLeaveEvent.Fire();
        }
        protected virtual void OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
            if (!(this is MenuItem*) && !(this is MenuControl*))
            {
                Window* window = GetWindow();
                if (window != null)
                {
                    MenuBar* menuBar = window->GetMenuBar();
                    if (menuBar != null)
                    {
                        menuBar->CloseMenu();
                    }
                }
            }
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        protected virtual void OnMouseDoubleClick(MouseEventArgs& args)
        {
            mouseDoubleClickEvent.Fire(args);
        }
        protected virtual void OnKeyPress(KeyPressEventArgs& args)
        {
            keyPressEvent.Fire(args);
        }
        protected virtual void OnKeyDown(KeyEventArgs& args)
        {
            keyDownEvent.Fire(args);
        }
        protected virtual void OnKeyUp(KeyEventArgs& args)
        {
            keyUpEvent.Fire(args);
        }
        protected virtual void OnClick()
        {
            clickEvent.Fire();
        }
        protected virtual void OnRightClick(RightClickEventArgs& args)
        {
            rightClickEvent.Fire(args);
        }
        protected virtual void OnCreated()
        {
            SetBaseOnCreatedCalled();
            createdEvent.Fire();
        }
        protected virtual void OnDestroyed()
        {
            destroyedEvent.Fire();
        }
        protected virtual void OnShown()
        {
            shownEvent.Fire();
        }
        protected virtual void OnHScroll(ScrollEventArgs& args)
        {
            hscrollEvent.Fire(args);
        }
        protected virtual void OnVScroll(ScrollEventArgs& args)
        {
            vscrollEvent.Fire(args);
        }
        protected virtual void OnMouseWheel(MouseWheelEventArgs& args)
        {
            mouseWheelEvent.Fire(args);
        }
        protected virtual void OnControlAdded(ControlEventArgs& args)
        {
            controlAddedEvent.Fire(args);
        }
        public virtual void OnControlRemoved(ControlEventArgs& args)
        {
            controlRemovedEvent.Fire(args);
        }
        public void* GetDC()
        {
            return GetDC(handle);
        }
        public void Invalidate()
        {
            InvalidateRect(handle, null, false);
        }
        public void Invalidate(const WinRect& rect)
        {
            InvalidateRect(handle, &rect, false);
        }
        public void Invalidate(const WinRect& rect, bool eraseBackground)
        {
            InvalidateRect(handle, &rect, eraseBackground);
        }
        public void Invalidate(const Rect& rect)
        {
            Invalidate(rect.ToWinRect());
        }
        public void Invalidate(const Rect& rect, bool eraseBackground)
        {
            Invalidate(rect.ToWinRect(), eraseBackground);
        }
        public nothrow inline const Color& BackgroundColor() const
        {
            return backgroundColor;
        }
        public void SetBackgroundColor(const Color& backgroundColor_)
        {
            backgroundColor = backgroundColor_;
            Invalidate();
        }
        public nothrow const Font& GetFont() const
        {
            if (!font.IsNull())
            {
                return font;
            }
            else
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    return parent->GetFont();
                }
                else
                {
                    return font;
                }
            }
        }
        public void SetFont(const Font& font_)
        {
            font = font_;
        }
        public nothrow void SetFont(Font&& font_)
        {
            font = Rvalue(font_);
        }
        public const FontHandle& GetFontHandle(Graphics& graphics)
        {
            if (!fontHandle.IsNull())
            {
                return fontHandle;
            }
            if (!font.IsNull())
            {
                fontHandle = font.ToHFontChecked(graphics);
                return fontHandle;
            }
            Control* parent = ParentControl();
            if (parent != null)
            {
                return parent->GetFontHandle(graphics);
            }
            else
            {
                return fontHandle; // fontHandle.IsNull() will be true
            }
        }
        public nothrow inline void* Handle() const
        {
            return handle;
        }
        public inline nothrow WindowStyle GetWindowStyle() const
        {
            return style;
        }
        public inline nothrow ExtendedWindowStyle GetExtendedWindowStyle() const
        {
            return exStyle;
        }
        public nothrow Event<PaintEventHandler, PaintEventArgs>& PaintEvent()
        {
            return paintEvent;
        }
        public nothrow Event<MouseEnterEventHandler>& MouseEnterEvent() const
        {
            return mouseEnterEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent() const
        {
            return mouseMoveEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseHoverEvent() const
        {
            return mouseHoverEvent;
        }
        public nothrow Event<MouseLeaveEventHandler>& MouseLeaveEvent() const
        {
            return mouseLeaveEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent() const
        {
            return mouseDownEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent() const
        {
            return mouseUpEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDoubleClickEvent() const
        {
            return mouseDoubleClickEvent;
        }
        public nothrow Event<KeyPressEventHandler, KeyPressEventArgs>& KeyPressEvent() const
        {
            return keyPressEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyDownEvent() const
        {
            return keyDownEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyUpEvent() const
        {
            return keyUpEvent;
        }
        public nothrow Event<CreatedEventHandler>& CreatedEvent() const
        {
            return createdEvent;
        }
        public nothrow Event<DestroyedEventHandler>& DestroyedEvent() const
        {
            return destroyedEvent;
        }
        public nothrow Event<ShownEventHandler>& ShownEvent() const
        {
            return shownEvent;
        }
        public nothrow Event<EnabledChangedEventHandler>& EnabledChangedEvent() const
        {
            return enabledChangedEvent;
        }
        public nothrow Event<VisibleChangedEventHandler>& VisibleChangedEvent() const
        {
            return visibleChangedEvent;
        }
        public nothrow Event<ClickEventHandler>& ClickEvent() const
        {
            return clickEvent;
        }
        public nothrow Event<SizeChangedEventHandler, uint>& SizeChangedEvent() const
        {
            return sizeChangedEvent;
        }
        public nothrow Event<SizeChangingEventHandler, SizeChangingEventArgs> SizeChangingEvent() const
        {
            return sizeChangingEvent;
        }
        public nothrow Event<ChildSizeChangedEventHandler, ControlEventArgs>& ChildSizeChangedEvent() const
        {
            return childSizeChangedEvent;
        }
        public nothrow Event<LocationChangedEventHandler>& LocationChangedEvent() const
        {
            return locationChangedEvent;
        }
        public nothrow Event<ContentChangedEventHandler>& ContentChangedEvent() const
        {
            return contentChangedEvent;
        }
        public nothrow Event<ChildContentChangedEventHandler, ControlEventArgs>& ChildContentChangedEvent() const
        {
            return childContentChangedEvent;
        }
        public nothrow Event<ContentLocationChangedEventHandler>& ContentLocationChangedEvent() const
        {
            return contentLocationChangedEvent;
        }
        public nothrow Event<ChildContentLocationChangedEventHandler, ControlEventArgs>& ChildContentLocationChangedEvent() const
        {
            return childContentLocationChangedEvent;
        }
        public nothrow Event<ContentSizeChangedEventHandler>& ContentSizeChangedEvent() const
        {
            return contentSizeChangedEvent;
        }
        public nothrow Event<ChildContentSizeChangedEventHandler, ControlEventArgs>& ChildContentSizeChangedEvent() const
        {
            return childContentSizeChangedEvent;
        }
        public nothrow Event<TextChangedEventHandler>& TextChangedEvent() const
        {
            return textChangedEvent;
        }
        public nothrow Event<HScrollEventHandler, ScrollEventArgs>& HScrollEvent() const
        {
            return hscrollEvent;
        }
        public nothrow Event<VScrollEventHandler, ScrollEventArgs>& VScrollEvent() const
        {
            return vscrollEvent;
        }
        public nothrow Event<MouseWheelEventHandler, MouseWheelEventArgs>& MouseWheelEvent() const
        {
            return mouseWheelEvent;
        }
        public nothrow Event<TimerEventHandler, TimerEventArgs>& TimerEvent() const
        {
            return timerEvent;
        }
        public nothrow Event<GotFocusEventHandler>& GotFocusEvent() const
        {
            return gotFocusEvent;
        }
        public nothrow Event<LostFocusEventHandler>& LostFocusEvent() const
        {
            return lostFocusEvent;
        }
        public nothrow Event<ControlEventHandler, ControlEventArgs>& ControlAddedEvent() const
        {
            return controlAddedEvent;
        }
        public nothrow Event<ControlEventHandler, ControlEventArgs>& ControlRemovedEvent() const
        {
            return controlRemovedEvent;
        }
        public nothrow Event<RightClickEventHandler, RightClickEventArgs>& RightClickEvent() const
        {
            return rightClickEvent;
        }
        public nothrow Event<ClipboardUpdateEventHandler>& ClipboadUpdateEvent() const
        {
            return clipboardUpdateEvent;
        }
        private nothrow inline bool MouseInClient() const
        {
            return (flags & Flags.mouseInClient) != 0;
        }
        private nothrow inline void SetMouseInClient()
        {
            flags = cast<Flags>(flags | Flags.mouseInClient);
        }
        private nothrow inline void ResetMouseInClient()
        {
            flags = cast<Flags>(flags & ~Flags.mouseInClient);
        }
        private nothrow inline bool LButtonPressed() const
        {
            return (flags & flags.lbuttonPressed) != 0;
        }
        private nothrow inline void SetLButtonPressed()
        {
            flags = cast<Flags>(flags | Flags.lbuttonPressed);
        }
        private nothrow inline void ResetLButtonPressed()
        {
            flags = cast<Flags>(flags & ~Flags.lbuttonPressed);
        }
        private nothrow inline bool MenuWantsKeys() const
        {
            return (flags & flags.menuWantsKeys) != 0;
        }
        private nothrow inline void SetMenuWantsKeys()
        {
            flags = cast<Flags>(flags | Flags.menuWantsKeys);
        }
        private nothrow inline void ResetMenuWantsKeys()
        {
            flags = cast<Flags>(flags & ~Flags.menuWantsKeys);
        }
        private nothrow inline bool KeyDownHandled() const
        {
            return (flags & Flags.keyDownHandled) != 0;
        }
        private nothrow inline void SetKeyDownHandled()
        {
            flags = cast<Flags>(flags | Flags.keyDownHandled);
        }
        private nothrow inline void ResetKeyDownHandled()
        {
            flags = cast<Flags>(flags & ~Flags.keyDownHandled);
        }
        public nothrow inline bool Focused() const
        {
            return (flags & Flags.focused) != 0;
        }
        private nothrow inline void SetFocused()
        {
            flags = cast<Flags>(flags | Flags.focused);
        }
        private nothrow inline void ResetFocused()
        {
            flags = cast<Flags>(flags & ~Flags.focused);
        }
        public nothrow inline bool CaretCreated() const
        {
            return (flags & Flags.caretCreated) != 0;
        }
        private nothrow inline void SetCaretCreated()
        {
            flags = cast<Flags>(flags | Flags.caretCreated);
        }
        private nothrow inline void ResetCaretCreated()
        {
            flags = cast<Flags>(flags & ~Flags.caretCreated);
        }
        private nothrow inline bool CaretShown() const
        {
            return (flags & Flags.caretShown) != 0;
        }
        private nothrow inline void SetCaretShown()
        {
            flags = cast<Flags>(flags | Flags.caretShown);
        }
        private nothrow inline void ResetCaretShown()
        {
            flags = cast<Flags>(flags & ~Flags.caretShown);
        }
        public nothrow inline bool IsDisabled() const
        {
            return (flags & Flags.disabled) != 0;
        }
        private nothrow inline void SetDisabled()
        {
            flags = cast<Flags>(flags | Flags.disabled);
        }
        private nothrow inline void ResetDisabled()
        {
            flags = cast<Flags>(flags & ~Flags.disabled);
        }
        private nothrow inline bool Hidden() const
        {
            return (flags & Flags.hidden) != 0;
        }
        private nothrow inline void SetHidden()
        {
            flags = cast<Flags>(flags | Flags.hidden);
        }
        private nothrow inline void ResetHidden()
        {
            flags = cast<Flags>(flags & ~Flags.hidden);
        }
        public nothrow inline bool IsTabStop() const
        {
            return (flags & Flags.tabStop) != Flags.none;
        }
        public nothrow inline void SetTabStop()
        {
            flags = cast<Flags>(flags | Flags.tabStop);
        }
        public nothrow inline void ResetTabStop()
        {
            flags = cast<Flags>(flags & ~Flags.tabStop);
        }
        internal nothrow inline bool BaseOnCreatedCalled() const
        {
            return (flags & Flags.baseOnCreatedCalled) != Flags.none;
        }
        internal nothrow inline void SetBaseOnCreatedCalled()
        {
            flags = cast<Flags>(flags | Flags.baseOnCreatedCalled);
        }
        private nothrow inline void ResetBaseOnCreatedCalled()
        {
            flags = cast<Flags>(flags & ~Flags.baseOnCreatedCalled);
        }
        private nothrow inline bool MouseHoverTimerStarted() const
        {
            return (flags & Flags.mouseHoverTimerStarted) != Flags.none;
        }
        private nothrow inline void SetMouseHoverTimerStarted()
        {
            flags = cast<Flags>(flags | Flags.mouseHoverTimerStarted);
        }
        private nothrow inline void ResetMouseHoverTimerStarted()
        {
            flags = cast<Flags>(flags & ~Flags.mouseHoverTimerStarted);
        }
        public nothrow inline bool IsDoubleBuffered() const
        {
            return (flags & Flags.doubleBuffered) != Flags.none;
        }
        public nothrow inline void SetDoubleBuffered()
        {
            flags = cast<Flags>(flags | Flags.doubleBuffered);
        }
        public nothrow inline void ResetDoubleBuffered()
        {
            flags = cast<Flags>(flags & ~Flags.doubleBuffered);
        }
        public nothrow inline bool IsScrollSubject() const
        {
            return (flags & Flags.scrollSubject) != Flags.none;
        }
        public nothrow inline void SetScrollSubject()
        {
            flags = cast<Flags>(flags | Flags.scrollSubject);
        }
        public nothrow inline void ResetScrollSubject()
        {
            flags = cast<Flags>(flags & ~Flags.scrollSubject);
        }
        private string windowClassName;
        private int windowClassBackgroundColor;
        private WindowClassStyle windowClassStyle;
        private Color backgroundColor;
        private WindowStyle style;
        private ExtendedWindowStyle exStyle;
        private void* handle;
        private string text;
        private Point location;
        private Size size;
        private Point contentLocation;
        private Size contentSize;
        private int verticalScrollUnit;
        private int horizontalScrollUnit;
        private Dock dock;
        private Anchors anchors;
        private Flags flags;
        private Keys currentModifierKeys;
        private List<Control*> createList;
        private Cursor arrowCursor;
        private int caretShowCount;
        private Font font;
        private FontHandle fontHandle;
        private void* originalWndProc;
        private Size mouseHoverRectSize;
        private uint mouseHoverMs;
        private Point mouseHoverLocation;
        private UniquePtr<Buffer> buffer;
        private Event<PaintEventHandler, PaintEventArgs> paintEvent;
        private Event<MouseEnterEventHandler> mouseEnterEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseHoverEvent;
        private Event<MouseLeaveEventHandler> mouseLeaveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDoubleClickEvent;
        private Event<KeyPressEventHandler, KeyPressEventArgs> keyPressEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyDownEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyUpEvent;
        private Event<ClickEventHandler> clickEvent;
        private Event<CreatedEventHandler> createdEvent;
        private Event<DestroyedEventHandler> destroyedEvent;
        private Event<ShownEventHandler> shownEvent;
        private Event<EnabledChangedEventHandler> enabledChangedEvent;
        private Event<VisibleChangedEventHandler> visibleChangedEvent;
        private Event<SizeChangedEventHandler, uint> sizeChangedEvent;
        private Event<SizeChangingEventHandler, SizeChangingEventArgs> sizeChangingEvent;
        private Event<ChildSizeChangedEventHandler, ControlEventArgs> childSizeChangedEvent;
        private Event<LocationChangedEventHandler> locationChangedEvent;
        private Event<ContentChangedEventHandler> contentChangedEvent;
        private Event<ChildContentChangedEventHandler, ControlEventArgs> childContentChangedEvent;
        private Event<ContentLocationChangedEventHandler> contentLocationChangedEvent;
        private Event<ChildContentLocationChangedEventHandler, ControlEventArgs> childContentLocationChangedEvent;
        private Event<ContentSizeChangedEventHandler> contentSizeChangedEvent;
        private Event<ChildContentSizeChangedEventHandler, ControlEventArgs> childContentSizeChangedEvent;
        private Event<TextChangedEventHandler> textChangedEvent;
        private Event<HScrollEventHandler, ScrollEventArgs> hscrollEvent;
        private Event<VScrollEventHandler, ScrollEventArgs> vscrollEvent;
        private Event<MouseWheelEventHandler, MouseWheelEventArgs> mouseWheelEvent;
        private Event<TimerEventHandler, TimerEventArgs> timerEvent;
        private Event<GotFocusEventHandler> gotFocusEvent;
        private Event<LostFocusEventHandler> lostFocusEvent;
        private Event<ChildGotFocusEventHandler, ControlEventArgs> childGotFocusEvent;
        private Event<ChildLostFocusEventHandler, ControlEventArgs> childLostFocusEvent;
        private Event<ControlEventHandler, ControlEventArgs> controlAddedEvent;
        private Event<ControlEventHandler, ControlEventArgs> controlRemovedEvent;
        private Event<RightClickEventHandler, RightClickEventArgs> rightClickEvent;
        private Event<ClipboardUpdateEventHandler> clipboardUpdateEvent;
    }
}

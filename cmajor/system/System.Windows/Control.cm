// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Windows.API;

namespace System.Windows
{
    public class delegate void PaintEventHandler(PaintEventArgs& paintEventArgs);
    public class delegate void MouseEnterEventHandler();
    public class delegate void MouseEventHandler(MouseEventArgs& mouseEventargs);
    public class delegate void MouseLeaveEventHandler();
    public class delegate void MouseWheelEventHandler(MouseWheelEventArgs& mouseWheelEventArgs);
    public class delegate void KeyPressEventHandler(KeyPressEventArgs& keyPressEventArgs);
    public class delegate void KeyEventHandler(KeyEventArgs& keyEventArgs);
    public class delegate void ClickEventHandler();
    public class delegate void CreatedEventHandler();
    public class delegate void DestroyedEventHandler();
    public class delegate void ShownEventHandler();
    public class delegate void EnabledChangedEventHandler();
    public class delegate void VisibleChangedEventHandler();
    public class delegate void SizeChangedEventHandler();
    public class delegate void LocationChangedEventHandler();
    public class delegate void ContentChangedEventHandler();
    public class delegate void ChildContentChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ContentLocationChangedEventHandler();
    public class delegate void ChildContentLocationChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ContentSizeChangedEventHandler();
    public class delegate void ChildContentSizeChangedEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void TextChangedEventHandler();
    public class delegate void HScrollEventHandler(ScrollEventArgs& scrollEventArgs);
    public class delegate void VScrollEventHandler(ScrollEventArgs& scrollEventArgs);
    public class delegate void TimerEventHandler(TimerEventArgs& timerEventArgs);
    public class delegate void GotFocusEventHandler();
    public class delegate void LostFocusEventHandler();
    public class delegate void ChildGotFocusEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ChildLostFocusEventHandler(ControlEventArgs& controlEventArgs);
    public class delegate void ControlEventHandler(ControlEventArgs& args);
    public class delegate void ClipboardUpdateEventHandler();

    public inline nothrow WindowClassStyle DefaultWindowClassStyle()
    {
        return WindowClassStyle.CS_DEFAULT;
    }

    public inline nothrow WindowClassStyle DoubleClickWindowClassStyle()
    {
        return WindowClassStyle.CS_DBLCLKS;
    }

    public inline nothrow WindowStyle DefaultChildWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CHILD | WindowStyle.WS_VISIBLE | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow WindowStyle HiddenChildWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CHILD | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow WindowStyle DialogWindowStyle()
    {
        return cast<WindowStyle>(WindowStyle.WS_CAPTION | WindowStyle.WS_DLGFRAME | WindowStyle.WS_CLIPSIBLINGS);
    }

    public inline nothrow ExtendedWindowStyle DefaultExtendedWindowStyle()
    {
        return ExtendedWindowStyle.WS_EX_DEFAULT;
    }

    public nothrow Color DefaultControlBackgroundColor()
    {
        return GetSystemColor(SystemColor.COLOR_MENU);
    }

    public abstract class Control : Component
    {
        private enum Flags : short
        {
            none = 0, mouseInClient = 1 << 0, lbuttonPressed = 1 << 1, menuWantsKeys = 1 << 2, keyDownHandled = 1 << 3, focused = 1 << 4, caretCreated = 1 << 5, caretShown = 1 << 6,
            disabled = 1 << 7, hidden = 1 << 8, tabStop = 1 << 9, baseOnCreatedCalled = 1 << 10
        }
        public Control(const char* windowClassName_, WindowClassStyle windowClassStyle_, WindowStyle style_, ExtendedWindowStyle exStyle_, 
            const Color& backgroundColor_, const string& text_, const Point& location_, const Size& size_, Dock dock_, Anchors anchors_) : 
            windowClassName(windowClassName_), windowClassStyle(windowClassStyle_), style(style_), exStyle(exStyle_),
            backgroundColor(backgroundColor_), handle(null), text(text_), location(location_), size(size_), contentLocation(0, 0), contentSize(), dock(dock_), anchors(anchors_), flags(Flags.none),
            arrowCursor(LoadStandardCursor(StandardCursorId.IDC_ARROW)), caretShowCount(0), font(null), fontHandle(null), originalWndProc(null)
        {
            if ((style & WindowStyle.WS_DISABLED) != 0)
            {
                SetDisabled();
            }
            if ((style & WindowStyle.WS_VISIBLE) == 0)
            {
                SetHidden();
            }
            if ((style & WindowStyle.WS_TABSTOP) != 0)
            {
                SetTabStop();
            }
            Application.Init();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                CreateWindow();
            }
        }
        public ~Control()
        {
            if (handle != null)
            {
                Application.GetWindowManager().RemoveWindow(this);
            } 
        }
        protected void CreateWindow()
        {
            CreateWindowInternal();
        }
        public nothrow Control* ParentControl() const
        {
            Control* parentControl = null;
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    parentControl = cast<Control*>(parent);
                }
            }
            return parentControl;
        }
        public nothrow string ParentText() const
        {
            string parentText;
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentText = "parent:" + string(typename(*parentControl)) + "." + parentControl->Text() + ".parentHandle=" + ToHexString(cast<ulong>(parentControl->Handle()));
            }
            return parentText;
        }
        internal nothrow void SetWindowCreateStyleFromFlags()
        {
            if (IsDisabled())
            {
                style = cast<WindowStyle>(style | WindowStyle.WS_DISABLED);
            }
            else
            {
                style = cast<WindowStyle>(style & ~WindowStyle.WS_DISABLED);
            }
            if (Hidden())
            {
                style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
            }
            else
            {
                style = cast<WindowStyle>(style | WindowStyle.WS_VISIBLE);
            }
        }
        internal void CreateWindowInternal()
        {
            if (handle != null) return;
            Control* parentControl = ParentControl();
            SetWindowCreateStyleFromFlags();
            if (Application.GetWindowManager().IsSystemClassName(windowClassName))
            {
                handle = CreateWindowByClassName(windowClassName, text.Chars(), style, exStyle, location, size, parentControl);
            }
            else
            {
                ushort windowClass = Application.GetWindowManager().RegisterWindowClass(windowClassName, windowClassStyle, 0);
                handle = CreateWindowByClassAtom(windowClass, text.Chars(), style, exStyle, location, size, parentControl);
            }
            if (!createList.IsEmpty())
            {
                for (Control* childControl : createList)
                {
                    childControl->CreateWindowInternal();
                }
                createList.Clear();
            }
            Application.GetWindowManager().AddWindow(this);
            OnCreated();
            WinRect clientRect = GetClientRect();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            size.w = clientRect.right - clientRect.left;
            size.h = clientRect.bottom - clientRect.top;
            if (parentControl != null && parentControl->createList.IsEmpty())
            {
                DockWindow();
            }
        }
        internal void AddChildVisual(Control* child)
        {
            if (handle != null)
            {
                if (child->Handle() == null)
                {
                    child->CreateWindowInternal();
                }
                else
                {
                    child->SetParentWindow(this);
                }
                if ((child->GetWindowStyle() & WindowStyle.WS_VISIBLE) != 0)
                {
                    child->Show();
                    child->Update();
                }
            }
            else
            {
                createList.Add(child);
            }
        }
        public nothrow virtual ContainerControl* GetContainerControl() const
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                return parentControl->GetContainerControl();
            }
            return null;
        }
        public Window* GetWindow() const
        {
            Control* thisControl = this;
            if (thisControl is Window*)
            {
                return cast<Window*>(this);
            }
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is Window*)
                    {
                        return cast<Window*>(parent);
                    }
                    else if (parent is Control*)
                    {
                        Control* control = cast<Control*>(parent);
                        return control->GetWindow();
                    }
                }
            }
            return null;
        }
        internal void SetParentWindow(Control* parentWindow)
        {
            SetParentWindow(handle, parentWindow->handle);
            DockWindow();
        }
        public nothrow inline bool IsEnabled() const
        {
            return !IsDisabled();
        }
        public void Enable()
        {
            if (IsDisabled())
            {
                ResetDisabled();
                style = cast<WindowStyle>(style & ~WindowStyle.WS_DISABLED);
                if (handle != null)
                {
                    EnableWindow(true);
                }
                OnEnabledChanged();
            }
        }
        public void Disable()
        {
            if (!IsDisabled())
            {
                SetDisabled();
                style = cast<WindowStyle>(style | WindowStyle.WS_DISABLED);
                if (handle != null)
                {
                    EnableWindow(false);
                }
                OnEnabledChanged();
            }
        }
        protected virtual void OnEnabledChanged()
        {
            enabledChangedEvent.Fire();
        }
        internal void EnableWindow(bool enable)
        {
            WinEnableWindow(handle, enable);
        }
        public void BringToFront()
        {
            BringWindowToTop(handle);
        }
        public Control* TopControl() const
        {
            void* topWindowHandle = GetTopWindow(handle);
            if (topWindowHandle != null)
            {
                return Application.GetWindowManager().GetWindow(topWindowHandle);
            }
            else
            {
                return null;
            }
        }
        public nothrow inline bool IsVisible() const
        {
            return !Hidden();
        }
        public void Show()
        {
            if (Hidden())
            {
                ResetHidden();
                style = cast<WindowStyle>(style | WindowStyle.WS_VISIBLE);
                OnVisibleChanged();
            }
            if (handle != null)
            {
                ShowWindow(ShowCommand.SW_SHOW);
            }
        }
        public void Hide()
        {
            if (handle != null)
            {
                ShowWindow(ShowCommand.SW_HIDE);
            }
            if (!Hidden())
            {
                SetHidden();
                style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
                OnVisibleChanged();
            }
        }
        public void ShowWindow(ShowCommand showCommand)
        {
            WinShowWindow(handle, showCommand);
            if (showCommand == ShowCommand.SW_HIDE)
            {
                if (!Hidden())
                {
                    SetHidden();
                    style = cast<WindowStyle>(style & ~WindowStyle.WS_VISIBLE);
                    OnVisibleChanged();
                }
            }
        }
        protected virtual void OnVisibleChanged()
        {
            visibleChangedEvent.Fire();
        }
        public void Update()
        {
            WinUpdateWindow(handle);
        }
        internal nothrow virtual Control* GetFirstEnabledTabStopControl() const
        {
            if (IsTabStop() && IsEnabled())
            {
                return this;
            }
            else
            {
                return null;
            }
        }
        internal nothrow virtual Control* GetLastEnabledTabStopControl() const
        {
            if (IsTabStop() && IsEnabled())
            {
                return this;
            }
            else
            {
                return null;
            }
        }
        public void SetFocus()
        {
            WinSetFocus(Handle());
            Window* window = GetWindow();
            if (window != null)
            {
                window->SetFocusedControl(this);
            }
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                SetWindowText(handle, text);
                OnTextChanged();
            }
        }
        internal void SetTextInternal(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                OnTextChanged();
            }
        }
        public int GetWindowTextLength() const
        {
            return GetWindowTextLength(handle);
        }
        public string GetWindowText()
        {
            return GetWindowText(handle);
        }
        protected virtual void OnTextChanged()
        {
            textChangedEvent.Fire();
        }
        public const Point& Location()
        {
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            return location;
        }
        public void SetLocation(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
                OnLocationChanged();
            }
        }
        protected virtual void OnLocationChanged()
        {
            locationChangedEvent.Fire();
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        internal nothrow void SetSizeInternal(const Size& sz)
        {
            if (size != sz)
            {
                size = sz;
                OnSizeChanged();
            }
        }
        public void SetSize(const Size& sz)
        {
            if (size != sz)
            {
                SetSizeInternal(sz);
                if (handle != null)
                {
                    MoveWindow(handle, location, size, true);
                }
            }
        }
        public void SendSetFontMessage(const FontHandle& fontHandle)
        {
            if (Handle() != null)
            {
                WinSendMessage(Handle(), WM_SETFONT, cast<uint>(cast<ulong>(fontHandle.HFont())), 0);
            }
        }
        protected virtual void OnSizeChanged()
        {
            sizeChangedEvent.Fire();
        }
        public void SetContentChanged()
        {
            OnContentChanged();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildContentChanged(args);
            }
        }
        protected virtual void OnContentChanged()
        {
            contentChangedEvent.Fire();
        }
        protected virtual void OnChildContentChanged(ControlEventArgs& args)
        {
            childContentChangedEvent.Fire(args);
        }
        public nothrow inline const Point& ContentLocation() const
        {
            return contentLocation;
        }
        internal nothrow void SetContentLocationInternal(const Point& contentLocation_)
        {
            contentLocation = contentLocation_;
        }
        public void SetContentLocation(const Point& contentLocation_)
        {
            if (contentLocation != contentLocation_)
            {
                contentLocation = contentLocation_;
                OnContentLocationChanged();
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    ControlEventArgs args(this);
                    parentControl->OnChildContentLocationChanged(args);
                }
            }
        }
        protected virtual void OnContentLocationChanged()
        {
            contentLocationChangedEvent.Fire();
        }
        protected virtual void OnChildContentLocationChanged(ControlEventArgs& args)
        {
            childContentLocationChangedEvent.Fire(args);
        }
        public nothrow inline const Size& ContentSize() const
        {
            return contentSize;
        }
        public void SetContentSize(const Size& contentSize_)
        {
            if (contentSize != contentSize_)
            {
                contentSize = contentSize_;
                OnContentSizeChanged();
                Control* parentControl = ParentControl();
                if (parentControl != null)
                {
                    ControlEventArgs args(this);
                    parentControl->OnChildContentSizeChanged(args);
                }
            }
        }
        protected virtual void OnContentSizeChanged()
        {
            contentSizeChangedEvent.Fire();
        }
        protected virtual void OnChildContentSizeChanged(ControlEventArgs& args)
        {
            childContentSizeChangedEvent.Fire(args);
        }
        public nothrow void SetScrollUnits(int verticalScrollUnit_, int horizontalScrollUnit_)
        {
            verticalScrollUnit = verticalScrollUnit_;
            horizontalScrollUnit = horizontalScrollUnit_;
        }
        public nothrow Pair<int, int> GetScrollUnits() const
        {
            return MakePair(verticalScrollUnit, horizontalScrollUnit);
        }
        protected virtual void SetCaretLocation()
        {
            SetCaretPos(Point(0, 0));
        }
        public inline nothrow Dock GetDock() const
        {
            return dock;
        }
        public void SetDock(Dock dock_)
        {
            dock = dock_;
            if (dock != Dock.none)
            {
                DockWindow();
            }
        }
        internal void DockWindow()
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                if (parentControl is ContainerControl*)
                {
                    ContainerControl* containerParent = cast<ContainerControl*>(parentControl);
                    containerParent->DockChildren();
                }
            }
        }
        internal void DockWindow(Rect& parentRect)
        {
            if (dock == Dock.none) return;
            if (handle == null) return;
            LogView* logView = Application.GetLogView();
            Point parentLoc = parentRect.location;
            Size parentSize = parentRect.size;
            Point newLocation = location;
            Size newSize = size;
            switch (dock)
            {
                case Dock.left:
                {
                    newLocation = parentLoc;
                    newSize.h = parentSize.h;
                    parentRect.location = Point(parentLoc.x + size.w, parentLoc.y);
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.left " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.top:
                {
                    newLocation = parentLoc;
                    newSize.w = parentSize.w;
                    parentRect.location = Point(parentLoc.x, parentLoc.y + size.h);
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.top " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.right:
                {
                    newLocation = Point(parentLoc.x + parentSize.w - size.w, parentLoc.y);
                    newSize.h = parentSize.h;
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.right " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.bottom:
                {
                    newLocation = Point(parentLoc.x, parentLoc.y + parentSize.h - size.h);
                    newSize.w = parentSize.w;
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.bottom " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
                case Dock.fill:
                {
                    newLocation = parentLoc;
                    newSize = parentSize;
                    parentRect.location = Point();
                    parentRect.size = Size();
                    if (Debug.Docking())
                    {
                        if (logView != null)
                        {
                            logView->WriteLine("Dock.fill " + text + ": [" + Rect(newLocation, newSize).ToString() + "], [" + parentRect.ToString() + "]");
                        }
                    }
                    break;
                }
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        internal void MoveWindow(int dx, int dy)
        {
            Point newLocation = location;
            Size newSize = size;
            bool leftAnchored = cast<Anchors>(anchors & Anchors.left) != Anchors.none;
            bool rightAnchored = cast<Anchors>(anchors & Anchors.right) != Anchors.none;
            if (!leftAnchored)
            {
                newLocation.x = newLocation.x + dx;
            }
            else if (rightAnchored)
            {
                newSize.w = newSize.w + dx;
            }
            bool topAnchored = cast<Anchors>(anchors & Anchors.top) != Anchors.none;
            bool bottomAnchored = cast<Anchors>(anchors & Anchors.bottom) != Anchors.none;
            if (!topAnchored)
            {
                newLocation.y = newLocation.y + dy;
            }
            else if (bottomAnchored)
            {
                newSize.h = newSize.h + dy;
            }
            if (location != newLocation || size != newSize)
            {
                SetLocation(newLocation);
                SetSize(newSize);
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Anchors GetAnchors() const
        {
            return anchors;
        }
        public inline nothrow void SetAnchors(Anchors anchors_) 
        {
            anchors = anchors_;
        }
        public virtual nothrow Padding DefaultPadding() const
        {
            return Padding();
        }
        public WinRect GetClientRect() const
        {
            return GetClientRect(handle);
        }
        public WinRect GetWindowRect() const
        {
            return GetWindowRect(handle);
        }
        public Point ClientToScreen(const Point& point) const
        {
            return ClientToScreen(handle, point);
        }
        public Point ScreenToClient(const Point& point) const
        {
            return ScreenToClient(handle, point);
        }
        internal bool ProcessMessageInternal(Message& message)
        {
            return ProcessMessage(message);
        }
        public virtual void PrintWindowTree(int level)
        {
            LogView* log = Application.GetLogView();
            if (log != null)
            {
                log->WriteLine(string(' ', level) + "Control." + Text() + ".handle=" + ToHexString(cast<ulong>(Handle())) + " " + ParentText() + "[" + Rect(Point(), GetSize()).ToString() + "]");
            }
        }
        public virtual void ScrollLineDown()
        {
            Control* parent = ParentControl();
            if (parent != null)
            {
                parent->ScrollLineDown();
            }
        }
        public virtual void ScrollLineUp()
        {
            Control* parent = ParentControl();
            if (parent != null)
            {
                parent->ScrollLineUp();
            }
        }
        protected void SubClassCommandWndProc()
        {
            if (originalWndProc == null && handle != null)
            {
                originalWndProc = WinSubClassCommandWndProc(handle);
            }
        }
        protected virtual bool ProcessMessage(Message& message)
        {
            if (originalWndProc != null)
            {
                // If this control has subclassed a standard Windows control for receiving WM_COMMAND notifications, first set address of original window procedure in the message:
                // Currently only GroupBox does this.
                if (message.originalWndProc == null)
                {
                    message.originalWndProc = originalWndProc;
                }
                // If this message is not a WM_COMMAND and not a WM_DESTROY message, return without processing the message.
                // Original window procedure will be called in all cases after returning from Application.ProcessMessage.
                if (message.msg != WM_COMMAND && message.msg != WM_DESTROY)
                {
                    return false;
                }
                // otherwise proceed to process the WM_COMMAND notification or WM_DESTROY message...
            }
            switch (message.msg)
            {
                case WM_PAINT:
                {
                    DoPaint();
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEMOVE:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam), 0);
                    DoMouseMove(args);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSELEAVE:
                {
                    DoMouseLeave();
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 1);
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDBLCLK:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton), 2);
                    DoMouseDoubleClick(args);
                    message.result = 0;
                    return true;
                }
                case WM_RBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.rbutton), 1);
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_RBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.rbutton), 1);
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_CHAR:
                {
                    wchar ch = cast<wchar>(message.wparam);
                    KeyPressEventArgs args(ch);
                    DoKeyPress(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYDOWN:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyDown(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYUP:
                {
                    int virtualKeyCode = cast<int>(message.wparam);
                    if (DoKeyUp(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SYSCOMMAND:
                {
                    if (DoSysCommand(message.wparam, message.lparam))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_HSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoHScroll(request);
                    message.result = 0;
                    return true;
                }
                case WM_VSCROLL:
                {
                    ushort request = message.WParamLoWord();
                    DoVScroll(request);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEWHEEL:
                {
                    MouseWheelEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(cast<uint>(cast<ushort>(message.wparam))), cast<short>(message.wparam >> 16u));
                    DoMouseWheel(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SETFOCUS:
                {
                    DoSetFocus();
                    message.result = 0;
                    return true;
                }
                case WM_KILLFOCUS:
                {
                    DoKillFocus();
                    message.result = 0;
                    return true;
                }
                case WM_SHOWWINDOW:
                {
                    if (message.wparam == 1)
                    {
                        OnShown();
                    }
                    message.result = 0;
                    return true;
                }
                case WM_TIMER:
                {
                    DoTimer(message.wparam);
                    message.result = 0;
                    return true;
                }
                case WM_DESTROY:
                {
                    DoDestroy();
                    message.result = 0;
                    return true;
                }
                case WM_CLIPBOARDUPDATE:
                {
                    DoClipboardUpdate();
                    message.result = 0;
                    return true;
                }
                case WM_COMMAND:
                {
                    void* childWindowHandle = message.LParamHandle();
                    ushort notificationCode = message.WParamHiWord();
                    ushort controlId = message.WParamLoWord();
                    Control* child = Application.GetWindowManager().GetWindow(childWindowHandle);
                    if (child != null)
                    {
                        switch (notificationCode)
                        {
                            case BN_CLICKED:
                            {
                                child->OnClick();
                                message.result = 0;
                                return true;
                            }
                            case BN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case BN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case EN_CHANGE:
                            {
                                child->SetTextInternal(child->GetWindowText());
                                message.result = 0;
                                return true;
                            }
                            case EN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case EN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_SETFOCUS:
                            {
                                child->DoGotFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_KILLFOCUS:
                            {
                                child->DoLostFocus();
                                message.result = 0;
                                return true;
                            }
                            case LBN_SELCHANGE:
                            {
                                if (child is ListBox*)
                                {
                                    ListBox* listBox = cast<ListBox*>(child);
                                    listBox->SelectedIndexChangedInternal();
                                }
                                message.result = 0;
                                return true;
                            }
                        }
                    }
                    break;
                }
            }
            return false;
        }
        private void DoDestroy()
        {
            OnDestroyed();
            if (originalWndProc != null)
            {
                WinRestoreOriginalWndProc(handle, originalWndProc);
            }
        }
        private void DoClipboardUpdate()
        {
            OnClipboardUpdate();
        }
        protected virtual void OnClipboardUpdate()
        {
            clipboardUpdateEvent.Fire();
        }
        private bool DoSysCommand(uint wparam, long lparam)
        {
            switch (wparam)
            {
                case SC_KEYMENU:
                {
                    wchar accessKey = cast<wchar>(ToUpper(cast<uchar>(cast<wchar>(lparam))));
                    if (DoMenu(accessKey, Keys.none))
                    {
                        return true;
                    }
                    else
                    {
                        currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.altModifier);
                        if (DoKeyDown(cast<int>(accessKey)))
                        {
                            currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                            return true;
                        }
                        currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                    }
                    break;
                }
                case SC_CLOSE:
                {
                    KeyEventArgs args(Keys.f4, Keys.altModifier);
                    DoMenu(args);
                    if (args.handled)
                    {
                        return true;
                    }
                    break;
                }
            }
            return false;
        }
        private bool DoKeyDown(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyDown: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            ResetKeyDownHandled();
            if (MenuWantsKeys())
            {
                if (DoMenu('\0', cast<Keys>(virtualKeyCode)))
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            Keys keyCode = cast<Keys>(virtualKeyCode);
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys | Keys.altModifier);
                    break;
                }
            }
            KeyEventArgs args(keyCode, currentModifierKeys);
            DoMenu(args);
            if (args.handled)
            {
                SetKeyDownHandled();
                return true;
            }
            else
            {
                DispatchKeyDown(args);
                if (args.handled)
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            return false;
        }
        private bool DoKeyUp(int virtualKeyCode)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyUp: " + ToString(cast<Keys>(virtualKeyCode)) + " " + ToHexString(cast<uint>(virtualKeyCode));
                logView->WriteLine(s);
            }
            Keys keyCode = cast<Keys>(virtualKeyCode);
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    currentModifierKeys = cast<Keys>(currentModifierKeys & ~Keys.altModifier);
                    break;
                }
            }
            if (KeyDownHandled() || MenuWantsKeys())
            {
                return KeyDownHandled();
            }
            Keys modifierKeys;
            switch (keyCode)
            {
                case Keys.controlKey:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.controlModifier);
                    break;
                }
                case Keys.shiftKey:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.shiftModifier);
                    break;
                }
                case Keys.menu:
                {
                    modifierKeys = cast<Keys>(modifierKeys | Keys.altModifier);
                    break;
                }
            }
            KeyEventArgs args(keyCode, modifierKeys);
            DispatchKeyUp(args);
            if (args.handled)
            {
                return true;
            }
            return false;
        }
        private void DoKeyPress(KeyPressEventArgs& args)
        {
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DoKeyPress: " + ToString(args.keyChar) + " " + ToHexString(cast<uint>(args.keyChar));
                logView->WriteLine(s);
            }
            if (KeyDownHandled() || MenuWantsKeys())
            {
                args.handled = KeyDownHandled();
                return;
            }
            DispatchKeyPress(args);
        }
        private void DispatchKeyPress(KeyPressEventArgs& args)
        {
            OnKeyPress(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyPress(args);
                }
            }
        }
        private void DispatchKeyDown(KeyEventArgs& args)
        {
            OnKeyDown(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyDown(args);
                }
            }
        }
        private void DispatchKeyUp(KeyEventArgs& args)
        {
            OnKeyUp(args);
            if (!args.handled)
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    parent->DispatchKeyUp(args);
                }
            }
        }
        private bool DoMenu(wchar accessKey, Keys keyCode)
        {
            ResetKeyDownHandled();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "MENU: " + ToString(accessKey) + " " + ToHexString(cast<ushort>(accessKey));
                logView->WriteLine(s);
            }
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    bool menuWantsKeys = false;
                    bool handled = menuBar->HandleAccessKey(accessKey, keyCode, menuWantsKeys);
                    if (handled)
                    {
                        SetKeyDownHandled();
                    }
                    if (menuWantsKeys)
                    {
                        SetMenuWantsKeys();
                    }
                    else
                    {
                        ResetMenuWantsKeys();
                    }
                    return handled;
                }
            }
            return false;
        }
        private void DoMenu(KeyEventArgs& args)
        {
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    menuBar->DoKeyDown(args);
                }
            }
        }
        private void DoVScroll(ushort request)
        {
            OnVScroll(request);
        }
        private void DoHScroll(ushort request)
        {
            OnHScroll(request);
        }
        private void DoMouseWheel(MouseWheelEventArgs& args)
        {
            OnMouseWheel(args);
        }
        private void DoSetFocus()
        {
            SetFocused();
            DoGotFocus();
            DoCreateAndShowCaret();
        }
        private void DoGotFocus()
        {
            OnGotFocus();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildGotFocus(args);
            }
        }
        protected virtual void OnGotFocus()
        {
            gotFocusEvent.Fire();
        }
        protected virtual void OnChildGotFocus(ControlEventArgs& args)
        {
            childGotFocusEvent.Fire(args);
        }
        private void DoKillFocus()
        {
            ResetFocused();
            DoLostFocus();
            DoDestroyCaret();
        }
        private void DoLostFocus()
        {
            OnLostFocus();
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                ControlEventArgs args(this);
                parentControl->OnChildLostFocus(args);
            }
        }
        protected virtual void OnLostFocus()
        {
            lostFocusEvent.Fire();
        }
        protected virtual void OnChildLostFocus(ControlEventArgs& args)
        {
            childLostFocusEvent.Fire(args);
        }
        protected nothrow virtual bool IsDecoratorControl() const
        {
            return false;
        }
        protected virtual void TranslateChildGraphics(Graphics& graphics)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateChildGraphics(graphics);
            }
        }
        protected virtual void TranslateMousePos(Point& location)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateMousePos(location);
            }
        }
        protected virtual void TranslateContentLocation(Point& location)
        {
            Control* parentControl = ParentControl();
            if (parentControl != null)
            {
                parentControl->TranslateContentLocation(location);
            }
        }
        private void DoPaint()
        {
            void* paintStruct = null;
            void* hdc = BeginPaint(handle, paintStruct);
            Rect clipRect;
            WinGetClipRect(paintStruct, clipRect.location.x, clipRect.location.y, clipRect.size.w, clipRect.size.h);
            PaintGuard paintGuard(hdc, paintStruct);
            Graphics graphics(hdc);
            PaintEventArgs args(graphics, clipRect);
            if (!IsDecoratorControl())
            {
                TranslateChildGraphics(graphics);
            }
            if (Focused())
            {
                --caretShowCount;
            }
            OnPaint(args);
            if (Focused() && CaretCreated())
            {
                ShowCaret();
            }
        }
        protected virtual void OnPaint(PaintEventArgs& args)
        {
            paintEvent.Fire(args);
        }
        internal virtual void PaintAll(PaintEventArgs& args, bool skipMenuBar)
        {
            try
            {
                OnPaint(args);
            }
            catch (const Exception& ex)
            {
                MessageBox.Show(ex.Message());
            }
        }
        private void DoCreateAndShowCaret()
        {
            if (Focused())
            {
                CreateCaret();
                SetCaretCreated();
                SetCaretLocation();
                ShowCaret();
            }
        }
        public virtual void CreateCaret()
        {
            System.Windows.API.CreateCaret(Handle(), null, 1, 15);
        }
        private void DoDestroyCaret()
        {
            if (CaretCreated())
            {
                HideCaret();
                ResetCaretCreated();
                DestroyCaret();
            }
        }
        public virtual void DestroyCaret()
        {
            System.Windows.API.DestroyCaret();
            caretShowCount = 0;
        }
        public void ShowCaret()
        {
            System.Windows.API.ShowCaret(Handle());
            ++caretShowCount;
        }
        public void HideCaret()
        {
            System.Windows.API.HideCaret(Handle());
            --caretShowCount;
        }
        public nothrow inline int CaretShowCount() const
        {
            return caretShowCount;
        }
        public Point GetCaretPos() const
        {
            return System.Windows.API.GetCaretPos();
        }
        public void SetCaretPos(const Point& caretPos)
        {
            if (CaretCreated())
            {
                System.Windows.API.SetCaretPos(caretPos);
            }
        }
        private void DoMouseMove(MouseEventArgs& args)
        {
            if (!MouseInClient())
            {
                SetMouseInClient();
                SetCursor();
                OnMouseEnter();
                WinTrackMouseEvent(handle, TME_LEAVE, HOVER_DEFAULT);
            }
            else 
            {
                if (!IsDecoratorControl())
                {
                    TranslateMousePos(args.location);
                }
                OnMouseMove(args);
            }
        }
        private void DoMouseLeave()
        {
            ResetMouseInClient();
            ResetLButtonPressed();
            OnMouseLeave();
        }
        private void DoMouseDown(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDown(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                SetLButtonPressed();
            }
        }
        private void DoMouseUp(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseUp(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                if (LButtonPressed())
                {
                    ResetLButtonPressed();
                    this->OnClick();
                }
            }
        }
        private void DoMouseDoubleClick(MouseEventArgs& args)
        {
            if (!IsDecoratorControl())
            {
                TranslateMousePos(args.location);
            }
            OnMouseDoubleClick(args);
        }
        public void SetTimer(uint timerId, uint elapseMs)
        {
            SetTimer(Handle(), timerId, elapseMs);
        }
        public void KillTimer(uint timerId)
        {
            KillTimer(Handle(), timerId);
        }
        private void DoTimer(uint timerId)
        {
            TimerEventArgs timerEventArgs(timerId);
            OnTimer(timerEventArgs);
        }
        protected virtual void OnTimer(TimerEventArgs& args)
        {
            timerEvent.Fire(args);
        }
        protected virtual void SetCursor()
        {
            SetCursor(arrowCursor);
        }
        protected virtual void OnMouseEnter()
        {
            mouseEnterEvent.Fire();
        }
        protected virtual void OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
        }
        protected virtual void OnMouseLeave()
        {
            mouseLeaveEvent.Fire();
        }
        protected virtual void OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        protected virtual void OnMouseDoubleClick(MouseEventArgs& args)
        {
            mouseDoubleClickEvent.Fire(args);
        }
        protected virtual void OnKeyPress(KeyPressEventArgs& args)
        {
            keyPressEvent.Fire(args);
        }
        protected virtual void OnKeyDown(KeyEventArgs& args)
        {
            keyDownEvent.Fire(args);
        }
        protected virtual void OnKeyUp(KeyEventArgs& args)
        {
            keyUpEvent.Fire(args);
        }
        protected virtual void OnClick()
        {
            clickEvent.Fire();
        }
        protected virtual void OnCreated()
        {
            SetBaseOnCreatedCalled();
            createdEvent.Fire();
        }
        protected virtual void OnDestroyed()
        {
            destroyedEvent.Fire();
        }
        protected virtual void OnShown()
        {
            shownEvent.Fire();
        }
        protected virtual void OnHScroll(ScrollEventArgs& args)
        {
            hscrollEvent.Fire(args);
        }
        protected virtual void OnVScroll(ScrollEventArgs& args)
        {
            vscrollEvent.Fire(args);
        }
        protected virtual void OnMouseWheel(MouseWheelEventArgs& args)
        {
            mouseWheelEvent.Fire(args);
        }
        protected virtual void OnControlAdded(ControlEventArgs& args)
        {
            controlAddedEvent.Fire(args);
        }
        public virtual void OnControlRemoved(ControlEventArgs& args)
        {
            controlRemovedEvent.Fire(args);
        }
        public void* GetDC()
        {
            return GetDC(handle);
        }
        public void Invalidate()
        {
            InvalidateRect(handle, null, true);
        }
        public void Invalidate(const WinRect& rect)
        {
            InvalidateRect(handle, &rect, false);
        }
        public void Invalidate(const WinRect& rect, bool eraseBackground)
        {
            InvalidateRect(handle, &rect, eraseBackground);
        }
        public nothrow inline const Color& BackgroundColor() const
        {
            return backgroundColor;
        }
        public void SetBackgroundColor(const Color& backgroundColor_)
        {
            backgroundColor = backgroundColor_;
            Invalidate();
        }
        public nothrow const Font& GetFont() const
        {
            if (!font.IsNull())
            {
                return font;
            }
            else
            {
                Control* parent = ParentControl();
                if (parent != null)
                {
                    return parent->GetFont();
                }
                else
                {
                    return font;
                }
            }
        }
        public void SetFont(const Font& font_)
        {
            font = font_;
        }
        public nothrow void SetFont(Font&& font_)
        {
            font = Rvalue(font_);
        }
        public const FontHandle& GetFontHandle(Graphics& graphics) 
        {
            if (!fontHandle.IsNull())
            {
                return fontHandle;
            }
            if (!font.IsNull())
            {
                fontHandle = font.ToHFontChecked(graphics);
                return fontHandle;
            }
            Control* parent = ParentControl();
            if (parent != null)
            {
                return parent->GetFontHandle(graphics);
            }
            else
            {
                return fontHandle; // fontHandle.IsNull() will be true
            }
        }
        public nothrow inline void* Handle() const
        {
            return handle;
        }
        public inline nothrow WindowStyle GetWindowStyle() const
        {
            return style;
        }
        public inline nothrow ExtendedWindowStyle GetExtendedWindowStyle() const
        {
            return exStyle;
        }
        public nothrow Event<PaintEventHandler, PaintEventArgs>& PaintEvent()
        {
            return paintEvent;
        }
        public nothrow Event<MouseEnterEventHandler>& MouseEnterEvent() const
        {
            return mouseEnterEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent() const
        {
            return mouseMoveEvent;
        }
        public nothrow Event<MouseLeaveEventHandler>& MouseLeaveEvent() const
        {
            return mouseLeaveEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent() const
        {
            return mouseDownEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent() const
        {
            return mouseUpEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDoubleClickEvent() const
        {
            return mouseDoubleClickEvent;
        }
        public nothrow Event<KeyPressEventHandler, KeyPressEventArgs>& KeyPressEvent() const
        {
            return keyPressEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyDownEvent() const
        {
            return keyDownEvent;
        }
        public nothrow Event<KeyEventHandler, KeyEventArgs>& KeyUpEvent() const
        {
            return keyUpEvent;
        }
        public nothrow Event<CreatedEventHandler>& CreatedEvent() const
        {
            return createdEvent;
        }
        public nothrow Event<DestroyedEventHandler>& DestroyedEvent() const
        {
            return destroyedEvent;
        }
        public nothrow Event<ShownEventHandler>& ShownEvent() const
        {
            return shownEvent;
        }
        public nothrow Event<EnabledChangedEventHandler>& EnabledChangedEvent() const
        {
            return enabledChangedEvent;
        }
        public nothrow Event<VisibleChangedEventHandler>& VisibleChangedEvent() const
        {
            return visibleChangedEvent;
        }
        public nothrow Event<ClickEventHandler>& ClickEvent() const
        {
            return clickEvent;
        }
        public nothrow Event<SizeChangedEventHandler>& SizeChangedEvent() const
        {
            return sizeChangedEvent;
        }
        public nothrow Event<LocationChangedEventHandler>& LocationChangedEvent() const
        {
            return locationChangedEvent;
        }
        public nothrow Event<ContentChangedEventHandler>& ContentChangedEvent() const
        {
            return contentChangedEvent;
        }
        public nothrow Event<ChildContentChangedEventHandler, ControlEventArgs>& ChildContentChangedEvent() const
        {
            return childContentChangedEvent;
        }
        public nothrow Event<ContentLocationChangedEventHandler>& ContentLocationChangedEvent() const
        {
            return contentLocationChangedEvent;
        }
        public nothrow Event<ChildContentLocationChangedEventHandler, ControlEventArgs>& ChildContentLocationChangedEvent() const
        {
            return childContentLocationChangedEvent;
        }
        public nothrow Event<ContentSizeChangedEventHandler>& ContentSizeChangedEvent() const
        {
            return contentSizeChangedEvent;
        }
        public nothrow Event<ChildContentSizeChangedEventHandler, ControlEventArgs>& ChildContentSizeChangedEvent() const
        {
            return childContentSizeChangedEvent;
        }
        public nothrow Event<TextChangedEventHandler>& TextChangedEvent() const
        {
            return textChangedEvent;
        }
        public nothrow Event<HScrollEventHandler, ScrollEventArgs>& HScrollEvent() const
        {
            return hscrollEvent;
        }
        public nothrow Event<VScrollEventHandler, ScrollEventArgs>& VScrollEvent() const
        {
            return vscrollEvent;
        }
        public nothrow Event<MouseWheelEventHandler, MouseWheelEventArgs>& MouseWheelEvent() const
        {
            return mouseWheelEvent;
        }
        public nothrow Event<TimerEventHandler, TimerEventArgs>& TimerEvent() const
        {
            return timerEvent;
        }
        public nothrow Event<GotFocusEventHandler>& GotFocusEvent() const
        {
            return gotFocusEvent;
        }
        public nothrow Event<LostFocusEventHandler>& LostFocusEvent() const
        {
            return lostFocusEvent;
        }
        public nothrow Event<ControlEventHandler, ControlEventArgs>& ControlAddedEvent() const
        {
            return controlAddedEvent;
        }
        public nothrow Event<ControlEventHandler, ControlEventArgs>& ControlRemovedEvent() const
        {
            return controlRemovedEvent;
        }
        public nothrow Event<ClipboardUpdateEventHandler>& ClipboadUpdateEvent() const
        {
            return clipboardUpdateEvent;
        }
        private nothrow inline bool MouseInClient() const
        {
            return (flags & Flags.mouseInClient) != 0;
        }
        private nothrow inline void SetMouseInClient()
        {
            flags = cast<Flags>(flags | Flags.mouseInClient);
        }
        private nothrow inline void ResetMouseInClient()
        {
            flags = cast<Flags>(flags & ~Flags.mouseInClient);
        }
        private nothrow inline bool LButtonPressed() const
        {
            return (flags & flags.lbuttonPressed) != 0;
        }
        private nothrow inline void SetLButtonPressed()
        {
            flags = cast<Flags>(flags | Flags.lbuttonPressed);
        }
        private nothrow inline void ResetLButtonPressed()
        {
            flags = cast<Flags>(flags & ~Flags.lbuttonPressed);
        }
        private nothrow inline bool MenuWantsKeys() const
        {
            return (flags & flags.menuWantsKeys) != 0;
        }
        private nothrow inline void SetMenuWantsKeys()
        {
            flags = cast<Flags>(flags | Flags.menuWantsKeys);
        }
        private nothrow inline void ResetMenuWantsKeys()
        {
            flags = cast<Flags>(flags & ~Flags.menuWantsKeys);
        }
        private nothrow inline bool KeyDownHandled() const
        {
            return (flags & Flags.keyDownHandled) != 0;
        }
        private nothrow inline void SetKeyDownHandled()
        {
            flags = cast<Flags>(flags | Flags.keyDownHandled);
        }
        private nothrow inline void ResetKeyDownHandled()
        {
            flags = cast<Flags>(flags & ~Flags.keyDownHandled);
        }
        public nothrow inline bool Focused() const
        {
            return (flags & Flags.focused) != 0;
        }
        private nothrow inline void SetFocused()
        {
            flags = cast<Flags>(flags | Flags.focused);
        }
        private nothrow inline void ResetFocused()
        {
            flags = cast<Flags>(flags & ~Flags.focused);
        }
        public nothrow inline bool CaretCreated() const
        {
            return (flags & Flags.caretCreated) != 0;
        }
        private nothrow inline void SetCaretCreated()
        {
            flags = cast<Flags>(flags | Flags.caretCreated);
        }
        private nothrow inline void ResetCaretCreated()
        {
            flags = cast<Flags>(flags & ~Flags.caretCreated);
        }
        private nothrow inline bool CaretShown() const
        {
            return (flags & Flags.caretShown) != 0;
        }
        private nothrow inline void SetCaretShown()
        {
            flags = cast<Flags>(flags | Flags.caretShown);
        }
        private nothrow inline void ResetCaretShown()
        {
            flags = cast<Flags>(flags & ~Flags.caretShown);
        }
        public nothrow inline bool IsDisabled() const
        {
            return (flags & Flags.disabled) != 0;
        }
        private nothrow inline void SetDisabled()
        {
            flags = cast<Flags>(flags | Flags.disabled);
        }
        private nothrow inline void ResetDisabled()
        {
            flags = cast<Flags>(flags & ~Flags.disabled);
        }
        private nothrow inline bool Hidden() const
        {
            return (flags & Flags.hidden) != 0;
        }
        private nothrow inline void SetHidden()
        {
            flags = cast<Flags>(flags | Flags.hidden);
        }
        private nothrow inline void ResetHidden()
        {
            flags = cast<Flags>(flags & ~Flags.hidden);
        }
        public nothrow inline bool IsTabStop() const
        {
            return (flags & Flags.tabStop) != Flags.none;
        }
        public nothrow inline void SetTabStop()
        {
            flags = cast<Flags>(flags | Flags.tabStop);
        }
        public nothrow inline void ResetTabStop()
        {
            flags = cast<Flags>(flags & ~Flags.tabStop);
        }
        internal nothrow inline bool BaseOnCreatedCalled() const
        {
            return (flags & Flags.baseOnCreatedCalled) != Flags.none;
        }
        internal nothrow inline void SetBaseOnCreatedCalled()
        {
            flags = cast<Flags>(flags | Flags.baseOnCreatedCalled);
        }
        private nothrow inline void ResetBaseOnCreatedCalled()
        {
            flags = cast<Flags>(flags & ~Flags.baseOnCreatedCalled);
        }
        private const char* windowClassName;
        private WindowClassStyle windowClassStyle;
        private Color backgroundColor;
        private WindowStyle style;
        private ExtendedWindowStyle exStyle;
        private void* handle;
        private string text;
        private Point location;
        private Size size;
        private Point contentLocation;
        private Size contentSize;
        private int verticalScrollUnit;
        private int horizontalScrollUnit;
        private Dock dock;
        private Anchors anchors;
        private Flags flags;
        private Keys currentModifierKeys;
        private List<Control*> createList;
        private Cursor arrowCursor;
        private int caretShowCount;
        private Font font;
        private FontHandle fontHandle;
        private void* originalWndProc;
        private Event<PaintEventHandler, PaintEventArgs> paintEvent;
        private Event<MouseEnterEventHandler> mouseEnterEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseLeaveEventHandler> mouseLeaveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDoubleClickEvent;
        private Event<KeyPressEventHandler, KeyPressEventArgs> keyPressEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyDownEvent;
        private Event<KeyEventHandler, KeyEventArgs> keyUpEvent;
        private Event<ClickEventHandler> clickEvent;
        private Event<CreatedEventHandler> createdEvent;
        private Event<DestroyedEventHandler> destroyedEvent;
        private Event<ShownEventHandler> shownEvent;
        private Event<EnabledChangedEventHandler> enabledChangedEvent;
        private Event<VisibleChangedEventHandler> visibleChangedEvent;
        private Event<SizeChangedEventHandler> sizeChangedEvent;
        private Event<LocationChangedEventHandler> locationChangedEvent;
        private Event<ContentChangedEventHandler> contentChangedEvent;
        private Event<ChildContentChangedEventHandler, ControlEventArgs> childContentChangedEvent;
        private Event<ContentLocationChangedEventHandler> contentLocationChangedEvent;
        private Event<ChildContentLocationChangedEventHandler, ControlEventArgs> childContentLocationChangedEvent;
        private Event<ContentSizeChangedEventHandler> contentSizeChangedEvent;
        private Event<ChildContentSizeChangedEventHandler, ControlEventArgs> childContentSizeChangedEvent;
        private Event<TextChangedEventHandler> textChangedEvent;
        private Event<HScrollEventHandler, ScrollEventArgs> hscrollEvent;
        private Event<VScrollEventHandler, ScrollEventArgs> vscrollEvent;
        private Event<MouseWheelEventHandler, MouseWheelEventArgs> mouseWheelEvent;
        private Event<TimerEventHandler, TimerEventArgs> timerEvent;
        private Event<GotFocusEventHandler> gotFocusEvent;
        private Event<LostFocusEventHandler> lostFocusEvent;
        private Event<ChildGotFocusEventHandler, ControlEventArgs> childGotFocusEvent;
        private Event<ChildLostFocusEventHandler, ControlEventArgs> childLostFocusEvent;
        private Event<ControlEventHandler, ControlEventArgs> controlAddedEvent;
        private Event<ControlEventHandler, ControlEventArgs> controlRemovedEvent;
        private Event<ClipboardUpdateEventHandler> clipboardUpdateEvent;
    }
}

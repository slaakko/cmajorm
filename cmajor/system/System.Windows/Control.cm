// =================================
// Copyright (c) 2020 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Windows.API;

namespace System.Windows
{
    public class delegate void PaintEventHandler(PaintEventArgs& paintEventArgs);
    public class delegate void MouseEnterEventHandler();
    public class delegate void MouseEventHandler(MouseEventArgs& mouseEventargs);
    public class delegate void MouseLeaveEventHandler();
    public class delegate void KeyPressEventHandler(KeyPressEventArgs& keyPressEventArgs);
    public class delegate void ClickEventHandler();
    
    public class Control : Component
    {
        private enum Flags : sbyte
        {
            none = 0, mouseInClient = 1 << 0, lbuttonPressed = 1 << 1, menuWantsKeys = 1 << 2, keyDownHandled = 1 << 3
        }
        public Control(const char* windowClassName_, WindowClassStyle windowClassStyle_, WindowStyle style_, ExtendedWindowStyle exStyle_, 
            const Color& backgroundColor_, const string& text_, const Point& location_, const Size& size_, Dock dock_, Anchors anchors_) : 
            windowClassName(windowClassName_), windowClassStyle(windowClassStyle_), style(style_), exStyle(exStyle_),
            backgroundColor(backgroundColor_), handle(null), text(text_), location(location_), size(size_), dock(dock_), anchors(anchors_), flags(Flags.none)
        {
            Application.Init();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                CreateWindow();
            }
        }
        public ~Control()
        {
            if (handle != null)
            {
                Application.GetWindowManager().RemoveWindow(this);
            } 
        }
        protected void CreateWindow()
        {
            CreateWindowInternal();
        }
        internal void CreateWindowInternal()
        {
            if (handle != null) return;
            Control* parentControl = null;
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is Control*))
                {
                    parentControl = cast<Control*>(parent);
                }
            }
            if (Application.GetWindowManager().IsSystemClassName(windowClassName))
            {
                handle = CreateWindowByClassName(windowClassName, text.Chars(), style, exStyle, location, size, parentControl);
            }
            else
            {
                ushort windowClass = Application.GetWindowManager().RegisterWindowClass(windowClassName, windowClassStyle, 0);
                handle = CreateWindowByClassAtom(windowClass, text.Chars(), style, exStyle, location, size, parentControl);
            }
            Application.GetWindowManager().AddWindow(this);
            WinRect clientRect = GetClientRect();
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            size.w = clientRect.right - clientRect.left;
            size.h = clientRect.bottom - clientRect.top;
            DockWindow();
        }
        internal void AddChildVisual(Control* child)
        {
            if (child->Handle() == null)
            {
                child->CreateWindowInternal();
            }
            else
            {
                child->SetParentWindow(this);
            }            
            if ((child->GetWindowStyle() & WindowStyle.WS_VISIBLE) != 0)
            {
                child->Show();
                child->Update();
            }
        }
        public Window* GetWindow() const
        {
            Control* thisControl = this;
            if (thisControl is Window*)
            {
                return cast<Window*>(this);
            }
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null)
                {
                    if (parent is Window*)
                    {
                        return cast<Window*>(parent);
                    }
                    else if (parent is Control*)
                    {
                        Control* control = cast<Control*>(parent);
                        return control->GetWindow();
                    }
                }
            }
            return null;
        }
        internal void SetParentWindow(Control* parentWindow)
        {
            SetParentWindow(handle, parentWindow->handle);
            DockWindow();
        }
        public void Show()
        {
            ShowWindow(ShowCommand.SW_SHOW);
        }
        public void Hide()
        {
            ShowWindow(ShowCommand.SW_HIDE);
        }
        public void ShowWindow(ShowCommand showCommand)
        {
            WinShowWindow(handle, showCommand);
        }
        public void Update()
        {
            WinUpdateWindow(handle);
        }
        public nothrow const string& Text() const
        {
            return text;
        }
        public void SetText(const string& text_)
        {
            if (text != text_)
            {
                text = text_;
                SetWindowText(handle, text);
            }
        }
        public const Point& Location()
        {
            if ((style & WindowStyle.WS_CHILD) == 0)
            {
                WinRect windowRect = GetWindowRect();
                location.x = windowRect.left;
                location.y = windowRect.top;
            }
            return location;
        }
        public void SetLocation(const Point& loc)
        {
            if (location != loc)
            {
                location = loc;
                MoveWindow(handle, location, size, true);
            }
        }
        public nothrow const Size& GetSize() const
        {
            return size;
        }
        internal nothrow void SetSizeInternal(const Size& sz)
        {
            size = sz;
        }
        public void SetSize(const Size& sz)
        {
            if (size != sz)
            {
                size = sz;
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Dock GetDock() const
        {
            return dock;
        }
        public void SetDock(Dock dock_)
        {
            dock = dock_;
            if (dock != Dock.none)
            {
                DockWindow();
            }
        }
        internal void DockWindow()
        {
            Container* container = GetContainer();
            if (container != null)
            {
                Component* parent = container->Parent();
                if (parent != null && (parent is ContainerControl*))
                {
                    ContainerControl* parentControl = cast<ContainerControl*>(parent);
                    parentControl->DockChildren();
                }
            }
        }
        internal void DockWindow(Rect& parentRect)
        {
            if (dock == Dock.none) return;
            Point parentLoc = parentRect.location;
            Size parentSize = parentRect.size;
            Point newLocation = location;
            Size newSize = size;
            switch (dock)
            {
                case Dock.left:
                {
                    newLocation = parentLoc;
                    newSize.h = parentSize.h;
                    parentRect.location = Point(parentLoc.x + size.w, parentLoc.y);
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    break;
                }
                case Dock.top:
                {
                    newLocation = parentLoc;
                    newSize.w = parentSize.w;
                    parentRect.location = Point(parentLoc.x, parentLoc.y + size.h);
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    break;
                }
                case Dock.right:
                {
                    newLocation = Point(parentLoc.x + parentSize.w - size.w, parentLoc.y);
                    newSize.h = parentSize.h;
                    parentRect.size = Size(parentSize.w - size.w, parentSize.h);
                    break;
                }
                case Dock.bottom:
                {
                    newLocation = Point(parentLoc.x, parentLoc.y + parentSize.h - size.h);
                    newSize.w = parentSize.w;
                    parentRect.size = Size(parentSize.w, parentSize.h - size.h);
                    break;
                }
                case Dock.fill:
                {
                    newLocation = parentLoc;
                    newSize = parentSize;
                    parentRect.location = Point();
                    parentRect.size = Size();
                    break;
                }
            }
            if (location != newLocation || size != newSize)
            {
                location = newLocation;
                size = newSize;
                MoveWindow(handle, location, size, true);
            }
        }
        internal void MoveWindow(int dx, int dy)
        {
            Point newLocation = location;
            Size newSize = size;
            bool leftAnchored = cast<Anchors>(anchors & Anchors.left) != Anchors.none;
            bool rightAnchored = cast<Anchors>(anchors & Anchors.right) != Anchors.none;
            if (!leftAnchored)
            {
                newLocation.x = newLocation.x + dx;
            }
            else if (rightAnchored)
            {
                newSize.w = newSize.w + dx;
            }
            bool topAnchored = cast<Anchors>(anchors & Anchors.top) != Anchors.none;
            bool bottomAnchored = cast<Anchors>(anchors & Anchors.bottom) != Anchors.none;
            if (!topAnchored)
            {
                newLocation.y = newLocation.y + dy;
            }
            else if (bottomAnchored)
            {
                newSize.h = newSize.h + dy;
            }
            if (location != newLocation || size != newSize)
            {
                location = newLocation;
                size = newSize;
                MoveWindow(handle, location, size, true);
            }
        }
        public inline nothrow Anchors GetAnchors() const
        {
            return anchors;
        }
        public inline nothrow void SetAnchors(Anchors anchors_) 
        {
            anchors = anchors_;
        }
        public virtual nothrow Padding DefaultPadding() const
        {
            return Padding();
        }
        public WinRect GetClientRect() const
        {
            return GetClientRect(handle);
        }
        public WinRect GetWindowRect() const
        {
            return GetWindowRect(handle);
        }
        public Point ClientToScreen(const Point& point) const
        {
            return ClientToScreen(handle, point);
        }
        public Point ScreenToClient(const Point& point) const
        {
            return ScreenToClient(handle, point);
        }
        internal bool ProcessMessageInternal(Message& message)
        {
            return ProcessMessage(message);
        }
        protected virtual bool ProcessMessage(Message& message)
        {
            switch (message.msg)
            {
                case WM_PAINT:
                {
                    DoPaint();
                    message.result = 0;
                    return true;
                }
                case WM_MOUSEMOVE:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam));
                    DoMouseMove(args);
                    message.result = 0;
                    return true;
                }
                case WM_MOUSELEAVE:
                {
                    DoMouseLeave();
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONDOWN:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton));
                    DoMouseDown(args);
                    message.result = 0;
                    return true;
                }
                case WM_LBUTTONUP:
                {
                    MouseEventArgs args(Point(message.LParamX(), message.LParamY()), cast<MouseButtons>(message.wparam | MouseButtons.lbutton));
                    DoMouseUp(args);
                    message.result = 0;
                    return true;
                }
                case WM_CHAR:
                {
                    wchar ch = cast<wchar>(message.wparam);
                    KeyPressEventArgs args(ch);
                    DoKeyPress(args);
                    if (args.handled)
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYDOWN:
                {
                    byte virtualKeyCode = cast<byte>(message.wparam);
                    if (DoKeyDown(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_KEYUP:
                {
                    byte virtualKeyCode = cast<byte>(message.wparam);
                    if (DoKeyUp(virtualKeyCode))
                    {
                        message.result = 0;
                        return true;
                    }
                    break;
                }
                case WM_SYSCOMMAND:
                {
                    if (message.wparam == SC_KEYMENU)
                    {
                        wchar accessKey = cast<wchar>(ToUpper(cast<uchar>(cast<wchar>(message.lparam))));
                        if (DoMenu(accessKey, Keys.none))
                        {
                            message.result = 0;
                            return true;
                        }
                    }
                    break;
                }
            }
            return false;
        }
        private bool DoKeyDown(byte virtualKeyCode)
        {
            ResetKeyDownHandled();
            if (MenuWantsKeys())
            {
                if (DoMenu('\0', cast<Keys>(cast<int>(virtualKeyCode))))
                {
                    SetKeyDownHandled();
                    return true;
                }
            }
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "DOWN: " + keyCodeStr[virtualKeyCode];
                logView->WriteLine(s);
            }
            return false;
        }
        private bool DoKeyUp(byte virtualKeyCode)
        {
            if (KeyDownHandled() || MenuWantsKeys())
            {
                return KeyDownHandled();
            }
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "UP: " + keyCodeStr[virtualKeyCode];
                logView->WriteLine(s);
            }
            return false;
        }
        private void DoKeyPress(KeyPressEventArgs& args)
        {
            if (KeyDownHandled() || MenuWantsKeys())
            {
                args.handled = KeyDownHandled();
                return;
            }
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "PRESS: " + ToString(args.keyChar);
                logView->WriteLine(s);
            }
            OnKeyPress(args);
        }
        private bool DoMenu(wchar accessKey, Keys keyCode)
        {
            ResetKeyDownHandled();
            LogView* logView = Application.GetLogView();
            if (logView != null)
            {
                string s = "MENU: " + ToString(accessKey) + " " + ToHexString(cast<ushort>(accessKey));
                logView->WriteLine(s);
            }
            Window* window = GetWindow();
            if (window != null)
            {
                MenuBar* menuBar = window->GetMenuBar();
                if (menuBar != null)
                {
                    bool menuWantsKeys = false;
                    bool handled = menuBar->HandleAccessKey(accessKey, keyCode, menuWantsKeys);
                    if (handled)
                    {
                        SetKeyDownHandled();
                    }
                    if (menuWantsKeys)
                    {
                        SetMenuWantsKeys();
                    }
                    else
                    {
                        ResetMenuWantsKeys();
                    }
                    return handled;
                }
            }
            return false;
        }
        private void DoPaint()
        {
            void* paintStruct = null;
            void* hdc = BeginPaint(handle, paintStruct);
            Rect clipRect;
            WinGetClipRect(paintStruct, clipRect.location.x, clipRect.location.y, clipRect.size.w, clipRect.size.h);
            PaintGuard paintGuard(hdc, paintStruct);
            Graphics graphics(hdc);
            PaintEventArgs args(graphics, clipRect);
            OnPaint(args);
        }
        protected virtual void OnPaint(PaintEventArgs& args)
        {
            args.graphics.Clear(backgroundColor);
            paintEvent.Fire(args);
        }
        private void DoMouseMove(MouseEventArgs& args)
        {
            if (!MouseInClient())
            {
                SetMouseInClient();
                OnMouseEnter();
                WinTrackMouseEvent(handle, TME_LEAVE, HOVER_DEFAULT);
            }
            else 
            {
                OnMouseMove(args);
            }
        }
        private void DoMouseLeave()
        {
            ResetMouseInClient();
            ResetLButtonPressed();
            OnMouseLeave();
        }
        private void DoMouseDown(MouseEventArgs& args)
        {
            OnMouseDown(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                SetLButtonPressed();
            }
        }
        private void DoMouseUp(MouseEventArgs& args)
        {
            OnMouseUp(args);
            if ((args.buttons & MouseButtons.lbutton) != 0)
            {
                if (LButtonPressed())
                {
                    ResetLButtonPressed();
                    OnClick();
                }
            }
        }
        protected virtual void OnMouseEnter()
        {
            mouseEnterEvent.Fire();
        }
        protected virtual void OnMouseMove(MouseEventArgs& args)
        {
            mouseMoveEvent.Fire(args);
        }
        protected virtual void OnMouseLeave()
        {
            mouseLeaveEvent.Fire();
        }
        protected virtual void OnMouseDown(MouseEventArgs& args)
        {
            mouseDownEvent.Fire(args);
        }
        protected virtual void OnMouseUp(MouseEventArgs& args)
        {
            mouseUpEvent.Fire(args);
        }
        protected virtual void OnKeyPress(KeyPressEventArgs& args)
        {
            keyPressEvent.Fire(args);
        }
        protected virtual void OnClick()
        {
            clickEvent.Fire();
        }
        public void* GetDC()
        {
            return GetDC(handle);
        }
        public void Invalidate()
        {
            InvalidateRect(handle, null, true);
        }
        public void Invalidate(const WinRect& rect)
        {
            InvalidateRect(handle, &rect, false);
        }
        public void Invalidate(const WinRect& rect, bool eraseBackground)
        {
            InvalidateRect(handle, &rect, eraseBackground);
        }
        public nothrow inline const Color& BackgroundColor() const
        {
            return backgroundColor;
        }
        public void SetBackgroundColor(const Color& backgroundColor_)
        {
            backgroundColor = backgroundColor_;
            Invalidate();
        }
        public nothrow inline void* Handle() const
        {
            return handle;
        }
        public inline nothrow WindowStyle GetWindowStyle() const
        {
            return style;
        }
        public inline nothrow ExtendedWindowStyle GetExtendedWindowStyle() const
        {
            return exStyle;
        }
        public nothrow Event<PaintEventHandler, PaintEventArgs>& PaintEvent()
        {
            return paintEvent;
        }
        public nothrow Event<MouseEnterEventHandler>& MouseEnterEvent() const
        {
            return mouseEnterEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseMoveEvent() const
        {
            return mouseMoveEvent;
        }
        public nothrow Event<MouseLeaveEventHandler>& MouseLeaveEvent() const
        {
            return mouseLeaveEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseDownEvent() const
        {
            return mouseDownEvent;
        }
        public nothrow Event<MouseEventHandler, MouseEventArgs>& MouseUpEvent() const
        {
            return mouseUpEvent;
        }
        public nothrow Event<ClickEventHandler>& ClickEvent() const
        {
            return clickEvent;
        }
        private nothrow inline bool MouseInClient() const
        {
            return (flags & Flags.mouseInClient) != 0;
        }
        private nothrow inline void SetMouseInClient()
        {
            flags = cast<Flags>(flags | Flags.mouseInClient);
        }
        private nothrow inline void ResetMouseInClient()
        {
            flags = cast<Flags>(flags & ~Flags.mouseInClient);
        }
        private nothrow inline bool LButtonPressed() const
        {
            return (flags & flags.lbuttonPressed) != 0;
        }
        private nothrow inline void SetLButtonPressed()
        {
            flags = cast<Flags>(flags | Flags.lbuttonPressed);
        }
        private nothrow inline void ResetLButtonPressed()
        {
            flags = cast<Flags>(flags & ~Flags.lbuttonPressed);
        }
        private nothrow inline bool MenuWantsKeys() const
        {
            return (flags & flags.menuWantsKeys) != 0;
        }
        private nothrow inline void SetMenuWantsKeys()
        {
            flags = cast<Flags>(flags | Flags.menuWantsKeys);
        }
        private nothrow inline void ResetMenuWantsKeys()
        {
            flags = cast<Flags>(flags & ~Flags.menuWantsKeys);
        }
        private nothrow inline bool KeyDownHandled() const
        {
            return (flags & flags.keyDownHandled) != 0;
        }
        private nothrow inline void SetKeyDownHandled()
        {
            flags = cast<Flags>(flags | Flags.keyDownHandled);
        }
        private nothrow inline void ResetKeyDownHandled()
        {
            flags = cast<Flags>(flags & ~Flags.keyDownHandled);
        }
        private const char* windowClassName;
        private WindowClassStyle windowClassStyle;
        private Color backgroundColor;
        private WindowStyle style;
        private ExtendedWindowStyle exStyle;
        private void* handle;
        private string text;
        private Point location;
        private Size size;
        private Dock dock;
        private Anchors anchors;
        private Flags flags;
        private Event<PaintEventHandler, PaintEventArgs> paintEvent;
        private Event<MouseEnterEventHandler> mouseEnterEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseMoveEvent;
        private Event<MouseLeaveEventHandler> mouseLeaveEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseDownEvent;
        private Event<MouseEventHandler, MouseEventArgs> mouseUpEvent;
        private Event<KeyPressEventHandler, KeyPressEventArgs> keyPressEvent;
        private Event<ClickEventHandler> clickEvent;
    }
}

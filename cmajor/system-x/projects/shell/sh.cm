// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Os;
using System.Lex;
using System.RegularExpressions;
using shtokens;

string CWD(ShellEnvironment& environment)
{
    string cwd = GetCurrentWorkingDirectory();
    if (cwd.StartsWith(environment.Home()))
    {
        cwd = Path.Combine("~", cwd.Substring(environment.Home().Length()));
    }
    return SetColors(ConsoleColor.blue, DefaultConsoleBackColor()).Append(cwd).Append(ResetColors());
}

void PrintPrompt(ShellEnvironment& environment)
{
    string prompt = "$ ";
    if (environment.UID() == 0)
    {
        prompt = "# ";
    }
    Console.Out() << SetColors(ConsoleColor.green, DefaultConsoleBackColor()).Append(environment.UserName()).Append("@").Append(environment.HostName()).Append(ResetColors()).
        Append(":").Append(CWD(environment)).Append(prompt);
}

string GetLine(ShellEnvironment& environment)
{
    PrintPrompt(environment);
    string line = Console.ReadLine();
    return line;
}

void ProcessLine(const string& line, ShellEnvironment& environment, Params& params, Context& context, Map<string, string>& executableMap)
{
    if (line.IsEmpty()) return;
    ustring uline = ToUtf32(line);
    TokenFlags globalFlags = TokenFlags.none;
    List<ShellToken> tokens = TokenizeLine(uline, globalFlags);
    Expand(tokens, environment, params, context, globalFlags);
    Environment programEnvironment;
    Environment.Instance().CopyTo(programEnvironment);
    UniquePtr<Command> cmd;
    Command* command = MakeCommand(tokens, executableMap, globalFlags, cmd);
    if (command != null)
    {
        List<string> args;
        int n = cast<int>(tokens.Count());
        for (int i = 1; i < n; ++i)
        {
            args.Add(ToUtf8(tokens[i].match));
        }
        if (environment.Debug())
        {
            Console.Out() << "executing command: " << command->ToString(args) << endl();
        }
        command->Execute(args, programEnvironment);
    }
    if (DirectoriesChanged())
    {
        ClearDirectoriesChanged();
        string path = GetEnv("PATH");
        ReadPathDirectories(path, executableMap);
    }
}

void Run(ShellEnvironment& environment, Params& params, Context& context)
{
    Map<string, string> executableMap;
    string path = GetEnv("PATH");
    AddDirChangeNotification(path.Chars());
    ReadPathDirectories(path, executableMap);
    string line = GetLine(environment);
    while (line != "exit")
    {
        ProcessLine(line, environment, params, context, executableMap);
        line = GetLine(environment);
    }
    RemoveDirChangeNotifications();
}

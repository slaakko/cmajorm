// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.IO;
using System.Os;
using System.Lex;
using System.RegularExpressions;
using shtokens;

class PushPopLines
{
    public PushPopLines()
    {
        PushLines();
    }
    public ~PushPopLines()
    {
        PopLines();
    }
}

string CWD(ShellEnvironment& environment)
{
    string cwd = GetCurrentWorkingDirectory();
    if (cwd.StartsWith(environment.Home()))
    {
        cwd = Path.Combine("~", cwd.Substring(environment.Home().Length()));
    }
    return SetColors(ConsoleColor.blue, DefaultConsoleBackColor()).Append(cwd).Append(ResetColors());
}

void PrintPrompt(ShellEnvironment& environment)
{
    string prompt = "$ ";
    if (environment.UID() == 0)
    {
        prompt = "# ";
    }
    Terminal.Out() << SetColors(ConsoleColor.green, DefaultConsoleBackColor()).Append(environment.UserName()).Append("@").Append(environment.HostName()).Append(ResetColors()).
        Append(":").Append(CWD(environment)).Append(prompt);
}

string GetLine(ShellEnvironment& environment)
{
	try
	{
		PrintPrompt(environment);
		PushPid(Terminal.Descriptor(), GetPid());
		Tab(Terminal.Descriptor(), environment.PutTabMsgQ(), environment.GetTabMsgQ());
		string line = Terminal.ReadLine();
		Untab(Terminal.Descriptor());
		PopPid(Terminal.Descriptor());
		return line;
	}
	catch (const Exception& ex)
	{
		Terminal.Out() << ex.Message() << endl();
		Untab(Terminal.Descriptor());
		PopPid(Terminal.Descriptor());
	}
	return string();
}

void ProcessLine(const string& line, ShellEnvironment& environment, Params& params, Context& context, Map<string, string>& executableMap)
{
    if (line.IsEmpty()) return;
    ustring uline = ToUtf32(line);
    TokenFlags globalFlags = TokenFlags.none;
    List<ShellToken> tokens = TokenizeLine(uline, globalFlags);
    Expand(tokens, environment, params, context, globalFlags);
    TokenLexer lexer(tokens);
    try
    {
        UniquePtr<Command> command = ParseCommand(lexer);
        if (!command.IsNull())
        {
            if (environment.Debug())
            {
                command->Print();
                Terminal.WriteLine();
            }
            ExecutionContext ctx;
            ctx.wait = true;
            ctx.environment = &Environment.Instance();
            ctx.executableMap = &executableMap;
            PushPopLines pushPopLines;
            command->Execute(ctx);
        }
        else
        {
            if (environment.Debug())
            {
                Terminal.WriteLine("command is empty");
            }
        }
    }
    catch (const Exception& ex)
    {
        Terminal.Out() << ex.Message() << ":" << endl();
        lexer.PrintErrorLines();
    }
    if (DirectoriesChanged())
    {
        ClearDirectoriesChanged();
        string path = GetEnv("PATH");
        ReadPathDirectories(path, executableMap);
    }
}

void Run(ShellEnvironment& environment, Params& params, Context& context)
{
    Map<string, string> executableMap;
    string path = GetEnv("PATH");
    AddDirChangeNotification(path.Chars());
    ReadPathDirectories(path, executableMap);
    string line = GetLine(environment);
    while (line != "exit")
    {
        ProcessLine(line, environment, params, context, executableMap);
        line = GetLine(environment);
    }
    RemoveDirChangeNotifications();
}

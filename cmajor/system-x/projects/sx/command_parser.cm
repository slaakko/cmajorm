// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

abstract class Command
{
    public abstract void Execute();
}

class PutCommand : Command
{
    public nothrow PutCommand(const string& path_) : path(path_)
    {
    }
    public override void Execute()
    {
        if (path.EndsWith(".cmp"))
		{
			project.Reset(ParseProjectFile(path));
		}
		else if (path.EndsWith(".cms"))
		{
			// todo
		}
    }
    private string path;
	private UniquePtr<Project> project;
}

class ParseResult
{
    public nothrow ParseResult() : command()
    {
    }
    public Command* GetCommand() 
    {
        return command.Get();
    }
    public nothrow void ResetCommand(Command* command_)
    {
        command.Reset(command_);
    }
    public nothrow Command* ReleaseCommand() 
    {
        return command.Release();
    }
    private UniquePtr<Command> command;
}

UniquePtr<Command> ParseCommand(const List<ustring>& commandWords)
{
    CommandLexer lexer(commandWords);
    ParseResult result;
    if (ParseCommand(lexer, result))
    {
        if (*lexer == END)
        {
            return UniquePtr<Command>(result.ReleaseCommand());
        }
        else
        {
            Console.Out() << "command syntax error:" << endl();
            lexer.PrintErrorLines();
        }
    }
    else
    {
        Console.Out() << "command syntax error:" << endl();
        lexer.PrintErrorLines();
    }
    return UniquePtr<Command>();
}

bool ParseCommand(CommandLexer& lexer, ParseResult& result)
{
    if (ParsePutCommand(lexer, result))
    {
        return true;
    }
    else
    {
        return false;
    }
}

ustring ParsePath(CommandLexer& lexer)
{
    ustring path;
    bool first = true;
    while (*lexer != END)
    {
        if (first)
        {
            first = false;
        }
        else
        {
            path.Append(' ');
        }
        path.Append(lexer.GetWord());
        ++lexer;
    }
    return path;
}

bool ParsePutCommand(CommandLexer& lexer, ParseResult& result)
{
    int save = lexer.GetPos();
    if (*lexer == PUT)
    {
        ++lexer;
        ustring path = ParsePath(lexer);
        if (!path.IsEmpty())
        {
            result.ResetCommand(new PutCommand(ToUtf8(path)));
            return true;
        }
        else
        {
            lexer.SetPos(save);
            return false;
        }
    }
    else
    {
        lexer.SetPos(save);
        return false;
    }
}

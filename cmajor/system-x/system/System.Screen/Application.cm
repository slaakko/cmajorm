// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Os;

namespace System.Screen
{
    public class Application
    {
        static Application() : instance(new Application())
        {
        }
        public ~Application()
        {
            try
            {
                CloseMsgQ(msgQ);
                SetCooked(Terminal.Descriptor());
                SetEcho(Terminal.Descriptor(), true);
                Terminal.Out() << ResetColors();
                ClearScreen(TerminalWindowWidth(), TerminalWindowHeight());
                SetCursorPos(0, 0);
            }
            catch (const Exception& ex)
            {
            }
        }
        public static Application& Instance() 
        {
            return *instance;
        }
        private Application() : msgQ(MsgQ("system.screen.msg.queue")), menuBar(null), focusedControl(null)
        {
            SetRaw(Terminal.Descriptor());
            SetEcho(Terminal.Descriptor(), false);
        }
        public nothrow Window* MainWindow() 
        {
            return mainWindow;
        }
		public nothrow MenuBar* GetMenuBar() const
		{
			return menuBar;
		}
		public nothrow void SetMenuBar(MenuBar* menuBar_)
		{
			menuBar = menuBar_;
		}
        public WindowManager& GetWindowManager() const
        {
            return windowManager;
        }
        public void Run(Window& mainWindow_)
        {
            mainWindow = &mainWindow_;
            mainWindow->SetMainWindow();
			mainWindow->SetLocation(Point(0, 0));
			mainWindow->SetSize(Size(TerminalWindowWidth(), TerminalWindowHeight()));
            mainWindow->Invalidate();
            UniquePtr<Message> message = ReadMessage();
            while (!(message.Get() is QuitMessage*))
            {
                bool handled = false;
                if (message->TargetWindowHandle() != -1)
                {
                    Control* control = windowManager.GetWindow(message->TargetWindowHandle());
                    if (control != null)
                    {
                        handled = control->HandleMessage(message.Get());
                    }
                }
                if (!handled)
                {
                    handled = mainWindow->HandleMessage(message.Get());
                }
                message = ReadMessage();
            }
        }
		public void RunDialog(Window* window)
		{
			WriteScreenMessage writeScreenMessage(Rect.Default());
			mainWindow->HandleWriteScreen(&writeScreenMessage);
            UniquePtr<Message> message = ReadMessage();
            while (!(message.Get() is QuitMessage*))
            {
                bool handled = window->HandleMessage(message.Get());
				if (handled)
				{
					if (window->GetDialogResult() != DialogResult.none)
					{
						WriteScreenMessage writeScreenMessage(window->GetRect());
						mainWindow->HandleWriteScreen(&writeScreenMessage);
						return;
					}
				}
                message = ReadMessage();
            }
		}
        public void Exit()
        {
            QuitMessage quitMessage;
            PostMessage(quitMessage);
        }
        public void PostMessage(Message& message)
        {
            int msgSize = message.Size();
            UniquePtr<byte> msg(cast<byte*>(MemAlloc(msgSize)));
            MemoryWriter writer(msg.Get(), msgSize);
            message.Write(writer);
            PutMsg(msgQ, msg.Get(), msgSize);
            SendKey(keyMsg);
        }
        public UniquePtr<Message> ReadMessage()
        {
            uchar key = ReadKey(Terminal.Descriptor());
            if (key == keyMsg)
            {
                return GetMessage();
            }
            else
            {
                UniquePtr<Message> keyPressedMessage(new KeyPressedMessage(key));
                return keyPressedMessage;
            }
        }
		public nothrow Control* FocusedControl() const
		{
			return focusedControl;
		}
		public nothrow void SetFocusedControl(Control* focusedControl_) 
		{
			focusedControl = focusedControl_;
		}
        private UniquePtr<Message> GetMessage()
        {
            int qlen = GetMsgQLength(msgQ);
            if (qlen > 0)
            {
                int msgSize = GetMsgSize(msgQ);
                if (msgSize > 0)
                {
                    UniquePtr<byte> msgData(cast<byte*>(MemAlloc(msgSize)));
                    GetMsg(msgQ, msgData.Get());
                    UniquePtr<Message> message(ReadMessage(msgData.Get(), msgSize));
                    return message;
                }
                else
                {
                    throw Exception("invalid message size 0");
                }
            }
            else
            {
                throw Exception("message queue " + ToString(msgQ) + " is empty");
            }
        }
        private static UniquePtr<Application> instance;
        private Window* mainWindow;
        private WindowManager windowManager;
        private int msgQ;
		private MenuBar* menuBar;
		private Control* focusedControl;
    }
}

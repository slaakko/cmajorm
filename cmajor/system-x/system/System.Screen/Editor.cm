// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;

namespace System.Screen
{
    const int tabSize = 4;
    
    public class Selection
    {
        public nothrow Selection() : startLine(-1), startCol(-1), endLine(-1), endCol(-1)
        {
        }
        public nothrow bool IsEmpty() const
        {
            return startLine == -1 && startCol == -1 && endLine == -1 && endCol == -1;
        }
        public nothrow void Reset()
        {
            startLine = -1;
            startCol = -1;
            endLine = -1;
            endCol = -1;
        }
        public nothrow void SetStart(int startLine_, int startCol_)
        {
            startLine = startLine_;
            startCol = startCol_;
        }
        public nothrow void SetEnd(int endLine_, int endCol_)
        {
            endLine = endLine_;
            endCol = endCol_;
        }
        public nothrow string ToString() const
        {
            return "[(" + ToString(startLine) + ", " + ToString(startCol) + "), (" + ToString(endLine) + ", " + ToString(endCol) + ")]";
        }
        public int startLine;
        public int startCol;
        public int endLine;
        public int endCol;
    }
    
    public class SelectionData
    {
        public nothrow SelectionData()
        {
        }
        public nothrow bool IsEmpty() const
        {
            return lines.IsEmpty();
        }
        public void SetLines(const List<ustring>& lines_)
        {
            lines = lines_;
        }
        public nothrow const List<ustring>& Lines() const
        {
            return lines;
        }
        private List<ustring> lines;
    }
    
    public class Clipboard
    {
        static Clipboard() : instance(new Clipboard())
        {
        }
        private Clipboard()
        {
        }
        public static Clipboard& Instance()
        {
            return *instance;
        }
        public nothrow bool IsEmpty() const
        {
            return selectionData.IsEmpty();
        }
        public nothrow SelectionData& GetSelectionData() 
        {
            return selectionData;
        }
        private static UniquePtr<Clipboard> instance;
        private SelectionData selectionData;
    }

    public class EditorCreateParams
    {
        public nothrow EditorCreateParams() :
            controlCreateParams(), 
            selectionForeColor(ConsoleColor.defaultColor), 
            selectionBackColor(ConsoleColor.defaultColor)
        {
        }
        public nothrow EditorCreateParams& Defaults() 
        {
            return *this;
        }
        public nothrow EditorCreateParams& SelectionForeColor(ConsoleColor selectionForeColor_)
        {
            selectionForeColor = selectionForeColor_;
            return *this;
        }
        public nothrow EditorCreateParams& SelectionBackColor(ConsoleColor selectionBackColor_)
        {
            selectionBackColor = selectionBackColor_;
            return *this;
        }
        public ControlCreateParams controlCreateParams;
        public ConsoleColor selectionForeColor;
        public ConsoleColor selectionBackColor;
    }
    
    public enum EditorFlags
    {
        none = 0, dirty = 1 << 0
    }
    
    public class Editor : Control
    {
        public nothrow Editor(EditorCreateParams& createParams) : 
            base(createParams.controlCreateParams), flags(EditorFlags.none), xOffset(0), yOffset(0), caretLine(0), caretCol(0)
        {
            InvalidateGuard invalidateGuard(this, InvalidateKind.dontInvalidate);
            if (ForeColor() == ConsoleColor.defaultColor)
            {
                SetForeColor(ConsoleColor.gray);
            }
            if (BackColor() == ConsoleColor.defaultColor)
            {
                SetBackColor(ConsoleColor.darkBlue);
            }
            if (createParams.selectionForeColor == ConsoleColor.defaultColor)
            {
                selectionForeColor = ConsoleColor.black;
            }
            else
            {
                selectionForeColor = createParams.selectionForeColor;
            }
            if (createParams.selectionBackColor == ConsoleColor.defaultColor)
            {
                selectionBackColor = ConsoleColor.cyan;
            }
            else
            {
                selectionBackColor = createParams.selectionBackColor;
            }
            if (Location().IsDefault())
            {
                SetLocation(Point(0, 1));
            }
            if (GetSize().IsDefault())
            {
                SetSize(Size(TerminalWindowWidth(), TerminalWindowHeight() - 2));
            }
        }
        public nothrow bool IsDirty() const 
        {
            return (flags & EditorFlags.dirty) != EditorFlags.none;
        }
        public nothrow void SetDirty()
        {
            if (!IsDirty())
            {
                flags = cast<EditorFlags>(flags | EditorFlags.dirty);
                dirtyChangedEvent.Fire();
            }
        }
        public nothrow void ResetDirty()
        {
            if (IsDirty())
            {
                flags = cast<EditorFlags>(flags & ~EditorFlags.dirty);
                dirtyChangedEvent.Fire();
            }
        }
        public void SetLines(const List<string>& lines_)
        {
            lines.Clear();
            for (const string& line : lines_)
            {
                lines.Add(ToUtf32(line));
            }
            CursorStartOfText(false);
            ResetDirty();
        }
        public void AddLine(const string& line)
        {
            lines.Add(ToUtf32(line));
            Invalidate(GetRect());
        }
        public nothrow void SetFilePath(const string& filePath_)
        {
            if (filePath != filePath_)
            {
                filePath = filePath_;
                filePathChangedEvent.Fire();
            }
        }
        public nothrow const string& FilePath() const
        {
            return filePath;
        }
        public void SetCaretPos(int caretLine_, int caretCol_)
        {
            if (caretLine != caretLine_ || caretCol != caretCol_)
            {
                caretLine = caretLine_;
                caretCol = caretCol_;
                caretPosChangedEvent.Fire();
            }
        }
        public nothrow int CaretLine() const
        {
            return caretLine;
        }
        public nothrow int CaretCol() const
        {
            return caretCol;
        }
        public void Clear()
        {
            lines.Clear();
            CursorStartOfText(false);
            SetStatusText("text cleared");
            ResetDirty();
        }
        public void Save()
        {
            try
            {
                if (filePath.IsEmpty()) return;
                StreamWriter writer = File.CreateText(filePath);
                for (const ustring& line : lines)
                {
                    writer.WriteLine(line);
                }
                SetStatusText("text saved");
                ResetDirty();
            }
            catch (const Exception& ex)
            {
                UniquePtr<MessageBox> messageBox = new MessageBox(MessageBoxCreateParams().Caption("Error").Text(ex.ToString()));
                messageBox->ShowDialog();
                SetFocus();
            }
        }
        public void Load()
        {
            try
            {
                if (filePath.IsEmpty()) return;
                List<string> lines_ = File.ReadAllLines(filePath);
                SetLines(lines_);
                SetStatusText("text loaded");
            }
            catch (const Exception& ex)
            {
                UniquePtr<MessageBox> messageBox = new MessageBox(MessageBoxCreateParams().Caption("Error").Text(ex.ToString()));
                messageBox->ShowDialog();
                SetFocus();
            }
        }
        public void Copy()
        {
            if (selection.IsEmpty()) return;
            MakeCanonicalSelection();
            List<ustring> selectionLines;
            for (int i = canonicalSelection.startLine; i <= canonicalSelection.endLine; ++i)
            {
                if (i >= 0 && i < lines.Count())
                {
                    selectionLines.Add(lines[i]);
                }
            }
            Clipboard.Instance().GetSelectionData().SetLines(selectionLines);
            SetStatusText("selection copied");
        }
        public void Cut()
        {
            if (selection.IsEmpty()) return;
            Copy();
            DeleteSelection();
            SetStatusText("selection was cut");
        }
        public void Paste()
        {
            if (Clipboard.Instance().IsEmpty()) return;
            const List<ustring>& selectionLines = Clipboard.Instance().GetSelectionData().Lines();
            for (const ustring& line : selectionLines)
            {
                if (caretLine < lines.Count())
                {
                    lines.Insert(lines.Begin() + caretLine, line);
                    ++caretLine;
                }
                else
                {
                    lines.Add(line);
                    ++caretLine;
                }
            }
            Invalidate(GetRect());
            SetDirty();
        }
        public nothrow Event<ChangedEventHandler>& FilePathChangedEvent() 
        {
            return filePathChangedEvent;
        }
        public nothrow Event<ChangedEventHandler>& CaretPosChangedEvent() 
        {
            return caretPosChangedEvent;
        }
        public nothrow Event<ChangedEventHandler>& StatusTextChangedEvent() 
        {
            return statusTextChangedEvent;
        }
        public nothrow Event<ChangedEventHandler>& DirtyChangedEvent()
        {
            return dirtyChangedEvent;
        }
        public nothrow void SetStatusText(const string& statusText_)
        {
            if (statusText != statusText_)
            {
                statusText = statusText_;
                statusTextChangedEvent.Fire();
            }
        }
        public nothrow const string& StatusText() const
        {
            return statusText;
        }
        public override void SetFocus()
        {
            base->SetFocus();
            SetCursorPos();
        }
        public void SetCursorPos()
        {
            Point cp = ScreenPoint(caretCol, caretLine);
            if (cp.x >= 0 && cp.x < TerminalWindowWidth() && cp.y >= 0 && cp.y < TerminalWindowHeight())
            {
                SetControlCursorPos(cp);
                SetCursorPos(cp.x, cp.y);
            }
        }
        public override void OnWriteScreen(WriteScreenEventArgs& args)
        {
            base->OnWriteScreen(args);
            Rect updateRect = GetRect();
            if (!args.GetRect().IsDefault())
            {
                updateRect = Rect.Intersection(updateRect, args.GetRect());
            }
            if (updateRect.IsEmpty()) return;
            Clear(updateRect, ForeColor(), BackColor());
            if (selection.IsEmpty())
            {
                WriteScreenNoSelection(updateRect);
            }
            else
            {
                WriteScreenWithSelection(updateRect);
            }
            SetCursorPos();
        }
        
        public override void OnKeyPressed(KeyEventArgs& args)
        {
            if (args.Handled()) return;
            Rect updateRect;
            int prevXOffset = xOffset;
            int prevYOffset = yOffset;
            uchar key = args.Key();
            if (key >= ' ' && key < specialKeyStart)
            {
                args.SetHandled();
                DeleteSelection();
                while (caretLine >= lines.Count())
                {
                    lines.Add(ustring());
                }
                ustring& line = lines[caretLine];
                bool inserted = false;
                if (caretCol < line.Length())
                {
                    line.Insert(caretCol, key);
                    inserted = true;
                }
                else
                {
                    line.Append(key);
                }
                Point start = ScreenPoint(caretCol, caretLine);
                SetCaretPos(caretLine, caretCol + 1);
                Point end = ScreenPoint(caretCol, caretLine + 1);
                if (inserted)
                {
                    end = ScreenPoint(cast<int>(line.Length()), caretLine + 1);
                }
                updateRect = ScreenRect(start, end);
                SetXOffset();
                SetYOffset();
                SetDirty();
            }
            else
            {
                if (key < specialKeyStart)
                {
                    if (key == keyNewline)
                    {
                        args.SetHandled();
                        Newline(updateRect);
                    }
                    else if (key == keyTab)
                    {
                        args.SetHandled();
                        Tab(updateRect);
                    }
                    else if (key == keyBackspace)
                    {
                        args.SetHandled();
                        Backspace(updateRect);
                    }
                }
                else
                {
                    switch (key)
                    {
                        case keyLeft:
                        {
                            args.SetHandled();
                            CursorLeft(false, true);
                            break;
                        }
                        case keyRight:
                        {
                            args.SetHandled();
                            CursorRight(false, true);
                            break;
                        }
                        case keyUp:
                        {
                            args.SetHandled();
                            CursorUp(false);
                            break;
                        }
                        case keyDown:
                        {
                            args.SetHandled();
                            CursorDown(false);
                            break;
                        }
                        case keyControlLeft:
                        {
                            args.SetHandled();
                            CursorPrevWord(false);
                            break;
                        }
                        case keyControlRight:
                        {
                            args.SetHandled();
                            CursorNextWord(false);
                            break;
                        }
                        case keyHome:
                        {
                            args.SetHandled();
                            CursorStartOfLine(false);
                            break;
                        }
                        case keyEnd:
                        {
                            args.SetHandled();
                            CursorEndOfLine(false);
                            break;
                        }
                        case keyPgUp:
                        {
                            args.SetHandled();
                            CursorPrevPage(false);
                            break;
                        }
                        case keyPgDown:
                        {
                            args.SetHandled();
                            CursorNextPage(false);
                            break;
                        }
                        case keyControlHome:
                        {
                            args.SetHandled();
                            CursorStartOfText(false);
                            break;
                        }
                        case keyControlEnd:
                        {
                            args.SetHandled();
                            CursorEndOfText(false);
                            break;
                        }
                        case keyShiftTab:
                        {
                            args.SetHandled();
                            Untab(updateRect);
                            break;
                        }
                        case keyDel:
                        {
                            args.SetHandled();
                            if (selection.IsEmpty())
                            {
                                DeleteChar(updateRect);
                            }
                            else
                            {    
                                DeleteSelection();
                            }
                            break;
                        }
                        case keyShiftLeft:
                        {
                            args.SetHandled();
                            CursorLeft(true, true);
                            break;
                        }
                        case keyShiftRight:
                        {
                            args.SetHandled();
                            CursorRight(true, true);
                            break;
                        }
                        case keyShiftDown:
                        {
                            args.SetHandled();
                            CursorDown(true);
                            break;
                        }
                        case keyShiftUp:
                        {
                            args.SetHandled();
                            CursorUp(true);
                            break;
                        }
                        case keyShiftHome:
                        {
                            args.SetHandled();
                            CursorStartOfLine(true);
                            break;
                        }
                        case keyShiftEnd:
                        {
                            args.SetHandled();
                            CursorEndOfLine(true);
                            break;
                        }
                        case keyShiftPgUp:
                        {
                            args.SetHandled();
                            CursorPrevPage(true);
                            break;
                        }
                        case keyShiftPgDown:
                        {
                            args.SetHandled();
                            CursorNextPage(true);
                            break;
                        }
                        case keyControlShiftLeft:
                        {
                            args.SetHandled();
                            CursorPrevWord(true);
                            break;
                        }
                        case keyControlShiftRight:
                        {
                            args.SetHandled();
                            CursorNextWord(true);
                            break;
                        }
                        case keyControlShiftHome:
                        {
                            args.SetHandled();
                            CursorStartOfText(true);
                            break;
                        }
                        case keyControlShiftEnd:
                        {
                            args.SetHandled();
                            CursorEndOfText(true);
                            break;
                        }
                    }
                }
            }
            if (xOffset != prevXOffset || yOffset != prevYOffset)
            {
                Invalidate(GetRect());
                SetCursorPos();
            }
            else
            {
                Invalidate(updateRect);
                SetCursorPos();
            }
        }
        private void WriteScreenNoSelection(const Rect& updateRect)
        {
            Terminal.Out() << SetColors(ForeColor(), BackColor());
            for (int y = 0; y < updateRect.size.h; ++y)
            {
                ustring updateLine;
                for (int x = 0; x < updateRect.size.w; ++x)
                {
                    uchar c = CharAt(updateRect.location.x + x, updateRect.location.y + y);
                    if (c == '\0')
                    {
                        break;
                    }
                    updateLine.Append(c);
                }
                SetCursorPos(updateRect.location.x, updateRect.location.y + y);
                Terminal.Out() << updateLine;
            }
        }
        private void WriteScreenWithSelection(const Rect& updateRect)
        {
            MakeCanonicalSelection();
            for (int y = 0; y < updateRect.size.h; ++y)
            {
                for (int x = 0; x < updateRect.size.w; ++x)
                {
                    uchar c = CharAt(updateRect.location.x + x, updateRect.location.y + y);
                    if (c != '\0')
                    {
                        int line = 0;
                        int col = 0;
                        LineCol(updateRect.location.x + x, updateRect.location.y + y, line, col);
                        if (LineColInSelection(line, col))
                        {
                            Terminal.Out() << SetColors(selectionForeColor, selectionBackColor);
                        }
                        else
                        {
                            Terminal.Out() << SetColors(ForeColor(), BackColor());
                        }
                        SetCursorPos(updateRect.location.x + x, updateRect.location.y + y);
                        Terminal.Out() << c;
                    }
                }
            }
        }
        private void SetXOffset()
        {
            Size sz = GetSize();
            while (caretCol - xOffset >= sz.w)
            {
                ++xOffset;
            }
        }
        private void SetYOffset()
        {
            Size sz = GetSize();
            while (caretLine - yOffset >= sz.h)
            {
                ++yOffset;
            }
        }
        private void CursorStartOfText(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            SetCaretPos(0, 0);
            xOffset = 0;
            yOffset = 0;
            SetCursorPos();
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, 0);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorEndOfText(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            SetCaretPos(cast<int>(lines.Count()), 0);
            SetXOffset();
            SetYOffset();
            SetCursorPos();
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorPrevPage(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            Size sz = GetSize();
            if (yOffset >= sz.h)
            {
                yOffset = yOffset - sz.h;
                SetCaretPos(caretLine - sz.h, 0);
                SetCursorPos();
            }
            else
            {
                CursorStartOfText(extendSelection);
            }
            if (extendSelection)
            {
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine - sz.h);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorNextPage(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            Size sz = GetSize();
            if (caretLine + sz.h >= lines.Count())
            {
                CursorEndOfText(extendSelection);
            }
            else
            {
                SetCaretPos(caretLine + sz.h, 0);
                yOffset = yOffset + sz.h;
                SetCursorPos();
            }
            if (extendSelection)
            {
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + sz.h);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorLeft(bool extendSelection, bool invalidate)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            if (caretCol > 0)
            {
                SetCaretPos(caretLine, caretCol - 1);
                SetCursorPos();
            }
            else
            {
                if (caretLine > 0)
                {
                    ustring& line = lines[caretLine - 1];
                    SetCaretPos(caretLine - 1, cast<int>(line.Length()));
                    SetXOffset();
                    SetCursorPos();
                }
            }
            if (caretCol < xOffset)
            {
                --xOffset;
            }
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                if (invalidate)
                {
                    Invalidate(selectionUpdateRect);
                }
            }
        }
        private void CursorRight(bool extendSelection, bool invalidate)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (caretLine >= lines.Count()) 
            {
                return;
            }
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            ustring& line = lines[caretLine];
            if (caretCol < line.Length())
            {
                SetCaretPos(caretLine, caretCol + 1);
            }
            else 
            {
                if (caretLine < lines.Count())
                {
                    SetCaretPos(caretLine + 1, 0);
                    xOffset = 0;
                }
            }
            SetXOffset();
            SetYOffset();
            SetCursorPos();
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                if (invalidate)
                {
                    Invalidate(selectionUpdateRect);
                }
            }
        }
        private void CursorUp(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (caretLine > 0)
            {
                if (extendSelection)
                {
                    if (selection.IsEmpty())
                    {
                        selection.SetStart(caretLine, caretCol);
                    }
                    selectionStartExtensionPoint = ScreenPoint(0, caretLine);
                }
                else
                {
                    ResetSelection();
                }
                SetCaretPos(caretLine - 1, Min(caretCol, cast<int>(line.Length())));
                ustring& line = lines[caretLine];
                SetCursorPos();
            }
            if (caretLine < yOffset)
            {
                --yOffset;
            }
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine - 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorDown(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (caretLine < lines.Count())
            {
                if (extendSelection)
                {
                    if (selection.IsEmpty())
                    {
                        selection.SetStart(caretLine, caretCol);
                    }
                    selectionStartExtensionPoint = ScreenPoint(0, caretLine);
                }
                else
                {
                    ResetSelection();
                }
                SetCaretPos(caretLine + 1, caretCol);
                SetYOffset();
                if (caretLine < lines.Count())
                {
                    ustring& line = lines[caretLine];
                    SetCaretPos(caretLine, Min(caretCol, cast<int>(line.Length())));
                    SetCursorPos();
                }
                else
                {
                    CursorEndOfText(extendSelection);
                }
            }
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorPrevWord(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            CursorLeft(extendSelection, false);
            uchar c = CharAtCursor();
            while ((caretCol != 0 || caretLine != 0) && c == ' ')
            {
                CursorLeft(extendSelection, false);
                c = CharAtCursor();
            }
            while ((caretCol != 0 || caretLine != 0) && c != ' ' && c != '\0')
            {
                CursorLeft(extendSelection, false);
                c = CharAtCursor();
            }
            if ((caretCol != 0 || caretLine != 0) && c == ' ')
            {
                CursorRight(extendSelection, false);
            }
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorNextWord(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            CursorRight(extendSelection, false);
            uchar c = CharAtCursor();
            while (caretLine < lines.Count() && c != ' ' && c != '\0')
            {
                CursorRight(extendSelection, false);
                c = CharAtCursor();
            }
            while (caretLine < lines.Count() && c == ' ')
            {
                CursorRight(extendSelection, false);
                c = CharAtCursor();
            }
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorStartOfLine(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (extendSelection)
            {
                if (selection.IsEmpty())
                {
                    selection.SetStart(caretLine, caretCol);
                }
                selectionStartExtensionPoint = ScreenPoint(0, caretLine);
            }
            else
            {
                ResetSelection();
            }
            SetCaretPos(caretLine, 0);
            xOffset = 0;
            SetCursorPos();
            if (extendSelection)
            {
                Size sz = GetSize();
                selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                selection.SetEnd(caretLine, caretCol);
                Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                Invalidate(selectionUpdateRect);
            }
        }
        private void CursorEndOfLine(bool extendSelection)
        {
            Point selectionStartExtensionPoint;
            Point selectionEndExtensionPoint;
            if (caretLine < lines.Count())
            {
                if (extendSelection)
                {
                    if (selection.IsEmpty())
                    {
                        selection.SetStart(caretLine, caretCol);
                    }
                    selectionStartExtensionPoint = ScreenPoint(0, caretLine);
                }
                else
                {
                    ResetSelection();
                }
                ustring& line = lines[caretLine];
                SetCaretPos(caretLine, cast<int>(line.Length()));
                SetXOffset();
                SetCursorPos();
                if (extendSelection)
                {
                    Size sz = GetSize();
                    selectionEndExtensionPoint = ScreenPoint(sz.w, caretLine + 1);
                    selection.SetEnd(caretLine, caretCol);
                    Rect selectionUpdateRect = ScreenRect(selectionStartExtensionPoint, selectionEndExtensionPoint);
                    Invalidate(selectionUpdateRect);
                }
            }
        }
        private void Newline(Rect& updateRect)
        {
            updateRect.location = ScreenPoint(0, caretLine);
            while (caretLine >= lines.Count())
            {
                lines.Add(ustring());
            }
            ustring& line = lines[caretLine];
            int numSpaces = 0;
            for (uchar c : line)
            {
                if (c == ' ')
                {
                    ++numSpaces;
                }
                else
                {
                    break;
                }
            }
            if (caretCol < line.Length())
            {
                ustring splitLine = ustring(' ', numSpaces) + line.Substring(caretCol);
                line.Remove(caretCol, line.Length() - caretCol);
                if (caretLine < lines.Count())
                {
                    lines.Insert(lines.Begin() + caretLine + 1, Rvalue(splitLine));
                }
                else
                {
                    lines.Add(Rvalue(splitLine));
                }
            }
            else
            {
                if (caretLine < lines.Count())
                {
                    lines.Insert(lines.Begin() + caretLine + 1, ustring(' ', numSpaces));
                }
                else
                {
                    lines.Add(ustring(' ', numSpaces));
                }
            }
            Size sz = GetSize();
            updateRect.size.w = sz.w + xOffset;
            updateRect.size.h = sz.h - (caretLine - yOffset);
            SetCaretPos(caretLine + 1, numSpaces);
            xOffset = 0;
            SetYOffset();
            SetDirty();
        }
        private void Tab(Rect& updateRect)
        {
            if (!selection.IsEmpty())
            {
                IndentSelection(updateRect);
            }
            else
            {
                while (caretLine >= lines.Count())
                {
                    lines.Add(ustring());
                }
                ustring& line = lines[caretLine];
                int numSpaces = tabSize - (caretCol % tabSize);
                if (caretCol < line.Length())
                {
                    line.Insert(caretCol, ustring(' ', numSpaces));
                }
                else
                {
                    line.Append(ustring(' ', numSpaces));
                }
                Point start = ScreenPoint(caretCol, caretLine);
                SetCaretPos(caretLine, caretCol + numSpaces);
                Point end = ScreenPoint(cast<int>(line.Length()), caretLine + 1);
                updateRect = ScreenRect(start, end);
                SetXOffset();
                SetYOffset();
                SetDirty();
            }
        }
        private void Untab(Rect& updateRect)
        {
            if (!selection.IsEmpty())
            {
                UnindentSelection(updateRect);
            }
            else
            {
                if (caretLine < lines.Count())
                {
                    if (caretCol >= tabSize)
                    {
                        ustring& line = lines[caretLine];
                        int numSpaces = tabSize - (caretCol % tabSize);
                        Point start = ScreenPoint(0, caretLine);
                        Point end = ScreenPoint(cast<int>(line.Length()), caretLine + 1);
                        updateRect = ScreenRect(start, end);
                        line.Remove(caretCol - numSpaces, numSpaces);
                        SetCaretPos(caretLine, caretCol - numSpaces);
                        SetXOffset();
                        SetYOffset();
                        SetCursorPos();
                        SetDirty();
                    }
                }
            }
        }
        private void IndentSelection(Rect& updateRect)
        {
            MakeCanonicalSelection();
            ustring spaces(' ', tabSize);
            for (int i = canonicalSelection.startLine; i < canonicalSelection.endLine; ++i)
            {
                ustring& line = lines[i];
                line.Insert(0, spaces);
            }
            Point start = ScreenPoint(0, canonicalSelection.startLine);
            Size sz = GetSize();
            Point end = ScreenPoint(sz.w, canonicalSelection.endLine);
            updateRect = ScreenRect(start, end);
            SetDirty();
        }
        private void UnindentSelection(Rect& updateRect)
        {
            MakeCanonicalSelection();
            ustring spaces(' ', tabSize);
            for (int i = canonicalSelection.startLine; i < canonicalSelection.endLine; ++i)
            {
                ustring& line = lines[i];
                if (line.StartsWith(spaces))
                {
                    line.Remove(0, tabSize);
                }
            }
            Point start = ScreenPoint(0, canonicalSelection.startLine);
            Size sz = GetSize();
            Point end = ScreenPoint(sz.w, canonicalSelection.endLine);
            updateRect = ScreenRect(start, end);
            SetDirty();
        }
        private void DeleteChar(Rect& updateRect)
        {
            if (caretLine >= lines.Count())
            {
                return;
            }
            ustring& line = lines[caretLine];
            if (caretCol < line.Length())
            {
                line.Remove(caretCol, 1);
                Point start = ScreenPoint(caretCol, caretLine);
                Point end = ScreenPoint(cast<int>(line.Length() + 1), caretLine + 1);
                updateRect = ScreenRect(start, end);
            }
            else if (caretLine < lines.Count() - 1)
            {
                line.Append(lines[caretLine + 1]);
                TrimEnd(line);
                lines.Remove(lines.Begin() + caretLine + 1);
                updateRect.location = ScreenPoint(0, caretLine);
                Size sz = GetSize();
                updateRect.size.w = sz.w + xOffset;
                updateRect.size.h = sz.h - (caretLine - yOffset);
            }
            if (caretLine < yOffset)
            {
                --yOffset;
            }
            SetXOffset();
            SetYOffset();
            SetCursorPos();
            SetDirty();
        }
        private void Backspace(Rect& updateRect)
        {
            if (caretCol != 0 || caretLine != 0)
            {
                CursorLeft(false, true);
                DeleteChar(updateRect);
            }
        }
        private void DeleteSelection()
        {
            if (selection.IsEmpty()) return;
            MakeCanonicalSelection();
            if (canonicalSelection.startLine == canonicalSelection.endLine)
            {
                ustring& line = lines[canonicalSelection.startLine];
                line.Remove(canonicalSelection.startCol, canonicalSelection.endCol - canonicalSelection.startCol);
                SetCaretPos(caretLine, canonicalSelection.startCol);
                Point start = ScreenPoint(0, canonicalSelection.startLine);
                Size sz = GetSize();
                Point end = ScreenPoint(sz.w, canonicalSelection.startLine + 1);
                Rect selectionUpdateRect = ScreenRect(start, end);
                Invalidate(selectionUpdateRect);
                SetCursorPos();
                selection.Reset();
            }
            else
            {
                int startLine = canonicalSelection.startLine;
                int numLines = Max(cast<int>(0), canonicalSelection.endLine - startLine);
                if (numLines > 0)
                {
                    if (canonicalSelection.startCol != 0)
                    {
                        ustring& line = lines[startLine];
                        line.Remove(canonicalSelection.startCol, line.Length() - canonicalSelection.startCol);
                        ++startLine;
                        --numLines;
                    }
                }
                while (numLines > 1)
                {
                    lines.Remove(lines.Begin() + startLine);
                    --numLines;
                }
                if (numLines > 0)
                {
                    if (canonicalSelection.endCol != 0)
                    {
                        ustring& line = lines[startLine];
                        line.Remove(0, canonicalSelection.endCol);
                    }
                    else
                    {
                        lines.Remove(lines.Begin() + startLine);
                    }
                }
                SetCaretPos(canonicalSelection.startLine, canonicalSelection.startCol);
                SetXOffset();
                SetYOffset();
                SetCursorPos();
                Invalidate(GetRect());
                SetDirty();
                selection.Reset();
            }
        }
        private void TrimEnd(ustring& line)
        {
            while (!line.IsEmpty() && line[line.Length() - 1] == ' ')
            {
                line.Remove(line.Length() - 1, 1);
            }
        }
        private Point ScreenPoint(int x, int y)
        {
            Point loc = Location();
            int sx = loc.x + x - xOffset;
            int sy = loc.y + y - yOffset;
            return Point(sx, sy);
        }
        private Rect ScreenRect(const Point& start, const Point& end)
        {
            int minX = Min(start.x, end.x);
            int minY = Min(start.y, end.y);
            int maxX = Max(start.x, end.x);
            int maxY = Max(start.y, end.y);
            Point loc(minX, minY);
            Size sz(maxX - minX, maxY - minY);
            return Rect(loc, sz);
        }
        private void LineCol(int x, int y, int& line, int& col)
        {
            Point loc = Location();
            line = yOffset + y - loc.y;
            col = xOffset + x - loc.x;
        }
        private uchar CharAt(int x, int y)
        {
            Point loc = Location();
            int line = yOffset + y - loc.y;
            int col = xOffset + x - loc.x;
            if (line < lines.Count())
            {
                const ustring& ln = lines[line];
                if (col < ln.Length())
                {
                    return ln[col];
                }
            }
            return uchar('\0');
        }
        private uchar CharAtCursor()
        {
            if (caretLine < lines.Count())
            {
                const ustring& line = lines[caretLine];
                if (caretCol < line.Length())
                {
                    return line[caretCol];
                }
            }
            return uchar('\0');
        }
        private void MakeCanonicalSelection()
        {
            canonicalSelection = selection;
            if (canonicalSelection.startLine > canonicalSelection.endLine ||
                canonicalSelection.startLine == canonicalSelection.endLine && 
                canonicalSelection.startCol > canonicalSelection.endCol)
            {
                Swap(canonicalSelection.startLine, canonicalSelection.endLine);
                Swap(canonicalSelection.startCol, canonicalSelection.endCol);
            }
        }
        private bool LineColInSelection(int line, int col)
        {
            if (line > canonicalSelection.startLine && line < canonicalSelection.endLine)
            {
                return true;
            }
            else if (line == canonicalSelection.startLine)
            {
                if (canonicalSelection.endLine == canonicalSelection.startLine)
                {
                    if (col >= canonicalSelection.startCol && col < canonicalSelection.endCol)
                    {
                        return true;
                    }
                }
                else if (col >= canonicalSelection.startCol)
                {
                    return true;
                }
            }
            else if (line == canonicalSelection.endLine)
            {
                if (col < canonicalSelection.endCol)
                {
                    return true;
                }
            }
            return false;
        }
        private void ResetSelection()
        {
            if (selection.IsEmpty())
            {
                return;
            }
            MakeCanonicalSelection();
            Point start = ScreenPoint(0, canonicalSelection.startLine);
            Size sz = GetSize();
            Point end = ScreenPoint(sz.w, canonicalSelection.endLine + 1);
            Rect updateRect = ScreenRect(start, end);
            Invalidate(updateRect);
            selection.Reset();
        }
        private EditorFlags flags;
        private int xOffset;
        private int yOffset;
        private List<ustring> lines;
        private string filePath;
        private int caretLine;
        private int caretCol;
        private string statusText;
        private Selection selection;
        private Selection canonicalSelection;
        private Rect selectionScreenRect;
        private ConsoleColor selectionForeColor;
        private ConsoleColor selectionBackColor;
        private Event<ChangedEventHandler> filePathChangedEvent;
        private Event<ChangedEventHandler> caretPosChangedEvent;
        private Event<ChangedEventHandler> statusTextChangedEvent;
        private Event<ChangedEventHandler> dirtyChangedEvent;
    }
}


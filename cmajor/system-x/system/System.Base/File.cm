// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Os;

namespace System.IO
{
	public enum FileType : int
	{
		regular = 1, directory = 2, fifo = 3
	}

	public enum Access : int
	{
		none = 0, read = 1 << 0, write = 1 << 1, execute = 1 << 2
	}

	public class FileStatus
	{
		public int fileSystemNumber;
		public int inodeNumber;
		public FileType fileType;
		public Access ownerAccess;
		public Access groupAccess;
		public Access otherAccess;
		public int nlinks;
		public int uid;
		public int gid;
		public long fileSize;
		public DateTime ctime;
		public DateTime mtime;
		public DateTime atime;
	}
	
	public void Stat(const char* path, FileStatus& status)
	{
		byte[statBufSize] statBuf;
		int result = stat(path, &statBuf[0], statBufSize);
		if (result == -1)
		{
			ThrowSystemError();
		}
		GetFileStatus(&statBuf[0], status);
	}
	
	public void GetFileStatus(byte* statBuf, FileStatus& status)
	{
		MemoryReader reader(statBuf, statBufSize);
		status.fileSystemNumber = reader.ReadInt();
		status.inodeNumber = reader.ReadInt();
		status.fileType = cast<FileType>(reader.ReadInt());
		status.ownerAccess = cast<Access>(reader.ReadInt());
		status.groupAccess = cast<Access>(reader.ReadInt());
		status.otherAccess = cast<Access>(reader.ReadInt());
		status.nlinks = reader.ReadInt();
		status.uid = reader.ReadInt();
		status.gid = reader.ReadInt();
		status.fileSize = reader.ReadLong();
		status.ctime = reader.ReadDateTime();
		status.mtime = reader.ReadDateTime();
		status.atime = reader.ReadDateTime();
	}

    public static class File
    {
        public static bool Exists(const string& filePath)
        {
            byte[statBufSize] statBuf;
            int result = stat(filePath.Chars(), &statBuf[0], statBufSize);
            if (result == -1) 
            {
                SystemError systemError = GetSystemError();
                if (systemError.errorCode == ENOTFOUND)
                {
                    return false;
                }
                else
                {
                    ThrowSystemError();
                }
            }
            else
            {
                FileStatus status;
                GetFileStatus(&statBuf[0], status);
                if (status.fileType == FileType.regular)
                {
                    return true;
                }
                else
                {
                    throw FileSystemException("path '" + filePath + "' is not a regular file path");
                }
            }
        }
        public static long Size(const string& filePath)
        {
            if (filePath.IsEmpty())
            {
                throw InvalidPathException("file path is empty");
            }
            FileStatus status;
            Stat(filePath.Chars(), status);
            if (status.fileType == FileType.regular)
            {
                return status.fileSize;
            }
            else
            {
                throw InvalidPathException("path '" + filePath + "' is not a file path");
            }
        }
        public static StreamWriter CreateText(const string& filePath)
        {
            return StreamWriter(SharedPtr<Stream>(new BufferedStream(SharedPtr<Stream>(
                new FileStream(filePath, cast<OpenFlags>(OpenFlags.write | OpenFlags.create | OpenFlags.truncate | OpenFlags.text))))));
        }
        public static BinaryWriter CreateBinary(const string& filePath)
        {
            return BinaryWriter(SharedPtr<Stream>(new BufferedStream(SharedPtr<Stream>(
                new FileStream(filePath, cast<OpenFlags>(OpenFlags.write | OpenFlags.create | OpenFlags.truncate | OpenFlags.random_access))))));
        }
        public static StreamWriter AppendText(const string& filePath)
        {
            return StreamWriter(SharedPtr<Stream>(new BufferedStream(SharedPtr<Stream>(
                new FileStream(filePath, cast<OpenFlags>(OpenFlags.append | OpenFlags.text))))));
        }
        public static StreamReader OpenRead(const string& filePath)
        {
            return StreamReader(SharedPtr<Stream>(new BufferedStream(SharedPtr<Stream>(
                new FileStream(filePath, cast<OpenFlags>(OpenFlags.read | OpenFlags.text))))));
        }
        public static BinaryReader OpenBinary(const string& filePath)
        {
            return BinaryReader(SharedPtr<Stream>(new BufferedStream(SharedPtr<Stream>(
                new FileStream(filePath, cast<OpenFlags>(OpenFlags.read | OpenFlags.random_access))))));
        }
    }
}

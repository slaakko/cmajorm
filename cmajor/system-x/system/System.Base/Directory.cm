// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

using System;
using System.Collections;
using System.Os;

namespace System.IO
{
    public const int nameMax = 252;
    public const int pathMax = 4096;
	public const int statBufSize = 68;

	public string GetCurrentWorkingDirectory()
    {
        Buffer buffer(pathMax);
        char* buf = cast<char*>(cast<void*>(buffer.Mem()));
        long count = buffer.Size();
        GetCWD(buf, count);
        return string(buf);
    }

    public static class Directory
    {
        public static bool Exists(const string& directoryPath)
        {
            byte[statBufSize] statBuf;
            int result = stat(directoryPath.Chars(), &statBuf[0], statBufSize);
            if (result == -1) 
            {
                SystemError systemError = GetSystemError();
                if (systemError.errorCode == ENOTFOUND)
                {
                    return false;
                }
                else
                {
                    ThrowSystemError();
                }
            }
            else
            {
                FileStatus status;
                GetFileStatus(&statBuf[0], status);
                if (status.fileType == FileType.directory)
                {
                    return true;
                }
                else
                {
                    throw FileSystemException("path '" + directoryPath + "' is not a directory path");
                }
            }
        }
/*		
        public static DateTime AccessTime(const string& directoryPath)
        {
            StatInfo statInfo;
            Stat(directoryPath.Chars(), statInfo);
            if (statInfo.Type() != FileType.directory)
            {
                throw FileSystemException("path '" + directoryPath + "' is not a directory path");
            }
            return statInfo.ATime();
        }
        public static DateTime ModificationTime(const string& directoryPath)
        {
            StatInfo statInfo;
            Stat(directoryPath.Chars(), statInfo);
            if (statInfo.Type() != FileType.directory)
            {
                throw FileSystemException("path '" + directoryPath + "' is not a directory path");
            }
            return statInfo.MTime();
        }
        public static void GetTimes(const string& directoryPath, DateTime& accessTime, DateTime& modificationTime)
        {
            StatInfo statInfo;
            Stat(directoryPath.Chars(), statInfo);
            if (statInfo.Type() != FileType.directory)
            {
                throw FileSystemException("path '" + directoryPath + "' is not a directory path");
            }
            accessTime = statInfo.ATime();
            modificationTime = statInfo.MTime();
        }
        public static void SetTimes(const string& directoryPath, const DateTime& accessTime, const DateTime& modificationTime)
        {
            UTime(directoryPath.Chars(), accessTime, modificationTime); 
        }
        public static void Remove(const string& directoryPath)
        {
            if (Exists(directoryPath))
            {
                Unlink(directoryPath.Chars());
            }
            else
            {
                throw SystemError(ENOTFOUND, "could not remove directory: directory '" + directoryPath + "' does not exist");
            }
        }
*/		
    }
  
/*  
    public void CreateDirectories(const string& directoryPath)
    {
        CreateDirectories(directoryPath, 0);
    }
    
    public void CreateDirectories(const string& directoryPath, int mode)
    {
        CreateDirectories(directoryPath, 0, false);
    }
    
    public void CreateDirectories(const string& directoryPath, int mode, bool verbose)
    {
        if (directoryPath.IsEmpty())
        {
            throw InvalidPathException("directory path is empty");
        }
        List<string> components = directoryPath.Split('/');
        int n = cast<int>(components.Count());
        string dir;
        int next = 0;
        if (components[0].IsEmpty())
        {
            dir = "/" + components[1];
            next = 2;
        }
        else
        {
            dir = components[0];
            next = 1;
        }
        if (!Directory.Exists(dir))
        {
            Mkdir(dir.Chars(), mode);
            if (verbose)
            {
                Console.Out() << "created directory '" + dir + "'" << endl();
            }
        }
        for (int i = next; i < n; ++i)
        {
            dir = Path.Combine(dir, components[i]);
            if (!Directory.Exists(dir))
            {
                Mkdir(dir.Chars(), mode);
                Console.Out() << "created directory '" + dir + "'" << endl();
            }
        }
    }
    
    public class DirectoryEntry
    {
        public int inodeNumber;
        public char[nameMax] name;
    }
    
    public class DirectoryReader
    {
        public nothrow DirectoryReader(const string& dirPath) : dd(OpenDir(dirPath.Chars()))
        {
        }
        public bool Read(DirectoryEntry& dirEntry)
        {
            int result = ReadDir(dd, &dirEntry.inodeNumber, &dirEntry.name[0]);
            return result == 1;
        }
        public ~DirectoryReader()
        {
            try
            {
                CloseDir(dd);
            }
            catch (const Exception&)
            {
            }
        }
        private int dd;
    }
*/	
}

// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

classmap TraceClassMap;

tokens TraceTokens
{
    (NAME, "'name'"), (THREAD, "'thread'"), (DURATION, "'duration'"), (TIME, "'time'"), (PARENT, "'parent'"), (LEVEL, "'level'"), (MESSAGE, "'message'"),
    (AND, "'and'"), (OR, "'or'"), (TRUE, "'true'"), (FALSE, "'false'"), (S, "'s'"), (MS, "'ms'"), (US, "'us'"), (NS, "'ns'"),
    (LPAREN, "'('"), (RPAREN, "')'"), (MATCH, "'match'"), (EQ, "'='"), (NEQ, "'<>'"), (LESSEQ, "'<='"), (GREATEREQ, "'>='"), (LESS, "'<"), (GREATER, "'>'"),
    (ID, "'id'"), (PATTERN, "'pattern'"), (STRING, "'string'"), (INTEGER, "'integer'")
}

keywords TraceKeywords
{
    ("name", NAME), ("thread", THREAD), ("duration", DURATION), ("time", TIME), ("parent", PARENT), ("level", LEVEL), ("message", MESSAGE),
    ("and", AND), ("or", OR), ("true", TRUE), ("false", FALSE), ("s", S), ("ms", MS), ("us", US), ("ns", NS), ("match", MATCH)
}

expressions
{
    ws = "[\n\r\t ]";
    id = "{idstart}{idcont}*";
    string = "\"[^\"]*\"";
    pattern = "'[^']*'";
    integer = "[0-9]([0-9'])*";
}

lexer TraceLexer
{
    "{ws}" {}
    "{id}" { int kw = GetKeywordToken(token.match); if (kw == INVALID_TOKEN) return ID; else return kw; }
    "{integer}"{ return INTEGER; }
    "{string}"{ return STRING; }
    "{pattern}"{ return PATTERN; }
    "\("{ return LPAREN; }
    "\)"{ return RPAREN; }
    "="{ return EQ; }
    "<>"{ return NEQ; }
    "<="{ return LESSEQ; }
    ">="{ return GREATEREQ; }
    "<"{ return LESS; }
    ">"{ return GREATER; }
}

// =================================
// Copyright (c) 2022 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <sngcm/cmparser/ParserApi.hpp>
[hpp]#include <sngcm/ast/Class.hpp>
[hpp]#include <sngcm/cmparser/ParsingContext.hpp>
[cpp]#include <sngcm/cmparser/Attribute.hpp>
[cpp]#include <sngcm/cmparser/Specifier.hpp>
[cpp]#include <sngcm/cmparser/Identifier.hpp>
[cpp]#include <sngcm/cmparser/TypeExpr.hpp>
[cpp]#include <sngcm/cmparser/Concept.hpp>
[cpp]#include <sngcm/cmparser/Expression.hpp>
[cpp]#include <sngcm/cmparser/Statement.hpp>
[cpp]#include <sngcm/cmparser/Parameter.hpp>
[cpp]#include <sngcm/cmparser/Function.hpp>
[cpp]#include <sngcm/cmparser/Template.hpp>
[cpp]#include <sngcm/cmparser/Typedef.hpp>
[cpp]#include <sngcm/cmparser/Enumeration.hpp>
[cpp]#include <sngcm/cmparser/Constant.hpp>
[cpp]#include <sngcm/cmparser/Delegate.hpp>
[cpp]#include <sngcm/cmlexer/CmajorLexer.hpp>
[cpp]#include <sngcm/cmlexer/CmajorTokens.hpp>

using namespace sngcm::ast;
using namespace CmajorTokens;

parser api(SNGCM_PARSER_API) ClassParser
{
    uselexer CmajorLexer;

    using AttributeParser.Attributes;
    using SpecifierParser.Specifiers;
    using IdentifierParser.Identifier;
    using IdentifierParser.QualifiedId;
    using TypeExprParser.TypeExpr;
    using ConceptParser.WhereConstraint;
    using ExpressionParser.ArgumentList;
    using StatementParser.CompoundStatement;
    using ParameterParser.ParameterList;
    using FunctionParser.FunctionGroupId;
    using TemplateParser.TemplateId;
    using TemplateParser.TemplateParameterList;
    using TypedefParser.Typedef;
    using EnumerationParser.EnumType;
    using ConstantParser.Constant;
    using DelegateParser.Delegate;
    using DelegateParser.ClassDelegate;

    Class(boost::uuids::uuid* moduleId, ParsingContext* ctx, var std::unique_ptr<ClassNode> cls, var Span s, var Span specifierSpan, var Span classSpan, var Span beginBraceSpan, var Span endBraceSpan) : ClassNode*
        ::= empty{ s = span; } Attributes(moduleId):attrs? (Specifiers:specifiers{ specifierSpan = span; } - NEW) CLASS{ classSpan = span; } Identifier(moduleId):id
        {
            s.end = span.end;
            cls.reset(new ClassNode(s, *moduleId, specifiers, id, attrs));
            cls->SetSpecifierSpan(specifierSpan);
            cls->SetClassSpan(classSpan);
        }
        TemplateParameterList(moduleId, ctx, cls.get()):templateParams?
        InheritanceAndInterfaces(moduleId, ctx, cls.get()):inheritance?
        (WhereConstraint(moduleId, ctx):constraint{ cls->SetConstraint(constraint); })?
        LBRACE!{ beginBraceSpan = span; } ClassContent(moduleId, ctx, cls.get()):content RBRACE!
        {
            endBraceSpan = span;
            cls->SetBeginBraceSpan(beginBraceSpan);
            cls->SetEndBraceSpan(endBraceSpan);
            return cls.release();
        }
        ;

    InheritanceAndInterfaces(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode)
        ::= COLON
        (   empty{ ctx->BeginParsingTypeExpr(); }
            BaseClassOrInterface(moduleId, ctx):baseOrIntf{ classNode->AddBaseClassOrInterface(baseOrIntf); ctx->EndParsingTypeExpr(); } / { ctx->EndParsingTypeExpr(); }
        ) % COMMA
        ;

    BaseClassOrInterface(boost::uuids::uuid* moduleId, ParsingContext* ctx) : Node*
        ::= TemplateId(moduleId, ctx):templateId{ return templateId; }
        |   QualifiedId(moduleId):qid{ return qid; }
        ;

    ClassContent(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode)
        ::= (ClassMember(moduleId, ctx, classNode):classMember{ classNode->AddMember(classMember); })*
        ;

    ClassMember(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode) : Node*
        ::= StaticConstructor(moduleId, ctx, classNode):staticConstructor{ return staticConstructor; }
        |   Constructor(moduleId, ctx, classNode):constructor{ return constructor; }
        |   Destructor(moduleId, ctx, classNode):destructor{ return destructor; }
        |   MemberFunction(moduleId, ctx):memberFunction{ return memberFunction; }
        |   ConversionFunction(moduleId, ctx):conversionFunction{ return conversionFunction; }
        |   MemberVariable(moduleId, ctx):memberVariable{ return memberVariable; }
        |   Typedef(moduleId, ctx):typedefinition{ return typedefinition; }
        |   Class(moduleId, ctx):cls{ return cls; }
        |   EnumType(moduleId, ctx):enumType{ return enumType; }
        |   Constant(moduleId, ctx):constant{ return constant; }
        |   Delegate(moduleId, ctx):delegate{ return delegate; }
        |   ClassDelegate(moduleId, ctx):classDelegate{ return classDelegate; }
        ;

    StaticConstructor(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode, var std::unique_ptr<StaticConstructorNode> staticConstructor, var Span s, var Span specifierSpan,
        var std::u32string className) : StaticConstructorNode*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } Identifier(moduleId):id{ className = lexer.GetMatch(span); } LPAREN RPAREN
            {
                s.end = span.end;
                if (className != classNode->Id()->Str()) pass = false; else if (!StaticConstructorSpecifiers(specifiers)) pass = false; else
                {
                    staticConstructor.reset(new StaticConstructorNode(s, *moduleId, specifiers, attrs));
                    staticConstructor->SetClassId(id);
                    staticConstructor->SetSpecifierSpan(specifierSpan);
                }
            }
            (COLON (Initializer(moduleId, ctx):initializer{ staticConstructor->AddInitializer(initializer); } % COMMA))?
            (WhereConstraint(moduleId, ctx):constraint{ staticConstructor->SetConstraint(constraint); })?
            (CompoundStatement(moduleId, ctx):body{ staticConstructor->SetBody(body); } | SEMICOLON)
        )
        {
            return staticConstructor.release();
        }
        ;

    Constructor(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode, var std::unique_ptr<ConstructorNode> ctor, var Span s, var Span specifierSpan) : Node*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } Identifier(moduleId):id
            {
                std::u32string className = lexer.GetMatch(span);
                s.end = span.end;
                if (className != classNode->Id()->Str()) pass = false; else
                {
                    ctor.reset(new ConstructorNode(s, *moduleId, specifiers, attrs));
                    ctor->SetClassId(id);
                    ctor->SetSpecifierSpan(specifierSpan);
                }
            }
            ParameterList(moduleId, ctx, ctor.get()):paramList
            (COLON (Initializer(moduleId, ctx):initializer{ ctor->AddInitializer(initializer); } % COMMA))?
            (WhereConstraint(moduleId, ctx):constraint{ ctor->SetConstraint(constraint); })?
            (CompoundStatement(moduleId, ctx):body{ ctor->SetBody(body); } | SEMICOLON)
        )
        {
            return ctor.release();
        }
        ;

    Destructor(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::ClassNode* classNode, var std::unique_ptr<DestructorNode> dtor, var Span s, var Span specifierSpan, var std::u32string className) : Node*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } CPL Identifier(moduleId):id{ className = lexer.GetMatch(span); } LPAREN! RPAREN!
            {
                s.end = span.end;
                if (className != classNode->Id()->Str()) pass = false; else
                {
                    dtor.reset(new DestructorNode(s, *moduleId, specifiers, attrs));
                    dtor->SetClassId(id);
                    dtor->SetSpecifierSpan(specifierSpan);
                }
            }
            (WhereConstraint(moduleId, ctx):contraint{ dtor->SetConstraint(contraint); })?
            (CompoundStatement(moduleId, ctx):body{ dtor->SetBody(body); } | SEMICOLON)
        )
        {
            return dtor.release();
        }
        ;

    Initializer(boost::uuids::uuid* moduleId, ParsingContext* ctx, var std::unique_ptr<InitializerNode> initializer) : InitializerNode*
        ::=
        (   THIS{ initializer.reset(new ThisInitializerNode(span, *moduleId)); } LPAREN! ArgumentList(moduleId, ctx, initializer.get()):thisArgs! RPAREN!
        |   BASE{ initializer.reset(new BaseInitializerNode(span, *moduleId)); } LPAREN! ArgumentList(moduleId, ctx, initializer.get()):baseArgs! RPAREN!
        |   Identifier(moduleId):id{ initializer.reset(new MemberInitializerNode(span, *moduleId, id)); } LPAREN! ArgumentList(moduleId, ctx, initializer.get()):memberArgs! RPAREN!
        )
        {
            return initializer.release();
        }
        ;

    MemberFunction(boost::uuids::uuid* moduleId, ParsingContext* ctx, var std::unique_ptr<MemberFunctionNode> memFun, var Span s, var Span specifierSpan, var Span groupIdSpan) : Node*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } TypeExpr(moduleId, ctx):returnType FunctionGroupId(moduleId, ctx):groupId
            {
                s.end = span.end;
                groupIdSpan = span;
                memFun.reset(new MemberFunctionNode(s, *moduleId, specifiers, returnType, groupId, attrs));
                memFun->SetSpecifierSpan(specifierSpan);
                memFun->SetGroupIdSpan(groupIdSpan);
            }
            ParameterList(moduleId, ctx, memFun.get()):paramList (CONST{ memFun->SetConst(); })?
            (WhereConstraint(moduleId, ctx):constraint{ memFun->SetConstraint(constraint); })?
            (CompoundStatement(moduleId, ctx):body{ memFun->SetBody(body); } | SEMICOLON)
        )
        {
            return memFun.release();
        }
        ;

    ConversionFunction(boost::uuids::uuid* moduleId, ParsingContext* ctx, var std::unique_ptr<ConversionFunctionNode> conversionFun, var Span s, var Span specifierSpan) : Node*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } OPERATOR TypeExpr(moduleId, ctx):type LPAREN! RPAREN!
            {
                s.end = span.end;
                conversionFun.reset(new ConversionFunctionNode(s, *moduleId, specifiers, type, attrs));
                conversionFun->SetSpecifierSpan(specifierSpan);
            }
            (CONST{ conversionFun->SetConst(); })?
            (WhereConstraint(moduleId, ctx):constraint{ conversionFun->SetConstraint(constraint); })?
            (CompoundStatement(moduleId, ctx):body{ conversionFun->SetBody(body); } | SEMICOLON)
        )
        {
            return conversionFun.release();
        }
        ;

    MemberVariable(boost::uuids::uuid* moduleId, ParsingContext* ctx, var Span s, var Span specifierSpan) : MemberVariableNode*
        ::= empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } TypeExpr(moduleId, ctx):type Identifier(moduleId):id SEMICOLON
        {
            s.end = span.end;
            MemberVariableNode* value = new MemberVariableNode(s, *moduleId, specifiers, type, id, attrs);
            value->SetSpecifierSpan(specifierSpan);
            return value;
        }
        ;
}

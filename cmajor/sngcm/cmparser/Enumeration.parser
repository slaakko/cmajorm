// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <sngcm/cmparser/ParserApi.hpp>
[hpp]#include <sngcm/ast/Enumeration.hpp>
[hpp]#include <sngcm/cmparser/ParsingContext.hpp>
[cpp]#include <sngcm/cmparser/Specifier.hpp>
[cpp]#include <sngcm/cmparser/Identifier.hpp>
[cpp]#include <sngcm/cmparser/TypeExpr.hpp>
[cpp]#include <sngcm/cmparser/Expression.hpp>
[cpp]#include <sngcm/cmlexer/CmajorLexer.hpp>
[cpp]#include <sngcm/cmlexer/CmajorTokens.hpp>

using namespace sngcm::ast;
using namespace CmajorTokens;

parser api(SNGCM_PARSER_API) EnumerationParser
{
    uselexer CmajorLexer;

    using SpecifierParser.Specifiers;
    using IdentifierParser.Identifier;
    using TypeExprParser.TypeExpr;
    using ExpressionParser.Expression;

    EnumType(boost::uuids::uuid* moduleId, ParsingContext* ctx, var std::unique_ptr<EnumTypeNode> enumTypeNode, var Span s, var Span beginBraceSpan, var Span endBraceSpan) : EnumTypeNode*
        ::= Specifiers:specifiers{ s = span; } ENUM Identifier(moduleId):enumTypeId!{ s.end = span.end; enumTypeNode.reset(new EnumTypeNode(s, *moduleId, specifiers, enumTypeId)); }
            (UnderlyingType(moduleId, ctx):underlyingType{ enumTypeNode->SetUnderlyingType(underlyingType); })?
            LBRACE!{ beginBraceSpan = span; } EnumConstants(moduleId, ctx, enumTypeNode.get()):enumConstants RBRACE!
            {
                endBraceSpan = span;
                enumTypeNode->SetBeginBraceSpan(beginBraceSpan);
                enumTypeNode->SetEndBraceSpan(endBraceSpan);
                return enumTypeNode.release();
            }
        ;

    UnderlyingType(boost::uuids::uuid* moduleId, ParsingContext* ctx) : Node*
        ::= COLON TypeExpr(moduleId, ctx):type{ return type; }
        ;

    EnumConstants(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::EnumTypeNode* enumType)
        ::= EnumConstant(moduleId, ctx, enumType):enumConstant!{ enumType->AddConstant(enumConstant); } % COMMA
        ;

    EnumConstant(boost::uuids::uuid* moduleId, ParsingContext* ctx, sngcm::ast::EnumTypeNode* enumType, var Span s, var std::unique_ptr<Node> expr) : EnumConstantNode*
        ::= Identifier(moduleId):constantId!{ s = span; }
        (   ASSIGN Expression(moduleId, ctx):constantValue
            {
                expr.reset(constantValue);
                expr->SetFullSpan();
                Span v = expr->GetSpan();
                s.end = expr->GetSpan().end;
                EnumConstantNode* value = new EnumConstantNode(s, *moduleId, constantId, expr.release());
                value->SetHasValue();
                value->SetStrValue(lexer.GetMatch(v));
                return value;
            }
        |   empty{ return new EnumConstantNode(s, *moduleId, constantId, MakeNextEnumConstantValue(s, *moduleId, enumType)); }
        )
        ;

    ruleinfo
    {
        (EnumType, "enumerated type"), (UnderlyingType, "underlying type"), (EnumConstants, "enumeration constants"), (EnumConstant, "enumeration constant")
    }
}

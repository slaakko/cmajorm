// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <sngcm/cmnothrowparser/ParserApi.hpp>
[hpp]#include <sngcm/ast/Enumeration.hpp>
[hpp]#include <sngcm/cmnothrowparser/NothrowParsingContext.hpp>
[cpp]#include <sngcm/cmnothrowparser/Specifier.hpp>
[cpp]#include <sngcm/cmnothrowparser/Identifier.hpp>
[cpp]#include <sngcm/cmnothrowparser/TypeExpr.hpp>
[cpp]#include <sngcm/cmnothrowparser/Expression.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowLexer.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowTokens.hpp>

using namespace sngcm::ast;
using namespace CmajorNothrowTokens;

parser api(SNGCM_NOTHROW_PARSER_API) NothrowEnumerationParser
{
    uselexer CmajorNothrowLexer;
    nothrow;

    using NothrowSpecifierParser.Specifiers;
    using NothrowIdentifierParser.Identifier;
    using NothrowTypeExprParser.TypeExpr;
    using NothrowExpressionParser.Expression;

    EnumType(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, var std::unique_ptr<EnumTypeNode> enumTypeNode, var Span s, var Span beginBraceSpan, var Span endBraceSpan) : EnumTypeNode*
        ::= Specifiers:specifiers{ s = span; } ENUM Identifier(moduleId):enumTypeId!{ s.end = span.end; enumTypeNode.reset(new EnumTypeNode(s, *moduleId, specifiers, enumTypeId)); }
            (UnderlyingType(moduleId, ctx):underlyingType{ enumTypeNode->SetUnderlyingType(underlyingType); })?
            LBRACE!{ beginBraceSpan = span; } EnumConstants(moduleId, ctx, enumTypeNode.get()):enumConstants RBRACE!
            {
                endBraceSpan = span;
                enumTypeNode->SetBeginBraceSpan(beginBraceSpan);
                enumTypeNode->SetEndBraceSpan(endBraceSpan);
                enumTypeNode->SetLexerFlags(lexer.Flags());
                return enumTypeNode.release();
            }
        ;

    UnderlyingType(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx) : Node*
        ::= COLON TypeExpr(moduleId, ctx):type{ return type; }
        ;

    EnumConstants(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, sngcm::ast::EnumTypeNode* enumType)
        ::= EnumConstant(moduleId, ctx, enumType):enumConstant!{ enumType->AddConstant(enumConstant); } % COMMA
        ;

    EnumConstant(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, sngcm::ast::EnumTypeNode* enumType, var Span s, var std::unique_ptr<Node> expr) : EnumConstantNode*
        ::= Identifier(moduleId):constantId!{ s = span; }
        (   ASSIGN Expression(moduleId, ctx):constantValue
            {
                expr.reset(constantValue);
                expr->SetFullSpan();
                Span v = expr->GetSpan();
                s.end = expr->GetSpan().end;
                EnumConstantNode* value = new EnumConstantNode(s, *moduleId, constantId, expr.release());
                value->SetHasValue();
                value->SetStrValue(lexer.GetMatch(v));
                value->SetLexerFlags(lexer.Flags());
                return value;
            }
        |   empty
        { 
            EnumConstantNode* node = new EnumConstantNode(s, *moduleId, constantId, MakeNextEnumConstantValue(s, *moduleId, enumType)); 
            node->SetLexerFlags(lexer.Flags());
            return node;
        }
        )
        ;

    ruleinfo
    {
        (EnumType, "enumerated type"), (UnderlyingType, "underlying type"), (EnumConstants, "enumeration constants"), (EnumConstant, "enumeration constant")
    }
}

// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <sngcm/cmnothrowparser/ParserApi.hpp>
[hpp]#include <sngcm/ast/Identifier.hpp>
[hpp]#include <sngcm/ast/Expression.hpp>
[hpp]#include <sngcm/ast/TypeExpr.hpp>
[hpp]#include <sngcm/cmnothrowparser/NothrowParsingContext.hpp>
[cpp]#include <sngcm/cmnothrowparser/BasicType.hpp>
[cpp]#include <sngcm/cmnothrowparser/Expression.hpp>
[cpp]#include <sngcm/cmnothrowparser/Template.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowLexer.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowTokens.hpp>

using namespace sngcm::ast;
using namespace CmajorNothrowTokens;

parser api(SNGCM_NOTHROW_PARSER_API) NothrowTypeExprParser
{
    uselexer CmajorNothrowLexer;
    main;
    nothrow;

    using NothrowBasicTypeParser.BasicType;
    using NothrowExpressionParser.Expression;
    using NothrowTemplateParser.TemplateId;

    TypeExpr(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx) : sngcm::ast::Node*
        ::= PrefixTypeExpr(moduleId, ctx):prefixTypeExpr{ return prefixTypeExpr; }
        ;

    PrefixTypeExpr(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, var Span s) : sngcm::ast::Node*
        ::= CONST{ s = span; } PostfixTypeExpr(moduleId, ctx):constTypeExpr{ s.end = span.end; ConstNode* node = new ConstNode(s, *moduleId, constTypeExpr); node->SetLexerFlags(lexer.Flags()); return node; }
        |   PostfixTypeExpr(moduleId, ctx):postfixTypeExpr{ return postfixTypeExpr; }
        ;

    PostfixTypeExpr(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, var std::unique_ptr<Node> typeExpr, var Span s) : sngcm::ast::Node*
        ::=
        (   PrimaryTypeExpr(moduleId, ctx):primaryTypeExpr{ s = span; typeExpr.reset(primaryTypeExpr); }
            (   DOT ID{ s.end = span.end; typeExpr.reset(new DotNode(s, *moduleId, typeExpr.release(), new IdentifierNode(span, *moduleId, lexer.GetToken(pos)))); }
            |   STAR{ s.end = span.end; typeExpr.reset(new PointerNode(s, *moduleId, typeExpr.release())); }
            |   AMPAMP{ s.end = span.end; typeExpr.reset(new RValueRefNode(s, *moduleId, typeExpr.release())); }
            |   AMP{ s.end = span.end; typeExpr.reset(new LValueRefNode(s, *moduleId, typeExpr.release())); }
            |   LBRACKET Expression(moduleId, ctx):size? RBRACKET!{ s.end = span.end; typeExpr.reset(new ArrayNode(s, *moduleId, typeExpr.release(), size)); }
            )*
        )
        {
            typeExpr->SetLexerFlags(lexer.Flags());
            return typeExpr.release();
        }
        ;

    PrimaryTypeExpr(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx) : sngcm::ast::Node*
        ::= BasicType(moduleId):basicType{ return basicType; }
        |   TemplateId(moduleId, ctx):templateId{ return templateId; }
        |   ID{ IdentifierNode* node = new IdentifierNode(span, *moduleId, lexer.GetToken(pos)); node->SetLexerFlags(lexer.Flags()); return node; }
        ;

    ruleinfo
    {
        (TypeExpr, "type expression"), (PrefixTypeExpr, "prefix type expression"), (PostfixTypeExpr, "postfix type expression"), (PrimaryTypeExpr, "primary type expression")
    }
}

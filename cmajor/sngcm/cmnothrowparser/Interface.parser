// =================================
// Copyright (c) 2021 Seppo Laakko
// Distributed under the MIT license
// =================================

[hpp]#include <sngcm/cmnothrowparser/ParserApi.hpp>
[hpp]#include <sngcm/ast/Interface.hpp>
[hpp]#include <sngcm/cmnothrowparser/NothrowParsingContext.hpp>
[cpp]#include <sngcm/cmnothrowparser/Attribute.hpp>
[cpp]#include <sngcm/cmnothrowparser/Specifier.hpp>
[cpp]#include <sngcm/cmnothrowparser/Identifier.hpp>
[cpp]#include <sngcm/cmnothrowparser/TypeExpr.hpp>
[cpp]#include <sngcm/cmnothrowparser/Parameter.hpp>
[hpp]#include <sngcm/ast/Class.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowLexer.hpp>
[cpp]#include <sngcm/cmnothrowlexer/CmajorNothrowTokens.hpp>

using namespace sngcm::ast;
using namespace CmajorNothrowTokens;

parser api(SNGCM_NOTHROW_PARSER_API) NothrowInterfaceParser
{
    uselexer CmajorNothrowLexer;
    nothrow;
    state;

    using NothrowAttributeParser.Attributes;
    using NothrowSpecifierParser.Specifiers;
    using NothrowIdentifierParser.Identifier;
    using NothrowTypeExprParser.TypeExpr;
    using NothrowParameterParser.ParameterList;

    Interface(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, var std::unique_ptr<InterfaceNode> intf, var Span s, var Span specifierSpan, var Span beginBraceSpan, var Span endBraceSpan) : InterfaceNode*
        ::=
        (   empty{ s = span; } Attributes(moduleId):attrs? Specifiers:specifiers{ specifierSpan = span; } INTERFACE DefiningInterfaceId(moduleId):id
            {
                s.end = span.end;
                intf.reset(new InterfaceNode(s, *moduleId, specifiers, id, attrs));
                intf->SetSpecifierSpan(specifierSpan);
            }
            LBRACE!{ beginBraceSpan = span; } InterfaceContent(moduleId, ctx, intf.get()):content RBRACE!{ endBraceSpan = span; intf->SetBeginBraceSpan(beginBraceSpan); intf->SetEndBraceSpan(endBraceSpan); }
        )
        {
            intf->SetLexerFlags(lexer.Flags());
            return intf.release();
        }
        ;

    DefiningInterfaceId(boost::uuids::uuid* moduleId) : IdentifierNode*
        ::= Identifier(moduleId):id{ return id; }
        ;

    InterfaceContent(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, sngcm::ast::InterfaceNode* intf)
        ::= (InterfaceMemFun(moduleId, ctx):intfMemFun{ intf->AddMember(intfMemFun); })*
        ;

    InterfaceMemFun(boost::uuids::uuid* moduleId, NothrowParsingContext* ctx, var std::unique_ptr<MemberFunctionNode> memFun, var Span s) : Node*
        ::= empty{ s = span; } Attributes(moduleId):attrs? TypeExpr(moduleId, ctx):returnType InterfaceFunctionGroupId:groupId
        {
            s.end = span.end;
            memFun.reset(new MemberFunctionNode(s, *moduleId, Specifiers(), returnType, groupId, attrs));
        }
        ParameterList(moduleId, ctx, memFun.get()):paramList SEMICOLON!
        {
            memFun->SetLexerFlags(lexer.Flags());
            return memFun.release();
        }
        ;

    InterfaceFunctionGroupId : std::u32string
        ::= ID{ return lexer.GetMatch(span); }
        ;

    ruleinfo
    {
        (Interface, "interface"), (InterfaceContent, "interface content"), (InterfaceMemFun, "interface member function"), (InterfaceFunctionGroupId, "interface function group identifier")
    }
}
